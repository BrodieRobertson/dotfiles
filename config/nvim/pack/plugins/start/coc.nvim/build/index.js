/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

const semver = __webpack_require__(1)
const version = process.version.replace('v', '')
const promiseFinally = __webpack_require__(44)
if (!semver.gte(version, '8.10.0')) {
  console.error('node version ' + version + ' < 8.10.0, please upgrade nodejs, or use `let g:coc_node_path = "/path/to/node"` in your vimrc')
  process.exit()
}
if (!semver.gte(version, '10.12.0')) {
  if (process.env.COC_NO_WARNINGS != '1') {
    console.error('node version ' + version + ' < 10.12.0, upgrade nodejs or use `let g:coc_disable_startup_warning = 1` to disable this warning.')
  }
}
Object.defineProperty(console, 'log', {
  value: function () {
    logger.info(...arguments)
  }
})
promiseFinally.shim()
const logger = __webpack_require__(64)('server')
const attach = __webpack_require__(154).default

attach({reader: process.stdin, writer: process.stdout})

process.on('uncaughtException', function (err) {
  let msg = 'Uncaught exception: ' + err.message
  console.error(msg)
  logger.error('uncaughtException', err.stack)
})

process.on('unhandledRejection', function (reason, p) {
  if (reason instanceof Error) {
    console.error('UnhandledRejection: ' + reason.message + '\n' + reason.stack)
  } else {
    console.error('UnhandledRejection: ' + reason)
  }
  logger.error('unhandledRejection ', p, reason)
})


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(2)
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(3).SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(5),
  compareIdentifiers: __webpack_require__(6).compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(6).rcompareIdentifiers,
  parse: __webpack_require__(7),
  valid: __webpack_require__(8),
  clean: __webpack_require__(9),
  inc: __webpack_require__(10),
  diff: __webpack_require__(11),
  major: __webpack_require__(14),
  minor: __webpack_require__(15),
  patch: __webpack_require__(16),
  prerelease: __webpack_require__(17),
  compare: __webpack_require__(13),
  rcompare: __webpack_require__(18),
  compareLoose: __webpack_require__(19),
  compareBuild: __webpack_require__(20),
  sort: __webpack_require__(21),
  rsort: __webpack_require__(22),
  gt: __webpack_require__(23),
  lt: __webpack_require__(24),
  eq: __webpack_require__(12),
  neq: __webpack_require__(25),
  gte: __webpack_require__(26),
  lte: __webpack_require__(27),
  cmp: __webpack_require__(28),
  coerce: __webpack_require__(29),
  Comparator: __webpack_require__(30),
  Range: __webpack_require__(31),
  satisfies: __webpack_require__(32),
  toComparators: __webpack_require__(33),
  maxSatisfying: __webpack_require__(34),
  minSatisfying: __webpack_require__(35),
  minVersion: __webpack_require__(36),
  validRange: __webpack_require__(37),
  outside: __webpack_require__(38),
  gtr: __webpack_require__(39),
  ltr: __webpack_require__(40),
  intersects: __webpack_require__(41),
  simplifyRange: __webpack_require__(42),
  subset: __webpack_require__(43),
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(3)
const debug = __webpack_require__(4)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),
/* 3 */
/***/ (function(module, exports) {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(4)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(3)
const { re, t } = __webpack_require__(2)

const { compareIdentifiers } = __webpack_require__(6)
class SemVer {
  constructor (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),
/* 6 */
/***/ (function(module, exports) {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

const {MAX_LENGTH} = __webpack_require__(3)
const { re, t } = __webpack_require__(2)
const SemVer = __webpack_require__(5)

const parse = (version, options) => {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(7)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(7)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(7)
const eq = __webpack_require__(12)

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(13)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(7)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(13)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(13)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

const compareBuild = __webpack_require__(20)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

const compareBuild = __webpack_require__(20)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(13)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(13)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(13)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(13)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(13)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

const eq = __webpack_require__(12)
const neq = __webpack_require__(25)
const gt = __webpack_require__(23)
const gte = __webpack_require__(26)
const lt = __webpack_require__(24)
const lte = __webpack_require__(27)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const parse = __webpack_require__(7)
const {re, t} = __webpack_require__(2)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const {re, t} = __webpack_require__(2)
const cmp = __webpack_require__(28)
const debug = __webpack_require__(4)
const SemVer = __webpack_require__(5)
const Range = __webpack_require__(31)


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    const loose = this.options.loose
    range = range.trim()
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    return range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const Comparator = __webpack_require__(30)
const debug = __webpack_require__(4)
const SemVer = __webpack_require__(5)
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(2)

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(31)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(31)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const Range = __webpack_require__(31)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const Range = __webpack_require__(31)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const Range = __webpack_require__(31)
const gt = __webpack_require__(23)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(31)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(5)
const Comparator = __webpack_require__(30)
const {ANY} = Comparator
const Range = __webpack_require__(31)
const satisfies = __webpack_require__(32)
const gt = __webpack_require__(23)
const lt = __webpack_require__(24)
const lte = __webpack_require__(27)
const gte = __webpack_require__(26)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(38)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

const outside = __webpack_require__(38)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(31)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(32)
const compare = __webpack_require__(13)
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(31)
const { ANY } = __webpack_require__(30)
const satisfies = __webpack_require__(32)
const compare = __webpack_require__(13)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else return false
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
// - If LT
//   - If LT.semver is greater than that of any > comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
// - If any C is a = range, and GT or LT are set, return false
// - Else return true

const subset = (sub, dom, options) => {
  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub.length === 1 && sub[0].semver === ANY)
    return dom.length === 1 && dom[0].semver === ANY

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }
    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(45);
var define = __webpack_require__(47);

var implementation = __webpack_require__(51);
var getPolyfill = __webpack_require__(62);
var shim = __webpack_require__(63);

var bound = bind.call(Function.call, getPolyfill());

define(bound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = bound;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(46);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(48);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(49);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(50);

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(49); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(52);

requirePromise();

var IsCallable = __webpack_require__(53);
var SpeciesConstructor = __webpack_require__(55);
var Type = __webpack_require__(60);

var promiseResolve = function PromiseResolve(C, value) {
	return new C(function (resolve) {
		resolve(value);
	});
};

var OriginalPromise = Promise;

var createThenFinally = function CreateThenFinally(C, onFinally) {
	return function (value) {
		var result = onFinally();
		var promise = promiseResolve(C, result);
		var valueThunk = function () {
			return value;
		};
		return promise.then(valueThunk);
	};
};

var createCatchFinally = function CreateCatchFinally(C, onFinally) {
	return function (reason) {
		var result = onFinally();
		var promise = promiseResolve(C, result);
		var thrower = function () {
			throw reason;
		};
		return promise.then(thrower);
	};
};

var promiseFinally = function finally_(onFinally) {
	/* eslint no-invalid-this: 0 */

	var promise = this;

	if (Type(promise) !== 'Object') {
		throw new TypeError('receiver is not an Object');
	}

	var C = SpeciesConstructor(promise, OriginalPromise); // may throw

	var thenFinally = onFinally;
	var catchFinally = onFinally;
	if (IsCallable(onFinally)) {
		thenFinally = createThenFinally(C, onFinally);
		catchFinally = createCatchFinally(C, onFinally);
	}

	return promise.then(thenFinally, catchFinally);
};

if (Object.getOwnPropertyDescriptor) {
	var descriptor = Object.getOwnPropertyDescriptor(promiseFinally, 'name');
	if (descriptor && descriptor.configurable) {
		Object.defineProperty(promiseFinally, 'name', { configurable: true, value: 'finally' });
	}
}

module.exports = promiseFinally;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function requirePromise() {
	if (typeof Promise !== 'function') {
		throw new TypeError('`Promise.prototype.finally` requires a global `Promise` be available.');
	}
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://www.ecma-international.org/ecma-262/5.1/#sec-9.11

module.exports = __webpack_require__(54);


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (typeof value === 'function' && !value.prototype) { return true; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(56);

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = GetIntrinsic('%TypeError%');

var IsConstructor = __webpack_require__(59);
var Type = __webpack_require__(60);

// https://ecma-international.org/ecma-262/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (Type(C) !== 'Object') {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* globals
	Atomics,
	SharedArrayBuffer,
*/

var undefined;

var $TypeError = TypeError;

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () { throw new $TypeError(); };
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(57)();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var generator; // = function * () {};
var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};
var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};
var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%ArrayPrototype%': Array.prototype,
	'%ArrayProto_entries%': Array.prototype.entries,
	'%ArrayProto_forEach%': Array.prototype.forEach,
	'%ArrayProto_keys%': Array.prototype.keys,
	'%ArrayProto_values%': Array.prototype.values,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': asyncFunction,
	'%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
	'%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
	'%AsyncGeneratorFunction%': asyncGenFunction,
	'%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
	'%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%Boolean%': Boolean,
	'%BooleanPrototype%': Boolean.prototype,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
	'%Date%': Date,
	'%DatePrototype%': Date.prototype,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%ErrorPrototype%': Error.prototype,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%EvalErrorPrototype%': EvalError.prototype,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
	'%Function%': Function,
	'%FunctionPrototype%': Function.prototype,
	'%Generator%': generator ? getProto(generator()) : undefined,
	'%GeneratorFunction%': generatorFunction,
	'%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
	'%Math%': Math,
	'%Number%': Number,
	'%NumberPrototype%': Number.prototype,
	'%Object%': Object,
	'%ObjectPrototype%': Object.prototype,
	'%ObjProto_toString%': Object.prototype.toString,
	'%ObjProto_valueOf%': Object.prototype.valueOf,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
	'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
	'%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
	'%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
	'%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%RangeErrorPrototype%': RangeError.prototype,
	'%ReferenceError%': ReferenceError,
	'%ReferenceErrorPrototype%': ReferenceError.prototype,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%RegExpPrototype%': RegExp.prototype,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%StringPrototype%': String.prototype,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
	'%SyntaxError%': SyntaxError,
	'%SyntaxErrorPrototype%': SyntaxError.prototype,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
	'%TypeError%': $TypeError,
	'%TypeErrorPrototype%': $TypeError.prototype,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
	'%URIError%': URIError,
	'%URIErrorPrototype%': URIError.prototype,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
	'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};

var bind = __webpack_require__(45);
var $replace = bind.call(Function.call, String.prototype.replace);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	if (!(name in INTRINSICS)) {
		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
	}

	// istanbul ignore if // hopefully this is impossible to test :-)
	if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
		throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	}

	return INTRINSICS[name];
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);

	var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
	for (var i = 1; i < parts.length; i += 1) {
		if (value != null) {
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, parts[i]);
				if (!allowMissing && !(parts[i] in value)) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				value = desc ? (desc.get || desc.value) : value[parts[i]];
			} else {
				value = value[parts[i]];
			}
		}
	}
	return value;
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var origSymbol = global.Symbol;
var hasSymbolSham = __webpack_require__(58);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://www.ecma-international.org/ecma-262/6.0/#sec-isconstructor

module.exports = function IsConstructor(argument) {
	return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ES5Type = __webpack_require__(61);

// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://www.ecma-international.org/ecma-262/5.1/#sec-8

module.exports = function Type(x) {
	if (x === null) {
		return 'Null';
	}
	if (typeof x === 'undefined') {
		return 'Undefined';
	}
	if (typeof x === 'function' || typeof x === 'object') {
		return 'Object';
	}
	if (typeof x === 'number') {
		return 'Number';
	}
	if (typeof x === 'boolean') {
		return 'Boolean';
	}
	if (typeof x === 'string') {
		return 'String';
	}
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(52);

var implementation = __webpack_require__(51);

module.exports = function getPolyfill() {
	requirePromise();
	return typeof Promise.prototype['finally'] === 'function' ? Promise.prototype['finally'] : implementation;
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(52);

var getPolyfill = __webpack_require__(62);
var define = __webpack_require__(47);

module.exports = function shimPromiseFinally() {
	requirePromise();

	var polyfill = getPolyfill();
	define(Promise.prototype, { 'finally': polyfill }, {
		'finally': function testFinally() {
			return Promise.prototype['finally'] !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const log4js_1 = tslib_1.__importDefault(__webpack_require__(67));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const os_1 = tslib_1.__importDefault(__webpack_require__(76));
function getLogFile() {
    let file = process.env.NVIM_COC_LOG_FILE;
    if (file)
        return file;
    let dir = process.env.XDG_RUNTIME_DIR;
    if (dir) {
        try {
            fs_1.default.accessSync(dir, fs_1.default.constants.R_OK | fs_1.default.constants.W_OK);
            return path_1.default.join(dir, `coc-nvim-${process.pid}.log`);
        }
        catch (err) {
            // noop
        }
    }
    dir = path_1.default.join(process.env.TMPDIR, `coc.nvim-${process.pid}`);
    if (os_1.default.platform() == 'win32') {
        dir = path_1.default.win32.normalize(dir);
    }
    if (!fs_1.default.existsSync(dir))
        fs_1.default.mkdirSync(dir, { recursive: true });
    return path_1.default.join(dir, `coc-nvim.log`);
}
const MAX_LOG_SIZE = 1024 * 1024;
const MAX_LOG_BACKUPS = 10;
let logfile = getLogFile();
const level = process.env.NVIM_COC_LOG_LEVEL || 'info';
if (fs_1.default.existsSync(logfile)) {
    // cleanup if exists
    try {
        fs_1.default.writeFileSync(logfile, '', { encoding: 'utf8', mode: 0o666 });
    }
    catch (e) {
        // noop
    }
}
log4js_1.default.configure({
    disableClustering: true,
    appenders: {
        out: {
            type: 'file',
            mode: 0o666,
            filename: logfile,
            maxLogSize: MAX_LOG_SIZE,
            backups: MAX_LOG_BACKUPS,
            layout: {
                type: 'pattern',
                // Format log in following pattern:
                // yyyy-MM-dd HH:mm:ss.mil $Level (pid:$pid) $categroy - $message.
                pattern: `%d{ISO8601} %p (pid:${process.pid}) [%c] - %m`,
            },
        }
    },
    categories: {
        default: { appenders: ['out'], level }
    }
});
module.exports = (name = 'coc-nvim') => {
    let logger = log4js_1.default.getLogger(name);
    logger.getLogFile = () => logfile;
    return logger;
};
//# sourceMappingURL=logger.js.map

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview log4js is a library to log in JavaScript in similar manner
 * than in log4j for Java (but not really).
 *
 * <h3>Example:</h3>
 * <pre>
 *  const logging = require('log4js');
 *  const log = logging.getLogger('some-category');
 *
 *  //call the log
 *  log.trace('trace me' );
 * </pre>
 *
 * NOTE: the authors below are the original browser-based log4js authors
 * don't try to contact them about bugs in this version :)
 * @author Stephan Strittmatter - http://jroller.com/page/stritti
 * @author Seth Chisamore - http://www.chisamore.com
 * @since 2005-05-20
 * Website: http://log4js.berlios.de
 */
const debug = __webpack_require__(68)("log4js:main");
const fs = __webpack_require__(66);
const deepClone = __webpack_require__(78)({ proto: true });
const configuration = __webpack_require__(79);
const layouts = __webpack_require__(80);
const levels = __webpack_require__(83);
const appenders = __webpack_require__(84);
const categories = __webpack_require__(151);
const Logger = __webpack_require__(152);
const clustering = __webpack_require__(85);
const connectLogger = __webpack_require__(153);

let enabled = false;

function sendLogEventToAppender(logEvent) {
  if (!enabled) return;
  debug("Received log event ", logEvent);
  const categoryAppenders = categories.appendersForCategory(
    logEvent.categoryName
  );
  categoryAppenders.forEach(appender => {
    appender(logEvent);
  });
}

function loadConfigurationFile(filename) {
  debug(`Loading configuration from ${filename}`);
  try {
    return JSON.parse(fs.readFileSync(filename, "utf8"));
  } catch (e) {
    throw new Error(
      `Problem reading config from file "${filename}". Error was ${e.message}`,
      e
    );
  }
}

function configure(configurationFileOrObject) {
  let configObject = configurationFileOrObject;

  if (typeof configObject === "string") {
    configObject = loadConfigurationFile(configurationFileOrObject);
  }
  debug(`Configuration is ${configObject}`);

  configuration.configure(deepClone(configObject));

  clustering.onMessage(sendLogEventToAppender);

  enabled = true;

  // eslint-disable-next-line no-use-before-define
  return log4js;
}

/**
 * Shutdown all log appenders. This will first disable all writing to appenders
 * and then call the shutdown function each appender.
 *
 * @params {Function} cb - The callback to be invoked once all appenders have
 *  shutdown. If an error occurs, the callback will be given the error object
 *  as the first argument.
 */
function shutdown(cb) {
  debug("Shutdown called. Disabling all log writing.");
  // First, disable all writing to appenders. This prevents appenders from
  // not being able to be drained because of run-away log writes.
  enabled = false;

  // Call each of the shutdown functions in parallel
  const appendersToCheck = Array.from(appenders.values());
  const shutdownFunctions = appendersToCheck.reduceRight(
    (accum, next) => (next.shutdown ? accum + 1 : accum),
    0
  );
  let completed = 0;
  let error;

  debug(`Found ${shutdownFunctions} appenders with shutdown functions.`);
  function complete(err) {
    error = error || err;
    completed += 1;
    debug(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
    if (completed >= shutdownFunctions) {
      debug("All shutdown functions completed.");
      if (cb) {
        cb(error);
      }
    }
  }

  if (shutdownFunctions === 0) {
    debug("No appenders with shutdown functions found.");
    return cb !== undefined && cb();
  }

  appendersToCheck.filter(a => a.shutdown).forEach(a => a.shutdown(complete));

  return null;
}

/**
 * Get a logger instance.
 * @static
 * @param loggerCategoryName
 * @return {Logger} instance of logger for the category
 */
function getLogger(category) {
  if (!enabled) {
    configure(
      process.env.LOG4JS_CONFIG || {
        appenders: { out: { type: "stdout" } },
        categories: { default: { appenders: ["out"], level: "OFF" } }
      }
    );
  }
  return new Logger(category || "default");
}

/**
 * @name log4js
 * @namespace Log4js
 * @property getLogger
 * @property configure
 * @property shutdown
 */
const log4js = {
  getLogger,
  configure,
  shutdown,
  connectLogger,
  levels,
  addLayout: layouts.addLayout
};

module.exports = log4js;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(69);
} else {
	module.exports = __webpack_require__(72);
}


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(70)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(71);

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),
/* 71 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(73);
const util = __webpack_require__(74);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(75);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(70)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.replace(/\s*\n\s*/g, ' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const os = __webpack_require__(76);
const tty = __webpack_require__(73);
const hasFlag = __webpack_require__(77);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if ('GITHUB_ACTIONS' in env) {
		return 1;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = rfdc

function rfdc (opts) {
  opts = opts || {}

  if (opts.circles) return rfdcCircles(opts)
  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a)
    var a2 = new Array(keys.length)
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]
      var cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur)
      } else {
        a2[k] = fn(cur)
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    var o2 = {}
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else {
        o2[k] = clone(cur)
      }
    }
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    var o2 = {}
    for (var k in o) {
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else {
        o2[k] = cloneProto(cur)
      }
    }
    return o2
  }
}

function rfdcCircles (opts) {
  var refs = []
  var refsNew = []

  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a)
    var a2 = new Array(keys.length)
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]
      var cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur)
      } else {
        var index = refs.indexOf(cur)
        if (index !== -1) {
          a2[k] = refsNew[index]
        } else {
          a2[k] = fn(cur)
        }
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    var o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else {
        var i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = clone(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    var o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (var k in o) {
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else {
        var i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = cloneProto(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }
}


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {



const util = __webpack_require__(74);
const debug = __webpack_require__(68)('log4js:configuration');

const preProcessingListeners = [];
const listeners = [];

const not = thing => !thing;

const anObject = thing => thing && typeof thing === 'object' && !Array.isArray(thing);

const validIdentifier = thing => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);

const anInteger = thing => thing && typeof thing === 'number' && Number.isInteger(thing);

const addListener = (fn) => {
  listeners.push(fn);
  debug(`Added listener, now ${listeners.length} listeners`);
};

const addPreProcessingListener = (fn) => {
  preProcessingListeners.push(fn);
  debug(`Added pre-processing listener, now ${preProcessingListeners.length} listeners`);
};

const throwExceptionIf = (config, checks, message) => {
  const tests = Array.isArray(checks) ? checks : [checks];
  tests.forEach((test) => {
    if (test) {
      throw new Error(`Problem with log4js configuration: (${util.inspect(config, { depth: 5 })})`
        + ` - ${message}`);
    }
  });
};

const configure = (candidate) => {
  debug('New configuration to be validated: ', candidate);
  throwExceptionIf(candidate, not(anObject(candidate)), 'must be an object.');

  debug(`Calling pre-processing listeners (${preProcessingListeners.length})`);
  preProcessingListeners.forEach(listener => listener(candidate));
  debug('Configuration pre-processing finished.');

  debug(`Calling configuration listeners (${listeners.length})`);
  listeners.forEach(listener => listener(candidate));
  debug('Configuration finished.');
};

module.exports = {
  configure,
  addListener,
  addPreProcessingListener,
  throwExceptionIf,
  anObject,
  anInteger,
  validIdentifier,
  not
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

const dateFormat = __webpack_require__(81);
const os = __webpack_require__(76);
const util = __webpack_require__(74);
const path = __webpack_require__(82);

const styles = {
  // styles
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  // grayscale
  white: [37, 39],
  grey: [90, 39],
  black: [90, 39],
  // colors
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [91, 39],
  yellow: [33, 39]
};

function colorizeStart(style) {
  return style ? `\x1B[${styles[style][0]}m` : '';
}

function colorizeEnd(style) {
  return style ? `\x1B[${styles[style][1]}m` : '';
}

/**
 * Taken from masylum's fork (https://github.com/masylum/log4js-node)
 */
function colorize(str, style) {
  return colorizeStart(style) + str + colorizeEnd(style);
}

function timestampLevelAndCategory(loggingEvent, colour) {
  return colorize(
    util.format(
      '[%s] [%s] %s - ',
      dateFormat.asString(loggingEvent.startTime),
      loggingEvent.level.toString(),
      loggingEvent.categoryName
    ),
    colour
  );
}

/**
 * BasicLayout is a simple layout for storing the logs. The logs are stored
 * in following format:
 * <pre>
 * [startTime] [logLevel] categoryName - message\n
 * </pre>
 *
 * @author Stephan Strittmatter
 */
function basicLayout(loggingEvent) {
  return timestampLevelAndCategory(loggingEvent) + util.format(...loggingEvent.data);
}

/**
 * colouredLayout - taken from masylum's fork.
 * same as basicLayout, but with colours.
 */
function colouredLayout(loggingEvent) {
  return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util.format(...loggingEvent.data);
}

function messagePassThroughLayout(loggingEvent) {
  return util.format(...loggingEvent.data);
}

function dummyLayout(loggingEvent) {
  return loggingEvent.data[0];
}

/**
 * PatternLayout
 * Format for specifiers is %[padding].[truncation][field]{[format]}
 * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10
 * both padding and truncation can be negative.
 * Negative truncation = trunc from end of string
 * Positive truncation = trunc from start of string
 * Negative padding = pad right
 * Positive padding = pad left
 *
 * Fields can be any of:
 *  - %r time in toLocaleTimeString format
 *  - %p log level
 *  - %c log category
 *  - %h hostname
 *  - %m log data
 *  - %d date in constious formats
 *  - %% %
 *  - %n newline
 *  - %z pid
 *  - %f filename
 *  - %l line number
 *  - %o column postion
 *  - %s call stack
 *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter
 *  - %X{<tokenname>} add dynamic tokens to your log. Tokens are specified in logger context
 * You can use %[ and %] to define a colored block.
 *
 * Tokens are specified as simple key:value objects.
 * The key represents the token name whereas the value can be a string or function
 * which is called to extract the value to put in the log message. If token is not
 * found, it doesn't replace the field.
 *
 * A sample token would be: { 'pid' : function() { return process.pid; } }
 *
 * Takes a pattern string, array of tokens and returns a layout function.
 * @return {Function}
 * @param pattern
 * @param tokens
 * @param timezoneOffset
 *
 * @authors ['Stephan Strittmatter', 'Jan Schmidle']
 */
function patternLayout(pattern, tokens) {
  const TTCC_CONVERSION_PATTERN = '%r %p %c - %m%n';
  const regex = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflos%])(\{([^}]+)\})?|([^%]+)/;

  pattern = pattern || TTCC_CONVERSION_PATTERN;

  function categoryName(loggingEvent, specifier) {
    let loggerName = loggingEvent.categoryName;
    if (specifier) {
      const precision = parseInt(specifier, 10);
      const loggerNameBits = loggerName.split('.');
      if (precision < loggerNameBits.length) {
        loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join('.');
      }
    }
    return loggerName;
  }

  function formatAsDate(loggingEvent, specifier) {
    let format = dateFormat.ISO8601_FORMAT;
    if (specifier) {
      format = specifier;
      // Pick up special cases
      if (format === 'ISO8601') {
        format = dateFormat.ISO8601_FORMAT;
      } else if (format === 'ISO8601_WITH_TZ_OFFSET') {
        format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
      } else if (format === 'ABSOLUTE') {
        format = dateFormat.ABSOLUTETIME_FORMAT;
      } else if (format === 'DATE') {
        format = dateFormat.DATETIME_FORMAT;
      }
    }
    // Format the date
    return dateFormat.asString(format, loggingEvent.startTime);
  }

  function hostname() {
    return os.hostname().toString();
  }

  function formatMessage(loggingEvent) {
    return util.format(...loggingEvent.data);
  }

  function endOfLine() {
    return os.EOL;
  }

  function logLevel(loggingEvent) {
    return loggingEvent.level.toString();
  }

  function startTime(loggingEvent) {
    return dateFormat.asString('hh:mm:ss', loggingEvent.startTime);
  }

  function startColour(loggingEvent) {
    return colorizeStart(loggingEvent.level.colour);
  }

  function endColour(loggingEvent) {
    return colorizeEnd(loggingEvent.level.colour);
  }

  function percent() {
    return '%';
  }

  function pid(loggingEvent) {
    return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();
  }

  function clusterInfo() {
    // this used to try to return the master and worker pids,
    // but it would never have worked because master pid is not available to workers
    // leaving this here to maintain compatibility for patterns
    return pid();
  }

  function userDefined(loggingEvent, specifier) {
    if (typeof tokens[specifier] !== 'undefined') {
      return typeof tokens[specifier] === 'function' ? tokens[specifier](loggingEvent) : tokens[specifier];
    }

    return null;
  }

  function contextDefined(loggingEvent, specifier) {
    const resolver = loggingEvent.context[specifier];

    if (typeof resolver !== 'undefined') {
      return typeof resolver === 'function' ? resolver(loggingEvent) : resolver;
    }

    return null;
  }

  function fileName(loggingEvent, specifier) {
    let filename = loggingEvent.fileName || '';
    if (specifier) {
      const fileDepth = parseInt(specifier, 10);
      const fileList = filename.split(path.sep);
      if (fileList.length > fileDepth) {
        filename = fileList.slice(-fileDepth).join(path.sep);
      }
    }

    return filename;
  }

  function lineNumber(loggingEvent) {
    return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : '';
  }

  function columnNumber(loggingEvent) {
    return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : '';
  }

  function callStack(loggingEvent) {
    return loggingEvent.callStack || '';
  }

  /* eslint quote-props:0 */
  const replacers = {
    c: categoryName,
    d: formatAsDate,
    h: hostname,
    m: formatMessage,
    n: endOfLine,
    p: logLevel,
    r: startTime,
    '[': startColour,
    ']': endColour,
    y: clusterInfo,
    z: pid,
    '%': percent,
    x: userDefined,
    X: contextDefined,
    f: fileName,
    l: lineNumber,
    o: columnNumber,
    s: callStack
  };

  function replaceToken(conversionCharacter, loggingEvent, specifier) {
    return replacers[conversionCharacter](loggingEvent, specifier);
  }

  function truncate(truncation, toTruncate) {
    let len;
    if (truncation) {
      len = parseInt(truncation.substr(1), 10);
      // negative truncate length means truncate from end of string
      return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
    }

    return toTruncate;
  }

  function pad(padding, toPad) {
    let len;
    if (padding) {
      if (padding.charAt(0) === '-') {
        len = parseInt(padding.substr(1), 10);
        // Right pad with spaces
        while (toPad.length < len) {
          toPad += ' ';
        }
      } else {
        len = parseInt(padding, 10);
        // Left pad with spaces
        while (toPad.length < len) {
          toPad = ` ${toPad}`;
        }
      }
    }
    return toPad;
  }

  function truncateAndPad(toTruncAndPad, truncation, padding) {
    let replacement = toTruncAndPad;
    replacement = truncate(truncation, replacement);
    replacement = pad(padding, replacement);
    return replacement;
  }

  return function (loggingEvent) {
    let formattedString = '';
    let result;
    let searchString = pattern;

    /* eslint no-cond-assign:0 */
    while ((result = regex.exec(searchString)) !== null) {
      // const matchedString = result[0];
      const padding = result[1];
      const truncation = result[2];
      const conversionCharacter = result[3];
      const specifier = result[5];
      const text = result[6];

      // Check if the pattern matched was just normal text
      if (text) {
        formattedString += text.toString();
      } else {
        // Create a raw replacement string based on the conversion
        // character and specifier
        const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);
        formattedString += truncateAndPad(replacement, truncation, padding);
      }
      searchString = searchString.substr(result.index + result[0].length);
    }
    return formattedString;
  };
}

const layoutMakers = {
  messagePassThrough () {
    return messagePassThroughLayout;
  },
  basic () {
    return basicLayout;
  },
  colored () {
    return colouredLayout;
  },
  coloured () {
    return colouredLayout;
  },
  pattern (config) {
    return patternLayout(config && config.pattern, config && config.tokens);
  },
  dummy () {
    return dummyLayout;
  }
};

module.exports = {
  basicLayout,
  messagePassThroughLayout,
  patternLayout,
  colouredLayout,
  coloredLayout: colouredLayout,
  dummyLayout,
  addLayout (name, serializerGenerator) {
    layoutMakers[name] = serializerGenerator;
  },
  layout (name, config) {
    return layoutMakers[name] && layoutMakers[name](config);
  }
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function padWithZeros(vNumber, width) {
  var numAsString = vNumber.toString();
  while (numAsString.length < width) {
    numAsString = "0" + numAsString;
  }
  return numAsString;
}

function addZero(vNumber) {
  return padWithZeros(vNumber, 2);
}

/**
 * Formats the TimeOffset
 * Thanks to http://www.svendtofte.com/code/date_format/
 * @private
 */
function offset(timezoneOffset) {
  var os = Math.abs(timezoneOffset);
  var h = String(Math.floor(os / 60));
  var m = String(os % 60);
  if (h.length === 1) {
    h = "0" + h;
  }
  if (m.length === 1) {
    m = "0" + m;
  }
  return timezoneOffset < 0 ? "+" + h + m : "-" + h + m;
}

function asString(format, date) {
  if (typeof format !== "string") {
    date = format;
    format = module.exports.ISO8601_FORMAT;
  }
  if (!date) {
    date = module.exports.now();
  }

  // Issue # 14 - Per ISO8601 standard, the time string should be local time
  // with timezone info.
  // See https://en.wikipedia.org/wiki/ISO_8601 section "Time offsets from UTC"

  var vDay = addZero(date.getDate());
  var vMonth = addZero(date.getMonth() + 1);
  var vYearLong = addZero(date.getFullYear());
  var vYearShort = addZero(vYearLong.substring(2, 4));
  var vYear = format.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
  var vHour = addZero(date.getHours());
  var vMinute = addZero(date.getMinutes());
  var vSecond = addZero(date.getSeconds());
  var vMillisecond = padWithZeros(date.getMilliseconds(), 3);
  var vTimeZone = offset(date.getTimezoneOffset());
  var formatted = format
    .replace(/dd/g, vDay)
    .replace(/MM/g, vMonth)
    .replace(/y{1,4}/g, vYear)
    .replace(/hh/g, vHour)
    .replace(/mm/g, vMinute)
    .replace(/ss/g, vSecond)
    .replace(/SSS/g, vMillisecond)
    .replace(/O/g, vTimeZone);
  return formatted;
}

function setDatePart(date, part, value, local) {
  date['set' + (local ? '' : 'UTC') + part](value);
}

function extractDateParts(pattern, str, missingValuesDate) {
  // Javascript Date object doesn't support custom timezone.  Sets all felds as
  // GMT based to begin with.  If the timezone offset is provided, then adjust
  // it using provided timezone, otherwise, adjust it with the system timezone.
  var local = pattern.indexOf('O') < 0;
  var matchers = [
    {
      pattern: /y{1,4}/,
      regexp: "\\d{1,4}",
      fn: function(date, value) {
        setDatePart(date, 'FullYear', value, local);
      }
    },
    {
      pattern: /MM/,
      regexp: "\\d{1,2}",
      fn: function(date, value) {
        setDatePart(date, 'Month', (value - 1), local);
      }
    },
    {
      pattern: /dd/,
      regexp: "\\d{1,2}",
      fn: function(date, value) {
        setDatePart(date, 'Date', value, local);
      }
    },
    {
      pattern: /hh/,
      regexp: "\\d{1,2}",
      fn: function(date, value) {
        setDatePart(date, 'Hours', value, local);
      }
    },
    {
      pattern: /mm/,
      regexp: "\\d\\d",
      fn: function(date, value) {
        setDatePart(date, 'Minutes', value, local);
      }
    },
    {
      pattern: /ss/,
      regexp: "\\d\\d",
      fn: function(date, value) {
        setDatePart(date, 'Seconds', value, local);
      }
    },
    {
      pattern: /SSS/,
      regexp: "\\d\\d\\d",
      fn: function(date, value) {
        setDatePart(date, 'Milliseconds', value, local);
      }
    },
    {
      pattern: /O/,
      regexp: "[+-]\\d{3,4}|Z",
      fn: function(date, value) {
        if (value === "Z") {
          value = 0;
        }
        var offset = Math.abs(value);
        var timezoneOffset = (value > 0 ? -1 :  1 ) * ((offset % 100) + Math.floor(offset / 100) * 60);
        // Per ISO8601 standard: UTC = local time - offset
        //
        // For example, 2000-01-01T01:00:00-0700
        //   local time: 2000-01-01T01:00:00
        //   ==> UTC   : 2000-01-01T08:00:00 ( 01 - (-7) = 8 )
        //
        // To make it even more confusing, the date.getTimezoneOffset() is
        // opposite sign of offset string in the ISO8601 standard.  So if offset
        // is '-0700' the getTimezoneOffset() would be (+)420. The line above
        // calculates timezoneOffset to matche Javascript's behavior.
        //
        // The date/time of the input is actually the local time, so the date
        // object that was constructed is actually local time even thought the
        // UTC setters are used.  This means the date object's internal UTC
        // representation was wrong.  It needs to be fixed by substracting the
        // offset (or adding the offset minutes as they are opposite sign).
        //
        // Note: the time zone has to be processed after all other fileds are
        // set.  The result would be incorrect if the offset was calculated
        // first then overriden by the other filed setters.
        date.setUTCMinutes(date.getUTCMinutes() + timezoneOffset);
      }
    }
  ];

  var parsedPattern = matchers.reduce(
    function(p, m) {
      if (m.pattern.test(p.regexp)) {
        m.index = p.regexp.match(m.pattern).index;
        p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
      } else {
        m.index = -1;
      }
      return p;
    },
    { regexp: pattern, index: [] }
  );

  var dateFns = matchers.filter(function(m) {
    return m.index > -1;
  });
  dateFns.sort(function(a, b) {
    return a.index - b.index;
  });

  var matcher = new RegExp(parsedPattern.regexp);
  var matches = matcher.exec(str);
  if (matches) {
    var date = missingValuesDate || module.exports.now();
    dateFns.forEach(function(f, i) {
      f.fn(date, matches[i + 1]);
    });

    return date;
  }

  throw new Error(
    "String '" + str + "' could not be parsed as '" + pattern + "'"
  );
}

function parse(pattern, str, missingValuesDate) {
  if (!pattern) {
    throw new Error("pattern must be supplied");
  }

  return extractDateParts(pattern, str, missingValuesDate);
}

/**
 * Used for testing - replace this function with a fixed date.
 */
function now() {
  return new Date();
}

module.exports = asString;
module.exports.asString = asString;
module.exports.parse = parse;
module.exports.now = now;
module.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
module.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
module.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
module.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";


/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {



const configuration = __webpack_require__(79);

const validColours = [
  'white', 'grey', 'black',
  'blue', 'cyan', 'green',
  'magenta', 'red', 'yellow'
];

class Level {
  constructor(level, levelStr, colour) {
    this.level = level;
    this.levelStr = levelStr;
    this.colour = colour;
  }

  toString() {
    return this.levelStr;
  }

  /**
   * converts given String to corresponding Level
   * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level
   * @param {Level} [defaultLevel] -- default Level, if no String representation
   * @return {Level}
   */
  static getLevel(sArg, defaultLevel) {
    if (!sArg) {
      return defaultLevel;
    }

    if (sArg instanceof Level) {
      return sArg;
    }

    // a json-serialised level won't be an instance of Level (see issue #768)
    if (sArg instanceof Object && sArg.levelStr) {
      sArg = sArg.levelStr;
    }

    return Level[sArg.toString().toUpperCase()] || defaultLevel;
  }

  static addLevels(customLevels) {
    if (customLevels) {
      const levels = Object.keys(customLevels);
      levels.forEach((l) => {
        const levelStr = l.toUpperCase();
        Level[levelStr] = new Level(
          customLevels[l].value,
          levelStr,
          customLevels[l].colour
        );
        const existingLevelIndex = Level.levels.findIndex(lvl => lvl.levelStr === levelStr);
        if (existingLevelIndex > -1) {
          Level.levels[existingLevelIndex] = Level[levelStr];
        } else {
          Level.levels.push(Level[levelStr]);
        }
      });
      Level.levels.sort((a, b) => a.level - b.level);
    }
  }


  isLessThanOrEqualTo(otherLevel) {
    if (typeof otherLevel === 'string') {
      otherLevel = Level.getLevel(otherLevel);
    }
    return this.level <= otherLevel.level;
  }

  isGreaterThanOrEqualTo(otherLevel) {
    if (typeof otherLevel === 'string') {
      otherLevel = Level.getLevel(otherLevel);
    }
    return this.level >= otherLevel.level;
  }

  isEqualTo(otherLevel) {
    if (typeof otherLevel === 'string') {
      otherLevel = Level.getLevel(otherLevel);
    }
    return this.level === otherLevel.level;
  }
}

Level.levels = [];
Level.addLevels({
  ALL: { value: Number.MIN_VALUE, colour: 'grey' },
  TRACE: { value: 5000, colour: 'blue' },
  DEBUG: { value: 10000, colour: 'cyan' },
  INFO: { value: 20000, colour: 'green' },
  WARN: { value: 30000, colour: 'yellow' },
  ERROR: { value: 40000, colour: 'red' },
  FATAL: { value: 50000, colour: 'magenta' },
  MARK: { value: 9007199254740992, colour: 'grey' }, // 2^53
  OFF: { value: Number.MAX_VALUE, colour: 'grey' }
});

configuration.addListener((config) => {
  const levelConfig = config.levels;
  if (levelConfig) {
    configuration.throwExceptionIf(
      config,
      configuration.not(configuration.anObject(levelConfig)),
      'levels must be an object'
    );
    const newLevels = Object.keys(levelConfig);
    newLevels.forEach((l) => {
      configuration.throwExceptionIf(
        config,
        configuration.not(configuration.validIdentifier(l)),
        `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`
      );
      configuration.throwExceptionIf(
        config,
        configuration.not(configuration.anObject(levelConfig[l])),
        `level "${l}" must be an object`
      );
      configuration.throwExceptionIf(
        config,
        configuration.not(levelConfig[l].value),
        `level "${l}" must have a 'value' property`
      );
      configuration.throwExceptionIf(
        config,
        configuration.not(configuration.anInteger(levelConfig[l].value)),
        `level "${l}".value must have an integer value`
      );
      configuration.throwExceptionIf(
        config,
        configuration.not(levelConfig[l].colour),
        `level "${l}" must have a 'colour' property`
      );
      configuration.throwExceptionIf(
        config,
        configuration.not(validColours.indexOf(levelConfig[l].colour) > -1),
        `level "${l}".colour must be one of ${validColours.join(', ')}`
      );
    });
  }
});

configuration.addListener((config) => {
  Level.addLevels(config.levels);
});

module.exports = Level;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

const path = __webpack_require__(82);
const debug = __webpack_require__(68)('log4js:appenders');
const configuration = __webpack_require__(79);
const clustering = __webpack_require__(85);
const levels = __webpack_require__(83);
const layouts = __webpack_require__(80);
const adapters = __webpack_require__(89);

// pre-load the core appenders so that webpack can find them
const coreAppenders = new Map();
coreAppenders.set('console', __webpack_require__(90));
coreAppenders.set('stdout', __webpack_require__(91));
coreAppenders.set('stderr', __webpack_require__(92));
coreAppenders.set('logLevelFilter', __webpack_require__(93));
coreAppenders.set('categoryFilter', __webpack_require__(94));
coreAppenders.set('noLogFilter', __webpack_require__(95));
coreAppenders.set('file', __webpack_require__(96));
coreAppenders.set('dateFile', __webpack_require__(148));
coreAppenders.set('fileSync', __webpack_require__(149));

const appenders = new Map();

const tryLoading = (modulePath, config) => {
  debug('Loading module from ', modulePath);
  try {
    return __webpack_require__(150)(modulePath); //eslint-disable-line
  } catch (e) {
    // if the module was found, and we still got an error, then raise it
    configuration.throwExceptionIf(
      config,
      e.code !== 'MODULE_NOT_FOUND',
      `appender "${modulePath}" could not be loaded (error was: ${e})`
    );
    return undefined;
  }
};

const loadAppenderModule = (type, config) => coreAppenders.get(type)
  || tryLoading(`./${type}`, config)
  || tryLoading(type, config)
  || (__webpack_require__.c[__webpack_require__.s] && tryLoading(path.join(path.dirname(__webpack_require__.c[__webpack_require__.s].filename), type), config))
  || tryLoading(path.join(process.cwd(), type), config);

const appendersLoading = new Set();

const getAppender = (name, config) => {
  if (appenders.has(name)) return appenders.get(name);
  if (!config.appenders[name]) return false;
  if (appendersLoading.has(name)) throw new Error(`Dependency loop detected for appender ${name}.`);
  appendersLoading.add(name);

  debug(`Creating appender ${name}`);
  // eslint-disable-next-line no-use-before-define
  const appender = createAppender(name, config);
  appendersLoading.delete(name);
  appenders.set(name, appender);
  return appender;
};

const createAppender = (name, config) => {
  const appenderConfig = config.appenders[name];
  const appenderModule = appenderConfig.type.configure
    ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config);
  configuration.throwExceptionIf(
    config,
    configuration.not(appenderModule),
    `appender "${name}" is not valid (type "${appenderConfig.type}" could not be found)`
  );
  if (appenderModule.appender) {
    debug(`DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`);
  }
  if (appenderModule.shutdown) {
    debug(`DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`);
  }

  debug(`${name}: clustering.isMaster ? ${clustering.isMaster()}`);
  debug(`${name}: appenderModule is ${__webpack_require__(74).inspect(appenderModule)}`); // eslint-disable-line
  return clustering.onlyOnMaster(() => {
    debug(`calling appenderModule.configure for ${name} / ${appenderConfig.type}`);
    return appenderModule.configure(
      adapters.modifyConfig(appenderConfig),
      layouts,
      appender => getAppender(appender, config),
      levels
    );
  }, () => { });
};

const setup = (config) => {
  appenders.clear();
  appendersLoading.clear();
  const usedAppenders = [];
  Object.values(config.categories).forEach(category => {
    usedAppenders.push(...category.appenders)
  });
  Object.keys(config.appenders).forEach((name) => {
    // dodgy hard-coding of special case for tcp-server which may not have
    // any categories associated with it, but needs to be started up anyway
    if (usedAppenders.includes(name) || config.appenders[name].type === 'tcp-server') {
      getAppender(name, config);
    }
  });
};

setup({ appenders: { out: { type: 'stdout' } }, categories: { default: { appenders: ['out'], level: 'trace' } } });

configuration.addListener((config) => {
  configuration.throwExceptionIf(
    config,
    configuration.not(configuration.anObject(config.appenders)),
    'must have a property "appenders" of type object.'
  );
  const appenderNames = Object.keys(config.appenders);
  configuration.throwExceptionIf(
    config,
    configuration.not(appenderNames.length),
    'must define at least one appender.'
  );

  appenderNames.forEach((name) => {
    configuration.throwExceptionIf(
      config,
      configuration.not(config.appenders[name].type),
      `appender "${name}" is not valid (must be an object with property "type")`
    );
  });
});

configuration.addListener(setup);

module.exports = appenders;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)("log4js:clustering");
const LoggingEvent = __webpack_require__(86);
const configuration = __webpack_require__(79);

let disabled = false;
let cluster = null;
try {
  cluster = __webpack_require__(88); //eslint-disable-line
} catch (e) {
  debug("cluster module not present");
  disabled = true;
}

const listeners = [];

let pm2 = false;
let pm2InstanceVar = "NODE_APP_INSTANCE";

const isPM2Master = () => pm2 && process.env[pm2InstanceVar] === "0";
const isMaster = () => disabled || cluster.isMaster || isPM2Master();

const sendToListeners = logEvent => {
  listeners.forEach(l => l(logEvent));
};

// in a multi-process node environment, worker loggers will use
// process.send
const receiver = (worker, message) => {
  // prior to node v6, the worker parameter was not passed (args were message, handle)
  debug("cluster message received from worker ", worker, ": ", message);
  if (worker.topic && worker.data) {
    message = worker;
    worker = undefined;
  }
  if (message && message.topic && message.topic === "log4js:message") {
    debug("received message: ", message.data);
    const logEvent = LoggingEvent.deserialise(message.data);
    sendToListeners(logEvent);
  }
};

if (!disabled) {
  configuration.addListener(config => {
    // clear out the listeners, because configure has been called.
    listeners.length = 0;

    ({
      pm2,
      disableClustering: disabled,
      pm2InstanceVar = "NODE_APP_INSTANCE"
    } = config);

    debug(`clustering disabled ? ${disabled}`);
    debug(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
    debug(`pm2 enabled ? ${pm2}`);
    debug(`pm2InstanceVar = ${pm2InstanceVar}`);
    debug(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);

    // just in case configure is called after shutdown
    if (pm2) {
      process.removeListener("message", receiver);
    }
    if (cluster && cluster.removeListener) {
      cluster.removeListener("message", receiver);
    }

    if (disabled || config.disableClustering) {
      debug("Not listening for cluster messages, because clustering disabled.");
    } else if (isPM2Master()) {
      // PM2 cluster support
      // PM2 runs everything as workers - install pm2-intercom for this to work.
      // we only want one of the app instances to write logs
      debug("listening for PM2 broadcast messages");
      process.on("message", receiver);
    } else if (cluster.isMaster) {
      debug("listening for cluster messages");
      cluster.on("message", receiver);
    } else {
      debug("not listening for messages, because we are not a master process");
    }
  });
}

module.exports = {
  onlyOnMaster: (fn, notMaster) => (isMaster() ? fn() : notMaster),
  isMaster,
  send: msg => {
    if (isMaster()) {
      sendToListeners(msg);
    } else {
      if (!pm2) {
        msg.cluster = {
          workerId: cluster.worker.id,
          worker: process.pid
        };
      }
      process.send({ topic: "log4js:message", data: msg.serialise() });
    }
  },
  onMessage: listener => {
    listeners.push(listener);
  }
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

const flatted = __webpack_require__(87);
const levels = __webpack_require__(83);

/**
 * @name LoggingEvent
 * @namespace Log4js
 */
class LoggingEvent {
  /**
   * Models a logging event.
   * @constructor
   * @param {string} categoryName name of category
   * @param {Log4js.Level} level level of message
   * @param {Array} data objects to log
   * @author Seth Chisamore
   */
  constructor(categoryName, level, data, context, location) {
    this.startTime = new Date();
    this.categoryName = categoryName;
    this.data = data;
    this.level = level;
    this.context = Object.assign({}, context);
    this.pid = process.pid;

    if (location) {
      this.functionName = location.functionName;
      this.fileName = location.fileName;
      this.lineNumber = location.lineNumber;
      this.columnNumber = location.columnNumber;
      this.callStack = location.callStack;
    }
  }

  serialise() {
    const logData = this.data.map((e) => {
      // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.
      // The following allows us to serialize errors correctly.
      if (e && e.message && e.stack) {
        e = Object.assign({ message: e.message, stack: e.stack }, e);
      }
      return e;
    });
    this.data = logData;
    return flatted.stringify(this);
  }

  static deserialise(serialised) {
    let event;
    try {
      const rehydratedEvent = flatted.parse(serialised);
      rehydratedEvent.data = rehydratedEvent.data.map((e) => {
        if (e && e.message && e.stack) {
          const fakeError = new Error(e);
          Object.keys(e).forEach((key) => { fakeError[key] = e[key]; });
          e = fakeError;
        }
        return e;
      });
      event = new LoggingEvent(
        rehydratedEvent.categoryName,
        levels.getLevel(rehydratedEvent.level.levelStr),
        rehydratedEvent.data,
        rehydratedEvent.context
      );
      event.startTime = new Date(rehydratedEvent.startTime);
      event.pid = rehydratedEvent.pid;
      event.cluster = rehydratedEvent.cluster;
    } catch (e) {
      event = new LoggingEvent(
        'log4js',
        levels.ERROR,
        ['Unable to parse log:', serialised, 'because: ', e]
      );
    }

    return event;
  }
}

module.exports = LoggingEvent;


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringify", function() { return stringify; });
var Flatted = (function (Primitive, primitive) {

  /*!
   * ISC License
   *
   * Copyright (c) 2018, Andrea Giammarchi, @WebReflection
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
   * PERFORMANCE OF THIS SOFTWARE.
   */

  var Flatted = {

    parse: function parse(text, reviver) {
      var input = JSON.parse(text, Primitives).map(primitives);
      var value = input[0];
      var $ = reviver || noop;
      var tmp = typeof value === 'object' && value ?
                  revive(input, new Set, value, $) :
                  value;
      return $.call({'': tmp}, '', tmp);
    },

    stringify: function stringify(value, replacer, space) {
      for (var
        firstRun,
        known = new Map,
        input = [],
        output = [],
        $ = replacer && typeof replacer === typeof input ?
              function (k, v) {
                if (k === '' || -1 < replacer.indexOf(k)) return v;
              } :
              (replacer || noop),
        i = +set(known, input, $.call({'': value}, '', value)),
        replace = function (key, value) {
          if (firstRun) {
            firstRun = !firstRun;
            return value;
          }
          var after = $.call(this, key, value);
          switch (typeof after) {
            case 'object':
              if (after === null) return after;
            case primitive:
              return known.get(after) || set(known, input, after);
          }
          return after;
        };
        i < input.length; i++
      ) {
        firstRun = true;
        output[i] = JSON.stringify(input[i], replace, space);
      }
      return '[' + output.join(',') + ']';
    }

  };

  return Flatted;

  function noop(key, value) {
    return value;
  }

  function revive(input, parsed, output, $) {
    return Object.keys(output).reduce(
      function (output, key) {
        var value = output[key];
        if (value instanceof Primitive) {
          var tmp = input[value];
          if (typeof tmp === 'object' && !parsed.has(tmp)) {
            parsed.add(tmp);
            output[key] = $.call(output, key, revive(input, parsed, tmp, $));
          } else {
            output[key] = $.call(output, key, tmp);
          }
        } else
          output[key] = $.call(output, key, value);
        return output;
      },
      output
    );
  }

  function set(known, input, value) {
    var index = Primitive(input.push(value) - 1);
    known.set(value, index);
    return index;
  }

  // the two kinds of primitives
  //  1. the real one
  //  2. the wrapped one

  function primitives(value) {
    return value instanceof Primitive ? Primitive(value) : value;
  }

  function Primitives(key, value) {
    return typeof value === primitive ? new Primitive(value) : value;
  }

}(String, 'string'));
/* harmony default export */ __webpack_exports__["default"] = (Flatted);
var parse = Flatted.parse;
var stringify = Flatted.stringify;


/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = require("cluster");

/***/ }),
/* 89 */
/***/ (function(module, exports) {

function maxFileSizeUnitTransform(maxLogSize) {
  if (typeof maxLogSize === 'number' && Number.isInteger(maxLogSize)) {
    return maxLogSize;
  }

  const units = {
    K: 1024,
    M: 1024 * 1024,
    G: 1024 * 1024 * 1024,
  };
  const validUnit = Object.keys(units);
  const unit = maxLogSize.substr(maxLogSize.length - 1).toLocaleUpperCase();
  const value = maxLogSize.substring(0, maxLogSize.length - 1).trim();

  if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {
    throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
  } else {
    return value * units[unit];
  }
}

function adapter(configAdapter, config) {
  const newConfig = Object.assign({}, config);
  Object.keys(configAdapter).forEach((key) => {
    if (newConfig[key]) {
      newConfig[key] = configAdapter[key](config[key]);
    }
  });
  return newConfig;
}

function fileAppenderAdapter(config) {
  const configAdapter = {
    maxLogSize: maxFileSizeUnitTransform
  };
  return adapter(configAdapter, config);
}

const adapters = {
  file: fileAppenderAdapter,
  fileSync: fileAppenderAdapter
};

module.exports.modifyConfig = config => (adapters[config.type] ? adapters[config.type](config) : config);


/***/ }),
/* 90 */
/***/ (function(module, exports) {

// eslint-disable-next-line no-console
const consoleLog = console.log.bind(console);

function consoleAppender(layout, timezoneOffset) {
  return (loggingEvent) => {
    consoleLog(layout(loggingEvent, timezoneOffset));
  };
}

function configure(config, layouts) {
  let layout = layouts.colouredLayout;
  if (config.layout) {
    layout = layouts.layout(config.layout.type, config.layout);
  }
  return consoleAppender(layout, config.timezoneOffset);
}

module.exports.configure = configure;


/***/ }),
/* 91 */
/***/ (function(module, exports) {



function stdoutAppender(layout, timezoneOffset) {
  return (loggingEvent) => {
    process.stdout.write(`${layout(loggingEvent, timezoneOffset)}\n`);
  };
}

function configure(config, layouts) {
  let layout = layouts.colouredLayout;
  if (config.layout) {
    layout = layouts.layout(config.layout.type, config.layout);
  }
  return stdoutAppender(layout, config.timezoneOffset);
}

exports.configure = configure;


/***/ }),
/* 92 */
/***/ (function(module, exports) {



function stderrAppender(layout, timezoneOffset) {
  return (loggingEvent) => {
    process.stderr.write(`${layout(loggingEvent, timezoneOffset)}\n`);
  };
}

function configure(config, layouts) {
  let layout = layouts.colouredLayout;
  if (config.layout) {
    layout = layouts.layout(config.layout.type, config.layout);
  }
  return stderrAppender(layout, config.timezoneOffset);
}

module.exports.configure = configure;


/***/ }),
/* 93 */
/***/ (function(module, exports) {

function logLevelFilter(minLevelString, maxLevelString, appender, levels) {
  const minLevel = levels.getLevel(minLevelString);
  const maxLevel = levels.getLevel(maxLevelString, levels.FATAL);
  return (logEvent) => {
    const eventLevel = logEvent.level;
    if (eventLevel.isGreaterThanOrEqualTo(minLevel) && eventLevel.isLessThanOrEqualTo(maxLevel)) {
      appender(logEvent);
    }
  };
}

function configure(config, layouts, findAppender, levels) {
  const appender = findAppender(config.appender);
  return logLevelFilter(config.level, config.maxLevel, appender, levels);
}

module.exports.configure = configure;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)('log4js:categoryFilter');

function categoryFilter(excludes, appender) {
  if (typeof excludes === 'string') excludes = [excludes];
  return (logEvent) => {
    debug(`Checking ${logEvent.categoryName} against ${excludes}`);
    if (excludes.indexOf(logEvent.categoryName) === -1) {
      debug('Not excluded, sending to appender');
      appender(logEvent);
    }
  };
}

function configure(config, layouts, findAppender) {
  const appender = findAppender(config.appender);
  return categoryFilter(config.exclude, appender);
}

module.exports.configure = configure;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {



const debug = __webpack_require__(68)('log4js:noLogFilter');

/**
 * The function removes empty or null regexp from the array
 * @param {string[]} regexp
 * @returns {string[]} a filtered string array with not empty or null regexp
 */
function removeNullOrEmptyRegexp(regexp) {
  const filtered = regexp.filter(el => ((el != null) && (el !== '')));
  return filtered;
}

/**
 * Returns a function that will exclude the events in case they match
 * with the regular expressions provided
 * @param {(string|string[])} filters contains the regexp that will be used for the evaluation
 * @param {*} appender
 * @returns {function}
 */
function noLogFilter(filters, appender) {
  return (logEvent) => {
    debug(`Checking data: ${logEvent.data} against filters: ${filters}`);
    if (typeof filters === 'string') {
      filters = [filters];
    }
    filters = removeNullOrEmptyRegexp(filters);
    const regex = new RegExp(filters.join('|'), 'i');
    if (filters.length === 0
      || logEvent.data.findIndex(value => regex.test(value)) < 0) {
      debug('Not excluded, sending to appender');
      appender(logEvent);
    }
  };
}

function configure(config, layouts, findAppender) {
  const appender = findAppender(config.appender);
  return noLogFilter(config.exclude, appender);
}

module.exports.configure = configure;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)('log4js:file');
const path = __webpack_require__(82);
const streams = __webpack_require__(97);
const os = __webpack_require__(76);

const eol = os.EOL;

function openTheStream(file, fileSize, numFiles, options) {
  const stream = new streams.RollingFileStream(
    file,
    fileSize,
    numFiles,
    options
  );
  stream.on('error', (err) => {
    console.error('log4js.fileAppender - Writing to file %s, error happened ', file, err); //eslint-disable-line
  });
  stream.on('drain', () => {
    process.emit("log4js:pause", false);
  });
  return stream;
}


/**
 * File Appender writing the logs to a text file. Supports rolling of logs by size.
 *
 * @param file file log messages will be written to
 * @param layout a function that takes a logEvent and returns a string
 *   (defaults to basicLayout).
 * @param logSize - the maximum size (in bytes) for a log file,
 *   if not provided then logs won't be rotated.
 * @param numBackups - the number of log files to keep after logSize
 *   has been reached (default 5)
 * @param options - options to be passed to the underlying stream
 * @param timezoneOffset - optional timezone offset in minutes (default system local)
 */
function fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {
  file = path.normalize(file);
  numBackups = numBackups === undefined ? 5 : numBackups;
  // there has to be at least one backup if logSize has been specified
  numBackups = numBackups === 0 ? 1 : numBackups;

  debug(
    'Creating file appender (',
    file, ', ',
    logSize, ', ',
    numBackups, ', ',
    options, ', ',
    timezoneOffset, ')'
  );

  let writer = openTheStream(file, logSize, numBackups, options);

  const app = function (loggingEvent) {
    if (options.removeColor === true) {
      // eslint-disable-next-line no-control-regex
      const regex = /\x1b[[0-9;]*m/g;
      loggingEvent.data = loggingEvent.data.map(d => {
        if (typeof d === 'string') return d.replace(regex, '')
        return d
      })
    }
    if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, "utf8")) {
      process.emit('log4js:pause', true);
    }
  };

  app.reopen = function () {
    writer.end(() => { writer = openTheStream(file, logSize, numBackups, options); });
  };

  app.sighupHandler = function () {
    debug('SIGHUP handler called.');
    app.reopen();
  };

  app.shutdown = function (complete) {
    process.removeListener('SIGHUP', app.sighupHandler);
    writer.end('', 'utf-8', complete);
  };

  // On SIGHUP, close and reopen all files. This allows this appender to work with
  // logrotate. Note that if you are using logrotate, you should not set
  // `logSize`.
  process.on('SIGHUP', app.sighupHandler);

  return app;
}

function configure(config, layouts) {
  let layout = layouts.basicLayout;
  if (config.layout) {
    layout = layouts.layout(config.layout.type, config.layout);
  }

  return fileAppender(
    config.filename,
    layout,
    config.maxLogSize,
    config.backups,
    config,
    config.timezoneOffset
  );
}

module.exports.configure = configure;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  RollingFileWriteStream: __webpack_require__(98),
  RollingFileStream: __webpack_require__(146),
  DateRollingFileStream: __webpack_require__(147)
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)("streamroller:RollingFileWriteStream");
const fs = __webpack_require__(99);
const path = __webpack_require__(82);
const newNow = __webpack_require__(140);
const format = __webpack_require__(141);
const { Writable } = __webpack_require__(106);
const fileNameFormatter = __webpack_require__(142);
const fileNameParser = __webpack_require__(143);
const moveAndMaybeCompressFile = __webpack_require__(144);

/**
 * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.
 * RollingFileWriteStream inherits from stream.Writable
 */
class RollingFileWriteStream extends Writable {
  /**
   * Create a RollingFileWriteStream
   * @constructor
   * @param {string} filePath - The file path to write.
   * @param {object} options - The extra options
   * @param {number} options.numToKeep - The max numbers of files to keep.
   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.
   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.
   * @param {string} options.mode - The mode of the files. The default is '0644'. Refer to stream.writable for more.
   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.
   * @param {boolean} options.compress - Whether to compress backup files.
   * @param {boolean} options.keepFileExt - Whether to keep the file extension.
   * @param {string} options.pattern - The date string pattern in the file name.
   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.
   */
  constructor(filePath, options) {
    debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);
    super(options);
    this.options = this._parseOption(options);
    this.fileObject = path.parse(filePath);
    if (this.fileObject.dir === "") {
      this.fileObject = path.parse(path.join(process.cwd(), filePath));
    }
    this.fileFormatter = fileNameFormatter({
      file: this.fileObject,
      alwaysIncludeDate: this.options.alwaysIncludePattern,
      needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
      compress: this.options.compress,
      keepFileExt: this.options.keepFileExt
    });

    this.fileNameParser = fileNameParser({
      file: this.fileObject,
      keepFileExt: this.options.keepFileExt,
      pattern: this.options.pattern
    });

    this.state = {
      currentSize: 0
    };

    if (this.options.pattern) {
      this.state.currentDate = format(this.options.pattern, newNow());
    }

    this.filename = this.fileFormatter({
      index: 0,
      date: this.state.currentDate
    });
    if (["a", "a+", "as", "as+"].includes(this.options.flags)) {
      this._setExistingSizeAndDate();
    }

    debug(
      `constructor: create new file ${this.filename}, state=${JSON.stringify(
        this.state
      )}`
    );
    this._renewWriteStream();
  }

  _setExistingSizeAndDate() {
    try {
      const stats = fs.statSync(this.filename);
      this.state.currentSize = stats.size;
      if (this.options.pattern) {
        this.state.currentDate = format(this.options.pattern, stats.mtime);
      }
    } catch (e) {
      //file does not exist, that's fine - move along
      return;
    }
  }

  _parseOption(rawOptions) {
    const defaultOptions = {
      maxSize: Number.MAX_SAFE_INTEGER,
      numToKeep: Number.MAX_SAFE_INTEGER,
      encoding: "utf8",
      mode: parseInt("0644", 8),
      flags: "a",
      compress: false,
      keepFileExt: false,
      alwaysIncludePattern: false
    };
    const options = Object.assign({}, defaultOptions, rawOptions);
    if (options.maxSize <= 0) {
      throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
    }
    if (options.numToKeep <= 0) {
      throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
    }
    debug(
      `_parseOption: creating stream with option=${JSON.stringify(options)}`
    );
    return options;
  }

  _final(callback) {
    this.currentFileStream.end("", this.options.encoding, callback);
  }

  _write(chunk, encoding, callback) {
    this._shouldRoll().then(() => {
      debug(
        `_write: writing chunk. ` +
          `file=${this.currentFileStream.path} ` +
          `state=${JSON.stringify(this.state)} ` +
          `chunk=${chunk}`
      );
      this.currentFileStream.write(chunk, encoding, e => {
        this.state.currentSize += chunk.length;
        callback(e);
      });
    });
  }

  async _shouldRoll() {
    if (this._dateChanged() || this._tooBig()) {
      debug(
        `_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`
      );
      await this._roll();
    }
  }

  _dateChanged() {
    return (
      this.state.currentDate &&
      this.state.currentDate !== format(this.options.pattern, newNow())
    );
  }

  _tooBig() {
    return this.state.currentSize >= this.options.maxSize;
  }

  _roll() {
    debug(`_roll: closing the current stream`);
    return new Promise((resolve, reject) => {
      this.currentFileStream.end("", this.options.encoding, () => {
        this._moveOldFiles()
          .then(resolve)
          .catch(reject);
      });
    });
  }

  async _moveOldFiles() {
    const files = await this._getExistingFiles();
    const todaysFiles = this.state.currentDate
      ? files.filter(f => f.date === this.state.currentDate)
      : files;
    for (let i = todaysFiles.length; i >= 0; i--) {
      debug(`_moveOldFiles: i = ${i}`);
      const sourceFilePath = this.fileFormatter({
        date: this.state.currentDate,
        index: i
      });
      const targetFilePath = this.fileFormatter({
        date: this.state.currentDate,
        index: i + 1
      });

      await moveAndMaybeCompressFile(
        sourceFilePath,
        targetFilePath,
        this.options.compress && i === 0
      );
    }

    this.state.currentSize = 0;
    this.state.currentDate = this.state.currentDate
      ? format(this.options.pattern, newNow())
      : null;
    debug(
      `_moveOldFiles: finished rolling files. state=${JSON.stringify(
        this.state
      )}`
    );
    this._renewWriteStream();
    // wait for the file to be open before cleaning up old ones,
    // otherwise the daysToKeep calculations can be off
    await new Promise((resolve, reject) => {
      this.currentFileStream.write("", "utf8", () => {
        this._clean()
          .then(resolve)
          .catch(reject);
      });
    });
  }

  // Sorted from the oldest to the latest
  async _getExistingFiles() {
    const files = await fs.readdir(this.fileObject.dir).catch(() => []);

    debug(`_getExistingFiles: files=${files}`);
    const existingFileDetails = files
      .map(n => this.fileNameParser(n))
      .filter(n => n);

    const getKey = n =>
      (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
    existingFileDetails.sort((a, b) => getKey(a) - getKey(b));

    return existingFileDetails;
  }

  _renewWriteStream() {
    fs.ensureDirSync(this.fileObject.dir);
    const filePath = this.fileFormatter({
      date: this.state.currentDate,
      index: 0
    });
    const ops = {
      flags: this.options.flags,
      encoding: this.options.encoding,
      mode: this.options.mode
    };
    this.currentFileStream = fs.createWriteStream(filePath, ops);
    this.currentFileStream.on("error", e => {
      this.emit("error", e);
    });
  }

  async _clean() {
    const existingFileDetails = await this._getExistingFiles();
    debug(
      `_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`
    );
    debug("_clean: existing files are: ", existingFileDetails);
    if (this._tooManyFiles(existingFileDetails.length)) {
      const fileNamesToRemove = existingFileDetails
        .slice(0, existingFileDetails.length - this.options.numToKeep - 1)
        .map(f => path.format({ dir: this.fileObject.dir, base: f.filename }));
      await deleteFiles(fileNamesToRemove);
    }
  }

  _tooManyFiles(numFiles) {
    return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
  }
}

const deleteFiles = fileNames => {
  debug(`deleteFiles: files to delete: ${fileNames}`);
  return Promise.all(fileNames.map(f => fs.unlink(f).catch((e) => {
    debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
  })));
};

module.exports = RollingFileWriteStream;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Object.assign(
  {},
  // Export promiseified graceful-fs:
  __webpack_require__(100),
  // Export extra methods:
  __webpack_require__(109),
  __webpack_require__(118),
  __webpack_require__(121),
  __webpack_require__(124),
  __webpack_require__(130),
  __webpack_require__(111),
  __webpack_require__(135),
  __webpack_require__(137),
  __webpack_require__(139),
  __webpack_require__(120),
  __webpack_require__(122)
)

// Export fs.promises as a getter property so that we don't trigger
// ExperimentalWarning before fs.promises is actually accessed.
const fs = __webpack_require__(66)
if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
  Object.defineProperty(module.exports, 'promises', {
    get () { return fs.promises }
  })
}


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = __webpack_require__(101).fromCallback
const fs = __webpack_require__(102)

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchown',
  'lchmod',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'readFile',
  'readdir',
  'readlink',
  'realpath',
  'rename',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
})

// Export all keys:
Object.keys(fs).forEach(key => {
  if (key === 'promises') {
    // fs.promises is a getter property that triggers ExperimentalWarning
    // Don't re-export it here, the getter is defined in "lib/index.js"
    return
  }
  exports[key] = fs[key]
})

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method])
})

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
}

// fs.read() & fs.write need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer })
    })
  })
}

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer })
    })
  })
}

// fs.realpath.native only available in Node v9.2+
if (typeof fs.realpath.native === 'function') {
  exports.realpath.native = u(fs.realpath.native)
}


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
    else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err)
          resolve(res)
        }
        arguments.length++
        fn.apply(this, arguments)
      })
    }
  }, 'name', { value: fn.name })
}

exports.fromPromise = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, arguments)
    else fn.apply(this, arguments).then(r => cb(null, r), cb)
  }, 'name', { value: fn.name })
}


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(66)
var polyfills = __webpack_require__(103)
var legacy = __webpack_require__(105)
var clone = __webpack_require__(107)

var util = __webpack_require__(74)

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          retry()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      retry()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      __webpack_require__(108).equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir (path, options, cb) {
    var args = [path]
    if (typeof options !== 'function') {
      args.push(options)
    } else {
      cb = options
    }
    args.push(go$readdir$cb)

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort()

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]])

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments)
        retry()
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
}

function retry () {
  var elem = fs[gracefulQueue].shift()
  if (elem) {
    debug('RETRY', elem[0].name, elem[1])
    elem[0].apply(null, elem[1])
  }
}


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(104)

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

var chdir = process.chdir
process.chdir = function(d) {
  cwd = null
  chdir.call(process, d)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now()
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er)
            })
          }, backoff)
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er)
      })
    }})(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    read.__proto__ = fs$read
    return read
  })(fs.read)

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}


/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = require("constants");

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(106).Stream

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}


/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = clone

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: obj.__proto__ }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}


/***/ }),
/* 108 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  copySync: __webpack_require__(110)
}


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const mkdirpSync = __webpack_require__(111).mkdirsSync
const utimesSync = __webpack_require__(115).utimesMillisSync
const stat = __webpack_require__(116)

function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  opts = opts || {}
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')
  stat.checkParentPathsSync(src, srcStat, dest, 'copy')
  return handleFilterAndCopy(destStat, src, dest, opts)
}

function handleFilterAndCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path.dirname(dest)
  if (!fs.existsSync(destParent)) mkdirpSync(destParent)
  return startCopy(destStat, src, dest, opts)
}

function startCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats(destStat, src, dest, opts)
}

function getStats (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync
  const srcStat = statSync(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
}

function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest)
    return copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile (srcStat, src, dest, opts) {
  if (typeof fs.copyFileSync === 'function') {
    fs.copyFileSync(src, dest)
    fs.chmodSync(dest, srcStat.mode)
    if (opts.preserveTimestamps) {
      return utimesSync(dest, srcStat.atime, srcStat.mtime)
    }
    return
  }
  return copyFileFallback(srcStat, src, dest, opts)
}

function copyFileFallback (srcStat, src, dest, opts) {
  const BUF_LENGTH = 64 * 1024
  const _buff = __webpack_require__(117)(BUF_LENGTH)

  const fdr = fs.openSync(src, 'r')
  const fdw = fs.openSync(dest, 'w', srcStat.mode)
  let pos = 0

  while (pos < srcStat.size) {
    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
    fs.writeSync(fdw, _buff, 0, bytesRead)
    pos += bytesRead
  }

  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)

  fs.closeSync(fdr)
  fs.closeSync(fdw)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)
  if (destStat && !destStat.isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
  }
  return copyDir(src, dest, opts)
}

function mkDirAndCopy (srcStat, src, dest, opts) {
  fs.mkdirSync(dest)
  copyDir(src, dest, opts)
  return fs.chmodSync(dest, srcStat.mode)
}

function copyDir (src, dest, opts) {
  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
}

function copyDirItem (item, src, dest, opts) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')
  return startCopy(destStat, srcItem, destItem, opts)
}

function onLink (destStat, src, dest, opts) {
  let resolvedSrc = fs.readlinkSync(src)
  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }

  if (!destStat) {
    return fs.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest
    try {
      resolvedDest = fs.readlinkSync(dest)
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest)
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink(resolvedSrc, dest)
  }
}

function copyLink (resolvedSrc, dest) {
  fs.unlinkSync(dest)
  return fs.symlinkSync(resolvedSrc, dest)
}

module.exports = copySync


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const u = __webpack_require__(101).fromCallback
const mkdirs = u(__webpack_require__(112))
const mkdirsSync = __webpack_require__(114)

module.exports = {
  mkdirs,
  mkdirsSync,
  // alias
  mkdirp: mkdirs,
  mkdirpSync: mkdirsSync,
  ensureDir: mkdirs,
  ensureDirSync: mkdirsSync
}


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const invalidWin32Path = __webpack_require__(113).invalidWin32Path

const o777 = parseInt('0777', 8)

function mkdirs (p, opts, callback, made) {
  if (typeof opts === 'function') {
    callback = opts
    opts = {}
  } else if (!opts || typeof opts !== 'object') {
    opts = { mode: opts }
  }

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.')
    errInval.code = 'EINVAL'
    return callback(errInval)
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (mode === undefined) {
    mode = o777 & (~process.umask())
  }
  if (!made) made = null

  callback = callback || function () {}
  p = path.resolve(p)

  xfs.mkdir(p, mode, er => {
    if (!er) {
      made = made || p
      return callback(null, made)
    }
    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return callback(er)
        mkdirs(path.dirname(p), opts, (er, made) => {
          if (er) callback(er, made)
          else mkdirs(p, opts, callback, made)
        })
        break

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) => {
          // if the stat fails, then that's super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made)
          else callback(null, made)
        })
        break
    }
  })
}

module.exports = mkdirs


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(82)

// get drive on windows
function getRootPath (p) {
  p = path.normalize(path.resolve(p)).split(path.sep)
  if (p.length > 0) return p[0]
  return null
}

// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/

function invalidWin32Path (p) {
  const rp = getRootPath(p)
  p = p.replace(rp, '')
  return INVALID_PATH_CHARS.test(p)
}

module.exports = {
  getRootPath,
  invalidWin32Path
}


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const invalidWin32Path = __webpack_require__(113).invalidWin32Path

const o777 = parseInt('0777', 8)

function mkdirsSync (p, opts, made) {
  if (!opts || typeof opts !== 'object') {
    opts = { mode: opts }
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.')
    errInval.code = 'EINVAL'
    throw errInval
  }

  if (mode === undefined) {
    mode = o777 & (~process.umask())
  }
  if (!made) made = null

  p = path.resolve(p)

  try {
    xfs.mkdirSync(p, mode)
    made = made || p
  } catch (err0) {
    if (err0.code === 'ENOENT') {
      if (path.dirname(p) === p) throw err0
      made = mkdirsSync(path.dirname(p), opts, made)
      mkdirsSync(p, opts, made)
    } else {
      // In the case of any other error, just see if there's a dir there
      // already. If so, then hooray!  If not, then something is borked.
      let stat
      try {
        stat = xfs.statSync(p)
      } catch (err1) {
        throw err0
      }
      if (!stat.isDirectory()) throw err0
    }
  }

  return made
}

module.exports = mkdirsSync


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const os = __webpack_require__(76)
const path = __webpack_require__(82)

// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync () {
  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))
  tmpfile = path.join(os.tmpdir(), tmpfile)

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862)
  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')
  const fd = fs.openSync(tmpfile, 'r+')
  fs.futimesSync(fd, d, d)
  fs.closeSync(fd)
  return fs.statSync(tmpfile).mtime > 1435410243000
}

function hasMillisRes (callback) {
  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))
  tmpfile = path.join(os.tmpdir(), tmpfile)

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862)
  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
    if (err) return callback(err)
    fs.open(tmpfile, 'r+', (err, fd) => {
      if (err) return callback(err)
      fs.futimes(fd, d, d, err => {
        if (err) return callback(err)
        fs.close(fd, err => {
          if (err) return callback(err)
          fs.stat(tmpfile, (err, stats) => {
            if (err) return callback(err)
            callback(null, stats.mtime > 1435410243000)
          })
        })
      })
    })
  })
}

function timeRemoveMillis (timestamp) {
  if (typeof timestamp === 'number') {
    return Math.floor(timestamp / 1000) * 1000
  } else if (timestamp instanceof Date) {
    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
  } else {
    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
  }
}

function utimesMillis (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    fs.futimes(fd, atime, mtime, futimesErr => {
      fs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr)
      })
    })
  })
}

function utimesMillisSync (path, atime, mtime) {
  const fd = fs.openSync(path, 'r+')
  fs.futimesSync(fd, atime, mtime)
  return fs.closeSync(fd)
}

module.exports = {
  hasMillisRes,
  hasMillisResSync,
  timeRemoveMillis,
  utimesMillis,
  utimesMillisSync
}


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)

const NODE_VERSION_MAJOR_WITH_BIGINT = 10
const NODE_VERSION_MINOR_WITH_BIGINT = 5
const NODE_VERSION_PATCH_WITH_BIGINT = 0
const nodeVersion = process.versions.node.split('.')
const nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)
const nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)
const nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)

function nodeSupportsBigInt () {
  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
    return true
  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
      return true
    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
        return true
      }
    }
  }
  return false
}

function getStats (src, dest, cb) {
  if (nodeSupportsBigInt()) {
    fs.stat(src, { bigint: true }, (err, srcStat) => {
      if (err) return cb(err)
      fs.stat(dest, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })
          return cb(err)
        }
        return cb(null, { srcStat, destStat })
      })
    })
  } else {
    fs.stat(src, (err, srcStat) => {
      if (err) return cb(err)
      fs.stat(dest, (err, destStat) => {
        if (err) {
          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })
          return cb(err)
        }
        return cb(null, { srcStat, destStat })
      })
    })
  }
}

function getStatsSync (src, dest) {
  let srcStat, destStat
  if (nodeSupportsBigInt()) {
    srcStat = fs.statSync(src, { bigint: true })
  } else {
    srcStat = fs.statSync(src)
  }
  try {
    if (nodeSupportsBigInt()) {
      destStat = fs.statSync(dest, { bigint: true })
    } else {
      destStat = fs.statSync(dest)
    }
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

function checkPaths (src, dest, funcName, cb) {
  getStats(src, dest, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats
    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
      return cb(new Error('Source and destination must not be the same.'))
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return cb(null, { srcStat, destStat })
  })
}

function checkPathsSync (src, dest, funcName) {
  const { srcStat, destStat } = getStatsSync(src, dest)
  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
    throw new Error('Source and destination must not be the same.')
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()
  if (nodeSupportsBigInt()) {
    fs.stat(destParent, { bigint: true }, (err, destStat) => {
      if (err) {
        if (err.code === 'ENOENT') return cb()
        return cb(err)
      }
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        return cb(new Error(errMsg(src, dest, funcName)))
      }
      return checkParentPaths(src, srcStat, destParent, funcName, cb)
    })
  } else {
    fs.stat(destParent, (err, destStat) => {
      if (err) {
        if (err.code === 'ENOENT') return cb()
        return cb(err)
      }
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        return cb(new Error(errMsg(src, dest, funcName)))
      }
      return checkParentPaths(src, srcStat, destParent, funcName, cb)
    })
  }
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return
  let destStat
  try {
    if (nodeSupportsBigInt()) {
      destStat = fs.statSync(destParent, { bigint: true })
    } else {
      destStat = fs.statSync(destParent)
    }
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path.resolve(src).split(path.sep).filter(i => i)
  const destArr = path.resolve(dest).split(path.sep).filter(i => i)
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

module.exports = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir
}


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable node/no-deprecated-api */
module.exports = function (size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    try {
      return Buffer.allocUnsafe(size)
    } catch (e) {
      return new Buffer(size)
    }
  }
  return new Buffer(size)
}


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
module.exports = {
  copy: u(__webpack_require__(119))
}


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const mkdirp = __webpack_require__(111).mkdirs
const pathExists = __webpack_require__(120).pathExists
const utimes = __webpack_require__(115).utimesMillis
const stat = __webpack_require__(116)

function copy (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts
    opts = {}
  } else if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  cb = cb || function () {}
  opts = opts || {}

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  stat.checkPaths(src, dest, 'copy', (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats
    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {
      if (err) return cb(err)
      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
      return checkParentDir(destStat, src, dest, opts, cb)
    })
  })
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path.dirname(dest)
  pathExists(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return startCopy(destStat, src, dest, opts, cb)
    mkdirp(destParent, err => {
      if (err) return cb(err)
      return startCopy(destStat, src, dest, opts, cb)
    })
  })
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(destStat, src, dest, opts, cb)
    return cb()
  }, error => cb(error))
}

function startCopy (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
  return getStats(destStat, src, dest, opts, cb)
}

function getStats (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? fs.stat : fs.lstat
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
  })
}

function onFile (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
  return mayCopyFile(srcStat, src, dest, opts, cb)
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    })
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  if (typeof fs.copyFile === 'function') {
    return fs.copyFile(src, dest, err => {
      if (err) return cb(err)
      return setDestModeAndTimestamps(srcStat, dest, opts, cb)
    })
  }
  return copyFileFallback(srcStat, src, dest, opts, cb)
}

function copyFileFallback (srcStat, src, dest, opts, cb) {
  const rs = fs.createReadStream(src)
  rs.on('error', err => cb(err)).once('open', () => {
    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })
    ws.on('error', err => cb(err))
      .on('open', () => rs.pipe(ws))
      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))
  })
}

function setDestModeAndTimestamps (srcStat, dest, opts, cb) {
  fs.chmod(dest, srcStat.mode, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) {
      return utimes(dest, srcStat.atime, srcStat.mtime, cb)
    }
    return cb()
  })
}

function onDir (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)
  if (destStat && !destStat.isDirectory()) {
    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
  }
  return copyDir(src, dest, opts, cb)
}

function mkDirAndCopy (srcStat, src, dest, opts, cb) {
  fs.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir(src, dest, opts, err => {
      if (err) return cb(err)
      return fs.chmod(dest, srcStat.mode, cb)
    })
  })
}

function copyDir (src, dest, opts, cb) {
  fs.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  })
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop()
  if (!item) return cb()
  return copyDirItem(items, item, src, dest, opts, cb)
}

function copyDirItem (items, item, src, dest, opts, cb) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
    if (err) return cb(err)
    const { destStat } = stats
    startCopy(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    })
  })
}

function onLink (destStat, src, dest, opts, cb) {
  fs.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
    }

    if (!destStat) {
      return fs.symlink(resolvedSrc, dest, cb)
    } else {
      fs.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest)
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink(resolvedSrc, dest, cb)
      })
    }
  })
}

function copyLink (resolvedSrc, dest, cb) {
  fs.unlink(dest, err => {
    if (err) return cb(err)
    return fs.symlink(resolvedSrc, dest, cb)
  })
}

module.exports = copy


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const u = __webpack_require__(101).fromPromise
const fs = __webpack_require__(100)

function pathExists (path) {
  return fs.access(path).then(() => true).catch(() => false)
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
}


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const mkdir = __webpack_require__(111)
const remove = __webpack_require__(122)

const emptyDir = u(function emptyDir (dir, callback) {
  callback = callback || function () {}
  fs.readdir(dir, (err, items) => {
    if (err) return mkdir.mkdirs(dir, callback)

    items = items.map(item => path.join(dir, item))

    deleteItem()

    function deleteItem () {
      const item = items.pop()
      if (!item) return callback()
      remove.remove(item, err => {
        if (err) return callback(err)
        deleteItem()
      })
    }
  })
})

function emptyDirSync (dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch (err) {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
}


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
const rimraf = __webpack_require__(123)

module.exports = {
  remove: u(rimraf),
  removeSync: rimraf.sync
}


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const assert = __webpack_require__(108)

const isWindows = (process.platform === 'win32')

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
}

function rimraf (p, options, cb) {
  let busyTries = 0

  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++
        const time = busyTries * 100
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null
    }

    cb(er)
  })
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er) {
    assert(er instanceof Error)
  }

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er)
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er)
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb)
        } else {
          options.unlink(p, cb)
        }
      })
    }
  })
}

function fixWinEPERMSync (p, options, er) {
  let stats

  assert(p)
  assert(options)
  if (er) {
    assert(er instanceof Error)
  }

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er)
  } else {
    options.unlinkSync(p)
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr) {
    assert(originalEr instanceof Error)
  }
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb)
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr)
    } else {
      cb(er)
    }
  })
}

function rmkids (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length
    let errState

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb)
        }
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st

  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  try {
    st = options.lstatSync(p)
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er)
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null)
    } else {
      options.unlinkSync(p)
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er)
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr) {
    assert(originalEr instanceof Error)
  }

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options)
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  if (isWindows) {
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now()
    do {
      try {
        const ret = options.rmdirSync(p, options)
        return ret
      } catch (er) { }
    } while (Date.now() - startTime < 500) // give up after 500ms
  } else {
    const ret = options.rmdirSync(p, options)
    return ret
  }
}

module.exports = rimraf
rimraf.sync = rimrafSync


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const file = __webpack_require__(125)
const link = __webpack_require__(126)
const symlink = __webpack_require__(127)

module.exports = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
}


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
const path = __webpack_require__(82)
const fs = __webpack_require__(102)
const mkdir = __webpack_require__(111)
const pathExists = __webpack_require__(120).pathExists

function createFile (file, callback) {
  function makeFile () {
    fs.writeFile(file, '', err => {
      if (err) return callback(err)
      callback()
    })
  }

  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path.dirname(file)
    pathExists(dir, (err, dirExists) => {
      if (err) return callback(err)
      if (dirExists) return makeFile()
      mkdir.mkdirs(dir, err => {
        if (err) return callback(err)
        makeFile()
      })
    })
  })
}

function createFileSync (file) {
  let stats
  try {
    stats = fs.statSync(file)
  } catch (e) {}
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  fs.writeFileSync(file, '')
}

module.exports = {
  createFile: u(createFile),
  createFileSync
}


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
const path = __webpack_require__(82)
const fs = __webpack_require__(102)
const mkdir = __webpack_require__(111)
const pathExists = __webpack_require__(120).pathExists

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null)
    })
  }

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink')
        return callback(err)
      }

      const dir = path.dirname(dstpath)
      pathExists(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath)
        })
      })
    })
  })
}

function createLinkSync (srcpath, dstpath) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  try {
    fs.lstatSync(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
}


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
const path = __webpack_require__(82)
const fs = __webpack_require__(102)
const _mkdirs = __webpack_require__(111)
const mkdirs = _mkdirs.mkdirs
const mkdirsSync = _mkdirs.mkdirsSync

const _symlinkPaths = __webpack_require__(128)
const symlinkPaths = _symlinkPaths.symlinkPaths
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync

const _symlinkType = __webpack_require__(129)
const symlinkType = _symlinkType.symlinkType
const symlinkTypeSync = _symlinkType.symlinkTypeSync

const pathExists = __webpack_require__(120).pathExists

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err)
      srcpath = relative.toDst
      symlinkType(relative.toCwd, type, (err, type) => {
        if (err) return callback(err)
        const dir = path.dirname(dstpath)
        pathExists(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
          mkdirs(dir, err => {
            if (err) return callback(err)
            fs.symlink(srcpath, dstpath, type, callback)
          })
        })
      })
    })
  })
}

function createSymlinkSync (srcpath, dstpath, type) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
}


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(82)
const fs = __webpack_require__(102)
const pathExists = __webpack_require__(120).pathExists

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths (srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink')
        return callback(err)
      }
      return callback(null, {
        'toCwd': srcpath,
        'toDst': srcpath
      })
    })
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    return pathExists(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          'toCwd': relativeToDst,
          'toDst': srcpath
        })
      } else {
        return fs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink')
            return callback(err)
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': path.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  let exists
  if (path.isAbsolute(srcpath)) {
    exists = fs.existsSync(srcpath)
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      'toCwd': srcpath,
      'toDst': srcpath
    }
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    exists = fs.existsSync(relativeToDst)
    if (exists) {
      return {
        'toCwd': relativeToDst,
        'toDst': srcpath
      }
    } else {
      exists = fs.existsSync(srcpath)
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        'toCwd': srcpath,
        'toDst': path.relative(dstdir, srcpath)
      }
    }
  }
}

module.exports = {
  symlinkPaths,
  symlinkPathsSync
}


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)

function symlinkType (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type
  if (type) return callback(null, type)
  fs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file'
    callback(null, type)
  })
}

function symlinkTypeSync (srcpath, type) {
  let stats

  if (type) return type
  try {
    stats = fs.lstatSync(srcpath)
  } catch (e) {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

module.exports = {
  symlinkType,
  symlinkTypeSync
}


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
const jsonFile = __webpack_require__(131)

jsonFile.outputJson = u(__webpack_require__(133))
jsonFile.outputJsonSync = __webpack_require__(134)
// aliases
jsonFile.outputJSON = jsonFile.outputJson
jsonFile.outputJSONSync = jsonFile.outputJsonSync
jsonFile.writeJSON = jsonFile.writeJson
jsonFile.writeJSONSync = jsonFile.writeJsonSync
jsonFile.readJSON = jsonFile.readJson
jsonFile.readJSONSync = jsonFile.readJsonSync

module.exports = jsonFile


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
const jsonFile = __webpack_require__(132)

module.exports = {
  // jsonfile exports
  readJson: u(jsonFile.readFile),
  readJsonSync: jsonFile.readFileSync,
  writeJson: u(jsonFile.writeFile),
  writeJsonSync: jsonFile.writeFileSync
}


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var _fs
try {
  _fs = __webpack_require__(102)
} catch (_) {
  _fs = __webpack_require__(66)
}

function readFile (file, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }

  if (typeof options === 'string') {
    options = {encoding: options}
  }

  options = options || {}
  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err)

    data = stripBom(data)

    var obj
    try {
      obj = JSON.parse(data, options ? options.reviver : null)
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message
        return callback(err2)
      } else {
        return callback(null, null)
      }
    }

    callback(null, obj)
  })
}

function readFileSync (file, options) {
  options = options || {}
  if (typeof options === 'string') {
    options = {encoding: options}
  }

  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  try {
    var content = fs.readFileSync(file, options)
    content = stripBom(content)
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message
      throw err
    } else {
      return null
    }
  }
}

function stringify (obj, options) {
  var spaces
  var EOL = '\n'
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces
    }
    if (options.EOL) {
      EOL = options.EOL
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)

  return str.replace(/\n/g, EOL) + EOL
}

function writeFile (file, obj, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }
  options = options || {}
  var fs = options.fs || _fs

  var str = ''
  try {
    str = stringify(obj, options)
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null)
    return
  }

  fs.writeFile(file, str, options, callback)
}

function writeFileSync (file, obj, options) {
  options = options || {}
  var fs = options.fs || _fs

  var str = stringify(obj, options)
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8')
  content = content.replace(/^\uFEFF/, '')
  return content
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
}

module.exports = jsonfile


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(82)
const mkdir = __webpack_require__(111)
const pathExists = __webpack_require__(120).pathExists
const jsonFile = __webpack_require__(131)

function outputJson (file, data, options, callback) {
  if (typeof options === 'function') {
    callback = options
    options = {}
  }

  const dir = path.dirname(file)

  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return jsonFile.writeJson(file, data, options, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)
      jsonFile.writeJson(file, data, options, callback)
    })
  })
}

module.exports = outputJson


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const mkdir = __webpack_require__(111)
const jsonFile = __webpack_require__(131)

function outputJsonSync (file, data, options) {
  const dir = path.dirname(file)

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  jsonFile.writeJsonSync(file, data, options)
}

module.exports = outputJsonSync


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  moveSync: __webpack_require__(136)
}


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const copySync = __webpack_require__(109).copySync
const removeSync = __webpack_require__(122).removeSync
const mkdirpSync = __webpack_require__(111).mkdirpSync
const stat = __webpack_require__(116)

function moveSync (src, dest, opts) {
  opts = opts || {}
  const overwrite = opts.overwrite || opts.clobber || false

  const { srcStat } = stat.checkPathsSync(src, dest, 'move')
  stat.checkParentPathsSync(src, srcStat, dest, 'move')
  mkdirpSync(path.dirname(dest))
  return doRename(src, dest, overwrite)
}

function doRename (src, dest, overwrite) {
  if (overwrite) {
    removeSync(dest)
    return rename(src, dest, overwrite)
  }
  if (fs.existsSync(dest)) throw new Error('dest already exists.')
  return rename(src, dest, overwrite)
}

function rename (src, dest, overwrite) {
  try {
    fs.renameSync(src, dest)
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice(src, dest, overwrite)
  }
}

function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  }
  copySync(src, dest, opts)
  return removeSync(src)
}

module.exports = moveSync


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
module.exports = {
  move: u(__webpack_require__(138))
}


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const copy = __webpack_require__(118).copy
const remove = __webpack_require__(122).remove
const mkdirp = __webpack_require__(111).mkdirp
const pathExists = __webpack_require__(120).pathExists
const stat = __webpack_require__(116)

function move (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  const overwrite = opts.overwrite || opts.clobber || false

  stat.checkPaths(src, dest, 'move', (err, stats) => {
    if (err) return cb(err)
    const { srcStat } = stats
    stat.checkParentPaths(src, srcStat, dest, 'move', err => {
      if (err) return cb(err)
      mkdirp(path.dirname(dest), err => {
        if (err) return cb(err)
        return doRename(src, dest, overwrite, cb)
      })
    })
  })
}

function doRename (src, dest, overwrite, cb) {
  if (overwrite) {
    return remove(dest, err => {
      if (err) return cb(err)
      return rename(src, dest, overwrite, cb)
    })
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename(src, dest, overwrite, cb)
  })
}

function rename (src, dest, overwrite, cb) {
  fs.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice(src, dest, overwrite, cb)
  })
}

function moveAcrossDevice (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  }
  copy(src, dest, opts, err => {
    if (err) return cb(err)
    return remove(src, cb)
  })
}

module.exports = move


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(101).fromCallback
const fs = __webpack_require__(102)
const path = __webpack_require__(82)
const mkdir = __webpack_require__(111)
const pathExists = __webpack_require__(120).pathExists

function outputFile (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding
    encoding = 'utf8'
  }

  const dir = path.dirname(file)
  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return fs.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)

      fs.writeFile(file, data, encoding, callback)
    })
  })
}

function outputFileSync (file, ...args) {
  const dir = path.dirname(file)
  if (fs.existsSync(dir)) {
    return fs.writeFileSync(file, ...args)
  }
  mkdir.mkdirsSync(dir)
  fs.writeFileSync(file, ...args)
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
}


/***/ }),
/* 140 */
/***/ (function(module, exports) {

// allows us to inject a mock date in tests
module.exports = () => new Date();


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function padWithZeros(vNumber, width) {
  var numAsString = vNumber.toString();
  while (numAsString.length < width) {
    numAsString = "0" + numAsString;
  }
  return numAsString;
}

function addZero(vNumber) {
  return padWithZeros(vNumber, 2);
}

/**
 * Formats the TimeOffset
 * Thanks to http://www.svendtofte.com/code/date_format/
 * @private
 */
function offset(timezoneOffset) {
  var os = Math.abs(timezoneOffset);
  var h = String(Math.floor(os / 60));
  var m = String(os % 60);
  if (h.length === 1) {
    h = "0" + h;
  }
  if (m.length === 1) {
    m = "0" + m;
  }
  return timezoneOffset < 0 ? "+" + h + m : "-" + h + m;
}

function datePart(date, displayUTC, part) {
  return displayUTC ? date["getUTC" + part]() : date["get" + part]();
}

function asString(format, date) {
  if (typeof format !== "string") {
    date = format;
    format = module.exports.ISO8601_FORMAT;
  }
  if (!date) {
    date = module.exports.now();
  }

  var displayUTC = format.indexOf("O") > -1;

  var vDay = addZero(datePart(date, displayUTC, "Date"));
  var vMonth = addZero(datePart(date, displayUTC, "Month") + 1);
  var vYearLong = addZero(datePart(date, displayUTC, "FullYear"));
  var vYearShort = addZero(vYearLong.substring(2, 4));
  var vYear = format.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
  var vHour = addZero(datePart(date, displayUTC, "Hours"));
  var vMinute = addZero(datePart(date, displayUTC, "Minutes"));
  var vSecond = addZero(datePart(date, displayUTC, "Seconds"));
  var vMillisecond = padWithZeros(
    datePart(date, displayUTC, "Milliseconds"),
    3
  );
  var vTimeZone = offset(date.getTimezoneOffset());
  var formatted = format
    .replace(/dd/g, vDay)
    .replace(/MM/g, vMonth)
    .replace(/y{1,4}/g, vYear)
    .replace(/hh/g, vHour)
    .replace(/mm/g, vMinute)
    .replace(/ss/g, vSecond)
    .replace(/SSS/g, vMillisecond)
    .replace(/O/g, vTimeZone);
  return formatted;
}

function extractDateParts(pattern, str, missingValuesDate) {
  var matchers = [
    {
      pattern: /y{1,4}/,
      regexp: "\\d{1,4}",
      fn: function(date, value) {
        date.setFullYear(value);
      }
    },
    {
      pattern: /MM/,
      regexp: "\\d{1,2}",
      fn: function(date, value) {
        date.setMonth(value - 1);
      }
    },
    {
      pattern: /dd/,
      regexp: "\\d{1,2}",
      fn: function(date, value) {
        date.setDate(value);
      }
    },
    {
      pattern: /hh/,
      regexp: "\\d{1,2}",
      fn: function(date, value) {
        date.setHours(value);
      }
    },
    {
      pattern: /mm/,
      regexp: "\\d\\d",
      fn: function(date, value) {
        date.setMinutes(value);
      }
    },
    {
      pattern: /ss/,
      regexp: "\\d\\d",
      fn: function(date, value) {
        date.setSeconds(value);
      }
    },
    {
      pattern: /SSS/,
      regexp: "\\d\\d\\d",
      fn: function(date, value) {
        date.setMilliseconds(value);
      }
    },
    {
      pattern: /O/,
      regexp: "[+-]\\d{3,4}|Z",
      fn: function(date, value) {
        if (value === "Z") {
          value = 0;
        }
        var offset = Math.abs(value);
        var minutes = (offset % 100) + Math.floor(offset / 100) * 60;
        date.setMinutes(date.getMinutes() + (value > 0 ? minutes : -minutes));
      }
    }
  ];

  var parsedPattern = matchers.reduce(
    function(p, m) {
      if (m.pattern.test(p.regexp)) {
        m.index = p.regexp.match(m.pattern).index;
        p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
      } else {
        m.index = -1;
      }
      return p;
    },
    { regexp: pattern, index: [] }
  );

  var dateFns = matchers.filter(function(m) {
    return m.index > -1;
  });
  dateFns.sort(function(a, b) {
    return a.index - b.index;
  });

  var matcher = new RegExp(parsedPattern.regexp);
  var matches = matcher.exec(str);
  if (matches) {
    var date = missingValuesDate || module.exports.now();
    dateFns.forEach(function(f, i) {
      f.fn(date, matches[i + 1]);
    });
    return date;
  }

  throw new Error(
    "String '" + str + "' could not be parsed as '" + pattern + "'"
  );
}

function parse(pattern, str, missingValuesDate) {
  if (!pattern) {
    throw new Error("pattern must be supplied");
  }

  return extractDateParts(pattern, str, missingValuesDate);
}

/**
 * Used for testing - replace this function with a fixed date.
 */
function now() {
  return new Date();
}

module.exports = asString;
module.exports.asString = asString;
module.exports.parse = parse;
module.exports.now = now;
module.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
module.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
module.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
module.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)("streamroller:fileNameFormatter");
const path = __webpack_require__(82);
const FILENAME_SEP = ".";
const ZIP_EXT = ".gz";

module.exports = ({
  file,
  keepFileExt,
  needsIndex,
  alwaysIncludeDate,
  compress
}) => {
  const dirAndName = path.join(file.dir, file.name);

  const ext = f => f + file.ext;

  const index = (f, i, d) =>
    (needsIndex || !d) && i ? f + FILENAME_SEP + i : f;

  const date = (f, i, d) => {
    return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;
  };

  const gzip = (f, i) => (i && compress ? f + ZIP_EXT : f);

  const parts = keepFileExt
    ? [date, index, ext, gzip]
    : [ext, date, index, gzip];

  return ({ date, index }) => {
    debug(`_formatFileName: date=${date}, index=${index}`);
    return parts.reduce(
      (filename, part) => part(filename, index, date),
      dirAndName
    );
  };
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)("streamroller:fileNameParser");
const FILENAME_SEP = ".";
const ZIP_EXT = ".gz";
const format = __webpack_require__(141);

module.exports = ({ file, keepFileExt, pattern }) => {
  // All these functions take two arguments: f, the filename, and p, the result placeholder
  // They return the filename with any matching parts removed.
  // The "zip" function, for instance, removes the ".gz" part of the filename (if present)
  const zip = (f, p) => {
    if (f.endsWith(ZIP_EXT)) {
      debug("it is gzipped");
      p.isCompressed = true;
      return f.slice(0, -1 * ZIP_EXT.length);
    }
    return f;
  };

  const __NOT_MATCHING__ = "__NOT_MATCHING__";

  const extAtEnd = f => {
    if (f.startsWith(file.name) && f.endsWith(file.ext)) {
      debug("it starts and ends with the right things");
      return f.slice(file.name.length + 1, -1 * file.ext.length);
    }
    return __NOT_MATCHING__;
  };

  const extInMiddle = f => {
    if (f.startsWith(file.base)) {
      debug("it starts with the right things");
      return f.slice(file.base.length + 1);
    }
    return __NOT_MATCHING__;
  };

  const dateAndIndex = (f, p) => {
    const items = f.split(FILENAME_SEP);
    let indexStr = items[items.length - 1];
    debug("items: ", items, ", indexStr: ", indexStr);
    let dateStr = f;
    if (indexStr !== undefined && indexStr.match(/^\d+$/)) {
      dateStr = f.slice(0, -1 * (indexStr.length + 1));
      debug(`dateStr is ${dateStr}`);
      if (pattern && !dateStr) {
        dateStr = indexStr;
        indexStr = "0";
      }
    } else {
      indexStr = "0";
    }

    try {
      // Two arguments for new Date() are intentional. This will set other date
      // components to minimal values in the current timezone instead of UTC,
      // as new Date(0) will do.
      const date = format.parse(pattern, dateStr, new Date(0, 0));
      if (format.asString(pattern, date) !== dateStr) return f;
      p.index = parseInt(indexStr, 10);
      p.date = dateStr;
      p.timestamp = date.getTime();
      return "";
    } catch (e) {
      //not a valid date, don't panic.
      debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
      return f;
    }
  };

  const index = (f, p) => {
    if (f.match(/^\d+$/)) {
      debug("it has an index");
      p.index = parseInt(f, 10);
      return "";
    }
    return f;
  };

  let parts = [
    zip,
    keepFileExt ? extAtEnd : extInMiddle,
    pattern ? dateAndIndex : index
  ];

  return filename => {
    let result = { filename, index: 0, isCompressed: false };
    // pass the filename through each of the file part parsers
    let whatsLeftOver = parts.reduce(
      (remains, part) => part(remains, result),
      filename
    );
    // if there's anything left after parsing, then it wasn't a valid filename
    return whatsLeftOver ? null : result;
  };
};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)('streamroller:moveAndMaybeCompressFile');
const fs = __webpack_require__(99);
const zlib = __webpack_require__(145);

const moveAndMaybeCompressFile = async (
  sourceFilePath,
  targetFilePath,
  needCompress
) => {
  if (sourceFilePath === targetFilePath) {
    debug(
      `moveAndMaybeCompressFile: source and target are the same, not doing anything`
    );
    return;
  }
    if (await fs.pathExists(sourceFilePath)) {

      debug(
        `moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${
          needCompress ? "with" : "without"
        } compress`
      );
      if (needCompress) {
        await new Promise((resolve, reject) => {
          fs.createReadStream(sourceFilePath)
            .pipe(zlib.createGzip())
            .pipe(fs.createWriteStream(targetFilePath))
            .on("finish", () => {
              debug(
                `moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`
              );
              fs.unlink(sourceFilePath)
                .then(resolve)
                .catch(() => {
                  debug(`Deleting ${sourceFilePath} failed, truncating instead`);
                  fs.truncate(sourceFilePath).then(resolve).catch(reject)
                });
            });
        });
      } else {
        debug(
          `moveAndMaybeCompressFile: deleting file=${targetFilePath}, renaming ${sourceFilePath} to ${targetFilePath}`
        );
        try {
          await fs.move(sourceFilePath, targetFilePath, { overwrite: true });
        } catch (e) {
          debug(
            `moveAndMaybeCompressFile: error moving ${sourceFilePath} to ${targetFilePath}`, e
          );
          debug(`Trying copy+truncate instead`);
          await fs.copy(sourceFilePath, targetFilePath, { overwrite: true });
          await fs.truncate(sourceFilePath);
        }
      }
    }
};

module.exports = moveAndMaybeCompressFile;


/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

const RollingFileWriteStream = __webpack_require__(98);

// just to adapt the previous version
class RollingFileStream extends RollingFileWriteStream {
  constructor(filename, size, backups, options) {
    if (!options) {
      options = {};
    }
    if (size) {
      options.maxSize = size;
    }
    if (!backups) {
      backups = 1;
    }
    options.numToKeep = backups;
    super(filename, options);
    this.backups = this.options.numToKeep;
    this.size = this.options.maxSize;
  }

  get theStream() {
    return this.currentFileStream;
  }

}

module.exports = RollingFileStream;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

const RollingFileWriteStream = __webpack_require__(98);

// just to adapt the previous version
class DateRollingFileStream extends RollingFileWriteStream {
  constructor(filename, pattern, options) {
    if (pattern && typeof(pattern) === 'object') {
      options = pattern;
      pattern = null;
    }
    if (!options) {
      options = {};
    }
    if (!pattern) {
      pattern = 'yyyy-MM-dd';
    }
    if (options.daysToKeep) {
      options.numToKeep = options.daysToKeep;
    }
    if (pattern.startsWith('.')) {
      pattern = pattern.substring(1);
    }
    options.pattern = pattern;
    super(filename, options);
    this.mode = this.options.mode;
  }

  get theStream() {
    return this.currentFileStream;
  }

}

module.exports = DateRollingFileStream;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

const streams = __webpack_require__(97);
const os = __webpack_require__(76);

const eol = os.EOL;

/**
 * File appender that rolls files according to a date pattern.
 * @filename base filename.
 * @pattern the format that will be added to the end of filename when rolling,
 *          also used to check when to roll files - defaults to '.yyyy-MM-dd'
 * @layout layout function for log messages - defaults to basicLayout
 * @timezoneOffset optional timezone offset in minutes - defaults to system local
 */
function appender(
  filename,
  pattern,
  layout,
  options,
  timezoneOffset
) {
  // the options for file appender use maxLogSize, but the docs say any file appender
  // options should work for dateFile as well.
  options.maxSize = options.maxLogSize;

  const logFile = new streams.DateRollingFileStream(
    filename,
    pattern,
    options
  );

  logFile.on("drain", () => {
    process.emit("log4js:pause", false);
  });

  const app = function (logEvent) {
    if (!logFile.write(layout(logEvent, timezoneOffset) + eol, "utf8")) {
      process.emit("log4js:pause", true);
    }
  };

  app.shutdown = function (complete) {
    logFile.write('', 'utf-8', () => {
      logFile.end(complete);
    });
  };

  return app;
}

function configure(config, layouts) {
  let layout = layouts.basicLayout;

  if (config.layout) {
    layout = layouts.layout(config.layout.type, config.layout);
  }

  if (!config.alwaysIncludePattern) {
    config.alwaysIncludePattern = false;
  }

  return appender(
    config.filename,
    config.pattern,
    layout,
    config,
    config.timezoneOffset
  );
}

module.exports.configure = configure;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)('log4js:fileSync');
const path = __webpack_require__(82);
const fs = __webpack_require__(66);
const os = __webpack_require__(76);

const eol = os.EOL || '\n';

function touchFile(file, options) {
  // if the file exists, nothing to do
  if (fs.existsSync(file)) {
    return;
  }

  // touch the file to apply flags (like w to truncate the file)
  const id = fs.openSync(file, options.flags, options.mode);
  fs.closeSync(id);
}

class RollingFileSync {
  constructor(filename, size, backups, options) {
    debug('In RollingFileStream');

    function throwErrorIfArgumentsAreNotValid() {
      if (!filename || !size || size <= 0) {
        throw new Error('You must specify a filename and file size');
      }
    }

    throwErrorIfArgumentsAreNotValid();

    this.filename = filename;
    this.size = size;
    this.backups = backups || 1;
    this.options = options;
    this.currentSize = 0;

    function currentFileSize(file) {
      let fileSize = 0;

      try {
        fileSize = fs.statSync(file).size;
      } catch (e) {
        // file does not exist
        touchFile(file, options);
      }
      return fileSize;
    }

    this.currentSize = currentFileSize(this.filename);
  }

  shouldRoll() {
    debug('should roll with current size %d, and max size %d', this.currentSize, this.size);
    return this.currentSize >= this.size;
  }

  roll(filename) {
    const that = this;
    const nameMatcher = new RegExp(`^${path.basename(filename)}`);

    function justTheseFiles(item) {
      return nameMatcher.test(item);
    }

    function index(filename_) {
      return parseInt(filename_.substring((`${path.basename(filename)}.`).length), 10) || 0;
    }

    function byIndex(a, b) {
      if (index(a) > index(b)) {
        return 1;
      }
      if (index(a) < index(b)) {
        return -1;
      }

      return 0;
    }

    function increaseFileIndex(fileToRename) {
      const idx = index(fileToRename);
      debug(`Index of ${fileToRename} is ${idx}`);
      if (idx < that.backups) {
        // on windows, you can get a EEXIST error if you rename a file to an existing file
        // so, we'll try to delete the file we're renaming to first
        try {
          fs.unlinkSync(`${filename}.${idx + 1}`);
        } catch (e) {
          // ignore err: if we could not delete, it's most likely that it doesn't exist
        }

        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
        fs.renameSync(path.join(path.dirname(filename), fileToRename), `${filename}.${idx + 1}`);
      }
    }

    function renameTheFiles() {
      // roll the backups (rename file.n to file.n+1, where n <= numBackups)
      debug('Renaming the old files');

      const files = fs.readdirSync(path.dirname(filename));
      files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);
    }

    debug('Rolling, rolling, rolling');
    renameTheFiles();
  }

  /* eslint no-unused-vars:0 */
  write(chunk, encoding) {
    const that = this;


    function writeTheChunk() {
      debug('writing the chunk to the file');
      that.currentSize += chunk.length;
      fs.appendFileSync(that.filename, chunk);
    }

    debug('in write');


    if (this.shouldRoll()) {
      this.currentSize = 0;
      this.roll(this.filename);
    }

    writeTheChunk();
  }
}

/**
 * File Appender writing the logs to a text file. Supports rolling of logs by size.
 *
 * @param file file log messages will be written to
 * @param layout a function that takes a logevent and returns a string
 *   (defaults to basicLayout).
 * @param logSize - the maximum size (in bytes) for a log file,
 *   if not provided then logs won't be rotated.
 * @param numBackups - the number of log files to keep after logSize
 *   has been reached (default 5)
 * @param timezoneOffset - optional timezone offset in minutes
 *   (default system local)
 * @param options - passed as is to fs options
 */
function fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {
  debug('fileSync appender created');
  file = path.normalize(file);
  numBackups = numBackups === undefined ? 5 : numBackups;
  // there has to be at least one backup if logSize has been specified
  numBackups = numBackups === 0 ? 1 : numBackups;

  function openTheStream(filePath, fileSize, numFiles) {
    let stream;

    if (fileSize) {
      stream = new RollingFileSync(
        filePath,
        fileSize,
        numFiles,
        options
      );
    } else {
      stream = (((f) => {
        // touch the file to apply flags (like w to truncate the file)
        touchFile(f, options);

        return {
          write(data) {
            fs.appendFileSync(f, data);
          }
        };
      }))(filePath);
    }

    return stream;
  }

  const logFile = openTheStream(file, logSize, numBackups);

  return (loggingEvent) => {
    logFile.write(layout(loggingEvent, timezoneOffset) + eol);
  };
}

function configure(config, layouts) {
  let layout = layouts.basicLayout;
  if (config.layout) {
    layout = layouts.layout(config.layout.type, config.layout);
  }

  const options = {
    flags: config.flags || 'a',
    encoding: config.encoding || 'utf8',
    mode: config.mode || 0o644
  };

  return fileAppender(
    config.filename,
    layout,
    config.maxLogSize,
    config.backups,
    config.timezoneOffset,
    options
  );
}

module.exports.configure = configure;


/***/ }),
/* 150 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 150;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(68)('log4js:categories');
const configuration = __webpack_require__(79);
const levels = __webpack_require__(83);
const appenders = __webpack_require__(84);

const categories = new Map();

/**
 * Add inherited config to this category.  That includes extra appenders from parent,
 * and level, if none is set on this category.
 * This is recursive, so each parent also gets loaded with inherited appenders.
 * Inheritance is blocked if a category has inherit=false
 * @param  {*} config
 * @param  {*} category the child category
 * @param  {string} categoryName dotted path to category
 * @return {void}
 */
function inheritFromParent(config, category, categoryName) {
  if (category.inherit === false) return;
  const lastDotIndex = categoryName.lastIndexOf('.');
  if (lastDotIndex < 0) return; // category is not a child
  const parentCategoryName = categoryName.substring(0, lastDotIndex);
  let parentCategory = config.categories[parentCategoryName];


  if (!parentCategory) {
    // parent is missing, so implicitly create it, so that it can inherit from its parents
    parentCategory = { inherit: true, appenders: [] };
  }

  // make sure parent has had its inheritance taken care of before pulling its properties to this child
  inheritFromParent(config, parentCategory, parentCategoryName);

  // if the parent is not in the config (because we just created it above),
  // and it inherited a valid configuration, add it to config.categories
  if (!config.categories[parentCategoryName]
    && parentCategory.appenders
    && parentCategory.appenders.length
    && parentCategory.level) {
    config.categories[parentCategoryName] = parentCategory;
  }

  category.appenders = category.appenders || [];
  category.level = category.level || parentCategory.level;

  // merge in appenders from parent (parent is already holding its inherited appenders)
  parentCategory.appenders.forEach((ap) => {
    if (!category.appenders.includes(ap)) {
      category.appenders.push(ap);
    }
  });
  category.parent = parentCategory;
}


/**
 * Walk all categories in the config, and pull down any configuration from parent to child.
 * This includes inherited appenders, and level, where level is not set.
 * Inheritance is skipped where a category has inherit=false.
 * @param  {*} config
 */
function addCategoryInheritance(config) {
  if (!config.categories) return;
  const categoryNames = Object.keys(config.categories);
  categoryNames.forEach((name) => {
    const category = config.categories[name];
    // add inherited appenders and level to this category
    inheritFromParent(config, category, name);
  });
}

configuration.addPreProcessingListener(config => addCategoryInheritance(config));

configuration.addListener((config) => {
  configuration.throwExceptionIf(
    config,
    configuration.not(configuration.anObject(config.categories)),
    'must have a property "categories" of type object.'
  );

  const categoryNames = Object.keys(config.categories);
  configuration.throwExceptionIf(
    config,
    configuration.not(categoryNames.length),
    'must define at least one category.'
  );

  categoryNames.forEach((name) => {
    const category = config.categories[name];
    configuration.throwExceptionIf(
      config,
      [
        configuration.not(category.appenders),
        configuration.not(category.level)
      ],
      `category "${name}" is not valid (must be an object with properties "appenders" and "level")`
    );

    configuration.throwExceptionIf(
      config,
      configuration.not(Array.isArray(category.appenders)),
      `category "${name}" is not valid (appenders must be an array of appender names)`
    );

    configuration.throwExceptionIf(
      config,
      configuration.not(category.appenders.length),
      `category "${name}" is not valid (appenders must contain at least one appender name)`
    );

    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {
      configuration.throwExceptionIf(
        config,
        typeof category.enableCallStack !== 'boolean',
        `category "${name}" is not valid (enableCallStack must be boolean type)`
      );
    }

    category.appenders.forEach((appender) => {
      configuration.throwExceptionIf(
        config,
        configuration.not(appenders.get(appender)),
        `category "${name}" is not valid (appender "${appender}" is not defined)`
      );
    });

    configuration.throwExceptionIf(
      config,
      configuration.not(levels.getLevel(category.level)),
      `category "${name}" is not valid (level "${category.level}" not recognised;`
      + ` valid levels are ${levels.levels.join(', ')})`
    );
  });

  configuration.throwExceptionIf(
    config,
    configuration.not(config.categories.default),
    'must define a "default" category.'
  );
});

const setup = (config) => {
  categories.clear();

  const categoryNames = Object.keys(config.categories);
  categoryNames.forEach((name) => {
    const category = config.categories[name];
    const categoryAppenders = [];
    category.appenders.forEach((appender) => {
      categoryAppenders.push(appenders.get(appender));
      debug(`Creating category ${name}`);
      categories.set(
        name,
        {
          appenders: categoryAppenders,
          level: levels.getLevel(category.level),
          enableCallStack: category.enableCallStack || false
        }
      );
    });
  });
};

setup({ categories: { default: { appenders: ['out'], level: 'OFF' } } });
configuration.addListener(setup);

const configForCategory = (category) => {
  debug(`configForCategory: searching for config for ${category}`);
  if (categories.has(category)) {
    debug(`configForCategory: ${category} exists in config, returning it`);
    return categories.get(category);
  }
  if (category.indexOf('.') > 0) {
    debug(`configForCategory: ${category} has hierarchy, searching for parents`);
    return configForCategory(category.substring(0, category.lastIndexOf('.')));
  }
  debug('configForCategory: returning config for default category');
  return configForCategory('default');
};

const appendersForCategory = category => configForCategory(category).appenders;
const getLevelForCategory = category => configForCategory(category).level;

const setLevelForCategory = (category, level) => {
  let categoryConfig = categories.get(category);
  debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);
  if (!categoryConfig) {
    const sourceCategoryConfig = configForCategory(category);
    debug('setLevelForCategory: no config found for category, '
      + `found ${sourceCategoryConfig} for parents of ${category}`);
    categoryConfig = { appenders: sourceCategoryConfig.appenders };
  }
  categoryConfig.level = level;
  categories.set(category, categoryConfig);
};

const getEnableCallStackForCategory = category => configForCategory(category).enableCallStack === true;
const setEnableCallStackForCategory = (category, useCallStack) => {
  configForCategory(category).enableCallStack = useCallStack;
};

module.exports = {
  appendersForCategory,
  getLevelForCategory,
  setLevelForCategory,
  getEnableCallStackForCategory,
  setEnableCallStackForCategory,
};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint no-underscore-dangle:0 */
const debug = __webpack_require__(68)("log4js:logger");
const LoggingEvent = __webpack_require__(86);
const levels = __webpack_require__(83);
const clustering = __webpack_require__(85);
const categories = __webpack_require__(151);
const configuration = __webpack_require__(79);

const stackReg = /at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/;
function defaultParseCallStack(data, skipIdx = 4) {
  const stacklines = data.stack.split("\n").slice(skipIdx);
  const lineMatch = stackReg.exec(stacklines[0]);
  if (lineMatch && lineMatch.length === 6) {
    return {
      functionName: lineMatch[1],
      fileName: lineMatch[2],
      lineNumber: parseInt(lineMatch[3], 10),
      columnNumber: parseInt(lineMatch[4], 10),
      callStack: stacklines.join("\n")
    };
  }
  return null;
}

/**
 * Logger to log messages.
 * use {@see log4js#getLogger(String)} to get an instance.
 *
 * @name Logger
 * @namespace Log4js
 * @param name name of category to log to
 * @param level - the loglevel for the category
 * @param dispatch - the function which will receive the logevents
 *
 * @author Stephan Strittmatter
 */
class Logger {
  constructor(name) {
    if (!name) {
      throw new Error("No category provided.");
    }
    this.category = name;
    this.context = {};
    this.parseCallStack = defaultParseCallStack;
    debug(`Logger created (${this.category}, ${this.level})`);
  }

  get level() {
    return levels.getLevel(
      categories.getLevelForCategory(this.category),
      levels.TRACE
    );
  }

  set level(level) {
    categories.setLevelForCategory(
      this.category,
      levels.getLevel(level, this.level)
    );
  }

  get useCallStack() {
    return categories.getEnableCallStackForCategory(this.category);
  }

  set useCallStack(bool) {
    categories.setEnableCallStackForCategory(this.category, bool === true);
  }

  log(level, ...args) {
    const logLevel = levels.getLevel(level, levels.INFO);
    if (this.isLevelEnabled(logLevel)) {
      this._log(logLevel, args);
    }
  }

  isLevelEnabled(otherLevel) {
    return this.level.isLessThanOrEqualTo(otherLevel);
  }

  _log(level, data) {
    debug(`sending log data (${level}) to appenders`);
    const loggingEvent = new LoggingEvent(
      this.category,
      level,
      data,
      this.context,
      this.useCallStack && this.parseCallStack(new Error())
    );
    clustering.send(loggingEvent);
  }

  addContext(key, value) {
    this.context[key] = value;
  }

  removeContext(key) {
    delete this.context[key];
  }

  clearContext() {
    this.context = {};
  }

  setParseCallStackFunction(parseFunction) {
    this.parseCallStack = parseFunction;
  }
}

function addLevelMethods(target) {
  const level = levels.getLevel(target);

  const levelStrLower = level.toString().toLowerCase();
  const levelMethod = levelStrLower.replace(/_([a-z])/g, g =>
    g[1].toUpperCase()
  );
  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);

  Logger.prototype[`is${isLevelMethod}Enabled`] = function() {
    return this.isLevelEnabled(level);
  };

  Logger.prototype[levelMethod] = function(...args) {
    this.log(level, ...args);
  };
}

levels.levels.forEach(addLevelMethods);

configuration.addListener(() => {
  levels.levels.forEach(addLevelMethods);
});

module.exports = Logger;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-plusplus */

const levels = __webpack_require__(83);

const DEFAULT_FORMAT =
  ":remote-addr - -" +
  ' ":method :url HTTP/:http-version"' +
  ' :status :content-length ":referrer"' +
  ' ":user-agent"';

/**
 * Return request url path,
 * adding this function prevents the Cyclomatic Complexity,
 * for the assemble_tokens function at low, to pass the tests.
 *
 * @param  {IncomingMessage} req
 * @return {string}
 * @api private
 */
function getUrl(req) {
  return req.originalUrl || req.url;
}

/**
 * Adds custom {token, replacement} objects to defaults,
 * overwriting the defaults if any tokens clash
 *
 * @param  {IncomingMessage} req
 * @param  {ServerResponse} res
 * @param  {Array} customTokens
 *    [{ token: string-or-regexp, replacement: string-or-replace-function }]
 * @return {Array}
 */
function assembleTokens(req, res, customTokens) {
  const arrayUniqueTokens = array => {
    const a = array.concat();
    for (let i = 0; i < a.length; ++i) {
      for (let j = i + 1; j < a.length; ++j) {
        // not === because token can be regexp object
        /* eslint eqeqeq:0 */
        if (a[i].token == a[j].token) {
          a.splice(j--, 1);
        }
      }
    }
    return a;
  };

  const defaultTokens = [];
  defaultTokens.push({ token: ":url", replacement: getUrl(req) });
  defaultTokens.push({ token: ":protocol", replacement: req.protocol });
  defaultTokens.push({ token: ":hostname", replacement: req.hostname });
  defaultTokens.push({ token: ":method", replacement: req.method });
  defaultTokens.push({
    token: ":status",
    replacement: res.__statusCode || res.statusCode
  });
  defaultTokens.push({
    token: ":response-time",
    replacement: res.responseTime
  });
  defaultTokens.push({ token: ":date", replacement: new Date().toUTCString() });
  defaultTokens.push({
    token: ":referrer",
    replacement: req.headers.referer || req.headers.referrer || ""
  });
  defaultTokens.push({
    token: ":http-version",
    replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`
  });
  defaultTokens.push({
    token: ":remote-addr",
    replacement:
      req.headers["x-forwarded-for"] ||
      req.ip ||
      req._remoteAddress ||
      (req.socket &&
        (req.socket.remoteAddress ||
          (req.socket.socket && req.socket.socket.remoteAddress)))
  });
  defaultTokens.push({
    token: ":user-agent",
    replacement: req.headers["user-agent"]
  });
  defaultTokens.push({
    token: ":content-length",
    replacement:
      res.getHeader("content-length") ||
      (res.__headers && res.__headers["Content-Length"]) ||
      "-"
  });
  defaultTokens.push({
    token: /:req\[([^\]]+)]/g,
    replacement(_, field) {
      return req.headers[field.toLowerCase()];
    }
  });
  defaultTokens.push({
    token: /:res\[([^\]]+)]/g,
    replacement(_, field) {
      return (
        res.getHeader(field.toLowerCase()) ||
        (res.__headers && res.__headers[field])
      );
    }
  });

  return arrayUniqueTokens(customTokens.concat(defaultTokens));
}

/**
 * Return formatted log line.
 *
 * @param  {string} str
 * @param {Array} tokens
 * @return {string}
 * @api private
 */
function format(str, tokens) {
  for (let i = 0; i < tokens.length; i++) {
    str = str.replace(tokens[i].token, tokens[i].replacement);
  }
  return str;
}

/**
 * Return RegExp Object about nolog
 *
 * @param  {(string|Array)} nolog
 * @return {RegExp}
 * @api private
 *
 * syntax
 *  1. String
 *   1.1 "\\.gif"
 *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.gif?fuga
 *         LOGGING http://example.com/hoge.agif
 *   1.2 in "\\.gif|\\.jpg$"
 *         NOT LOGGING http://example.com/hoge.gif and
 *           http://example.com/hoge.gif?fuga and http://example.com/hoge.jpg?fuga
 *         LOGGING http://example.com/hoge.agif,
 *           http://example.com/hoge.ajpg and http://example.com/hoge.jpg?hoge
 *   1.3 in "\\.(gif|jpe?g|png)$"
 *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.jpeg
 *         LOGGING http://example.com/hoge.gif?uid=2 and http://example.com/hoge.jpg?pid=3
 *  2. RegExp
 *   2.1 in /\.(gif|jpe?g|png)$/
 *         SAME AS 1.3
 *  3. Array
 *   3.1 ["\\.jpg$", "\\.png", "\\.gif"]
 *         SAME AS "\\.jpg|\\.png|\\.gif"
 */
function createNoLogCondition(nolog) {
  let regexp = null;

  if (nolog instanceof RegExp) {
    regexp = nolog;
  }

  if (typeof nolog === "string") {
    regexp = new RegExp(nolog);
  }

  if (Array.isArray(nolog)) {
    // convert to strings
    const regexpsAsStrings = nolog.map(reg => (reg.source ? reg.source : reg));
    regexp = new RegExp(regexpsAsStrings.join("|"));
  }

  return regexp;
}

/**
 * Allows users to define rules around status codes to assign them to a specific
 * logging level.
 * There are two types of rules:
 *   - RANGE: matches a code within a certain range
 *     E.g. { 'from': 200, 'to': 299, 'level': 'info' }
 *   - CONTAINS: matches a code to a set of expected codes
 *     E.g. { 'codes': [200, 203], 'level': 'debug' }
 * Note*: Rules are respected only in order of prescendence.
 *
 * @param {Number} statusCode
 * @param {Level} currentLevel
 * @param {Object} ruleSet
 * @return {Level}
 * @api private
 */
function matchRules(statusCode, currentLevel, ruleSet) {
  let level = currentLevel;

  if (ruleSet) {
    const matchedRule = ruleSet.find(rule => {
      let ruleMatched = false;
      if (rule.from && rule.to) {
        ruleMatched = statusCode >= rule.from && statusCode <= rule.to;
      } else {
        ruleMatched = rule.codes.indexOf(statusCode) !== -1;
      }
      return ruleMatched;
    });
    if (matchedRule) {
      level = levels.getLevel(matchedRule.level, level);
    }
  }
  return level;
}

/**
 * Log requests with the given `options` or a `format` string.
 *
 * Options:
 *
 *   - `format`        Format string, see below for tokens
 *   - `level`         A log4js levels instance. Supports also 'auto'
 *   - `nolog`         A string or RegExp to exclude target logs
 *   - `statusRules`   A array of rules for setting specific logging levels base on status codes
 *   - `context`       Whether to add a response of express to the context
 *
 * Tokens:
 *
 *   - `:req[header]` ex: `:req[Accept]`
 *   - `:res[header]` ex: `:res[Content-Length]`
 *   - `:http-version`
 *   - `:response-time`
 *   - `:remote-addr`
 *   - `:date`
 *   - `:method`
 *   - `:url`
 *   - `:referrer`
 *   - `:user-agent`
 *   - `:status`
 *
 * @return {Function}
 * @param logger4js
 * @param options
 * @api public
 */
module.exports = function getLogger(logger4js, options) {
  /* eslint no-underscore-dangle:0 */
  if (typeof options === "string" || typeof options === "function") {
    options = { format: options };
  } else {
    options = options || {};
  }

  const thisLogger = logger4js;
  let level = levels.getLevel(options.level, levels.INFO);
  const fmt = options.format || DEFAULT_FORMAT;
  const nolog = createNoLogCondition(options.nolog);

  return (req, res, next) => {
    // mount safety
    if (req._logging) return next();

    // nologs
    if (nolog && nolog.test(req.originalUrl)) return next();

    if (thisLogger.isLevelEnabled(level) || options.level === "auto") {
      const start = new Date();
      const { writeHead } = res;

      // flag as logging
      req._logging = true;

      // proxy for statusCode.
      res.writeHead = (code, headers) => {
        res.writeHead = writeHead;
        res.writeHead(code, headers);

        res.__statusCode = code;
        res.__headers = headers || {};
      };

      // hook on end request to emit the log entry of the HTTP request.
      res.on("finish", () => {
        res.responseTime = new Date() - start;
        // status code response level handling
        if (res.statusCode && options.level === "auto") {
          level = levels.INFO;
          if (res.statusCode >= 300) level = levels.WARN;
          if (res.statusCode >= 400) level = levels.ERROR;
        }
        level = matchRules(res.statusCode, level, options.statusRules);

        const combinedTokens = assembleTokens(req, res, options.tokens || []);

        if (options.context) thisLogger.addContext("res", res);
        if (typeof fmt === "function") {
          const line = fmt(req, res, str => format(str, combinedTokens));
          if (line) thisLogger.log(level, line);
        } else {
          thisLogger.log(level, format(fmt, combinedTokens));
        }
        if (options.context) thisLogger.removeContext("res");
      });
    }

    // ensure next gets always called
    return next();
  };
};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const neovim_1 = __webpack_require__(155);
const log4js_1 = tslib_1.__importDefault(__webpack_require__(67));
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const plugin_1 = tslib_1.__importDefault(__webpack_require__(251));
const semver_1 = tslib_1.__importDefault(__webpack_require__(1));
const is_1 = __webpack_require__(250);
__webpack_require__(491);
const vscode_uri_1 = __webpack_require__(243);
const logger = __webpack_require__(64)('attach');
const isTest = global.hasOwnProperty('__TEST__');
exports.default = (opts, requestApi = true) => {
    const nvim = neovim_1.attach(opts, log4js_1.default.getLogger('node-client'), requestApi);
    const timeout = process.env.COC_CHANNEL_TIMEOUT ? parseInt(process.env.COC_CHANNEL_TIMEOUT, 10) : 30;
    if (!global.hasOwnProperty('__TEST__')) {
        nvim.call('coc#util#path_replace_patterns').then(prefixes => {
            if (is_1.objectLiteral(prefixes)) {
                const old_uri = vscode_uri_1.URI.file;
                vscode_uri_1.URI.file = (path) => {
                    path = path.replace(/\\/g, '/');
                    Object.keys(prefixes).forEach(k => path = path.replace(new RegExp('^' + k), prefixes[k]));
                    return old_uri(path);
                };
            }
        }).logError();
    }
    nvim.setVar('coc_process_pid', process.pid, true);
    const plugin = new plugin_1.default(nvim);
    let clientReady = false;
    let initialized = false;
    nvim.on('notification', async (method, args) => {
        switch (method) {
            case 'VimEnter': {
                if (!initialized && clientReady) {
                    initialized = true;
                    await plugin.init();
                }
                break;
            }
            case 'TaskExit':
            case 'TaskStderr':
            case 'TaskStdout':
            case 'GlobalChange':
            case 'InputChar':
            case 'OptionSet':
                await events_1.default.fire(method, args);
                break;
            case 'CocAutocmd':
                await events_1.default.fire(args[0], args.slice(1));
                break;
            default: {
                let exists = plugin.hasAction(method);
                if (!exists) {
                    if (global.hasOwnProperty('__TEST__'))
                        return;
                    console.error(`action "${method}" not registered`);
                    return;
                }
                try {
                    if (!plugin.isReady) {
                        logger.warn(`Plugin not ready when received "${method}"`, args);
                    }
                    await plugin.ready;
                    await plugin.cocAction(method, ...args);
                }
                catch (e) {
                    console.error(`Error on notification "${method}": ${e.message || e.toString()}`);
                    logger.error(`Notification error:`, method, args, e);
                }
            }
        }
    });
    nvim.on('request', async (method, args, resp) => {
        let timer = setTimeout(() => {
            logger.error('Request cost more than 3s', method, args);
        }, timeout * 3000);
        try {
            if (method == 'CocAutocmd') {
                await events_1.default.fire(args[0], args.slice(1));
                resp.send();
            }
            else {
                if (!plugin.hasAction(method)) {
                    throw new Error(`action "${method}" not registered`);
                }
                if (!plugin.isReady) {
                    logger.warn(`Plugin not ready when received "${method}"`, args);
                }
                let res = await plugin.cocAction(method, ...args);
                resp.send(res);
            }
            clearTimeout(timer);
        }
        catch (e) {
            clearTimeout(timer);
            resp.send(e.message || e.toString(), true);
            logger.error(`Request error:`, method, args, e);
        }
    });
    nvim.channelId.then(async (channelId) => {
        clientReady = true;
        // Used for test client on vim side
        if (isTest)
            nvim.command(`let g:coc_node_channel_id = ${channelId}`, true);
        let json = __webpack_require__(328);
        let { major, minor, patch } = semver_1.default.parse(json.version);
        nvim.setClientInfo('coc', { major, minor, patch }, 'remote', {}, {});
        let entered = await nvim.getVvar('vim_did_enter');
        if (entered && !initialized) {
            initialized = true;
            await plugin.init();
        }
    }).catch(e => {
        console.error(`Channel create error: ${e.message}`);
    });
    return plugin;
};
//# sourceMappingURL=attach.js.map

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var attach_1 = __webpack_require__(156);
exports.attach = attach_1.attach;
var index_1 = __webpack_require__(209);
exports.Neovim = index_1.Neovim;
exports.NeovimClient = index_1.NeovimClient;
exports.Buffer = index_1.Buffer;
exports.Tabpage = index_1.Tabpage;
exports.Window = index_1.Window;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __webpack_require__(157);
const client_1 = __webpack_require__(158);
function attach({ reader: _reader, writer: _writer, proc, socket, }, _logger = null, requestApi = true) {
    let writer;
    let reader;
    let neovim;
    if (socket) {
        const client = net_1.createConnection(socket);
        writer = client;
        reader = client;
        client.once('close', () => {
            neovim.detach();
        });
    }
    else if (_reader && _writer) {
        writer = _writer;
        reader = _reader;
    }
    else if (proc) {
        writer = proc.stdin;
        reader = proc.stdout;
        proc.once('disconnect', () => {
            neovim.detach();
        });
    }
    writer.on('error', err => {
        if (err.code == 'EPIPE') {
            neovim.detach();
        }
    });
    if (writer && reader) {
        neovim = new client_1.NeovimClient();
        neovim.attach({
            writer,
            reader,
        }, requestApi);
        return neovim;
    }
    throw new Error('Invalid arguments, could not attach');
}
exports.attach = attach;


/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Handles attaching transport
 */
const nvim_1 = __webpack_require__(159);
const vim_1 = __webpack_require__(204);
const Neovim_1 = __webpack_require__(208);
const Buffer_1 = __webpack_require__(196);
const Window_1 = __webpack_require__(199);
const Tabpage_1 = __webpack_require__(201);
const logger_1 = __webpack_require__(203);
const logger = logger_1.createLogger('client');
const isVim = process.env.VIM_NODE_RPC == '1';
class AsyncResponse {
    constructor(requestId, cb) {
        this.requestId = requestId;
        this.cb = cb;
        this.finished = false;
    }
    finish(err, res) {
        if (this.finished)
            return;
        this.finished = true;
        if (err) {
            this.cb(new Error(err));
            return;
        }
        this.cb(null, res);
    }
}
exports.AsyncResponse = AsyncResponse;
class NeovimClient extends Neovim_1.Neovim {
    constructor() {
        // Neovim has no `data` or `metadata`
        super({});
        this.requestId = 1;
        this.responses = new Map();
        this.attachedBuffers = new Map();
        this.timers = new Map();
        Object.defineProperty(this, 'client', {
            value: this
        });
        let transport = isVim ? new vim_1.VimTransport() : new nvim_1.NvimTransport();
        this.setTransport(transport);
        this.transportAttached = false;
        this.handleRequest = this.handleRequest.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
    }
    createBuffer(id) {
        return new Buffer_1.Buffer({
            transport: this.transport,
            data: id,
            client: this
        });
    }
    createWindow(id) {
        return new Window_1.Window({
            transport: this.transport,
            data: id,
            client: this
        });
    }
    createTabpage(id) {
        return new Tabpage_1.Tabpage({
            transport: this.transport,
            data: id,
            client: this
        });
    }
    send(arr) {
        this.transport.send(arr);
    }
    /** Attaches msgpack to read/write streams * */
    attach({ reader, writer, }, requestApi = true) {
        this.transport.attach(writer, reader, this);
        this.transportAttached = true;
        this.setupTransport(requestApi);
    }
    /* called when attach process disconnected*/
    detach() {
        for (let timer of this.timers.values()) {
            clearTimeout(timer);
        }
        this.transport.detach();
        this.transportAttached = false;
    }
    get isApiReady() {
        return this.transportAttached && typeof this._channelId !== 'undefined';
    }
    get channelId() {
        return this._isReady.then(() => {
            return this._channelId;
        });
    }
    isAttached(bufnr) {
        return this.attachedBuffers.has(bufnr);
    }
    handleRequest(method, args, resp) {
        this.emit('request', method, args, resp);
    }
    sendAsyncRequest(method, args) {
        let id = this.requestId;
        this.requestId = id + 1;
        this.notify('nvim_call_function', ['coc#rpc#async_request', [id, method, args || []]]);
        return new Promise((resolve, reject) => {
            let response = new AsyncResponse(id, (err, res) => {
                if (err)
                    return reject(err);
                resolve(res);
            });
            this.responses.set(id, response);
        });
    }
    emitNotification(method, args) {
        if (method.endsWith('_event')) {
            if (method.startsWith('nvim_buf_')) {
                const shortName = method.replace(/nvim_buf_(.*)_event/, '$1');
                const { id } = args[0];
                if (!this.attachedBuffers.has(id))
                    return;
                const bufferMap = this.attachedBuffers.get(id);
                const cbs = bufferMap.get(shortName) || [];
                cbs.forEach(cb => cb(...args));
                // Handle `nvim_buf_detach_event`
                // clean `attachedBuffers` since it will no longer be attached
                if (shortName === 'detach') {
                    this.attachedBuffers.delete(id);
                }
                return;
            }
            // async_request_event from vim
            if (method.startsWith('nvim_async_request')) {
                const [id, method, arr] = args;
                this.handleRequest(method, arr, {
                    send: (resp, isError) => {
                        this.notify('nvim_call_function', ['coc#rpc#async_response', [id, resp, isError]]);
                    }
                });
            }
            // nvim_async_response_event
            if (method.startsWith('nvim_async_response')) {
                const [id, err, res] = args;
                const response = this.responses.get(id);
                if (!response) {
                    // tslint:disable-next-line: no-console
                    console.error(`Response not found for request ${id}`);
                    return;
                }
                this.responses.delete(id);
                response.finish(err, res);
                return;
            }
            // tslint:disable-next-line: no-console
            // console.error(`Unhandled event: ${method}`)
        }
        else {
            this.emit('notification', method, args);
        }
    }
    handleNotification(method, args) {
        this.emitNotification(method, args);
    }
    // Listen and setup handlers for transport
    setupTransport(requestApi = true) {
        if (!this.transportAttached) {
            throw new Error('Not attached to input/output');
        }
        this.transport.on('request', this.handleRequest);
        this.transport.on('notification', this.handleNotification);
        this.transport.on('detach', () => {
            this.emit('disconnect');
            this.transport.removeAllListeners('request');
            this.transport.removeAllListeners('notification');
            this.transport.removeAllListeners('detach');
        });
        if (requestApi) {
            this._isReady = this.generateApi();
        }
        else {
            this._channelId = 0;
            this._isReady = Promise.resolve(true);
        }
    }
    requestApi() {
        return new Promise((resolve, reject) => {
            this.transport.request('nvim_get_api_info', [], (err, res) => {
                if (err) {
                    reject(new Error(Array.isArray(err) ? err[1] : err.message || err.toString()));
                }
                else {
                    resolve(res);
                }
            });
        });
    }
    generateApi() {
        return __awaiter(this, void 0, void 0, function* () {
            let results;
            try {
                results = yield this.requestApi();
            }
            catch (err) {
                // tslint:disable-next-line: no-console
                console.error('Could not get vim api results');
                logger.error(err);
            }
            if (results) {
                try {
                    const [channelId, metadata] = results;
                    this.functions = metadata.functions.map(f => f.name);
                    this._channelId = channelId;
                    return true;
                }
                catch (err) {
                    logger.error(err.stack);
                    return null;
                }
            }
            return null;
        });
    }
    attachBufferEvent(buffer, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(buffer.id) || new Map();
        const cbs = bufferMap.get(eventName) || [];
        if (cbs.includes(cb))
            return;
        cbs.push(cb);
        bufferMap.set(eventName, cbs);
        this.attachedBuffers.set(buffer.id, bufferMap);
        return;
    }
    /**
     * Returns `true` if buffer should be detached
     */
    detachBufferEvent(buffer, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(buffer.id);
        if (!bufferMap || !bufferMap.has(eventName))
            return;
        const handlers = bufferMap.get(eventName).filter(handler => handler !== cb);
        bufferMap.set(eventName, handlers);
    }
    pauseNotification() {
        this.transport.pauseNotification();
        let pauseLevel = this.transport.pauseLevel;
        let stack = Error().stack;
        let timer = setTimeout(() => {
            if (this.transport.pauseLevel >= pauseLevel) {
                this.transport.cancelNotification();
                logger.error(`pauseNotification not finished after 1s`, stack);
            }
        }, 2000);
        this.timers.set(pauseLevel, timer);
    }
    resumeNotification(cancel, notify) {
        let { pauseLevel } = this.transport;
        let timer = this.timers.get(pauseLevel);
        if (timer) {
            this.timers.delete(pauseLevel);
            clearTimeout(timer);
        }
        if (cancel)
            return Promise.resolve(this.transport.cancelNotification());
        if (notify) {
            return Promise.resolve(this.transport.resumeNotification(true));
        }
        return Promise.resolve(this.transport.resumeNotification());
    }
    hasFunction(name) {
        if (!this.functions)
            return true;
        return this.functions.indexOf(name) !== -1;
    }
}
exports.NeovimClient = NeovimClient;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const msgpack = __importStar(__webpack_require__(160));
const buffered_1 = __importDefault(__webpack_require__(194));
const types_1 = __webpack_require__(195);
const base_1 = __importDefault(__webpack_require__(202));
class NvimTransport extends base_1.default {
    constructor() {
        super();
        this.pending = new Map();
        this.nextRequestId = 1;
        this.attached = false;
        const codec = this.setupCodec();
        this.encodeStream = msgpack.createEncodeStream({ codec });
        this.decodeStream = msgpack.createDecodeStream({ codec });
        this.decodeStream.on('data', (msg) => {
            this.parseMessage(msg);
        });
        this.decodeStream.on('end', () => {
            this.detach();
            this.emit('detach');
        });
    }
    parseMessage(msg) {
        const msgType = msg[0];
        this.debugMessage(msg);
        if (msgType === 0) {
            // request
            //   - msg[1]: id
            //   - msg[2]: method name
            //   - msg[3]: arguments
            this.emit('request', msg[2].toString(), msg[3], this.createResponse(msg[1]));
        }
        else if (msgType === 1) {
            // response to a previous request:
            //   - msg[1]: the id
            //   - msg[2]: error(if any)
            //   - msg[3]: result(if not errored)
            const id = msg[1];
            const handler = this.pending.get(id);
            if (handler) {
                this.pending.delete(id);
                let err = msg[2];
                if (err && err.length != 2) {
                    err = [0, err instanceof Error ? err.message : err];
                }
                handler(err, msg[3]);
            }
        }
        else if (msgType === 2) {
            // notification/event
            //   - msg[1]: event name
            //   - msg[2]: arguments
            this.emit('notification', msg[1].toString(), msg[2]);
        }
        else {
            // tslint:disable-next-line: no-console
            console.error(`Invalid message type ${msgType}`);
        }
    }
    setupCodec() {
        const codec = msgpack.createCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
            codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));
            codec.addExtUnpacker(id, data => new constructor({
                transport: this,
                client: this.client,
                data: msgpack.decode(data),
            }));
        });
        this.codec = codec;
        return this.codec;
    }
    attach(writer, reader, client) {
        this.encodeStream = this.encodeStream.pipe(writer);
        const buffered = new buffered_1.default();
        reader.pipe(buffered).pipe(this.decodeStream);
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.attached = true;
    }
    detach() {
        if (!this.attached)
            return;
        this.attached = false;
        this.encodeStream.unpipe(this.writer);
        this.reader.unpipe(this.decodeStream);
    }
    request(method, args, cb) {
        if (!this.attached)
            return;
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId + 1;
        let startTs = Date.now();
        this.debug('request to nvim:', id, method, args);
        this.encodeStream.write(msgpack.encode([0, id, method, args], {
            codec: this.codec,
        }));
        let timer = setTimeout(() => {
            this.debug(`request to nvim cost more than 1s`, method, args);
        }, 1000);
        this.pending.set(id, (err, res) => {
            clearTimeout(timer);
            this.debug('response of nvim:', id, `${Date.now() - startTs}ms`, res, err);
            cb(err, res);
        });
    }
    notify(method, args) {
        if (!this.attached)
            return;
        if (this.pauseLevel != 0) {
            let arr = this.paused.get(this.pauseLevel);
            if (arr) {
                arr.push([method, args]);
                return;
            }
        }
        this.debug('nvim notification:', method, args);
        this.encodeStream.write(msgpack.encode([2, method, args], {
            codec: this.codec,
        }));
    }
    send(arr) {
        this.encodeStream.write(msgpack.encode(arr, {
            codec: this.codec,
        }));
    }
    createResponse(requestId) {
        let { encodeStream } = this;
        let startTs = Date.now();
        let called = false;
        let timer = setTimeout(() => {
            this.debug(`request to client cost more than 1s`, requestId);
        }, 1000);
        return {
            send: (resp, isError) => {
                clearTimeout(timer);
                if (called || !this.attached)
                    return;
                this.debug('response of client:', requestId, `${Date.now() - startTs}ms`, resp, isError == true);
                called = true;
                encodeStream.write(msgpack.encode([
                    1,
                    requestId,
                    isError ? resp : null,
                    !isError ? resp : null,
                ]));
            }
        };
    }
}
exports.NvimTransport = NvimTransport;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

// msgpack.js

exports.encode = __webpack_require__(161).encode;
exports.decode = __webpack_require__(181).decode;

exports.Encoder = __webpack_require__(187).Encoder;
exports.Decoder = __webpack_require__(189).Decoder;

exports.createEncodeStream = __webpack_require__(190).createEncodeStream;
exports.createDecodeStream = __webpack_require__(191).createDecodeStream;

exports.createCodec = __webpack_require__(192).createCodec;
exports.codec = __webpack_require__(193).codec;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

// encode.js

exports.encode = encode;

var EncodeBuffer = __webpack_require__(162).EncodeBuffer;

function encode(input, options) {
  var encoder = new EncodeBuffer(options);
  encoder.write(input);
  return encoder.read();
}


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

// encode-buffer.js

exports.EncodeBuffer = EncodeBuffer;

var preset = __webpack_require__(163).preset;

var FlexEncoder = __webpack_require__(180).FlexEncoder;

FlexEncoder.mixin(EncodeBuffer.prototype);

function EncodeBuffer(options) {
  if (!(this instanceof EncodeBuffer)) return new EncodeBuffer(options);

  if (options) {
    this.options = options;
    if (options.codec) {
      var codec = this.codec = options.codec;
      if (codec.bufferish) this.bufferish = codec.bufferish;
    }
  }
}

EncodeBuffer.prototype.codec = preset;

EncodeBuffer.prototype.write = function(input) {
  this.codec.encode(this, input);
};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

// write-core.js

var ExtBuffer = __webpack_require__(164).ExtBuffer;
var ExtPacker = __webpack_require__(173);
var WriteType = __webpack_require__(174);
var CodecBase = __webpack_require__(179);

CodecBase.install({
  addExtPacker: addExtPacker,
  getExtPacker: getExtPacker,
  init: init
});

exports.preset = init.call(CodecBase.preset);

function getEncoder(options) {
  var writeType = WriteType.getWriteType(options);
  return encode;

  function encode(encoder, value) {
    var func = writeType[typeof value];
    if (!func) throw new Error("Unsupported type \"" + (typeof value) + "\": " + value);
    func(encoder, value);
  }
}

function init() {
  var options = this.options;
  this.encode = getEncoder(options);

  if (options && options.preset) {
    ExtPacker.setExtPackers(this);
  }

  return this;
}

function addExtPacker(etype, Class, packer) {
  packer = CodecBase.filter(packer);
  var name = Class.name;
  if (name && name !== "Object") {
    var packers = this.extPackers || (this.extPackers = {});
    packers[name] = extPacker;
  } else {
    // fallback for IE
    var list = this.extEncoderList || (this.extEncoderList = []);
    list.unshift([Class, extPacker]);
  }

  function extPacker(value) {
    if (packer) value = packer(value);
    return new ExtBuffer(value, etype);
  }
}

function getExtPacker(value) {
  var packers = this.extPackers || (this.extPackers = {});
  var c = value.constructor;
  var e = c && c.name && packers[c.name];
  if (e) return e;

  // fallback for IE
  var list = this.extEncoderList || (this.extEncoderList = []);
  var len = list.length;
  for (var i = 0; i < len; i++) {
    var pair = list[i];
    if (c === pair[0]) return pair[1];
  }
}


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

// ext-buffer.js

exports.ExtBuffer = ExtBuffer;

var Bufferish = __webpack_require__(165);

function ExtBuffer(buffer, type) {
  if (!(this instanceof ExtBuffer)) return new ExtBuffer(buffer, type);
  this.buffer = Bufferish.from(buffer);
  this.type = type;
}


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

// bufferish.js

var Buffer = exports.global = __webpack_require__(166);
var hasBuffer = exports.hasBuffer = Buffer && !!Buffer.isBuffer;
var hasArrayBuffer = exports.hasArrayBuffer = ("undefined" !== typeof ArrayBuffer);

var isArray = exports.isArray = __webpack_require__(167);
exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
var isBuffer = exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false;
var isView = exports.isView = hasArrayBuffer ? (ArrayBuffer.isView || _is("ArrayBuffer", "buffer")) : _false;

exports.alloc = alloc;
exports.concat = concat;
exports.from = from;

var BufferArray = exports.Array = __webpack_require__(168);
var BufferBuffer = exports.Buffer = __webpack_require__(169);
var BufferUint8Array = exports.Uint8Array = __webpack_require__(170);
var BufferProto = exports.prototype = __webpack_require__(171);

/**
 * @param value {Array|ArrayBuffer|Buffer|String}
 * @returns {Buffer|Uint8Array|Array}
 */

function from(value) {
  if (typeof value === "string") {
    return fromString.call(this, value);
  } else {
    return auto(this).from(value);
  }
}

/**
 * @param size {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function alloc(size) {
  return auto(this).alloc(size);
}

/**
 * @param list {Array} array of (Buffer|Uint8Array|Array)s
 * @param [length]
 * @returns {Buffer|Uint8Array|Array}
 */

function concat(list, length) {
  if (!length) {
    length = 0;
    Array.prototype.forEach.call(list, dryrun);
  }
  var ref = (this !== exports) && this || list[0];
  var result = alloc.call(ref, length);
  var offset = 0;
  Array.prototype.forEach.call(list, append);
  return result;

  function dryrun(buffer) {
    length += buffer.length;
  }

  function append(buffer) {
    offset += BufferProto.copy.call(buffer, result, offset);
  }
}

var _isArrayBuffer = _is("ArrayBuffer");

function isArrayBuffer(value) {
  return (value instanceof ArrayBuffer) || _isArrayBuffer(value);
}

/**
 * @private
 */

function fromString(value) {
  var expected = value.length * 3;
  var that = alloc.call(this, expected);
  var actual = BufferProto.write.call(that, value);
  if (expected !== actual) {
    that = BufferProto.slice.call(that, 0, actual);
  }
  return that;
}

function auto(that) {
  return isBuffer(that) ? BufferBuffer
    : isView(that) ? BufferUint8Array
    : isArray(that) ? BufferArray
    : hasBuffer ? BufferBuffer
    : hasArrayBuffer ? BufferUint8Array
    : BufferArray;
}

function _false() {
  return false;
}

function _is(name, key) {
  /* jshint eqnull:true */
  name = "[object " + name + "]";
  return function(value) {
    return (value != null) && {}.toString.call(key ? value[key] : value) === name;
  };
}

/***/ }),
/* 166 */
/***/ (function(module, exports) {

/* globals Buffer */

module.exports =
  c(("undefined" !== typeof Buffer) && Buffer) ||
  c(this.Buffer) ||
  c(("undefined" !== typeof window) && window.Buffer) ||
  this.Buffer;

function c(B) {
  return B && B.isBuffer && B;
}

/***/ }),
/* 167 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

// bufferish-array.js

var Bufferish = __webpack_require__(165);

var exports = module.exports = alloc(0);

exports.alloc = alloc;
exports.concat = Bufferish.concat;
exports.from = from;

/**
 * @param size {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function alloc(size) {
  return new Array(size);
}

/**
 * @param value {Array|ArrayBuffer|Buffer|String}
 * @returns {Array}
 */

function from(value) {
  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
    // TypedArray to Uint8Array
    value = Bufferish.Uint8Array.from(value);
  } else if (Bufferish.isArrayBuffer(value)) {
    // ArrayBuffer to Uint8Array
    value = new Uint8Array(value);
  } else if (typeof value === "string") {
    // String to Array
    return Bufferish.from.call(exports, value);
  } else if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }

  // Array-like to Array
  return Array.prototype.slice.call(value);
}


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

// bufferish-buffer.js

var Bufferish = __webpack_require__(165);
var Buffer = Bufferish.global;

var exports = module.exports = Bufferish.hasBuffer ? alloc(0) : [];

exports.alloc = Bufferish.hasBuffer && Buffer.alloc || alloc;
exports.concat = Bufferish.concat;
exports.from = from;

/**
 * @param size {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function alloc(size) {
  return new Buffer(size);
}

/**
 * @param value {Array|ArrayBuffer|Buffer|String}
 * @returns {Buffer}
 */

function from(value) {
  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
    // TypedArray to Uint8Array
    value = Bufferish.Uint8Array.from(value);
  } else if (Bufferish.isArrayBuffer(value)) {
    // ArrayBuffer to Uint8Array
    value = new Uint8Array(value);
  } else if (typeof value === "string") {
    // String to Buffer
    return Bufferish.from.call(exports, value);
  } else if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }

  // Array-like to Buffer
  if (Buffer.from && Buffer.from.length !== 1) {
    return Buffer.from(value); // node v6+
  } else {
    return new Buffer(value); // node v4
  }
}


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

// bufferish-uint8array.js

var Bufferish = __webpack_require__(165);

var exports = module.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];

exports.alloc = alloc;
exports.concat = Bufferish.concat;
exports.from = from;

/**
 * @param size {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function alloc(size) {
  return new Uint8Array(size);
}

/**
 * @param value {Array|ArrayBuffer|Buffer|String}
 * @returns {Uint8Array}
 */

function from(value) {
  if (Bufferish.isView(value)) {
    // TypedArray to ArrayBuffer
    var byteOffset = value.byteOffset;
    var byteLength = value.byteLength;
    value = value.buffer;
    if (value.byteLength !== byteLength) {
      if (value.slice) {
        value = value.slice(byteOffset, byteOffset + byteLength);
      } else {
        // Android 4.1 does not have ArrayBuffer.prototype.slice
        value = new Uint8Array(value);
        if (value.byteLength !== byteLength) {
          // TypedArray to ArrayBuffer to Uint8Array to Array
          value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);
        }
      }
    }
  } else if (typeof value === "string") {
    // String to Uint8Array
    return Bufferish.from.call(exports, value);
  } else if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }

  return new Uint8Array(value);
}


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

// bufferish-proto.js

/* jshint eqnull:true */

var BufferLite = __webpack_require__(172);

exports.copy = copy;
exports.slice = slice;
exports.toString = toString;
exports.write = gen("write");

var Bufferish = __webpack_require__(165);
var Buffer = Bufferish.global;

var isBufferShim = Bufferish.hasBuffer && ("TYPED_ARRAY_SUPPORT" in Buffer);
var brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;

/**
 * @param target {Buffer|Uint8Array|Array}
 * @param [targetStart] {Number}
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function copy(target, targetStart, start, end) {
  var thisIsBuffer = Bufferish.isBuffer(this);
  var targetIsBuffer = Bufferish.isBuffer(target);
  if (thisIsBuffer && targetIsBuffer) {
    // Buffer to Buffer
    return this.copy(target, targetStart, start, end);
  } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer &&
    Bufferish.isView(this) && Bufferish.isView(target)) {
    // Uint8Array to Uint8Array (except for minor some browsers)
    var buffer = (start || end != null) ? slice.call(this, start, end) : this;
    target.set(buffer, targetStart);
    return buffer.length;
  } else {
    // other cases
    return BufferLite.copy.call(this, target, targetStart, start, end);
  }
}

/**
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function slice(start, end) {
  // for Buffer, Uint8Array (except for minor some browsers) and Array
  var f = this.slice || (!brokenTypedArray && this.subarray);
  if (f) return f.call(this, start, end);

  // Uint8Array (for minor some browsers)
  var target = Bufferish.alloc.call(this, end - start);
  copy.call(this, target, 0, start, end);
  return target;
}

/**
 * Buffer.prototype.toString()
 *
 * @param [encoding] {String} ignored
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {String}
 */

function toString(encoding, start, end) {
  var f = (!isBufferShim && Bufferish.isBuffer(this)) ? this.toString : BufferLite.toString;
  return f.apply(this, arguments);
}

/**
 * @private
 */

function gen(method) {
  return wrap;

  function wrap() {
    var f = this[method] || BufferLite[method];
    return f.apply(this, arguments);
  }
}


/***/ }),
/* 172 */
/***/ (function(module, exports) {

// buffer-lite.js

var MAXBUFLEN = 8192;

exports.copy = copy;
exports.toString = toString;
exports.write = write;

/**
 * Buffer.prototype.write()
 *
 * @param string {String}
 * @param [offset] {Number}
 * @returns {Number}
 */

function write(string, offset) {
  var buffer = this;
  var index = offset || (offset |= 0);
  var length = string.length;
  var chr = 0;
  var i = 0;
  while (i < length) {
    chr = string.charCodeAt(i++);

    if (chr < 128) {
      buffer[index++] = chr;
    } else if (chr < 0x800) {
      // 2 bytes
      buffer[index++] = 0xC0 | (chr >>> 6);
      buffer[index++] = 0x80 | (chr & 0x3F);
    } else if (chr < 0xD800 || chr > 0xDFFF) {
      // 3 bytes
      buffer[index++] = 0xE0 | (chr  >>> 12);
      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);
      buffer[index++] = 0x80 | (chr          & 0x3F);
    } else {
      // 4 bytes - surrogate pair
      chr = (((chr - 0xD800) << 10) | (string.charCodeAt(i++) - 0xDC00)) + 0x10000;
      buffer[index++] = 0xF0 | (chr >>> 18);
      buffer[index++] = 0x80 | ((chr >>> 12) & 0x3F);
      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);
      buffer[index++] = 0x80 | (chr          & 0x3F);
    }
  }
  return index - offset;
}

/**
 * Buffer.prototype.toString()
 *
 * @param [encoding] {String} ignored
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {String}
 */

function toString(encoding, start, end) {
  var buffer = this;
  var index = start|0;
  if (!end) end = buffer.length;
  var string = '';
  var chr = 0;

  while (index < end) {
    chr = buffer[index++];
    if (chr < 128) {
      string += String.fromCharCode(chr);
      continue;
    }

    if ((chr & 0xE0) === 0xC0) {
      // 2 bytes
      chr = (chr & 0x1F) << 6 |
            (buffer[index++] & 0x3F);

    } else if ((chr & 0xF0) === 0xE0) {
      // 3 bytes
      chr = (chr & 0x0F)             << 12 |
            (buffer[index++] & 0x3F) << 6  |
            (buffer[index++] & 0x3F);

    } else if ((chr & 0xF8) === 0xF0) {
      // 4 bytes
      chr = (chr & 0x07)             << 18 |
            (buffer[index++] & 0x3F) << 12 |
            (buffer[index++] & 0x3F) << 6  |
            (buffer[index++] & 0x3F);
    }

    if (chr >= 0x010000) {
      // A surrogate pair
      chr -= 0x010000;

      string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
    } else {
      string += String.fromCharCode(chr);
    }
  }

  return string;
}

/**
 * Buffer.prototype.copy()
 *
 * @param target {Buffer}
 * @param [targetStart] {Number}
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {number}
 */

function copy(target, targetStart, start, end) {
  var i;
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (!targetStart) targetStart = 0;
  var len = end - start;

  if (target === this && start < targetStart && targetStart < end) {
    // descending
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    // ascending
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start];
    }
  }

  return len;
}


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

// ext-packer.js

exports.setExtPackers = setExtPackers;

var Bufferish = __webpack_require__(165);
var Buffer = Bufferish.global;
var packTypedArray = Bufferish.Uint8Array.from;
var _encode;

var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};

function setExtPackers(codec) {
  codec.addExtPacker(0x0E, Error, [packError, encode]);
  codec.addExtPacker(0x01, EvalError, [packError, encode]);
  codec.addExtPacker(0x02, RangeError, [packError, encode]);
  codec.addExtPacker(0x03, ReferenceError, [packError, encode]);
  codec.addExtPacker(0x04, SyntaxError, [packError, encode]);
  codec.addExtPacker(0x05, TypeError, [packError, encode]);
  codec.addExtPacker(0x06, URIError, [packError, encode]);

  codec.addExtPacker(0x0A, RegExp, [packRegExp, encode]);
  codec.addExtPacker(0x0B, Boolean, [packValueOf, encode]);
  codec.addExtPacker(0x0C, String, [packValueOf, encode]);
  codec.addExtPacker(0x0D, Date, [Number, encode]);
  codec.addExtPacker(0x0F, Number, [packValueOf, encode]);

  if ("undefined" !== typeof Uint8Array) {
    codec.addExtPacker(0x11, Int8Array, packTypedArray);
    codec.addExtPacker(0x12, Uint8Array, packTypedArray);
    codec.addExtPacker(0x13, Int16Array, packTypedArray);
    codec.addExtPacker(0x14, Uint16Array, packTypedArray);
    codec.addExtPacker(0x15, Int32Array, packTypedArray);
    codec.addExtPacker(0x16, Uint32Array, packTypedArray);
    codec.addExtPacker(0x17, Float32Array, packTypedArray);

    // PhantomJS/1.9.7 doesn't have Float64Array
    if ("undefined" !== typeof Float64Array) {
      codec.addExtPacker(0x18, Float64Array, packTypedArray);
    }

    // IE10 doesn't have Uint8ClampedArray
    if ("undefined" !== typeof Uint8ClampedArray) {
      codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);
    }

    codec.addExtPacker(0x1A, ArrayBuffer, packTypedArray);
    codec.addExtPacker(0x1D, DataView, packTypedArray);
  }

  if (Bufferish.hasBuffer) {
    codec.addExtPacker(0x1B, Buffer, Bufferish.from);
  }
}

function encode(input) {
  if (!_encode) _encode = __webpack_require__(161).encode; // lazy load
  return _encode(input);
}

function packValueOf(value) {
  return (value).valueOf();
}

function packRegExp(value) {
  value = RegExp.prototype.toString.call(value).split("/");
  value.shift();
  var out = [value.pop()];
  out.unshift(value.join("/"));
  return out;
}

function packError(value) {
  var out = {};
  for (var key in ERROR_COLUMNS) {
    out[key] = value[key];
  }
  return out;
}


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

// write-type.js

var IS_ARRAY = __webpack_require__(167);
var Int64Buffer = __webpack_require__(175);
var Uint64BE = Int64Buffer.Uint64BE;
var Int64BE = Int64Buffer.Int64BE;

var Bufferish = __webpack_require__(165);
var BufferProto = __webpack_require__(171);
var WriteToken = __webpack_require__(176);
var uint8 = __webpack_require__(178).uint8;
var ExtBuffer = __webpack_require__(164).ExtBuffer;

var HAS_UINT8ARRAY = ("undefined" !== typeof Uint8Array);
var HAS_MAP = ("undefined" !== typeof Map);

var extmap = [];
extmap[1] = 0xd4;
extmap[2] = 0xd5;
extmap[4] = 0xd6;
extmap[8] = 0xd7;
extmap[16] = 0xd8;

exports.getWriteType = getWriteType;

function getWriteType(options) {
  var token = WriteToken.getWriteToken(options);
  var useraw = options && options.useraw;
  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
  var usemap = HAS_MAP && options && options.usemap;
  var map = usemap ? map_to_map : obj_to_map;

  var writeType = {
    "boolean": bool,
    "function": nil,
    "number": number,
    "object": (useraw ? object_raw : object),
    "string": _string(useraw ? raw_head_size : str_head_size),
    "symbol": nil,
    "undefined": nil
  };

  return writeType;

  // false -- 0xc2
  // true -- 0xc3
  function bool(encoder, value) {
    var type = value ? 0xc3 : 0xc2;
    token[type](encoder, value);
  }

  function number(encoder, value) {
    var ivalue = value | 0;
    var type;
    if (value !== ivalue) {
      // float 64 -- 0xcb
      type = 0xcb;
      token[type](encoder, value);
      return;
    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {
      // positive fixint -- 0x00 - 0x7f
      // negative fixint -- 0xe0 - 0xff
      type = ivalue & 0xFF;
    } else if (0 <= ivalue) {
      // uint 8 -- 0xcc
      // uint 16 -- 0xcd
      // uint 32 -- 0xce
      type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;
    } else {
      // int 8 -- 0xd0
      // int 16 -- 0xd1
      // int 32 -- 0xd2
      type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;
    }
    token[type](encoder, ivalue);
  }

  // uint 64 -- 0xcf
  function uint64(encoder, value) {
    var type = 0xcf;
    token[type](encoder, value.toArray());
  }

  // int 64 -- 0xd3
  function int64(encoder, value) {
    var type = 0xd3;
    token[type](encoder, value.toArray());
  }

  // str 8 -- 0xd9
  // str 16 -- 0xda
  // str 32 -- 0xdb
  // fixstr -- 0xa0 - 0xbf
  function str_head_size(length) {
    return (length < 32) ? 1 : (length <= 0xFF) ? 2 : (length <= 0xFFFF) ? 3 : 5;
  }

  // raw 16 -- 0xda
  // raw 32 -- 0xdb
  // fixraw -- 0xa0 - 0xbf
  function raw_head_size(length) {
    return (length < 32) ? 1 : (length <= 0xFFFF) ? 3 : 5;
  }

  function _string(head_size) {
    return string;

    function string(encoder, value) {
      // prepare buffer
      var length = value.length;
      var maxsize = 5 + length * 3;
      encoder.offset = encoder.reserve(maxsize);
      var buffer = encoder.buffer;

      // expected header size
      var expected = head_size(length);

      // expected start point
      var start = encoder.offset + expected;

      // write string
      length = BufferProto.write.call(buffer, value, start);

      // actual header size
      var actual = head_size(length);

      // move content when needed
      if (expected !== actual) {
        var targetStart = start + actual - expected;
        var end = start + length;
        BufferProto.copy.call(buffer, buffer, targetStart, start, end);
      }

      // write header
      var type = (actual === 1) ? (0xa0 + length) : (actual <= 3) ? (0xd7 + actual) : 0xdb;
      token[type](encoder, length);

      // move cursor
      encoder.offset += length;
    }
  }

  function object(encoder, value) {
    // null
    if (value === null) return nil(encoder, value);

    // Buffer
    if (isBuffer(value)) return bin(encoder, value);

    // Array
    if (IS_ARRAY(value)) return array(encoder, value);

    // int64-buffer objects
    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);
    if (Int64BE.isInt64BE(value)) return int64(encoder, value);

    // ext formats
    var packer = encoder.codec.getExtPacker(value);
    if (packer) value = packer(value);
    if (value instanceof ExtBuffer) return ext(encoder, value);

    // plain old Objects or Map
    map(encoder, value);
  }

  function object_raw(encoder, value) {
    // Buffer
    if (isBuffer(value)) return raw(encoder, value);

    // others
    object(encoder, value);
  }

  // nil -- 0xc0
  function nil(encoder, value) {
    var type = 0xc0;
    token[type](encoder, value);
  }

  // fixarray -- 0x90 - 0x9f
  // array 16 -- 0xdc
  // array 32 -- 0xdd
  function array(encoder, value) {
    var length = value.length;
    var type = (length < 16) ? (0x90 + length) : (length <= 0xFFFF) ? 0xdc : 0xdd;
    token[type](encoder, length);

    var encode = encoder.codec.encode;
    for (var i = 0; i < length; i++) {
      encode(encoder, value[i]);
    }
  }

  // bin 8 -- 0xc4
  // bin 16 -- 0xc5
  // bin 32 -- 0xc6
  function bin_buffer(encoder, value) {
    var length = value.length;
    var type = (length < 0xFF) ? 0xc4 : (length <= 0xFFFF) ? 0xc5 : 0xc6;
    token[type](encoder, length);
    encoder.send(value);
  }

  function bin_arraybuffer(encoder, value) {
    bin_buffer(encoder, new Uint8Array(value));
  }

  // fixext 1 -- 0xd4
  // fixext 2 -- 0xd5
  // fixext 4 -- 0xd6
  // fixext 8 -- 0xd7
  // fixext 16 -- 0xd8
  // ext 8 -- 0xc7
  // ext 16 -- 0xc8
  // ext 32 -- 0xc9
  function ext(encoder, value) {
    var buffer = value.buffer;
    var length = buffer.length;
    var type = extmap[length] || ((length < 0xFF) ? 0xc7 : (length <= 0xFFFF) ? 0xc8 : 0xc9);
    token[type](encoder, length);
    uint8[value.type](encoder);
    encoder.send(buffer);
  }

  // fixmap -- 0x80 - 0x8f
  // map 16 -- 0xde
  // map 32 -- 0xdf
  function obj_to_map(encoder, value) {
    var keys = Object.keys(value);
    var length = keys.length;
    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;
    token[type](encoder, length);

    var encode = encoder.codec.encode;
    keys.forEach(function(key) {
      encode(encoder, key);
      encode(encoder, value[key]);
    });
  }

  // fixmap -- 0x80 - 0x8f
  // map 16 -- 0xde
  // map 32 -- 0xdf
  function map_to_map(encoder, value) {
    if (!(value instanceof Map)) return obj_to_map(encoder, value);

    var length = value.size;
    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;
    token[type](encoder, length);

    var encode = encoder.codec.encode;
    value.forEach(function(val, key, m) {
      encode(encoder, key);
      encode(encoder, val);
    });
  }

  // raw 16 -- 0xda
  // raw 32 -- 0xdb
  // fixraw -- 0xa0 - 0xbf
  function raw(encoder, value) {
    var length = value.length;
    var type = (length < 32) ? (0xa0 + length) : (length <= 0xFFFF) ? 0xda : 0xdb;
    token[type](encoder, length);
    encoder.send(value);
  }
}


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

// int64-buffer.js

/*jshint -W018 */ // Confusing use of '!'.
/*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.
/*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?

var Uint64BE, Int64BE, Uint64LE, Int64LE;

!function(exports) {
  // constants

  var UNDEFINED = "undefined";
  var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;
  var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;
  var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;
  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
  var isArray = Array.isArray || _isArray;
  var BIT32 = 4294967296;
  var BIT24 = 16777216;

  // storage class

  var storage; // Array;

  // generate classes

  Uint64BE = factory("Uint64BE", true, true);
  Int64BE = factory("Int64BE", true, false);
  Uint64LE = factory("Uint64LE", false, true);
  Int64LE = factory("Int64LE", false, false);

  // class factory

  function factory(name, bigendian, unsigned) {
    var posH = bigendian ? 0 : 4;
    var posL = bigendian ? 4 : 0;
    var pos0 = bigendian ? 0 : 3;
    var pos1 = bigendian ? 1 : 2;
    var pos2 = bigendian ? 2 : 1;
    var pos3 = bigendian ? 3 : 0;
    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
    var proto = Int64.prototype;
    var isName = "is" + name;
    var _isInt64 = "_" + isName;

    // properties
    proto.buffer = void 0;
    proto.offset = 0;
    proto[_isInt64] = true;

    // methods
    proto.toNumber = toNumber;
    proto.toString = toString;
    proto.toJSON = toNumber;
    proto.toArray = toArray;

    // add .toBuffer() method only when Buffer available
    if (BUFFER) proto.toBuffer = toBuffer;

    // add .toArrayBuffer() method only when Uint8Array available
    if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;

    // isUint64BE, isInt64BE
    Int64[isName] = isInt64;

    // CommonJS
    exports[name] = Int64;

    return Int64;

    // constructor
    function Int64(buffer, offset, value, raddix) {
      if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);
      return init(this, buffer, offset, value, raddix);
    }

    // isUint64BE, isInt64BE
    function isInt64(b) {
      return !!(b && b[_isInt64]);
    }

    // initializer
    function init(that, buffer, offset, value, raddix) {
      if (UINT8ARRAY && ARRAYBUFFER) {
        if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);
        if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);
      }

      // Int64BE() style
      if (!buffer && !offset && !value && !storage) {
        // shortcut to initialize with zero
        that.buffer = newArray(ZERO, 0);
        return;
      }

      // Int64BE(value, raddix) style
      if (!isValidBuffer(buffer, offset)) {
        var _storage = storage || Array;
        raddix = offset;
        value = buffer;
        offset = 0;
        buffer = new _storage(8);
      }

      that.buffer = buffer;
      that.offset = offset |= 0;

      // Int64BE(buffer, offset) style
      if (UNDEFINED === typeof value) return;

      // Int64BE(buffer, offset, value, raddix) style
      if ("string" === typeof value) {
        fromString(buffer, offset, value, raddix || 10);
      } else if (isValidBuffer(value, raddix)) {
        fromArray(buffer, offset, value, raddix);
      } else if ("number" === typeof raddix) {
        writeInt32(buffer, offset + posH, value); // high
        writeInt32(buffer, offset + posL, raddix); // low
      } else if (value > 0) {
        fromPositive(buffer, offset, value); // positive
      } else if (value < 0) {
        fromNegative(buffer, offset, value); // negative
      } else {
        fromArray(buffer, offset, ZERO, 0); // zero, NaN and others
      }
    }

    function fromString(buffer, offset, str, raddix) {
      var pos = 0;
      var len = str.length;
      var high = 0;
      var low = 0;
      if (str[0] === "-") pos++;
      var sign = pos;
      while (pos < len) {
        var chr = parseInt(str[pos++], raddix);
        if (!(chr >= 0)) break; // NaN
        low = low * raddix + chr;
        high = high * raddix + Math.floor(low / BIT32);
        low %= BIT32;
      }
      if (sign) {
        high = ~high;
        if (low) {
          low = BIT32 - low;
        } else {
          high++;
        }
      }
      writeInt32(buffer, offset + posH, high);
      writeInt32(buffer, offset + posL, low);
    }

    function toNumber() {
      var buffer = this.buffer;
      var offset = this.offset;
      var high = readInt32(buffer, offset + posH);
      var low = readInt32(buffer, offset + posL);
      if (!unsigned) high |= 0; // a trick to get signed
      return high ? (high * BIT32 + low) : low;
    }

    function toString(radix) {
      var buffer = this.buffer;
      var offset = this.offset;
      var high = readInt32(buffer, offset + posH);
      var low = readInt32(buffer, offset + posL);
      var str = "";
      var sign = !unsigned && (high & 0x80000000);
      if (sign) {
        high = ~high;
        low = BIT32 - low;
      }
      radix = radix || 10;
      while (1) {
        var mod = (high % radix) * BIT32 + low;
        high = Math.floor(high / radix);
        low = Math.floor(mod / radix);
        str = (mod % radix).toString(radix) + str;
        if (!high && !low) break;
      }
      if (sign) {
        str = "-" + str;
      }
      return str;
    }

    function writeInt32(buffer, offset, value) {
      buffer[offset + pos3] = value & 255;
      value = value >> 8;
      buffer[offset + pos2] = value & 255;
      value = value >> 8;
      buffer[offset + pos1] = value & 255;
      value = value >> 8;
      buffer[offset + pos0] = value & 255;
    }

    function readInt32(buffer, offset) {
      return (buffer[offset + pos0] * BIT24) +
        (buffer[offset + pos1] << 16) +
        (buffer[offset + pos2] << 8) +
        buffer[offset + pos3];
    }
  }

  function toArray(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    storage = null; // Array
    if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;
    return newArray(buffer, offset);
  }

  function toBuffer(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    storage = BUFFER;
    if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;
    var dest = new BUFFER(8);
    fromArray(dest, 0, buffer, offset);
    return dest;
  }

  function toArrayBuffer(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    var arrbuf = buffer.buffer;
    storage = UINT8ARRAY;
    if (raw !== false && offset === 0 && (arrbuf instanceof ARRAYBUFFER) && arrbuf.byteLength === 8) return arrbuf;
    var dest = new UINT8ARRAY(8);
    fromArray(dest, 0, buffer, offset);
    return dest.buffer;
  }

  function isValidBuffer(buffer, offset) {
    var len = buffer && buffer.length;
    offset |= 0;
    return len && (offset + 8 <= len) && ("string" !== typeof buffer[offset]);
  }

  function fromArray(destbuf, destoff, srcbuf, srcoff) {
    destoff |= 0;
    srcoff |= 0;
    for (var i = 0; i < 8; i++) {
      destbuf[destoff++] = srcbuf[srcoff++] & 255;
    }
  }

  function newArray(buffer, offset) {
    return Array.prototype.slice.call(buffer, offset, offset + 8);
  }

  function fromPositiveBE(buffer, offset, value) {
    var pos = offset + 8;
    while (pos > offset) {
      buffer[--pos] = value & 255;
      value /= 256;
    }
  }

  function fromNegativeBE(buffer, offset, value) {
    var pos = offset + 8;
    value++;
    while (pos > offset) {
      buffer[--pos] = ((-value) & 255) ^ 255;
      value /= 256;
    }
  }

  function fromPositiveLE(buffer, offset, value) {
    var end = offset + 8;
    while (offset < end) {
      buffer[offset++] = value & 255;
      value /= 256;
    }
  }

  function fromNegativeLE(buffer, offset, value) {
    var end = offset + 8;
    value++;
    while (offset < end) {
      buffer[offset++] = ((-value) & 255) ^ 255;
      value /= 256;
    }
  }

  // https://github.com/retrofox/is-array
  function _isArray(val) {
    return !!val && "[object Array]" == Object.prototype.toString.call(val);
  }

}( true && typeof exports.nodeName !== 'string' ? exports : (this || {}));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

// write-token.js

var ieee754 = __webpack_require__(177);
var Int64Buffer = __webpack_require__(175);
var Uint64BE = Int64Buffer.Uint64BE;
var Int64BE = Int64Buffer.Int64BE;

var uint8 = __webpack_require__(178).uint8;
var Bufferish = __webpack_require__(165);
var Buffer = Bufferish.global;
var IS_BUFFER_SHIM = Bufferish.hasBuffer && ("TYPED_ARRAY_SUPPORT" in Buffer);
var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;
var Buffer_prototype = Bufferish.hasBuffer && Buffer.prototype || {};

exports.getWriteToken = getWriteToken;

function getWriteToken(options) {
  if (options && options.uint8array) {
    return init_uint8array();
  } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {
    return init_safe();
  } else {
    return init_token();
  }
}

function init_uint8array() {
  var token = init_token();

  // float 32 -- 0xca
  // float 64 -- 0xcb
  token[0xca] = writeN(0xca, 4, writeFloatBE);
  token[0xcb] = writeN(0xcb, 8, writeDoubleBE);

  return token;
}

// Node.js and browsers with TypedArray

function init_token() {
  // (immediate values)
  // positive fixint -- 0x00 - 0x7f
  // nil -- 0xc0
  // false -- 0xc2
  // true -- 0xc3
  // negative fixint -- 0xe0 - 0xff
  var token = uint8.slice();

  // bin 8 -- 0xc4
  // bin 16 -- 0xc5
  // bin 32 -- 0xc6
  token[0xc4] = write1(0xc4);
  token[0xc5] = write2(0xc5);
  token[0xc6] = write4(0xc6);

  // ext 8 -- 0xc7
  // ext 16 -- 0xc8
  // ext 32 -- 0xc9
  token[0xc7] = write1(0xc7);
  token[0xc8] = write2(0xc8);
  token[0xc9] = write4(0xc9);

  // float 32 -- 0xca
  // float 64 -- 0xcb
  token[0xca] = writeN(0xca, 4, (Buffer_prototype.writeFloatBE || writeFloatBE), true);
  token[0xcb] = writeN(0xcb, 8, (Buffer_prototype.writeDoubleBE || writeDoubleBE), true);

  // uint 8 -- 0xcc
  // uint 16 -- 0xcd
  // uint 32 -- 0xce
  // uint 64 -- 0xcf
  token[0xcc] = write1(0xcc);
  token[0xcd] = write2(0xcd);
  token[0xce] = write4(0xce);
  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);

  // int 8 -- 0xd0
  // int 16 -- 0xd1
  // int 32 -- 0xd2
  // int 64 -- 0xd3
  token[0xd0] = write1(0xd0);
  token[0xd1] = write2(0xd1);
  token[0xd2] = write4(0xd2);
  token[0xd3] = writeN(0xd3, 8, writeInt64BE);

  // str 8 -- 0xd9
  // str 16 -- 0xda
  // str 32 -- 0xdb
  token[0xd9] = write1(0xd9);
  token[0xda] = write2(0xda);
  token[0xdb] = write4(0xdb);

  // array 16 -- 0xdc
  // array 32 -- 0xdd
  token[0xdc] = write2(0xdc);
  token[0xdd] = write4(0xdd);

  // map 16 -- 0xde
  // map 32 -- 0xdf
  token[0xde] = write2(0xde);
  token[0xdf] = write4(0xdf);

  return token;
}

// safe mode: for old browsers and who needs asserts

function init_safe() {
  // (immediate values)
  // positive fixint -- 0x00 - 0x7f
  // nil -- 0xc0
  // false -- 0xc2
  // true -- 0xc3
  // negative fixint -- 0xe0 - 0xff
  var token = uint8.slice();

  // bin 8 -- 0xc4
  // bin 16 -- 0xc5
  // bin 32 -- 0xc6
  token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);
  token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);
  token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);

  // ext 8 -- 0xc7
  // ext 16 -- 0xc8
  // ext 32 -- 0xc9
  token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);
  token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);
  token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);

  // float 32 -- 0xca
  // float 64 -- 0xcb
  token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);
  token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);

  // uint 8 -- 0xcc
  // uint 16 -- 0xcd
  // uint 32 -- 0xce
  // uint 64 -- 0xcf
  token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);
  token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);
  token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);
  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);

  // int 8 -- 0xd0
  // int 16 -- 0xd1
  // int 32 -- 0xd2
  // int 64 -- 0xd3
  token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);
  token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);
  token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);
  token[0xd3] = writeN(0xd3, 8, writeInt64BE);

  // str 8 -- 0xd9
  // str 16 -- 0xda
  // str 32 -- 0xdb
  token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);
  token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);
  token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);

  // array 16 -- 0xdc
  // array 32 -- 0xdd
  token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);
  token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);

  // map 16 -- 0xde
  // map 32 -- 0xdf
  token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);
  token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);

  return token;
}

function write1(type) {
  return function(encoder, value) {
    var offset = encoder.reserve(2);
    var buffer = encoder.buffer;
    buffer[offset++] = type;
    buffer[offset] = value;
  };
}

function write2(type) {
  return function(encoder, value) {
    var offset = encoder.reserve(3);
    var buffer = encoder.buffer;
    buffer[offset++] = type;
    buffer[offset++] = value >>> 8;
    buffer[offset] = value;
  };
}

function write4(type) {
  return function(encoder, value) {
    var offset = encoder.reserve(5);
    var buffer = encoder.buffer;
    buffer[offset++] = type;
    buffer[offset++] = value >>> 24;
    buffer[offset++] = value >>> 16;
    buffer[offset++] = value >>> 8;
    buffer[offset] = value;
  };
}

function writeN(type, len, method, noAssert) {
  return function(encoder, value) {
    var offset = encoder.reserve(len + 1);
    encoder.buffer[offset++] = type;
    method.call(encoder.buffer, value, offset, noAssert);
  };
}

function writeUInt64BE(value, offset) {
  new Uint64BE(this, offset, value);
}

function writeInt64BE(value, offset) {
  new Int64BE(this, offset, value);
}

function writeFloatBE(value, offset) {
  ieee754.write(this, value, offset, false, 23, 4);
}

function writeDoubleBE(value, offset) {
  ieee754.write(this, value, offset, false, 52, 8);
}


/***/ }),
/* 177 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 178 */
/***/ (function(module, exports) {

// write-unit8.js

var constant = exports.uint8 = new Array(256);

for (var i = 0x00; i <= 0xFF; i++) {
  constant[i] = write0(i);
}

function write0(type) {
  return function(encoder) {
    var offset = encoder.reserve(1);
    encoder.buffer[offset] = type;
  };
}


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// codec-base.js

var IS_ARRAY = __webpack_require__(167);

exports.createCodec = createCodec;
exports.install = install;
exports.filter = filter;

var Bufferish = __webpack_require__(165);

function Codec(options) {
  if (!(this instanceof Codec)) return new Codec(options);
  this.options = options;
  this.init();
}

Codec.prototype.init = function() {
  var options = this.options;

  if (options && options.uint8array) {
    this.bufferish = Bufferish.Uint8Array;
  }

  return this;
};

function install(props) {
  for (var key in props) {
    Codec.prototype[key] = add(Codec.prototype[key], props[key]);
  }
}

function add(a, b) {
  return (a && b) ? ab : (a || b);

  function ab() {
    a.apply(this, arguments);
    return b.apply(this, arguments);
  }
}

function join(filters) {
  filters = filters.slice();

  return function(value) {
    return filters.reduce(iterator, value);
  };

  function iterator(value, filter) {
    return filter(value);
  }
}

function filter(filter) {
  return IS_ARRAY(filter) ? join(filter) : filter;
}

// @public
// msgpack.createCodec()

function createCodec(options) {
  return new Codec(options);
}

// default shared codec

exports.preset = createCodec({preset: true});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// flex-buffer.js

exports.FlexDecoder = FlexDecoder;
exports.FlexEncoder = FlexEncoder;

var Bufferish = __webpack_require__(165);

var MIN_BUFFER_SIZE = 2048;
var MAX_BUFFER_SIZE = 65536;
var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";

function FlexDecoder() {
  if (!(this instanceof FlexDecoder)) return new FlexDecoder();
}

function FlexEncoder() {
  if (!(this instanceof FlexEncoder)) return new FlexEncoder();
}

FlexDecoder.mixin = mixinFactory(getDecoderMethods());
FlexDecoder.mixin(FlexDecoder.prototype);

FlexEncoder.mixin = mixinFactory(getEncoderMethods());
FlexEncoder.mixin(FlexEncoder.prototype);

function getDecoderMethods() {
  return {
    bufferish: Bufferish,
    write: write,
    fetch: fetch,
    flush: flush,
    push: push,
    pull: pull,
    read: read,
    reserve: reserve,
    offset: 0
  };

  function write(chunk) {
    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
    this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;
    this.offset = 0;
  }

  function flush() {
    while (this.offset < this.buffer.length) {
      var start = this.offset;
      var value;
      try {
        value = this.fetch();
      } catch (e) {
        if (e && e.message != BUFFER_SHORTAGE) throw e;
        // rollback
        this.offset = start;
        break;
      }
      this.push(value);
    }
  }

  function reserve(length) {
    var start = this.offset;
    var end = start + length;
    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);
    this.offset = end;
    return start;
  }
}

function getEncoderMethods() {
  return {
    bufferish: Bufferish,
    write: write,
    fetch: fetch,
    flush: flush,
    push: push,
    pull: pull,
    read: read,
    reserve: reserve,
    send: send,
    maxBufferSize: MAX_BUFFER_SIZE,
    minBufferSize: MIN_BUFFER_SIZE,
    offset: 0,
    start: 0
  };

  function fetch() {
    var start = this.start;
    if (start < this.offset) {
      var end = this.start = this.offset;
      return Bufferish.prototype.slice.call(this.buffer, start, end);
    }
  }

  function flush() {
    while (this.start < this.offset) {
      var value = this.fetch();
      if (value) this.push(value);
    }
  }

  function pull() {
    var buffers = this.buffers || (this.buffers = []);
    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
    buffers.length = 0; // buffer exhausted
    return chunk;
  }

  function reserve(length) {
    var req = length | 0;

    if (this.buffer) {
      var size = this.buffer.length;
      var start = this.offset | 0;
      var end = start + req;

      // is it long enough?
      if (end < size) {
        this.offset = end;
        return start;
      }

      // flush current buffer
      this.flush();

      // resize it to 2x current length
      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
    }

    // minimum buffer size
    length = Math.max(length, this.minBufferSize);

    // allocate new buffer
    this.buffer = this.bufferish.alloc(length);
    this.start = 0;
    this.offset = req;
    return 0;
  }

  function send(buffer) {
    var length = buffer.length;
    if (length > this.minBufferSize) {
      this.flush();
      this.push(buffer);
    } else {
      var offset = this.reserve(length);
      Bufferish.prototype.copy.call(buffer, this.buffer, offset);
    }
  }
}

// common methods

function write() {
  throw new Error("method not implemented: write()");
}

function fetch() {
  throw new Error("method not implemented: fetch()");
}

function read() {
  var length = this.buffers && this.buffers.length;

  // fetch the first result
  if (!length) return this.fetch();

  // flush current buffer
  this.flush();

  // read from the results
  return this.pull();
}

function push(chunk) {
  var buffers = this.buffers || (this.buffers = []);
  buffers.push(chunk);
}

function pull() {
  var buffers = this.buffers || (this.buffers = []);
  return buffers.shift();
}

function mixinFactory(source) {
  return mixin;

  function mixin(target) {
    for (var key in source) {
      target[key] = source[key];
    }
    return target;
  }
}


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// decode.js

exports.decode = decode;

var DecodeBuffer = __webpack_require__(182).DecodeBuffer;

function decode(input, options) {
  var decoder = new DecodeBuffer(options);
  decoder.write(input);
  return decoder.read();
}

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// decode-buffer.js

exports.DecodeBuffer = DecodeBuffer;

var preset = __webpack_require__(183).preset;

var FlexDecoder = __webpack_require__(180).FlexDecoder;

FlexDecoder.mixin(DecodeBuffer.prototype);

function DecodeBuffer(options) {
  if (!(this instanceof DecodeBuffer)) return new DecodeBuffer(options);

  if (options) {
    this.options = options;
    if (options.codec) {
      var codec = this.codec = options.codec;
      if (codec.bufferish) this.bufferish = codec.bufferish;
    }
  }
}

DecodeBuffer.prototype.codec = preset;

DecodeBuffer.prototype.fetch = function() {
  return this.codec.decode(this);
};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

// read-core.js

var ExtBuffer = __webpack_require__(164).ExtBuffer;
var ExtUnpacker = __webpack_require__(184);
var readUint8 = __webpack_require__(185).readUint8;
var ReadToken = __webpack_require__(186);
var CodecBase = __webpack_require__(179);

CodecBase.install({
  addExtUnpacker: addExtUnpacker,
  getExtUnpacker: getExtUnpacker,
  init: init
});

exports.preset = init.call(CodecBase.preset);

function getDecoder(options) {
  var readToken = ReadToken.getReadToken(options);
  return decode;

  function decode(decoder) {
    var type = readUint8(decoder);
    var func = readToken[type];
    if (!func) throw new Error("Invalid type: " + (type ? ("0x" + type.toString(16)) : type));
    return func(decoder);
  }
}

function init() {
  var options = this.options;
  this.decode = getDecoder(options);

  if (options && options.preset) {
    ExtUnpacker.setExtUnpackers(this);
  }

  return this;
}

function addExtUnpacker(etype, unpacker) {
  var unpackers = this.extUnpackers || (this.extUnpackers = []);
  unpackers[etype] = CodecBase.filter(unpacker);
}

function getExtUnpacker(type) {
  var unpackers = this.extUnpackers || (this.extUnpackers = []);
  return unpackers[type] || extUnpacker;

  function extUnpacker(buffer) {
    return new ExtBuffer(buffer, type);
  }
}


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

// ext-unpacker.js

exports.setExtUnpackers = setExtUnpackers;

var Bufferish = __webpack_require__(165);
var Buffer = Bufferish.global;
var _decode;

var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};

function setExtUnpackers(codec) {
  codec.addExtUnpacker(0x0E, [decode, unpackError(Error)]);
  codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);
  codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);
  codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);
  codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);
  codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);
  codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);

  codec.addExtUnpacker(0x0A, [decode, unpackRegExp]);
  codec.addExtUnpacker(0x0B, [decode, unpackClass(Boolean)]);
  codec.addExtUnpacker(0x0C, [decode, unpackClass(String)]);
  codec.addExtUnpacker(0x0D, [decode, unpackClass(Date)]);
  codec.addExtUnpacker(0x0F, [decode, unpackClass(Number)]);

  if ("undefined" !== typeof Uint8Array) {
    codec.addExtUnpacker(0x11, unpackClass(Int8Array));
    codec.addExtUnpacker(0x12, unpackClass(Uint8Array));
    codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array)]);
    codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array)]);
    codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array)]);
    codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array)]);
    codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array)]);

    // PhantomJS/1.9.7 doesn't have Float64Array
    if ("undefined" !== typeof Float64Array) {
      codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array)]);
    }

    // IE10 doesn't have Uint8ClampedArray
    if ("undefined" !== typeof Uint8ClampedArray) {
      codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));
    }

    codec.addExtUnpacker(0x1A, unpackArrayBuffer);
    codec.addExtUnpacker(0x1D, [unpackArrayBuffer, unpackClass(DataView)]);
  }

  if (Bufferish.hasBuffer) {
    codec.addExtUnpacker(0x1B, unpackClass(Buffer));
  }
}

function decode(input) {
  if (!_decode) _decode = __webpack_require__(181).decode; // lazy load
  return _decode(input);
}

function unpackRegExp(value) {
  return RegExp.apply(null, value);
}

function unpackError(Class) {
  return function(value) {
    var out = new Class();
    for (var key in ERROR_COLUMNS) {
      out[key] = value[key];
    }
    return out;
  };
}

function unpackClass(Class) {
  return function(value) {
    return new Class(value);
  };
}

function unpackArrayBuffer(value) {
  return (new Uint8Array(value)).buffer;
}


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

// read-format.js

var ieee754 = __webpack_require__(177);
var Int64Buffer = __webpack_require__(175);
var Uint64BE = Int64Buffer.Uint64BE;
var Int64BE = Int64Buffer.Int64BE;

exports.getReadFormat = getReadFormat;
exports.readUint8 = uint8;

var Bufferish = __webpack_require__(165);
var BufferProto = __webpack_require__(171);

var HAS_MAP = ("undefined" !== typeof Map);
var NO_ASSERT = true;

function getReadFormat(options) {
  var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
  var int64 = options && options.int64;
  var usemap = HAS_MAP && options && options.usemap;

  var readFormat = {
    map: (usemap ? map_to_map : map_to_obj),
    array: array,
    str: str,
    bin: (binarraybuffer ? bin_arraybuffer : bin_buffer),
    ext: ext,
    uint8: uint8,
    uint16: uint16,
    uint32: uint32,
    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
    int8: int8,
    int16: int16,
    int32: int32,
    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
    float32: read(4, readFloatBE),
    float64: read(8, readDoubleBE)
  };

  return readFormat;
}

function map_to_obj(decoder, len) {
  var value = {};
  var i;
  var k = new Array(len);
  var v = new Array(len);

  var decode = decoder.codec.decode;
  for (i = 0; i < len; i++) {
    k[i] = decode(decoder);
    v[i] = decode(decoder);
  }
  for (i = 0; i < len; i++) {
    value[k[i]] = v[i];
  }
  return value;
}

function map_to_map(decoder, len) {
  var value = new Map();
  var i;
  var k = new Array(len);
  var v = new Array(len);

  var decode = decoder.codec.decode;
  for (i = 0; i < len; i++) {
    k[i] = decode(decoder);
    v[i] = decode(decoder);
  }
  for (i = 0; i < len; i++) {
    value.set(k[i], v[i]);
  }
  return value;
}

function array(decoder, len) {
  var value = new Array(len);
  var decode = decoder.codec.decode;
  for (var i = 0; i < len; i++) {
    value[i] = decode(decoder);
  }
  return value;
}

function str(decoder, len) {
  var start = decoder.reserve(len);
  var end = start + len;
  return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
}

function bin_buffer(decoder, len) {
  var start = decoder.reserve(len);
  var end = start + len;
  var buf = BufferProto.slice.call(decoder.buffer, start, end);
  return Bufferish.from(buf);
}

function bin_arraybuffer(decoder, len) {
  var start = decoder.reserve(len);
  var end = start + len;
  var buf = BufferProto.slice.call(decoder.buffer, start, end);
  return Bufferish.Uint8Array.from(buf).buffer;
}

function ext(decoder, len) {
  var start = decoder.reserve(len+1);
  var type = decoder.buffer[start++];
  var end = start + len;
  var unpack = decoder.codec.getExtUnpacker(type);
  if (!unpack) throw new Error("Invalid ext type: " + (type ? ("0x" + type.toString(16)) : type));
  var buf = BufferProto.slice.call(decoder.buffer, start, end);
  return unpack(buf);
}

function uint8(decoder) {
  var start = decoder.reserve(1);
  return decoder.buffer[start];
}

function int8(decoder) {
  var start = decoder.reserve(1);
  var value = decoder.buffer[start];
  return (value & 0x80) ? value - 0x100 : value;
}

function uint16(decoder) {
  var start = decoder.reserve(2);
  var buffer = decoder.buffer;
  return (buffer[start++] << 8) | buffer[start];
}

function int16(decoder) {
  var start = decoder.reserve(2);
  var buffer = decoder.buffer;
  var value = (buffer[start++] << 8) | buffer[start];
  return (value & 0x8000) ? value - 0x10000 : value;
}

function uint32(decoder) {
  var start = decoder.reserve(4);
  var buffer = decoder.buffer;
  return (buffer[start++] * 16777216) + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
}

function int32(decoder) {
  var start = decoder.reserve(4);
  var buffer = decoder.buffer;
  return (buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start];
}

function read(len, method) {
  return function(decoder) {
    var start = decoder.reserve(len);
    return method.call(decoder.buffer, start, NO_ASSERT);
  };
}

function readUInt64BE(start) {
  return new Uint64BE(this, start).toNumber();
}

function readInt64BE(start) {
  return new Int64BE(this, start).toNumber();
}

function readUInt64BE_int64(start) {
  return new Uint64BE(this, start);
}

function readInt64BE_int64(start) {
  return new Int64BE(this, start);
}

function readFloatBE(start) {
  return ieee754.read(this, start, false, 23, 4);
}

function readDoubleBE(start) {
  return ieee754.read(this, start, false, 52, 8);
}

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

// read-token.js

var ReadFormat = __webpack_require__(185);

exports.getReadToken = getReadToken;

function getReadToken(options) {
  var format = ReadFormat.getReadFormat(options);

  if (options && options.useraw) {
    return init_useraw(format);
  } else {
    return init_token(format);
  }
}

function init_token(format) {
  var i;
  var token = new Array(256);

  // positive fixint -- 0x00 - 0x7f
  for (i = 0x00; i <= 0x7f; i++) {
    token[i] = constant(i);
  }

  // fixmap -- 0x80 - 0x8f
  for (i = 0x80; i <= 0x8f; i++) {
    token[i] = fix(i - 0x80, format.map);
  }

  // fixarray -- 0x90 - 0x9f
  for (i = 0x90; i <= 0x9f; i++) {
    token[i] = fix(i - 0x90, format.array);
  }

  // fixstr -- 0xa0 - 0xbf
  for (i = 0xa0; i <= 0xbf; i++) {
    token[i] = fix(i - 0xa0, format.str);
  }

  // nil -- 0xc0
  token[0xc0] = constant(null);

  // (never used) -- 0xc1
  token[0xc1] = null;

  // false -- 0xc2
  // true -- 0xc3
  token[0xc2] = constant(false);
  token[0xc3] = constant(true);

  // bin 8 -- 0xc4
  // bin 16 -- 0xc5
  // bin 32 -- 0xc6
  token[0xc4] = flex(format.uint8, format.bin);
  token[0xc5] = flex(format.uint16, format.bin);
  token[0xc6] = flex(format.uint32, format.bin);

  // ext 8 -- 0xc7
  // ext 16 -- 0xc8
  // ext 32 -- 0xc9
  token[0xc7] = flex(format.uint8, format.ext);
  token[0xc8] = flex(format.uint16, format.ext);
  token[0xc9] = flex(format.uint32, format.ext);

  // float 32 -- 0xca
  // float 64 -- 0xcb
  token[0xca] = format.float32;
  token[0xcb] = format.float64;

  // uint 8 -- 0xcc
  // uint 16 -- 0xcd
  // uint 32 -- 0xce
  // uint 64 -- 0xcf
  token[0xcc] = format.uint8;
  token[0xcd] = format.uint16;
  token[0xce] = format.uint32;
  token[0xcf] = format.uint64;

  // int 8 -- 0xd0
  // int 16 -- 0xd1
  // int 32 -- 0xd2
  // int 64 -- 0xd3
  token[0xd0] = format.int8;
  token[0xd1] = format.int16;
  token[0xd2] = format.int32;
  token[0xd3] = format.int64;

  // fixext 1 -- 0xd4
  // fixext 2 -- 0xd5
  // fixext 4 -- 0xd6
  // fixext 8 -- 0xd7
  // fixext 16 -- 0xd8
  token[0xd4] = fix(1, format.ext);
  token[0xd5] = fix(2, format.ext);
  token[0xd6] = fix(4, format.ext);
  token[0xd7] = fix(8, format.ext);
  token[0xd8] = fix(16, format.ext);

  // str 8 -- 0xd9
  // str 16 -- 0xda
  // str 32 -- 0xdb
  token[0xd9] = flex(format.uint8, format.str);
  token[0xda] = flex(format.uint16, format.str);
  token[0xdb] = flex(format.uint32, format.str);

  // array 16 -- 0xdc
  // array 32 -- 0xdd
  token[0xdc] = flex(format.uint16, format.array);
  token[0xdd] = flex(format.uint32, format.array);

  // map 16 -- 0xde
  // map 32 -- 0xdf
  token[0xde] = flex(format.uint16, format.map);
  token[0xdf] = flex(format.uint32, format.map);

  // negative fixint -- 0xe0 - 0xff
  for (i = 0xe0; i <= 0xff; i++) {
    token[i] = constant(i - 0x100);
  }

  return token;
}

function init_useraw(format) {
  var i;
  var token = init_token(format).slice();

  // raw 8 -- 0xd9
  // raw 16 -- 0xda
  // raw 32 -- 0xdb
  token[0xd9] = token[0xc4];
  token[0xda] = token[0xc5];
  token[0xdb] = token[0xc6];

  // fixraw -- 0xa0 - 0xbf
  for (i = 0xa0; i <= 0xbf; i++) {
    token[i] = fix(i - 0xa0, format.bin);
  }

  return token;
}

function constant(value) {
  return function() {
    return value;
  };
}

function flex(lenFunc, decodeFunc) {
  return function(decoder) {
    var len = lenFunc(decoder);
    return decodeFunc(decoder, len);
  };
}

function fix(len, method) {
  return function(decoder) {
    return method(decoder, len);
  };
}


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

// encoder.js

exports.Encoder = Encoder;

var EventLite = __webpack_require__(188);
var EncodeBuffer = __webpack_require__(162).EncodeBuffer;

function Encoder(options) {
  if (!(this instanceof Encoder)) return new Encoder(options);
  EncodeBuffer.call(this, options);
}

Encoder.prototype = new EncodeBuffer();

EventLite.mixin(Encoder.prototype);

Encoder.prototype.encode = function(chunk) {
  this.write(chunk);
  this.emit("data", this.read());
};

Encoder.prototype.end = function(chunk) {
  if (arguments.length) this.encode(chunk);
  this.flush();
  this.emit("end");
};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */

function EventLite() {
  if (!(this instanceof EventLite)) return new EventLite();
}

(function(EventLite) {
  // export the class for node.js
  if (true) module.exports = EventLite;

  // property name to hold listeners
  var LISTENERS = "listeners";

  // methods to export
  var methods = {
    on: on,
    once: once,
    off: off,
    emit: emit
  };

  // mixin to self
  mixin(EventLite.prototype);

  // export mixin function
  EventLite.mixin = mixin;

  /**
   * Import on(), once(), off() and emit() methods into target object.
   *
   * @function EventLite.mixin
   * @param target {Prototype}
   */

  function mixin(target) {
    for (var key in methods) {
      target[key] = methods[key];
    }
    return target;
  }

  /**
   * Add an event listener.
   *
   * @function EventLite.prototype.on
   * @param type {string}
   * @param func {Function}
   * @returns {EventLite} Self for method chaining
   */

  function on(type, func) {
    getListeners(this, type).push(func);
    return this;
  }

  /**
   * Add one-time event listener.
   *
   * @function EventLite.prototype.once
   * @param type {string}
   * @param func {Function}
   * @returns {EventLite} Self for method chaining
   */

  function once(type, func) {
    var that = this;
    wrap.originalListener = func;
    getListeners(that, type).push(wrap);
    return that;

    function wrap() {
      off.call(that, type, wrap);
      func.apply(this, arguments);
    }
  }

  /**
   * Remove an event listener.
   *
   * @function EventLite.prototype.off
   * @param [type] {string}
   * @param [func] {Function}
   * @returns {EventLite} Self for method chaining
   */

  function off(type, func) {
    var that = this;
    var listners;
    if (!arguments.length) {
      delete that[LISTENERS];
    } else if (!func) {
      listners = that[LISTENERS];
      if (listners) {
        delete listners[type];
        if (!Object.keys(listners).length) return off.call(that);
      }
    } else {
      listners = getListeners(that, type, true);
      if (listners) {
        listners = listners.filter(ne);
        if (!listners.length) return off.call(that, type);
        that[LISTENERS][type] = listners;
      }
    }
    return that;

    function ne(test) {
      return test !== func && test.originalListener !== func;
    }
  }

  /**
   * Dispatch (trigger) an event.
   *
   * @function EventLite.prototype.emit
   * @param type {string}
   * @param [value] {*}
   * @returns {boolean} True when a listener received the event
   */

  function emit(type, value) {
    var that = this;
    var listeners = getListeners(that, type, true);
    if (!listeners) return false;
    var arglen = arguments.length;
    if (arglen === 1) {
      listeners.forEach(zeroarg);
    } else if (arglen === 2) {
      listeners.forEach(onearg);
    } else {
      var args = Array.prototype.slice.call(arguments, 1);
      listeners.forEach(moreargs);
    }
    return !!listeners.length;

    function zeroarg(func) {
      func.call(that);
    }

    function onearg(func) {
      func.call(that, value);
    }

    function moreargs(func) {
      func.apply(that, args);
    }
  }

  /**
   * @ignore
   */

  function getListeners(that, type, readonly) {
    if (readonly && !that[LISTENERS]) return;
    var listeners = that[LISTENERS] || (that[LISTENERS] = {});
    return listeners[type] || (listeners[type] = []);
  }

})(EventLite);


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

// decoder.js

exports.Decoder = Decoder;

var EventLite = __webpack_require__(188);
var DecodeBuffer = __webpack_require__(182).DecodeBuffer;

function Decoder(options) {
  if (!(this instanceof Decoder)) return new Decoder(options);
  DecodeBuffer.call(this, options);
}

Decoder.prototype = new DecodeBuffer();

EventLite.mixin(Decoder.prototype);

Decoder.prototype.decode = function(chunk) {
  if (arguments.length) this.write(chunk);
  this.flush();
};

Decoder.prototype.push = function(chunk) {
  this.emit("data", chunk);
};

Decoder.prototype.end = function(chunk) {
  this.decode(chunk);
  this.emit("end");
};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

// encode-stream.js

exports.createEncodeStream = EncodeStream;

var util = __webpack_require__(74);
var Transform = __webpack_require__(106).Transform;
var EncodeBuffer = __webpack_require__(162).EncodeBuffer;

util.inherits(EncodeStream, Transform);

var DEFAULT_OPTIONS = {objectMode: true};

function EncodeStream(options) {
  if (!(this instanceof EncodeStream)) return new EncodeStream(options);
  if (options) {
    options.objectMode = true;
  } else {
    options = DEFAULT_OPTIONS;
  }
  Transform.call(this, options);

  var stream = this;
  var encoder = this.encoder = new EncodeBuffer(options);
  encoder.push = function(chunk) {
    stream.push(chunk);
  };
}

EncodeStream.prototype._transform = function(chunk, encoding, callback) {
  this.encoder.write(chunk);
  if (callback) callback();
};

EncodeStream.prototype._flush = function(callback) {
  this.encoder.flush();
  if (callback) callback();
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// decode-stream.js

exports.createDecodeStream = DecodeStream;

var util = __webpack_require__(74);
var Transform = __webpack_require__(106).Transform;
var DecodeBuffer = __webpack_require__(182).DecodeBuffer;

util.inherits(DecodeStream, Transform);

var DEFAULT_OPTIONS = {objectMode: true};

function DecodeStream(options) {
  if (!(this instanceof DecodeStream)) return new DecodeStream(options);
  if (options) {
    options.objectMode = true;
  } else {
    options = DEFAULT_OPTIONS;
  }
  Transform.call(this, options);
  var stream = this;
  var decoder = this.decoder = new DecodeBuffer(options);
  decoder.push = function(chunk) {
    stream.push(chunk);
  };
}

DecodeStream.prototype._transform = function(chunk, encoding, callback) {
  this.decoder.write(chunk);
  this.decoder.flush();
  if (callback) callback();
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// ext.js

// load both interfaces
__webpack_require__(183);
__webpack_require__(163);

exports.createCodec = __webpack_require__(179).createCodec;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

// codec.js

// load both interfaces
__webpack_require__(183);
__webpack_require__(163);

// @public
// msgpack.codec.preset

exports.codec = {
  preset: __webpack_require__(179).preset
};


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = __webpack_require__(106);
class Buffered extends stream_1.Transform {
    constructor() {
        super({
            readableHighWaterMark: 10 * 1024 * 1024,
            writableHighWaterMark: 10 * 1024 * 1024,
        });
        this.chunks = null;
        this.timer = null;
    }
    sendData() {
        const { chunks } = this;
        if (chunks) {
            this.chunks = null;
            const buf = Buffer.concat(chunks);
            this.push(buf);
        }
    }
    // eslint-disable-next-line consistent-return
    _transform(chunk, _encoding, callback) {
        const { chunks, timer } = this;
        const MIN_SIZE = Buffer.poolSize;
        if (timer)
            clearTimeout(timer);
        if (chunk.length < MIN_SIZE) {
            if (!chunks)
                return callback(null, chunk);
            chunks.push(chunk);
            this.sendData();
            callback();
        }
        else {
            if (!chunks) {
                this.chunks = [chunk];
            }
            else {
                chunks.push(chunk);
            }
            this.timer = setTimeout(this.sendData.bind(this), 20);
            callback();
        }
    }
    _flush(callback) {
        const { chunks } = this;
        if (chunks) {
            this.chunks = null;
            const buf = Buffer.concat(chunks);
            callback(null, buf);
        }
        else {
            callback();
        }
    }
}
exports.default = Buffered;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Buffer_1 = __webpack_require__(196);
const Window_1 = __webpack_require__(199);
const Tabpage_1 = __webpack_require__(201);
var ExtType;
(function (ExtType) {
    ExtType[ExtType["Buffer"] = 0] = "Buffer";
    ExtType[ExtType["Window"] = 1] = "Window";
    ExtType[ExtType["Tabpage"] = 2] = "Tabpage";
})(ExtType = exports.ExtType || (exports.ExtType = {}));
exports.Metadata = [
    {
        constructor: Buffer_1.Buffer,
        name: 'Buffer',
        prefix: 'nvim_buf_',
    },
    {
        constructor: Window_1.Window,
        name: 'Window',
        prefix: 'nvim_win_',
    },
    {
        constructor: Tabpage_1.Tabpage,
        name: 'Tabpage',
        prefix: 'nvim_tabpage_',
    },
];


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __webpack_require__(197);
class Buffer extends Base_1.BaseApi {
    constructor() {
        super(...arguments);
        this.prefix = 'nvim_buf_';
    }
    /**
     * Attach to buffer to listen to buffer events
     * @param sendBuffer Set to true if the initial notification should contain
     *        the whole buffer. If so, the first notification will be a
     *        `nvim_buf_lines_event`. Otherwise, the first notification will be
     *        a `nvim_buf_changedtick_event`
     */
    attach(sendBuffer = false, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request(`${this.prefix}attach`, [sendBuffer, options]);
        });
    }
    /**
     * Detach from buffer to stop listening to buffer events
     */
    detach() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request(`${this.prefix}detach`, []);
        });
    }
    /**
     * Get the bufnr of Buffer
     */
    get id() {
        return this.data;
    }
    /** Total number of lines in buffer */
    get length() {
        return this.request(`${this.prefix}line_count`, []);
    }
    /** Get lines in buffer */
    get lines() {
        return this.getLines();
    }
    /** Gets a changed tick of a buffer */
    get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, []);
    }
    get commands() {
        return this.getCommands();
    }
    getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
    }
    /** Get specific lines of buffer */
    getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === 'undefined' ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
            start,
            end,
            indexing,
        ]);
    }
    /** Set lines of buffer given indeces */
    setLines(_lines, { start: _start, end: _end, strictIndexing } = {
        strictIndexing: true,
    }, notify = false) {
        // TODO: Error checking
        // if (typeof start === 'undefined' || typeof end === 'undefined') {
        // }
        const indexing = typeof strictIndexing === 'undefined' ? true : strictIndexing;
        const lines = typeof _lines === 'string' ? [_lines] : _lines;
        const end = typeof _end !== 'undefined' ? _end : _start + 1;
        const method = notify ? 'notify' : 'request';
        return this[method](`${this.prefix}set_lines`, [
            _start,
            end,
            indexing,
            lines,
        ]);
    }
    /**
     * Set virtual text for a line
     *
     * @public
     * @param {number} src_id - Source group to use or 0 to use a new group, or -1
     * @param {number} line - Line to annotate with virtual text (zero-indexed)
     * @param {Chunk[]} chunks - List with [text, hl_group]
     * @param {{[index} opts
     * @returns {Promise<number>}
     */
    setVirtualText(src_id, line, chunks, opts = {}) {
        this.notify(`${this.prefix}set_virtual_text`, [
            src_id,
            line,
            chunks,
            opts,
        ]);
        return Promise.resolve(src_id);
    }
    /** Insert lines at `start` index */
    insert(lines, start) {
        return this.setLines(lines, {
            start,
            end: start,
            strictIndexing: true,
        });
    }
    /** Replace lines starting at `start` index */
    replace(_lines, start) {
        const lines = typeof _lines === 'string' ? [_lines] : _lines;
        return this.setLines(lines, {
            start,
            end: start + lines.length,
            strictIndexing: false,
        });
    }
    /** Remove lines at index */
    remove(start, end, strictIndexing = false) {
        return this.setLines([], { start, end, strictIndexing });
    }
    /** Append a string or list of lines to end of buffer */
    append(lines) {
        return this.setLines(lines, {
            start: -1,
            end: -1,
            strictIndexing: false,
        });
    }
    /** Get buffer name */
    get name() {
        return this.request(`${this.prefix}get_name`, []);
    }
    /** Set current buffer name */
    setName(value) {
        return this.request(`${this.prefix}set_name`, [value]);
    }
    /** Is current buffer valid */
    get valid() {
        return this.request(`${this.prefix}is_valid`, []);
    }
    /** Get mark position given mark name */
    mark(name) {
        return this.request(`${this.prefix}get_mark`, [name]);
    }
    // range(start, end) {
    // """Return a `Range` object, which represents part of the Buffer."""
    // return Range(this, start, end)
    // }
    /** Gets keymap */
    getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
    }
    /**
   * Checks if a buffer is valid and loaded. See |api-buffer| for
   * more info about unloaded buffers.
   */
    get loaded() {
        return this.request(`${this.prefix}is_loaded`, []);
    }
    /**
     * Returns the byte offset for a line.
     *
     * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is
     * one byte. 'fileformat' and 'fileencoding' are ignored. The
     * line index just after the last line gives the total byte-count
     * of the buffer. A final EOL byte is counted if it would be
     * written, see 'eol'.
     *
     * Unlike |line2byte()|, throws error for out-of-bounds indexing.
     * Returns -1 for unloaded buffer.
     *
     * @return {Number} Integer byte offset, or -1 for unloaded buffer.
     */
    getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [index]);
    }
    /**
      Adds a highlight to buffer.
  
      This can be used for plugins which dynamically generate
      highlights to a buffer (like a semantic highlighter or
      linter). The function adds a single highlight to a buffer.
      Unlike matchaddpos() highlights follow changes to line
      numbering (as lines are inserted/removed above the highlighted
      line), like signs and marks do.
  
      "src_id" is useful for batch deletion/updating of a set of
      highlights. When called with src_id = 0, an unique source id
      is generated and returned. Succesive calls can pass in it as
      "src_id" to add new highlights to the same source group. All
      highlights in the same group can then be cleared with
      nvim_buf_clear_highlight. If the highlight never will be
      manually deleted pass in -1 for "src_id".
  
      If "hl_group" is the empty string no highlight is added, but a
      new src_id is still returned. This is useful for an external
      plugin to synchrounously request an unique src_id at
      initialization, and later asynchronously add and clear
      highlights in response to buffer changes. */
    addHighlight({ hlGroup: _hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId, }) {
        const hlGroup = typeof _hlGroup !== 'undefined' ? _hlGroup : '';
        const colEnd = typeof _end !== 'undefined' ? _end : -1;
        const colStart = typeof _start !== 'undefined' ? _start : -0;
        const srcId = typeof _srcId !== 'undefined' ? _srcId : -1;
        const method = hlGroup === '' ? 'request' : 'notify';
        let res = this[method](`${this.prefix}add_highlight`, [
            srcId,
            hlGroup,
            line,
            colStart,
            colEnd,
        ]);
        return method === 'request' ? res : Promise.resolve(null);
    }
    /** Clears highlights from a given source group and a range of
    lines
    To clear a source group in the entire buffer, pass in 1 and -1
    to lineStart and lineEnd respectively. */
    clearHighlight(args = {}) {
        const defaults = {
            srcId: -1,
            lineStart: 0,
            lineEnd: -1,
        };
        const { srcId, lineStart, lineEnd } = Object.assign({}, defaults, args);
        return this.notify(`${this.prefix}clear_highlight`, [
            srcId,
            lineStart,
            lineEnd,
        ]);
    }
    clearNamespace(id, lineStart = 0, lineEnd = -1) {
        return this.notify(`${this.prefix}clear_namespace`, [
            id,
            lineStart,
            lineEnd,
        ]);
    }
    /**
     * Listens to buffer for events
     */
    listen(eventName, cb, disposables) {
        this.client.attachBufferEvent(this, eventName, cb);
        if (disposables) {
            disposables.push({
                dispose: () => {
                    this.client.detachBufferEvent(this, eventName, cb);
                }
            });
        }
    }
}
exports.Buffer = Buffer;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(198);
const isVim = process.env.VIM_NODE_RPC == '1';
// i.e. a plugin that detaches will affect all plugins registered on host
// const EXCLUDED = ['nvim_buf_attach', 'nvim_buf_detach']
// Instead of dealing with multiple inheritance (or lackof), just extend EE
// Only the Neovim API class should use EE though
class BaseApi extends events_1.EventEmitter {
    constructor({ transport, data, client, }) {
        super();
        this.setTransport(transport);
        this.data = data;
        this.client = client;
    }
    setTransport(transport) {
        this.transport = transport;
    }
    equals(other) {
        try {
            return String(this.data) === String(other.data);
        }
        catch (e) {
            return false;
        }
    }
    request(name, args = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.transport.request(name, this.getArgsByPrefix(args), (err, res) => {
                    if (err) {
                        reject(new Error(`request error ${name} - ${err[1]}`));
                    }
                    else {
                        resolve(res);
                    }
                });
            });
        });
    }
    getArgsByPrefix(args) {
        // Check if class is Neovim and if so, should not send `this` as first arg
        if (this.prefix !== 'nvim_' && args[0] != this) {
            let id = isVim ? this.data : this;
            return [id, ...args];
        }
        return args;
    }
    /** Retrieves a scoped variable depending on type (using `this.prefix`) */
    getVar(name) {
        return this.request(`${this.prefix}get_var`, [name]).then(res => res, _err => {
            return null;
        });
    }
    setVar(name, value, isNotify = false) {
        if (isNotify) {
            this.notify(`${this.prefix}set_var`, [name, value]);
            return;
        }
        return this.request(`${this.prefix}set_var`, [name, value]);
    }
    /** Delete a scoped variable */
    deleteVar(name) {
        this.notify(`${this.prefix}del_var`, [name]);
    }
    /** Retrieves a scoped option depending on type of `this` */
    getOption(name) {
        return this.request(`${this.prefix}get_option`, [name]);
    }
    setOption(name, value, isNotify) {
        if (isNotify) {
            this.notify(`${this.prefix}set_option`, [name, value]);
            return;
        }
        return this.request(`${this.prefix}set_option`, [name, value]);
    }
    /** `request` is basically the same except you can choose to wait forpromise to be resolved */
    notify(name, args = []) {
        this.transport.notify(name, this.getArgsByPrefix(args));
    }
}
exports.BaseApi = BaseApi;


/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __webpack_require__(197);
const timers_1 = __webpack_require__(200);
class Window extends Base_1.BaseApi {
    constructor() {
        super(...arguments);
        this.prefix = 'nvim_win_';
    }
    /**
     * The windowid that not change within a Vim session
     */
    get id() {
        return this.data;
    }
    /** Get current buffer of window */
    get buffer() {
        return this.request(`${this.prefix}get_buf`, []);
    }
    /** Get the Tabpage that contains the window */
    get tabpage() {
        return this.request(`${this.prefix}get_tabpage`, []);
    }
    /** Get cursor position */
    get cursor() {
        return this.request(`${this.prefix}get_cursor`, []);
    }
    setCursor(pos, isNotify = false) {
        let method = isNotify ? 'notify' : 'request';
        return this[method](`${this.prefix}set_cursor`, [pos]);
    }
    /** Get window height by number of rows */
    get height() {
        return this.request(`${this.prefix}get_height`, []);
    }
    setHeight(height, isNotify = false) {
        let method = isNotify ? 'notify' : 'request';
        return this[method](`${this.prefix}set_height`, [height]);
    }
    /** Get window width by number of columns */
    get width() {
        return this.request(`${this.prefix}get_width`, []);
    }
    setWidth(width, isNotify = false) {
        let method = isNotify ? 'notify' : 'request';
        return this[method](`${this.prefix}set_height`, [width]);
    }
    /** Get window position */
    get position() {
        return this.request(`${this.prefix}get_position`, []);
    }
    /** 0-indexed, on-screen window position(row) in display cells. */
    get row() {
        return this.request(`${this.prefix}get_position`, []).then(position => position[0]);
    }
    /** 0-indexed, on-screen window position(col) in display cells. */
    get col() {
        return this.request(`${this.prefix}get_position`, []).then(position => position[1]);
    }
    /** Is window valid */
    get valid() {
        return this.request(`${this.prefix}is_valid`, []);
    }
    /** Get window number */
    get number() {
        return this.request(`${this.prefix}get_number`, []);
    }
    setConfig(options, isNotify) {
        let method = isNotify ? 'notify' : 'request';
        return this[method](`${this.prefix}set_config`, [options]);
    }
    getConfig() {
        return this.request(`${this.prefix}get_config`, []);
    }
    close(force, isNotify) {
        if (isNotify) {
            this.notify(`${this.prefix}close`, [force]);
            let count = 0;
            let interval = setInterval(() => {
                if (count == 5)
                    return timers_1.clearInterval(interval);
                this.request(`${this.prefix}is_valid`, []).then(valid => {
                    if (!valid) {
                        timers_1.clearInterval(interval);
                    }
                    else {
                        this.notify(`${this.prefix}close`, [force]);
                    }
                }, () => {
                    timers_1.clearInterval(interval);
                });
                count++;
            }, 50);
            return null;
        }
        return this.request(`${this.prefix}close`, [force]);
    }
}
exports.Window = Window;


/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = require("timers");

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __webpack_require__(197);
class Tabpage extends Base_1.BaseApi {
    constructor() {
        super(...arguments);
        this.prefix = 'nvim_tabpage_';
    }
    /** Returns all windows of tabpage */
    get windows() {
        return this.request(`${this.prefix}list_wins`, []);
    }
    /** Gets the current window of tabpage */
    get window() {
        return this.request(`${this.prefix}get_win`, []);
    }
    /** Is current tabpage valid */
    get valid() {
        return this.request(`${this.prefix}is_valid`, []);
    }
    /** Tabpage number */
    get number() {
        return this.request(`${this.prefix}get_number`, []);
    }
    /** Invalid */
    getOption() {
        throw new Error('Tabpage does not have `getOption`');
    }
    /** Invalid */
    setOption() {
        throw new Error('Tabpage does not have `setOption`');
    }
}
exports.Tabpage = Tabpage;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(198);
const logger_1 = __webpack_require__(203);
const debug = process.env.NODE_CLIENT_LOG_LEVEL == 'debug';
const logger = logger_1.createLogger('transport');
class Transport extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.pauseLevel = 0;
        this.paused = new Map();
    }
    debug(key, ...meta) {
        if (!debug)
            return;
        logger.debug(key, ...meta);
    }
    info(key, ...meta) {
        logger.info(key, ...meta);
    }
    debugMessage(msg) {
        if (!debug)
            return;
        const msgType = msg[0];
        if (msgType == 0) {
            logger.debug('receive request:', msg.slice(1));
        }
        else if (msgType == 1) {
            // logger.debug('receive response:', msg.slice(1))
        }
        else if (msgType == 2) {
            logger.debug('receive notification:', msg.slice(1));
        }
        else {
            logger.debug('unknown message:', msg);
        }
    }
    pauseNotification() {
        this.pauseLevel = this.pauseLevel + 1;
        this.paused.set(this.pauseLevel, []);
    }
    cancelNotification() {
        let { pauseLevel } = this;
        if (pauseLevel > 0) {
            this.paused.delete(pauseLevel);
            this.pauseLevel = pauseLevel - 1;
        }
    }
    resumeNotification(isNotify = false) {
        let { pauseLevel } = this;
        if (pauseLevel == 0)
            return isNotify ? null : Promise.resolve([null, null]);
        this.pauseLevel = pauseLevel - 1;
        let list = this.paused.get(pauseLevel);
        this.paused.delete(pauseLevel);
        if (list && list.length) {
            return new Promise((resolve, reject) => {
                if (!isNotify) {
                    return this.request('nvim_call_atomic', [list], (err, res) => {
                        if (err)
                            return reject(new Error(`call_atomic error: ${err[1]}`));
                        resolve(res);
                    });
                }
                this.notify('nvim_call_atomic', [list]);
                resolve();
            });
        }
        return isNotify ? null : Promise.resolve([[], undefined]);
    }
}
exports.default = Transport;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(__webpack_require__(66));
const os_1 = __importDefault(__webpack_require__(76));
const path_1 = __importDefault(__webpack_require__(82));
function getLogFile() {
    let file = process.env.NODE_CLIENT_LOG_FILE;
    if (file)
        return file;
    let dir = process.env.XDG_RUNTIME_DIR;
    if (dir)
        return path_1.default.join(dir, 'node-client.log');
    return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);
}
const LOG_FILE_PATH = getLogFile();
const level = process.env.NODE_CLIENT_LOG_LEVEL || 'info';
let invalid = process.getuid && process.getuid() == 0;
if (!invalid) {
    try {
        fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), { recursive: true });
        fs_1.default.writeFileSync(LOG_FILE_PATH, '', { encoding: 'utf8', mode: 0o666 });
    }
    catch (_e) {
        invalid = true;
    }
}
function toObject(arg) {
    if (arg == null) {
        return arg;
    }
    if (Array.isArray(arg)) {
        return arg.map(o => toObject(o));
    }
    if (typeof arg == 'object' && typeof arg.prefix == 'string' && typeof arg.data == 'number') {
        return '[' + arg.prefix + arg.data + ']';
    }
    return arg;
}
function toString(arg) {
    if (arg == null)
        return String(arg);
    if (typeof arg == 'object')
        return JSON.stringify(arg, null, 2);
    return String(arg);
}
const stream = invalid ? null : fs_1.default.createWriteStream(LOG_FILE_PATH, { encoding: 'utf8' });
class Logger {
    constructor(name) {
        this.name = name;
    }
    getText(level, data, meta) {
        let more = '';
        if (meta.length) {
            let arr = toObject(meta);
            more = ' ' + arr.map(o => toString(o));
        }
        return `${new Date().toLocaleTimeString()} ${level.toUpperCase()} [${this.name}] - ${data}${more}\n`;
    }
    debug(data, ...meta) {
        if (level != 'debug' || stream == null)
            return;
        stream.write(this.getText('debug', data, meta));
    }
    info(data, ...meta) {
        if (stream == null)
            return;
        stream.write(this.getText('info', data, meta));
    }
    error(data, ...meta) {
        if (stream == null)
            return;
        stream.write(this.getText('error', data, meta));
    }
    trace(data, ...meta) {
        if (level != 'trace' || stream == null)
            return;
        stream.write(this.getText('trace', data, meta));
    }
}
function createLogger(name) {
    return new Logger(name);
}
exports.createLogger = createLogger;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __importDefault(__webpack_require__(202));
const connection_1 = __importDefault(__webpack_require__(205));
const request_1 = __importDefault(__webpack_require__(207));
class VimTransport extends base_1.default {
    constructor() {
        super();
        this.pending = new Map();
        this.nextRequestId = -1;
        this.attached = false;
        this.notifyMethod = process.env.COC_NVIM == '1' ? 'coc#api#notify' : 'nvim#api#notify';
    }
    attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on('request', (id, obj) => {
            let [method, args] = obj;
            this.emit('request', method, args, this.createResponse(id));
        });
        connection.on('notification', (obj) => {
            let [event, args] = obj;
            this.emit('notification', event.toString(), args);
        });
        connection.on('response', (id, obj) => {
            let req = this.pending.get(id);
            if (req) {
                this.pending.delete(id);
                let err = null;
                let result = null;
                if (!Array.isArray(obj)) {
                    err = obj;
                }
                else {
                    err = obj[0];
                    result = obj[1];
                }
                req.callback(this.client, err, result);
            }
        });
    }
    send(arr) {
        this.connection.send(arr);
    }
    detach() {
        if (!this.attached)
            return;
        this.attached = false;
        this.connection.dispose();
    }
    /**
     * Send request to vim
     */
    request(method, args, cb) {
        if (!this.attached)
            return cb([0, 'transport disconnected']);
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        let startTs = Date.now();
        this.debug('request to vim:', id, method, args);
        let timer = setTimeout(() => {
            this.debug(`request to vim cost more than 1s`, method, args);
        }, 1000);
        let req = new request_1.default(this.connection, (err, res) => {
            clearTimeout(timer);
            this.debug(`response from vim cost:`, id, `${Date.now() - startTs}ms`);
            cb(err, res);
        }, id);
        this.pending.set(id, req);
        req.request(method, args);
    }
    notify(method, args) {
        if (!this.attached)
            return;
        if (this.pauseLevel != 0) {
            let arr = this.paused.get(this.pauseLevel);
            if (arr) {
                arr.push([method, args]);
                return;
            }
        }
        this.connection.call(this.notifyMethod, [method.slice(5), args]);
    }
    createResponse(requestId) {
        let called = false;
        let { connection } = this;
        let startTs = Date.now();
        let timer = setTimeout(() => {
            this.debug(`request to client cost more than 1s`, requestId);
        }, 1000);
        return {
            send: (resp, isError) => {
                clearTimeout(timer);
                if (called || !this.attached)
                    return;
                called = true;
                let err = null;
                if (isError)
                    err = typeof resp === 'string' ? resp : resp.toString();
                this.debug('response of client cost:', requestId, `${Date.now() - startTs}ms`);
                connection.response(requestId, [err, isError ? null : resp]);
            }
        };
    }
}
exports.VimTransport = VimTransport;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(__webpack_require__(198));
const readline_1 = __importDefault(__webpack_require__(206));
const logger_1 = __webpack_require__(203);
const logger = logger_1.createLogger('connection');
const debug = process.env.NODE_CLIENT_LOG_LEVEL == 'debug';
class Connection extends events_1.default {
    constructor(readable, writeable) {
        super();
        this.readable = readable;
        this.writeable = writeable;
        const rl = readline_1.default.createInterface(this.readable);
        rl.on('line', (line) => {
            this.parseData(line);
        });
        rl.on('close', () => {
            logger.error('connection closed');
            process.exit(0);
        });
    }
    parseData(str) {
        if (str.length == 0)
            return;
        let arr;
        try {
            arr = JSON.parse(str);
        }
        catch (e) {
            // tslint:disable-next-line: no-console
            console.error(`Invalid data from vim: ${str}`);
            return;
        }
        // request, notification, response
        let [id, obj] = arr;
        if (id > 0) {
            logger.debug('received request:', id, obj);
            this.emit('request', id, obj);
        }
        else if (id == 0) {
            logger.debug('received notification:', obj);
            this.emit('notification', obj);
        }
        else {
            logger.debug('received response:', id, obj);
            // response for previous request
            this.emit('response', id, obj);
        }
    }
    response(requestId, data) {
        this.send([requestId, data || null]);
    }
    notify(event, data) {
        this.send([0, [event, data || null]]);
    }
    send(arr) {
        logger.debug('send to vim:', arr);
        try {
            this.writeable.write(JSON.stringify(arr) + '\n');
        }
        catch (e) {
            logger.error('Send error:', arr);
        }
    }
    redraw(force = false) {
        this.send(['redraw', force ? 'force' : '']);
    }
    commmand(cmd) {
        this.send(['ex', cmd]);
    }
    expr(expr) {
        this.send(['expr', expr]);
    }
    call(func, args, requestId) {
        if (!requestId) {
            this.send(['call', func, args]);
            return;
        }
        this.send(['call', func, args, requestId]);
    }
    dispose() {
        this.removeAllListeners();
    }
}
exports.default = Connection;


/***/ }),
/* 206 */
/***/ (function(module, exports) {

module.exports = require("readline");

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __webpack_require__(203);
const logger = logger_1.createLogger('request');
const debug = process.env.NODE_CLIENT_LOG_LEVEL == 'debug';
const func = process.env.COC_NVIM == '1' ? 'coc#api#call' : 'nvim#api#call';
class Request {
    constructor(connection, cb, id) {
        this.connection = connection;
        this.cb = cb;
        this.id = id;
    }
    request(method, args = []) {
        this.method = method;
        this.args = args;
        this.connection.call(func, [method.slice(5), args], this.id);
    }
    callback(client, err, result) {
        let { method, cb } = this;
        if (debug && err) {
            logger.debug(`request ${this.method} error:`, err, this.args);
        }
        if (err)
            return cb([0, err.toString()]);
        switch (method) {
            case 'nvim_list_wins':
            case 'nvim_tabpage_list_wins':
                return cb(null, result.map(o => client.createWindow(o)));
            case 'nvim_tabpage_get_win':
            case 'nvim_get_current_win':
            case 'nvim_open_win':
                return cb(null, client.createWindow(result));
            case 'nvim_list_bufs':
                return cb(null, result.map(o => client.createBuffer(o)));
            case 'nvim_win_get_buf':
            case 'nvim_create_buf':
            case 'nvim_get_current_buf':
                return cb(null, client.createBuffer(result));
            case 'nvim_list_tabpages':
                return cb(null, result.map(o => client.createTabpage(o)));
            case 'nvim_get_current_tabpage':
                return cb(null, client.createTabpage(result));
            default:
                return cb(null, result);
        }
    }
}
exports.default = Request;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __webpack_require__(197);
const Buffer_1 = __webpack_require__(196);
const Tabpage_1 = __webpack_require__(201);
const Window_1 = __webpack_require__(199);
const isVim = process.env.VIM_NODE_RPC == '1';
/**
 * Neovim API
 */
class Neovim extends Base_1.BaseApi {
    constructor() {
        super(...arguments);
        this.prefix = 'nvim_';
        this.Buffer = Buffer_1.Buffer;
        this.Window = Window_1.Window;
        this.Tabpage = Tabpage_1.Tabpage;
    }
    getArgs(args) {
        if (!args)
            return [];
        if (Array.isArray(args))
            return args;
        return [args];
    }
    get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
    }
    /** Get list of all buffers */
    get buffers() {
        return this.request(`${this.prefix}list_bufs`);
    }
    /** Get current buffer */
    get buffer() {
        return this.request(`${this.prefix}get_current_buf`);
    }
    /** Set current buffer */
    setBuffer(buffer) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.request(`${this.prefix}set_current_buf`, [buffer]);
        });
    }
    get chans() {
        return this.request(`${this.prefix}list_chans`);
    }
    getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
    }
    createNamespace(name = "") {
        return this.request(`${this.prefix}create_namespace`, [name]);
    }
    get namespaces() {
        return this.request(`${this.prefix}get_namespaces`, [name]);
    }
    get commands() {
        return this.getCommands();
    }
    getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
    }
    /** Get list of all tabpages */
    get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
    }
    /** Get current tabpage */
    get tabpage() {
        return this.request(`${this.prefix}get_current_tabpage`);
    }
    /** Set current tabpage */
    setTabpage(tabpage) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
        });
    }
    /** Get list of all windows */
    get windows() {
        return this.getWindows();
    }
    /** Get current window */
    get window() {
        return this.request(`${this.prefix}get_current_win`);
    }
    /** Get list of all windows */
    getWindows() {
        return this.request(`${this.prefix}list_wins`);
    }
    setWindow(win) {
        return __awaiter(this, void 0, void 0, function* () {
            // Throw error if win is not instance of Window?
            yield this.request(`${this.prefix}set_current_win`, [win]);
        });
    }
    /** Get list of all runtime paths */
    get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
    }
    /** Set current directory */
    setDirectory(dir) {
        return this.request(`${this.prefix}set_current_dir`, [dir]);
    }
    /** Get current line. Always returns a Promise. */
    get line() {
        return this.getLine();
    }
    createNewBuffer(listed = false, scratch = false) {
        return this.request(`${this.prefix}create_buf`, [listed, scratch]);
    }
    openFloatWindow(buffer, enter, options) {
        return this.request(`${this.prefix}open_win`, [buffer, enter, options]);
    }
    getLine() {
        return this.request(`${this.prefix}get_current_line`);
    }
    /** Set current line */
    setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
    }
    /** Gets keymap */
    getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
    }
    /** Gets current mode */
    get mode() {
        return this.request(`${this.prefix}get_mode`);
    }
    /** Gets map of defined colors */
    get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
    }
    /** Get color by name */
    getColorByName(name) {
        return this.request(`${this.prefix}get_color_by_name`, [name]);
    }
    /** Get highlight by name or id */
    getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === 'string' ? 'by_name' : 'by_id';
        return this.request(`${this.prefix}get_hl_${functionName}`, [
            nameOrId,
            isRgb,
        ]);
    }
    getHighlightByName(name, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name, isRgb]);
    }
    getHighlightById(id, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
    }
    /** Delete current line in buffer */
    deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
    }
    /**
     * Evaluates a VimL expression (:help expression). Dictionaries
     * and Lists are recursively expanded. On VimL error: Returns a
     * generic error; v:errmsg is not updated.
     *
     */
    eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
    }
    /**
     * Executes lua, it's possible neovim client does not support this
     */
    lua(code, args = []) {
        const _args = this.getArgs(args);
        return this.request(`${this.prefix}execute_lua`, [code, _args]);
    }
    // Alias for `lua()` to be consistent with neovim API
    executeLua(code, args = []) {
        return this.lua(code, args);
    }
    callDictFunction(dict, fname, args = []) {
        const _args = this.getArgs(args);
        return this.request(`${this.prefix}call_dict_function`, [
            dict,
            fname,
            _args,
        ]);
    }
    call(fname, args = [], isNotify) {
        const _args = this.getArgs(args);
        if (isNotify) {
            this.notify(`${this.prefix}call_function`, [fname, _args]);
            return null;
        }
        return this.request(`${this.prefix}call_function`, [fname, _args]);
    }
    callTimer(fname, args = [], isNotify) {
        const _args = this.getArgs(args);
        if (isNotify) {
            this.notify(`${this.prefix}call_function`, ['coc#util#timer', [fname, _args]]);
            return null;
        }
        if (isVim) {
            this.notify(`${this.prefix}call_function`, ['coc#util#timer', [fname, _args]]);
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve(null);
                }, 20);
            });
        }
        return this.request(`${this.prefix}call_function`, ['coc#util#timer', [fname, _args]]);
    }
    callAsync(fname, args = []) {
        const _args = this.getArgs(args);
        return this.client.sendAsyncRequest(fname, _args);
    }
    /** Alias for `call` */
    callFunction(fname, args = []) {
        return this.call(fname, args);
    }
    /** Call Atomic calls */
    callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
    }
    command(arg, isNotify) {
        if (isNotify) {
            this.notify(`${this.prefix}command`, [arg]);
            return null;
        }
        return this.request(`${this.prefix}command`, [arg]);
    }
    /** Runs a command and returns output (synchronous?) */
    commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
    }
    /** Gets a v: variable */
    getVvar(name) {
        return this.request(`${this.prefix}get_vvar`, [name]);
    }
    /** feedKeys */
    feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
    }
    /** Sends input keys */
    input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
    }
    /**
     * Parse a VimL Expression
     *
     * TODO: return type, see :help
     */
    parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
            expr,
            flags,
            highlight,
        ]);
    }
    getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
    }
    getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
    }
    /** Replace term codes */
    replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
            str,
            fromPart,
            doIt,
            special,
        ]);
    }
    /** Gets width of string */
    strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
    }
    /** Write to output buffer */
    outWrite(str) {
        this.notify(`${this.prefix}out_write`, [str]);
    }
    outWriteLine(str) {
        this.outWrite(`${str}\n`);
    }
    /** Write to error buffer */
    errWrite(str) {
        this.notify(`${this.prefix}err_write`, [str]);
    }
    /** Write to error buffer */
    errWriteLine(str) {
        this.notify(`${this.prefix}err_writeln`, [str]);
    }
    // TODO: add type
    get uis() {
        return this.request(`${this.prefix}list_uis`);
    }
    uiAttach(width, height, options) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options]);
    }
    uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
    }
    uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
    }
    /** Set UI Option */
    uiSetOption(name, value) {
        return this.request(`${this.prefix}ui_set_option`, [name, value]);
    }
    /** Subscribe to nvim event broadcasts */
    subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
    }
    /** Unsubscribe to nvim event broadcasts */
    unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
    }
    setClientInfo(name, version, type, methods, attributes) {
        this.notify(`${this.prefix}set_client_info`, [
            name,
            version,
            type,
            methods,
            attributes,
        ]);
    }
    /** Quit nvim */
    quit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.command('qa!', true);
            if (this.transport) {
                this.transport.detach();
            }
        });
    }
}
exports.Neovim = Neovim;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var client_1 = __webpack_require__(158);
exports.Neovim = client_1.NeovimClient;
var client_2 = __webpack_require__(158);
exports.NeovimClient = client_2.NeovimClient;
var Buffer_1 = __webpack_require__(196);
exports.Buffer = Buffer_1.Buffer;
var Window_1 = __webpack_require__(199);
exports.Window = Window_1.Window;
var Tabpage_1 = __webpack_require__(201);
exports.Tabpage = Tabpage_1.Tabpage;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const util_1 = __webpack_require__(238);
const object_1 = __webpack_require__(249);
const logger = __webpack_require__(64)('events');
class Events {
    constructor() {
        this.handlers = new Map();
        this.insertMode = false;
    }
    get cursor() {
        return this._cursor;
    }
    async fire(event, args) {
        logger.debug('Event:', event, args);
        let cbs = this.handlers.get(event);
        if (event == 'InsertEnter') {
            this.insertMode = true;
        }
        else if (event == 'InsertLeave') {
            this.insertMode = false;
        }
        else if (!this.insertMode && (event == 'CursorHoldI' || event == 'CursorMovedI')) {
            this.insertMode = true;
            await this.fire('InsertEnter', [args[0]]);
        }
        else if (this.insertMode && (event == 'CursorHold' || event == 'CursorMoved')) {
            this.insertMode = false;
            await this.fire('InsertLeave', [args[0]]);
        }
        if (event == 'CursorMoved' || event == 'CursorMovedI') {
            let cursor = {
                bufnr: args[0],
                lnum: args[1][0],
                col: args[1][1],
                insert: event == 'CursorMovedI'
            };
            // not handle CursorMoved when it's not moved at all
            if (this._cursor && object_1.equals(this._cursor, cursor))
                return;
            this._cursor = cursor;
        }
        if (cbs) {
            try {
                await Promise.all(cbs.map(fn => fn(args)));
            }
            catch (e) {
                if (e.message && e.message.indexOf('transport disconnected') == -1) {
                    console.error(`Error on ${event}: ${e.message}${e.stack ? '\n' + e.stack : ''} `);
                }
                logger.error(`Handler Error on ${event}`, e.stack);
            }
        }
    }
    on(event, handler, thisArg, disposables) {
        if (Array.isArray(event)) {
            let arr = disposables || [];
            for (let ev of event) {
                this.on(ev, handler, thisArg, arr);
            }
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                util_1.disposeAll(arr);
            });
        }
        else {
            let arr = this.handlers.get(event) || [];
            let stack = Error().stack;
            let wrappedhandler = args => new Promise((resolve, reject) => {
                let timer;
                try {
                    Promise.resolve(handler.apply(thisArg || null, args)).then(() => {
                        if (timer)
                            clearTimeout(timer);
                        resolve();
                    }, e => {
                        if (timer)
                            clearTimeout(timer);
                        reject(e);
                    });
                    timer = setTimeout(() => {
                        logger.warn(`Handler of ${event} blocked more than 2s:`, stack);
                    }, 2000);
                }
                catch (e) {
                    reject(e);
                }
            });
            arr.push(wrappedhandler);
            this.handlers.set(event, arr);
            let disposable = vscode_languageserver_protocol_1.Disposable.create(() => {
                let idx = arr.indexOf(wrappedhandler);
                if (idx !== -1) {
                    arr.splice(idx, 1);
                }
            });
            if (disposables) {
                disposables.push(disposable);
            }
            return disposable;
        }
    }
}
exports.default = new Events();
//# sourceMappingURL=events.js.map

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.CancellationToken = vscode_jsonrpc_1.CancellationToken;
exports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
exports.Disposable = vscode_jsonrpc_1.Disposable;
exports.Event = vscode_jsonrpc_1.Event;
exports.Emitter = vscode_jsonrpc_1.Emitter;
exports.Trace = vscode_jsonrpc_1.Trace;
exports.TraceFormat = vscode_jsonrpc_1.TraceFormat;
exports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
exports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
exports.RequestType = vscode_jsonrpc_1.RequestType;
exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
exports.NotificationType = vscode_jsonrpc_1.NotificationType;
exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
exports.MessageReader = vscode_jsonrpc_1.MessageReader;
exports.MessageWriter = vscode_jsonrpc_1.MessageWriter;
exports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
exports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
exports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
exports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
exports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
exports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
exports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
exports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
exports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
exports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
exports.ProgressType = vscode_jsonrpc_1.ProgressType;
__export(__webpack_require__(223));
__export(__webpack_require__(224));
const callHierarchy = __webpack_require__(236);
const st = __webpack_require__(237);
var Proposed;
(function (Proposed) {
    let CallHierarchyPrepareRequest;
    (function (CallHierarchyPrepareRequest) {
        CallHierarchyPrepareRequest.method = callHierarchy.CallHierarchyPrepareRequest.method;
        CallHierarchyPrepareRequest.type = callHierarchy.CallHierarchyPrepareRequest.type;
    })(CallHierarchyPrepareRequest = Proposed.CallHierarchyPrepareRequest || (Proposed.CallHierarchyPrepareRequest = {}));
    let CallHierarchyIncomingCallsRequest;
    (function (CallHierarchyIncomingCallsRequest) {
        CallHierarchyIncomingCallsRequest.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;
        CallHierarchyIncomingCallsRequest.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;
    })(CallHierarchyIncomingCallsRequest = Proposed.CallHierarchyIncomingCallsRequest || (Proposed.CallHierarchyIncomingCallsRequest = {}));
    let CallHierarchyOutgoingCallsRequest;
    (function (CallHierarchyOutgoingCallsRequest) {
        CallHierarchyOutgoingCallsRequest.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;
        CallHierarchyOutgoingCallsRequest.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;
    })(CallHierarchyOutgoingCallsRequest = Proposed.CallHierarchyOutgoingCallsRequest || (Proposed.CallHierarchyOutgoingCallsRequest = {}));
    Proposed.SemanticTokenTypes = st.SemanticTokenTypes;
    Proposed.SemanticTokenModifiers = st.SemanticTokenModifiers;
    Proposed.SemanticTokens = st.SemanticTokens;
    let SemanticTokensRequest;
    (function (SemanticTokensRequest) {
        SemanticTokensRequest.method = st.SemanticTokensRequest.method;
        SemanticTokensRequest.type = st.SemanticTokensRequest.type;
    })(SemanticTokensRequest = Proposed.SemanticTokensRequest || (Proposed.SemanticTokensRequest = {}));
    let SemanticTokensEditsRequest;
    (function (SemanticTokensEditsRequest) {
        SemanticTokensEditsRequest.method = st.SemanticTokensEditsRequest.method;
        SemanticTokensEditsRequest.type = st.SemanticTokensEditsRequest.type;
    })(SemanticTokensEditsRequest = Proposed.SemanticTokensEditsRequest || (Proposed.SemanticTokensEditsRequest = {}));
    let SemanticTokensRangeRequest;
    (function (SemanticTokensRangeRequest) {
        SemanticTokensRangeRequest.method = st.SemanticTokensRangeRequest.method;
        SemanticTokensRangeRequest.type = st.SemanticTokensRangeRequest.type;
    })(SemanticTokensRangeRequest = Proposed.SemanticTokensRangeRequest || (Proposed.SemanticTokensRangeRequest = {}));
})(Proposed = exports.Proposed || (exports.Proposed = {}));
function createProtocolConnection(reader, writer, logger, strategy) {
    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../typings/thenable.d.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const Is = __webpack_require__(213);
const messages_1 = __webpack_require__(214);
exports.RequestType = messages_1.RequestType;
exports.RequestType0 = messages_1.RequestType0;
exports.RequestType1 = messages_1.RequestType1;
exports.RequestType2 = messages_1.RequestType2;
exports.RequestType3 = messages_1.RequestType3;
exports.RequestType4 = messages_1.RequestType4;
exports.RequestType5 = messages_1.RequestType5;
exports.RequestType6 = messages_1.RequestType6;
exports.RequestType7 = messages_1.RequestType7;
exports.RequestType8 = messages_1.RequestType8;
exports.RequestType9 = messages_1.RequestType9;
exports.ResponseError = messages_1.ResponseError;
exports.ErrorCodes = messages_1.ErrorCodes;
exports.NotificationType = messages_1.NotificationType;
exports.NotificationType0 = messages_1.NotificationType0;
exports.NotificationType1 = messages_1.NotificationType1;
exports.NotificationType2 = messages_1.NotificationType2;
exports.NotificationType3 = messages_1.NotificationType3;
exports.NotificationType4 = messages_1.NotificationType4;
exports.NotificationType5 = messages_1.NotificationType5;
exports.NotificationType6 = messages_1.NotificationType6;
exports.NotificationType7 = messages_1.NotificationType7;
exports.NotificationType8 = messages_1.NotificationType8;
exports.NotificationType9 = messages_1.NotificationType9;
const messageReader_1 = __webpack_require__(215);
exports.MessageReader = messageReader_1.MessageReader;
exports.StreamMessageReader = messageReader_1.StreamMessageReader;
exports.IPCMessageReader = messageReader_1.IPCMessageReader;
exports.SocketMessageReader = messageReader_1.SocketMessageReader;
const messageWriter_1 = __webpack_require__(217);
exports.MessageWriter = messageWriter_1.MessageWriter;
exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
exports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
const events_1 = __webpack_require__(216);
exports.Disposable = events_1.Disposable;
exports.Event = events_1.Event;
exports.Emitter = events_1.Emitter;
const cancellation_1 = __webpack_require__(218);
exports.CancellationTokenSource = cancellation_1.CancellationTokenSource;
exports.CancellationToken = cancellation_1.CancellationToken;
const linkedMap_1 = __webpack_require__(219);
__export(__webpack_require__(220));
__export(__webpack_require__(222));
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    let notificationHandlers = Object.create(null);
    let progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let unhandledProgressEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        let message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    let callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                let key = createRequestQueueKey(message.params.id);
                let toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== void 0 || response.result !== void 0)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === void 0) {
                result = null;
            }
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            let cancellationSource = new cancellation_1.CancellationTokenSource();
            let tokenKey = String(requestMessage.id);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    handlerResult = requestHandler
                        ? requestHandler(cancellationSource.token)
                        : starRequestHandler(requestMessage.method, cancellationSource.token);
                }
                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
                    handlerResult = requestHandler
                        ? requestHandler(...requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
                }
                else {
                    handlerResult = requestHandler
                        ? requestHandler(requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                let promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            let key = String(responseMessage.id);
            let responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        let error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== void 0) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                let id = params.id;
                let source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            let element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
                }
                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
                }
                else {
                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        let responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            let key = String(responseMessage.id);
            let responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === void 0) {
            return null;
        }
        else {
            return param;
        }
    }
    function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = null;
                break;
            case 1:
                result = undefinedToNull(params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    let connection = {
        sendNotification: (type, ...params) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        messageParams = params[0];
                        break;
                    default:
                        messageParams = params;
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            let notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    notificationHandlers[type.method] = { type, handler };
                }
            }
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...params) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        // The cancellation token is optional so it can also be undefined.
                        if (cancellation_1.CancellationToken.is(params[0])) {
                            messageParams = null;
                            token = params[0];
                        }
                        else {
                            messageParams = undefinedToNull(params[0]);
                        }
                        break;
                    default:
                        const last = params.length - 1;
                        if (cancellation_1.CancellationToken.is(params[last])) {
                            token = params[last];
                            if (params.length === 2) {
                                messageParams = undefinedToNull(params[0]);
                            }
                            else {
                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));
                            }
                        }
                        else {
                            messageParams = params.map(value => undefinedToNull(value));
                        }
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
                let numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            let id = sequenceNumber++;
            let result = new Promise((resolve, reject) => {
                let requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            if (token) {
                token.onCancellationRequested(() => {
                    connection.sendNotification(CancelNotification.type, { id });
                });
            }
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starRequestHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    requestHandlers[type] = { type: undefined, handler };
                }
                else {
                    requestHandlers[type.method] = { type, handler };
                }
            }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            let error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
}
function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
}
function createMessageConnection(input, output, logger, strategy) {
    if (!logger) {
        logger = exports.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger, strategy);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const is = __webpack_require__(213);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    ErrorCodes.serverErrorStart = -32099;
    ErrorCodes.serverErrorEnd = -32000;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    // Defined by the protocol.
    ErrorCodes.RequestCancelled = -32800;
    ErrorCodes.ContentModified = -32801;
    // Defined by VSCode library.
    ErrorCodes.MessageWriteError = 1;
    ErrorCodes.MessageReadError = 2;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageType {
    constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
    }
    get method() {
        return this._method;
    }
    get numberOfParams() {
        return this._numberOfParams;
    }
}
exports.AbstractMessageType = AbstractMessageType;
/**
 * Classes to type request response pairs
 *
 * The type parameter RO will be removed in the next major version
 * of the JSON RPC library since it is a LSP concept and doesn't
 * belong here. For now it is tagged as default never.
 */
class RequestType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
/**
 * The type parameter RO will be removed in the next major version
 * of the JSON RPC library since it is a LSP concept and doesn't
 * belong here. For now it is tagged as default never.
 */
class NotificationType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(216);
const Is = __webpack_require__(213);
let DefaultSize = 8192;
let CR = Buffer.from('\r', 'ascii')[0];
let LF = Buffer.from('\n', 'ascii')[0];
let CRLF = '\r\n';
class MessageBuffer {
    constructor(encoding = 'utf8') {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
    }
    append(chunk) {
        var toAppend = chunk;
        if (typeof (chunk) === 'string') {
            var str = chunk;
            var bufferLen = Buffer.byteLength(str, this.encoding);
            toAppend = Buffer.allocUnsafe(bufferLen);
            toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
            toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        }
        else {
            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
            if (this.index === 0) {
                this.buffer = Buffer.allocUnsafe(newSize);
                toAppend.copy(this.buffer, 0, 0, toAppend.length);
            }
            else {
                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
            }
        }
        this.index += toAppend.length;
    }
    tryReadHeaders() {
        let result = undefined;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
            current++;
        }
        // No header / body separator found (e.g CRLFCRLF)
        if (current + 3 >= this.index) {
            return result;
        }
        result = Object.create(null);
        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);
        headers.forEach((header) => {
            let index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            let key = header.substr(0, index);
            let value = header.substr(index + 1).trim();
            result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    tryReadContent(length) {
        if (this.index < length) {
            return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    get numberOfBytes() {
        return this.index;
    }
}
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
class StreamMessageReader extends AbstractMessageReader {
    constructor(readable, encoding = 'utf8') {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 10000;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        this.readable.on('data', (data) => {
            this.onData(data);
        });
        this.readable.on('error', (error) => this.fireError(error));
        this.readable.on('close', () => this.fireClose());
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                let headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                let contentLength = headers['Content-Length'];
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                let length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
                // Take the encoding form the header. For compatibility
                // treat both utf-8 and utf8 as node utf8
            }
            var msg = this.buffer.tryReadContent(this.nextMessageLength);
            if (msg === null) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.messageToken++;
            var json = JSON.parse(msg);
            this.callback(json);
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class IPCMessageReader extends AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
    }
}
exports.IPCMessageReader = IPCMessageReader;
class SocketMessageReader extends StreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(socket, encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                let result;
                result = {
                    dispose: () => {
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(216);
const Is = __webpack_require__(213);
let ContentLength = 'Content-Length: ';
let CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
class StreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, encoding = 'utf8') {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on('error', (error) => this.fireError(error));
        this.writable.on('close', () => this.fireClose());
    }
    write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.writable.write(headers.join(''), 'ascii');
            // Now write the content. This can be written in any encoding
            this.writable.write(json, this.encoding);
            this.errorCount = 0;
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
class IPCMessageWriter extends AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        try {
            if (this.process.send) {
                this.sending = true;
                this.process.send(msg, undefined, undefined, (error) => {
                    this.sending = false;
                    if (error) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    else {
                        this.errorCount = 0;
                    }
                    if (this.queue.length > 0) {
                        this.doWriteMessage(this.queue.shift());
                    }
                });
            }
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageWriter extends AbstractMessageWriter {
    constructor(socket, encoding = 'utf8') {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on('error', (error) => this.fireError(error));
        this.socket.on('close', () => this.fireClose());
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.sending = true;
            this.socket.write(headers.join(''), 'ascii', (error) => {
                if (error) {
                    this.handleError(error, msg);
                }
                try {
                    // Now write the content. This can be written in any encoding
                    this.socket.write(json, this.encoding, (error) => {
                        this.sending = false;
                        if (error) {
                            this.handleError(error, msg);
                        }
                        else {
                            this.errorCount = 0;
                        }
                        if (this.queue.length > 0) {
                            this.doWriteMessage(this.queue.shift());
                        }
                    });
                }
                catch (error) {
                    this.handleError(error, msg);
                }
            });
        }
        catch (error) {
            this.handleError(error, msg);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
}
exports.SocketMessageWriter = SocketMessageWriter;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(216);
const Is = __webpack_require__(213);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.Last = 2;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
    }
    delete(key) {
        const item = this._map.get(key);
        if (!item) {
            return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.next;
        }
    }
    forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.previous;
        }
    }
    values() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }
    keys() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.key);
            current = current.next;
        }
        return result;
    }
    /* JSON RPC run on es5 which has no Symbol.iterator
    public keys(): IterableIterator<K> {
        let current = this._head;
        let iterator: IterableIterator<K> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<K> {
                if (current) {
                    let result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }

    public values(): IterableIterator<V> {
        let current = this._head;
        let iterator: IterableIterator<V> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<V> {
                if (current) {
                    let result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    */
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            this._head = item.next;
        }
        else if (item === this._tail) {
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
        }
    }
}
exports.LinkedMap = LinkedMap;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(82);
const os_1 = __webpack_require__(76);
const crypto_1 = __webpack_require__(221);
const net_1 = __webpack_require__(157);
const messageReader_1 = __webpack_require__(215);
const messageWriter_1 = __webpack_require__(217);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    else {
        // Mac/Unix: use socket file
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;


/***/ }),
/* 221 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __webpack_require__(157);
const messageReader_1 = __webpack_require__(215);
const messageWriter_1 = __webpack_require__(217);
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Location", function() { return Location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationLink", function() { return LocationLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorInformation", function() { return ColorInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPresentation", function() { return ColorPresentation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FoldingRangeKind", function() { return FoldingRangeKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FoldingRange", function() { return FoldingRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticRelatedInformation", function() { return DiagnosticRelatedInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticSeverity", function() { return DiagnosticSeverity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticTag", function() { return DiagnosticTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Diagnostic", function() { return Diagnostic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Command", function() { return Command; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEdit", function() { return TextEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentEdit", function() { return TextDocumentEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CreateFile", function() { return CreateFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenameFile", function() { return RenameFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeleteFile", function() { return DeleteFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorkspaceEdit", function() { return WorkspaceEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorkspaceChange", function() { return WorkspaceChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentIdentifier", function() { return TextDocumentIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VersionedTextDocumentIdentifier", function() { return VersionedTextDocumentIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentItem", function() { return TextDocumentItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkupKind", function() { return MarkupKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkupContent", function() { return MarkupContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItemKind", function() { return CompletionItemKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InsertTextFormat", function() { return InsertTextFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItemTag", function() { return CompletionItemTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItem", function() { return CompletionItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionList", function() { return CompletionList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkedString", function() { return MarkedString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hover", function() { return Hover; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParameterInformation", function() { return ParameterInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignatureInformation", function() { return SignatureInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentHighlightKind", function() { return DocumentHighlightKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentHighlight", function() { return DocumentHighlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolKind", function() { return SymbolKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolTag", function() { return SymbolTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolInformation", function() { return SymbolInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentSymbol", function() { return DocumentSymbol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeActionKind", function() { return CodeActionKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeActionContext", function() { return CodeActionContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeAction", function() { return CodeAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeLens", function() { return CodeLens; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormattingOptions", function() { return FormattingOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentLink", function() { return DocumentLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionRange", function() { return SelectionRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EOL", function() { return EOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocument", function() { return TextDocument; });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given liternal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.red)
            && Is.number(candidate.green)
            && Is.number(candidate.blue)
            && Is.number(candidate.alpha);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.startLine) && Is.number(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && VersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&
            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits) {
        this.edits = edits;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText) {
        this.edits.push(TextEdit.insert(position, newText));
    };
    TextEditChangeImpl.prototype.replace = function (range, newText) {
        this.edits.push(TextEdit.replace(range, newText));
    };
    TextEditChangeImpl.prototype.delete = function (range) {
        this.edits.push(TextEdit.del(range));
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            return this._workspaceEdit;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (VersionedTextDocumentIdentifier.is(key)) {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    documentChanges: []
                };
            }
            if (!this._workspaceEdit.documentChanges) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = key;
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    changes: Object.create(null)
                };
            }
            if (!this._workspaceEdit.changes) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
    };
    WorkspaceChange.prototype.deleteFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
    };
    WorkspaceChange.prototype.checkDocumentChanges = function () {
        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.15
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== void 0) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === void 0 || Is.string(candidate.detail)) &&
            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&
            (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== void 0 && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, commandOrEdit, kind) {
        var result = { title: title };
        if (Command.is(commandOrEdit)) {
            result.command = commandOrEdit;
        }
        else {
            result.edit = commandOrEdit;
        }
        if (kind !== void 0) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === void 0 || Is.string(candidate.kind)) &&
            (candidate.edit !== void 0 || candidate.command !== void 0) &&
            (candidate.command === void 0 || Command.is(candidate.command)) &&
            (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const Is = __webpack_require__(225);
const vscode_jsonrpc_1 = __webpack_require__(212);
const messages_1 = __webpack_require__(226);
const protocol_implementation_1 = __webpack_require__(227);
exports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
const protocol_typeDefinition_1 = __webpack_require__(228);
exports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
const protocol_workspaceFolders_1 = __webpack_require__(229);
exports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
exports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
const protocol_configuration_1 = __webpack_require__(230);
exports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
const protocol_colorProvider_1 = __webpack_require__(231);
exports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
exports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
const protocol_foldingRange_1 = __webpack_require__(232);
exports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
const protocol_declaration_1 = __webpack_require__(233);
exports.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
const protocol_selectionRange_1 = __webpack_require__(234);
exports.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;
const protocol_progress_1 = __webpack_require__(235);
exports.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;
exports.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;
exports.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling startegy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The intialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
    /** @deprecated Use CompletionRequest.type */
    CompletionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
    /** @deprecated Use DefinitionRequest.type */
    DefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
    /** @deprecated Use ReferencesRequest.type */
    ReferencesRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
    /** @deprecated Use DocumentHighlightRequest.type */
    DocumentHighlightRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
    /** @deprecated Use DocumentSymbolRequest.type */
    DocumentSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
    /** @deprecated Use CodeActionRequest.type */
    CodeActionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
    /** @deprecated Use WorkspaceSymbolRequest.type */
    WorkspaceSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.type = new messages_1.ProtocolRequestType('textDocument/codeLens');
    /** @deprecated Use CodeLensRequest.type */
    CodeLensRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType('codeLens/resolve');
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
    /** @deprecated Use DocumentLinkRequest.type */
    DocumentLinkRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType('documentLink/resolve');
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
const messages_1 = __webpack_require__(226);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
    /** @deprecated Use ImplementationRequest.type */
    ImplementationRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
const messages_1 = __webpack_require__(226);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
    /** @deprecated Use TypeDefinitionRequest.type */
    TypeDefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(226);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(226);
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
const messages_1 = __webpack_require__(226);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
    /** @deprecated Use DocumentColorRequest.type */
    DocumentColorRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
const messages_1 = __webpack_require__(226);
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
    /** @deprecated Use FoldingRangeRequest.type */
    FoldingRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
const messages_1 = __webpack_require__(226);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
    /** @deprecated Use DeclarationRequest.type */
    DeclarationRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
const messages_1 = __webpack_require__(226);
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
    /** @deprecated  Use SelectionRangeRequest.type */
    SelectionRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(212);
const messages_1 = __webpack_require__(226);
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(226);
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(226);
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0 - Proposed state
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    SemanticTokenTypes["namespace"] = "namespace";
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["member"] = "member";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["label"] = "label";
})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0 - Proposed state
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["reference"] = "reference";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["volatile"] = "volatile";
    SemanticTokenModifiers["readonly"] = "readonly";
})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensEditsRequest;
(function (SemanticTokensEditsRequest) {
    SemanticTokensEditsRequest.method = 'textDocument/semanticTokens/edits';
    SemanticTokensEditsRequest.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest.method);
})(SemanticTokensEditsRequest = exports.SemanticTokensEditsRequest || (exports.SemanticTokensEditsRequest = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const child_process_1 = __webpack_require__(239);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const isuri_1 = tslib_1.__importDefault(__webpack_require__(241));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const which_1 = tslib_1.__importDefault(__webpack_require__(244));
const platform = tslib_1.__importStar(__webpack_require__(248));
exports.platform = platform;
const logger = __webpack_require__(64)('util-index');
exports.CONFIG_FILE_NAME = 'coc-settings.json';
function escapeSingleQuote(str) {
    return str.replace(/'/g, "''");
}
exports.escapeSingleQuote = escapeSingleQuote;
function wait(ms) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
}
exports.wait = wait;
function getUri(fullpath, id, buftype, isCygwin) {
    if (!fullpath)
        return `untitled:${id}`;
    if (platform.isWindows && !isCygwin)
        fullpath = path_1.default.win32.normalize(fullpath);
    if (path_1.default.isAbsolute(fullpath))
        return vscode_uri_1.URI.file(fullpath).toString();
    if (isuri_1.default.isValid(fullpath))
        return vscode_uri_1.URI.parse(fullpath).toString();
    if (buftype != '')
        return `${buftype}:${id}`;
    return `unknown:${id}`;
}
exports.getUri = getUri;
function disposeAll(disposables) {
    while (disposables.length) {
        const item = disposables.pop();
        if (item) {
            item.dispose();
        }
    }
}
exports.disposeAll = disposeAll;
function executable(command) {
    try {
        which_1.default.sync(command);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.executable = executable;
function runCommand(cmd, opts = {}, timeout) {
    if (!platform.isWindows) {
        opts.shell = opts.shell || process.env.SHELL;
    }
    opts.maxBuffer = 500 * 1024;
    return new Promise((resolve, reject) => {
        let timer;
        if (timeout) {
            timer = setTimeout(() => {
                reject(new Error(`timeout after ${timeout}s`));
            }, timeout * 1000);
        }
        child_process_1.exec(cmd, opts, (err, stdout, stderr) => {
            if (timer)
                clearTimeout(timer);
            if (err) {
                reject(new Error(`exited with ${err.code}\n${err}\n${stderr}`));
                return;
            }
            resolve(stdout);
        });
    });
}
exports.runCommand = runCommand;
function watchFile(filepath, onChange) {
    let callback = debounce_1.default(onChange, 100);
    try {
        let watcher = fs_1.default.watch(filepath, {
            persistent: true,
            recursive: false,
            encoding: 'utf8'
        }, () => {
            callback();
        });
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            callback.clear();
            watcher.close();
        });
    }
    catch (e) {
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            callback.clear();
        });
    }
}
exports.watchFile = watchFile;
function isRunning(pid) {
    try {
        let res = process.kill(pid, 0);
        return res == true;
    }
    catch (e) {
        return e.code === 'EPERM';
    }
}
exports.isRunning = isRunning;
function getKeymapModifier(mode) {
    if (mode == 'n' || mode == 'o' || mode == 'x' || mode == 'v')
        return '<C-U>';
    if (mode == 'i')
        return '<C-o>';
    if (mode == 's')
        return '<Esc>';
    return '';
}
exports.getKeymapModifier = getKeymapModifier;
// consider textDocument without version to be valid
function isDocumentEdit(edit) {
    if (edit == null)
        return false;
    if (!vscode_languageserver_protocol_1.TextDocumentIdentifier.is(edit.textDocument))
        return false;
    if (!Array.isArray(edit.edits))
        return false;
    return true;
}
exports.isDocumentEdit = isDocumentEdit;
function concurrent(arr, fn, limit = 3) {
    if (arr.length == 0)
        return Promise.resolve();
    let finished = 0;
    let total = arr.length;
    let remain = arr.slice();
    return new Promise(resolve => {
        let run = (val) => {
            let cb = () => {
                finished = finished + 1;
                if (finished == total) {
                    resolve();
                }
                else if (remain.length) {
                    let next = remain.shift();
                    run(next);
                }
            };
            fn(val).then(cb, cb);
        };
        for (let i = 0; i < Math.min(limit, remain.length); i++) {
            let val = remain.shift();
            run(val);
        }
    });
}
exports.concurrent = concurrent;
//# sourceMappingURL=index.js.map

/***/ }),
/* 239 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 240 */
/***/ (function(module, exports) {

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */
function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  };

  var debounced = function(){
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };

  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
};

// Adds compatibility for ES modules
debounce.debounce = debounce;

module.exports = debounce;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var rfc3986 = __webpack_require__(242);

// See: https://github.com/hapijs/hoek/blob/f62961d3d07aca68ab11480893e6e80a421914b4/lib/index.js#L783-L787
function escapeRegex(string) {
    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
}

var internals = {
    Uri: {
        createUriRegex: function (options) {
            options = options || {};

            if (typeof options !== 'object' || Array.isArray(options)) {
                throw new Error('options must be an object');
            }

            var customScheme = '';

            // If we were passed a scheme, use it instead of the generic one
            if (options.scheme) {
                if (!Array.isArray(options.scheme)) {
                    options.scheme = [options.scheme];
                }

                if (options.scheme.length <= 0) {
                    throw new Error('scheme must have at least 1 scheme specified');
                }

                for (var i = 0; i < options.scheme.length; ++i) {
                    var currentScheme = options.scheme[i];

                    if (!(currentScheme instanceof RegExp || typeof currentScheme === 'string')) {
                        throw new Error('scheme must only contain Regular Expressions or Strings');
                    }

                    // Add OR separators if a value already exists
                    customScheme = customScheme + (customScheme ? '|' : '');

                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
                    if (currentScheme instanceof RegExp) {
                        customScheme = customScheme + currentScheme.source;
                    } else {
                        if (!/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(currentScheme)) {
                            throw new Error('scheme at position ' + i + ' must be a valid scheme');
                        }
                        customScheme = customScheme + escapeRegex(currentScheme);
                    }
                }

            }

            // Have to put this in a non-capturing group to handle the OR statements
            var scheme = '(?:' + (customScheme || rfc3986.scheme) + ')';

            /**
             * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
             *
             * OR
             *
             * relative-ref = relative-part [ "?" query ] [ "#" fragment ]
             */
            return new RegExp('^(?:' + scheme + ':' + rfc3986.hierPart + ')(?:\\?' + rfc3986.query + ')?(?:#' + rfc3986.fragment + ')?$');
        },
        uriRegex: new RegExp(rfc3986.uri)
    }
};

internals.Uri.isValid = function (val) {
    return internals.Uri.uriRegex.test(val);
};

module.exports = {
    createUriRegex: internals.Uri.createUriRegex,

    uriRegex: internals.Uri.uriRegex,
    isValid: internals.Uri.isValid
};

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Load modules

// Delcare internals

var internals = {
    rfc3986: {}
};

internals.generate = function () {

    /**
     * elements separated by forward slash ("/") are alternatives.
     */
    var or = '|';

    /**
     * DIGIT = %x30-39 ; 0-9
     */
    var digit = '0-9';
    var digitOnly = '[' + digit + ']';

    /**
     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z
     */
    var alpha = 'a-zA-Z';
    var alphaOnly = '[' + alpha + ']';

    /**
     * cidr       = DIGIT                ; 0-9
     *            / %x31-32 DIGIT         ; 10-29
     *            / "3" %x30-32           ; 30-32
     */
    internals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';

    /**
     * HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
     */
    var hexDigit = digit + 'A-Fa-f';
    var hexDigitOnly = '[' + hexDigit + ']';

    /**
     * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
     */
    var unreserved = alpha + digit + '-\\._~';

    /**
     * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
     */
    var subDelims = '!\\$&\'\\(\\)\\*\\+,;=';

    /**
     * pct-encoded = "%" HEXDIG HEXDIG
     */
    var pctEncoded = '%' + hexDigit;

    /**
     * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
     */
    var pchar = unreserved + pctEncoded + subDelims + ':@';
    var pcharOnly = '[' + pchar + ']';

    /**
     * Rule to support zero-padded addresses.
     */
    var zeroPad = '0?';

    /**
     * dec-octet   = DIGIT                 ; 0-9
     *            / %x31-39 DIGIT         ; 10-99
     *            / "1" 2DIGIT            ; 100-199
     *            / "2" %x30-34 DIGIT     ; 200-249
     *            / "25" %x30-35          ; 250-255
     */
    var decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';

    /**
     * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
     */
    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\.){3}' + decOctect;

    /**
     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
     * ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
     * IPv6address =                            6( h16 ":" ) ls32
     *             /                       "::" 5( h16 ":" ) ls32
     *             / [               h16 ] "::" 4( h16 ":" ) ls32
     *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
     *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
     *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
     *             / [ *4( h16 ":" ) h16 ] "::"              ls32
     *             / [ *5( h16 ":" ) h16 ] "::"              h16
     *             / [ *6( h16 ":" ) h16 ] "::"
     */
    var h16 = hexDigitOnly + '{1,4}';
    var ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';
    var IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    var IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    var IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
    var IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
    var IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
    var IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
    var IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
    var IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
    var IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';
    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';

    /**
     * IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
     */
    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';

    /**
     * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
     */
    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\.]*';

    /**
     * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
     */
    var userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';

    /**
     * IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
     */
    internals.rfc3986.IPLiteral = '\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\]';

    /**
     * reg-name = *( unreserved / pct-encoded / sub-delims )
     */
    var regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';

    /**
     * host = IP-literal / IPv4address / reg-name
     */
    var host = '(?:' + internals.rfc3986.IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';

    /**
     * port = *DIGIT
     */
    var port = digitOnly + '*';

    /**
     * authority   = [ userinfo "@" ] host [ ":" port ]
     */
    var authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';

    /**
     * segment       = *pchar
     * segment-nz    = 1*pchar
     * path          = path-abempty    ; begins with "/" or is empty
     *               / path-absolute   ; begins with "/" but not "//"
     *               / path-noscheme   ; begins with a non-colon segment
     *               / path-rootless   ; begins with a segment
     *               / path-empty      ; zero characters
     * path-abempty  = *( "/" segment )
     * path-absolute = "/" [ segment-nz *( "/" segment ) ]
     * path-rootless = segment-nz *( "/" segment )
     */
    var segment = pcharOnly + '*';
    var segmentNz = pcharOnly + '+';
    var pathAbEmpty = '(?:\\/' + segment + ')*';
    var pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    var pathRootless = segmentNz + pathAbEmpty;

    /**
     * hier-part = "//" authority path
     */
    internals.rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathRootless + ')';

    /**
     * query = *( pchar / "/" / "?" )
     */
    internals.rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

    /**
     * fragment = *( pchar / "/" / "?" )
     */
    internals.rfc3986.fragment = '[' + pchar + '\\/\\?]*';

    /**
     * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
     *
     * OR
     *
     * relative-ref = relative-part [ "?" query ] [ "#" fragment ]
     */
    internals.rfc3986.uri = '^(?:' + internals.rfc3986.scheme + ':' + internals.rfc3986.hierPart + ')(?:\\?' + internals.rfc3986.query + ')?' + '(?:#' + internals.rfc3986.fragment + ')?$';
};

internals.generate();

module.exports = internals.rfc3986;

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URI", function() { return URI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uriToFsPath", function() { return uriToFsPath; });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _a;
var isWindows;
if (typeof process === 'object') {
    isWindows = process.platform === 'win32';
}
else if (typeof navigator === 'object') {
    var userAgent = navigator.userAgent;
    isWindows = userAgent.indexOf('Windows') >= 0;
}
function isHighSurrogate(charCode) {
    return (0xD800 <= charCode && charCode <= 0xDBFF);
}
function isLowSurrogate(charCode) {
    return (0xDC00 <= charCode && charCode <= 0xDFFF);
}
function isLowerAsciiHex(code) {
    return code >= 97 /* a */ && code <= 102 /* f */;
}
function isLowerAsciiLetter(code) {
    return code >= 97 /* a */ && code <= 122 /* z */;
}
function isUpperAsciiLetter(code) {
    return code >= 65 /* A */ && code <= 90 /* Z */;
}
function isAsciiLetter(code) {
    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
}
//#endregion
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
    // scheme, must be set
    if (!ret.scheme && _strict) {
        throw new Error("[UriError]: Scheme is missing: {scheme: \"\", authority: \"" + ret.authority + "\", path: \"" + ret.path + "\", query: \"" + ret.query + "\", fragment: \"" + ret.fragment + "\"}");
    }
    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
    // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
        throw new Error('[UriError]: Scheme contains illegal characters.');
    }
    // path, http://tools.ietf.org/html/rfc3986#section-3.3
    // If a URI contains an authority component, then the path component
    // must either be empty or begin with a slash ("/") character.  If a URI
    // does not contain an authority component, then the path cannot begin
    // with two slash characters ("//").
    if (ret.path) {
        if (ret.authority) {
            if (!_singleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
        }
        else {
            if (_doubleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        }
    }
}
// for a while we allowed uris *without* schemes and this is the migration
// for them, e.g. an uri without scheme and without strict-mode warns and falls
// back to the file-scheme. that should cause the least carnage and still be a
// clear warning
function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
        return 'file';
    }
    return scheme;
}
// implements a bit of https://tools.ietf.org/html/rfc3986#section-5
function _referenceResolution(scheme, path) {
    // the slash-character is our 'default base' as we don't
    // support constructing URIs relative to other URIs. This
    // also means that we alter and potentially break paths.
    // see https://tools.ietf.org/html/rfc3986#section-5.1.4
    switch (scheme) {
        case 'https':
        case 'http':
        case 'file':
            if (!path) {
                path = _slash;
            }
            else if (path[0] !== _slash) {
                path = _slash + path;
            }
            break;
    }
    return path;
}
var _empty = '';
var _slash = '/';
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
var URI = /** @class */ (function () {
    /**
     * @internal
     */
    function URI(schemeOrData, authority, path, query, fragment, _strict) {
        if (_strict === void 0) { _strict = false; }
        if (typeof schemeOrData === 'object') {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
            // no validation because it's this URI
            // that creates uri components.
            // _validateUri(this);
        }
        else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
        }
    }
    URI.isUri = function (thing) {
        if (thing instanceof URI) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.authority === 'string'
            && typeof thing.fragment === 'string'
            && typeof thing.path === 'string'
            && typeof thing.query === 'string'
            && typeof thing.scheme === 'string'
            && typeof thing.fsPath === 'function'
            && typeof thing.with === 'function'
            && typeof thing.toString === 'function';
    };
    Object.defineProperty(URI.prototype, "fsPath", {
        // ---- filesystem path -----------------------
        /**
         * Returns a string representing the corresponding file system path of this URI.
         * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
         * platform specific path separator.
         *
         * * Will *not* validate the path for invalid characters and semantics.
         * * Will *not* look at the scheme of this URI.
         * * The result shall *not* be used for display purposes but for accessing a file on disk.
         *
         *
         * The *difference* to `URI#path` is the use of the platform specific separator and the handling
         * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
         *
         * ```ts
            const u = URI.parse('file://server/c$/folder/file.txt')
            u.authority === 'server'
            u.path === '/shares/c$/file.txt'
            u.fsPath === '\\server\c$\folder\file.txt'
        ```
         *
         * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
         * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
         * with URIs that represent files on disk (`file` scheme).
         */
        get: function () {
            // if (this.scheme !== 'file') {
            // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
            // }
            return uriToFsPath(this, false);
        },
        enumerable: true,
        configurable: true
    });
    // ---- modify to new -------------------------
    URI.prototype.with = function (change) {
        if (!change) {
            return this;
        }
        var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
        if (scheme === undefined) {
            scheme = this.scheme;
        }
        else if (scheme === null) {
            scheme = _empty;
        }
        if (authority === undefined) {
            authority = this.authority;
        }
        else if (authority === null) {
            authority = _empty;
        }
        if (path === undefined) {
            path = this.path;
        }
        else if (path === null) {
            path = _empty;
        }
        if (query === undefined) {
            query = this.query;
        }
        else if (query === null) {
            query = _empty;
        }
        if (fragment === undefined) {
            fragment = this.fragment;
        }
        else if (fragment === null) {
            fragment = _empty;
        }
        if (scheme === this.scheme
            && authority === this.authority
            && path === this.path
            && query === this.query
            && fragment === this.fragment) {
            return this;
        }
        return new _URI(scheme, authority, path, query, fragment);
    };
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    URI.parse = function (value, _strict) {
        if (_strict === void 0) { _strict = false; }
        var match = _regexp.exec(value);
        if (!match) {
            return new _URI(_empty, _empty, _empty, _empty, _empty);
        }
        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    };
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    URI.file = function (path) {
        var authority = _empty;
        // normalize to fwd-slashes on windows,
        // on other systems bwd-slashes are valid
        // filename character, eg /f\oo/ba\r.txt
        if (isWindows) {
            path = path.replace(/\\/g, _slash);
        }
        // check for authority as used in UNC shares
        // or use the path as given
        if (path[0] === _slash && path[1] === _slash) {
            var idx = path.indexOf(_slash, 2);
            if (idx === -1) {
                authority = path.substring(2);
                path = _slash;
            }
            else {
                authority = path.substring(2, idx);
                path = path.substring(idx) || _slash;
            }
        }
        return new _URI('file', authority, path, _empty, _empty);
    };
    URI.from = function (components) {
        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
    };
    // /**
    //  * Join a URI path with path fragments and normalizes the resulting path.
    //  *
    //  * @param uri The input URI.
    //  * @param pathFragment The path fragment to add to the URI path.
    //  * @returns The resulting URI.
    //  */
    // static joinPath(uri: URI, ...pathFragment: string[]): URI {
    // 	if (!uri.path) {
    // 		throw new Error(`[UriError]: cannot call joinPaths on URI without path`);
    // 	}
    // 	let newPath: string;
    // 	if (isWindows && uri.scheme === 'file') {
    // 		newPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
    // 	} else {
    // 		newPath = paths.posix.join(uri.path, ...pathFragment);
    // 	}
    // 	return uri.with({ path: newPath });
    // }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    URI.prototype.toString = function (skipEncoding) {
        if (skipEncoding === void 0) { skipEncoding = false; }
        return _asFormatted(this, skipEncoding);
    };
    URI.prototype.toJSON = function () {
        return this;
    };
    URI.revive = function (data) {
        if (!data) {
            return data;
        }
        else if (data instanceof URI) {
            return data;
        }
        else {
            var result = new _URI(data);
            result._formatted = data.external;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
            return result;
        }
    };
    return URI;
}());

var _pathSepMarker = isWindows ? 1 : undefined;
// eslint-disable-next-line @typescript-eslint/class-name-casing
var _URI = /** @class */ (function (_super) {
    __extends(_URI, _super);
    function _URI() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._formatted = null;
        _this._fsPath = null;
        return _this;
    }
    Object.defineProperty(_URI.prototype, "fsPath", {
        get: function () {
            if (!this._fsPath) {
                this._fsPath = uriToFsPath(this, false);
            }
            return this._fsPath;
        },
        enumerable: true,
        configurable: true
    });
    _URI.prototype.toString = function (skipEncoding) {
        if (skipEncoding === void 0) { skipEncoding = false; }
        if (!skipEncoding) {
            if (!this._formatted) {
                this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
        }
        else {
            // we don't cache that
            return _asFormatted(this, true);
        }
    };
    _URI.prototype.toJSON = function () {
        var res = {
            $mid: 1
        };
        // cached state
        if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
        }
        if (this._formatted) {
            res.external = this._formatted;
        }
        // uri components
        if (this.path) {
            res.path = this.path;
        }
        if (this.scheme) {
            res.scheme = this.scheme;
        }
        if (this.authority) {
            res.authority = this.authority;
        }
        if (this.query) {
            res.query = this.query;
        }
        if (this.fragment) {
            res.fragment = this.fragment;
        }
        return res;
    };
    return _URI;
}(URI));
// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
var encodeTable = (_a = {},
    _a[58 /* Colon */] = '%3A',
    _a[47 /* Slash */] = '%2F',
    _a[63 /* QuestionMark */] = '%3F',
    _a[35 /* Hash */] = '%23',
    _a[91 /* OpenSquareBracket */] = '%5B',
    _a[93 /* CloseSquareBracket */] = '%5D',
    _a[64 /* AtSign */] = '%40',
    _a[33 /* ExclamationMark */] = '%21',
    _a[36 /* DollarSign */] = '%24',
    _a[38 /* Ampersand */] = '%26',
    _a[39 /* SingleQuote */] = '%27',
    _a[40 /* OpenParen */] = '%28',
    _a[41 /* CloseParen */] = '%29',
    _a[42 /* Asterisk */] = '%2A',
    _a[43 /* Plus */] = '%2B',
    _a[44 /* Comma */] = '%2C',
    _a[59 /* Semicolon */] = '%3B',
    _a[61 /* Equals */] = '%3D',
    _a[32 /* Space */] = '%20',
    _a);
function encodeURIComponentFast(uriComponent, allowSlash) {
    var res = undefined;
    var nativeEncodePos = -1;
    for (var pos = 0; pos < uriComponent.length; pos++) {
        var code = uriComponent.charCodeAt(pos);
        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
        if ((code >= 97 /* a */ && code <= 122 /* z */)
            || (code >= 65 /* A */ && code <= 90 /* Z */)
            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
            || code === 45 /* Dash */
            || code === 46 /* Period */
            || code === 95 /* Underline */
            || code === 126 /* Tilde */
            || (allowSlash && code === 47 /* Slash */)) {
            // check if we are delaying native encode
            if (nativeEncodePos !== -1) {
                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                nativeEncodePos = -1;
            }
            // check if we write into a new string (by default we try to return the param)
            if (res !== undefined) {
                res += uriComponent.charAt(pos);
            }
        }
        else {
            // encoding needed, we need to allocate a new string
            if (res === undefined) {
                res = uriComponent.substr(0, pos);
            }
            // check with default table first
            var escaped = encodeTable[code];
            if (escaped !== undefined) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // append escaped variant to result
                res += escaped;
            }
            else if (nativeEncodePos === -1) {
                // use native encode only when needed
                nativeEncodePos = pos;
            }
        }
    }
    if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== undefined ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
    var res = undefined;
    for (var pos = 0; pos < path.length; pos++) {
        var code = path.charCodeAt(pos);
        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
            if (res === undefined) {
                res = path.substr(0, pos);
            }
            res += encodeTable[code];
        }
        else {
            if (res !== undefined) {
                res += path[pos];
            }
        }
    }
    return res !== undefined ? res : path;
}
/**
 * Compute `fsPath` for the given uri
 */
function uriToFsPath(uri, keepDriveLetterCasing) {
    var value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
        // unc path: file://shares/c$/far/boo
        value = "//" + uri.authority + uri.path;
    }
    else if (uri.path.charCodeAt(0) === 47 /* Slash */
        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
        && uri.path.charCodeAt(2) === 58 /* Colon */) {
        if (!keepDriveLetterCasing) {
            // windows drive letter: file:///c:/far/boo
            value = uri.path[1].toLowerCase() + uri.path.substr(2);
        }
        else {
            value = uri.path.substr(1);
        }
    }
    else {
        // other path
        value = uri.path;
    }
    if (isWindows) {
        value = value.replace(/\//g, '\\');
    }
    return value;
}
/**
 * Create the external version of a uri
 */
function _asFormatted(uri, skipEncoding) {
    var encoder = !skipEncoding
        ? encodeURIComponentFast
        : encodeURIComponentMinimal;
    var res = '';
    var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
    if (scheme) {
        res += scheme;
        res += ':';
    }
    if (authority || scheme === 'file') {
        res += _slash;
        res += _slash;
    }
    if (authority) {
        var idx = authority.indexOf('@');
        if (idx !== -1) {
            // <user>@<auth>
            var userinfo = authority.substr(0, idx);
            authority = authority.substr(idx + 1);
            idx = userinfo.indexOf(':');
            if (idx === -1) {
                res += encoder(userinfo, false);
            }
            else {
                // <user>:<pass>@<auth>
                res += encoder(userinfo.substr(0, idx), false);
                res += ':';
                res += encoder(userinfo.substr(idx + 1), false);
            }
            res += '@';
        }
        authority = authority.toLowerCase();
        idx = authority.indexOf(':');
        if (idx === -1) {
            res += encoder(authority, false);
        }
        else {
            // <auth>:<port>
            res += encoder(authority.substr(0, idx), false);
            res += authority.substr(idx);
        }
    }
    if (path) {
        // lower-case windows drive letters in /C:/fff or C:/fff
        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
            var code = path.charCodeAt(1);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = "/" + String.fromCharCode(code + 32) + ":" + path.substr(3); // "/c:".length === 3
            }
        }
        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
            var code = path.charCodeAt(0);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = String.fromCharCode(code + 32) + ":" + path.substr(2); // "/c:".length === 3
            }
        }
        // encode the rest of the path
        res += encoder(path, true);
    }
    if (query) {
        res += '?';
        res += encoder(query, false);
    }
    if (fragment) {
        res += '#';
        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
    }
    return res;
}
// --- decode
function decodeURIComponentGraceful(str) {
    try {
        return decodeURIComponent(str);
    }
    catch (_a) {
        if (str.length > 3) {
            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
        }
        else {
            return str;
        }
    }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
        return str;
    }
    return str.replace(_rEncodedAsHex, function (match) { return decodeURIComponentGraceful(match); });
}


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

const path = __webpack_require__(82)
const COLON = isWindows ? ';' : ':'
const isexe = __webpack_require__(245)

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    )
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : ''
  const pathExt = isWindows ? pathExtExe.split(colon) : ['']

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
}

const which = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }
  if (!opt)
    opt = {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    resolve(subStep(p, i, 0))
  })

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii]
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext)
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    })
  })

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
}

const whichSync = (cmd, opt) => {
  opt = opt || {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j]
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}

module.exports = which
which.sync = whichSync


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(66)
var core
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = __webpack_require__(246)
} else {
  core = __webpack_require__(247)
}

module.exports = isexe
isexe.sync = sync

function isexe (path, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er)
        } else {
          resolve(is)
        }
      })
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null
        is = false
      }
    }
    cb(er, is)
  })
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(66)

function checkPathExt (path, options) {
  var pathext = options.pathExt !== undefined ?
    options.pathExt : process.env.PATHEXT

  if (!pathext) {
    return true
  }

  pathext = pathext.split(';')
  if (pathext.indexOf('') !== -1) {
    return true
  }
  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase()
    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true
    }
  }
  return false
}

function checkStat (stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false
  }
  return checkPathExt(path, options)
}

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), path, options)
}


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(66)

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), options)
}

function checkStat (stat, options) {
  return stat.isFile() && checkMode(stat, options)
}

function checkMode (stat, options) {
  var mod = stat.mode
  var uid = stat.uid
  var gid = stat.gid

  var myUid = options.uid !== undefined ?
    options.uid : process.getuid && process.getuid()
  var myGid = options.gid !== undefined ?
    options.gid : process.getgid && process.getgid()

  var u = parseInt('100', 8)
  var g = parseInt('010', 8)
  var o = parseInt('001', 8)
  var ug = u | g

  var ret = (mod & o) ||
    (mod & g) && gid === myGid ||
    (mod & u) && uid === myUid ||
    (mod & ug) && myUid === 0

  return ret
}


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
let _isWindows = false;
let _isMacintosh = false;
let _isLinux = false;
let _isNative = false;
let _isWeb = false;
exports.language = 'en';
// OS detection
if (typeof process === 'object' &&
    typeof process.nextTick === 'function' &&
    typeof process.platform === 'string') {
    _isWindows = process.platform === 'win32';
    _isMacintosh = process.platform === 'darwin';
    _isLinux = process.platform === 'linux';
    _isNative = true;
}
var Platform;
(function (Platform) {
    Platform[Platform["Web"] = 0] = "Web";
    Platform[Platform["Mac"] = 1] = "Mac";
    Platform[Platform["Linux"] = 2] = "Linux";
    Platform[Platform["Windows"] = 3] = "Windows";
})(Platform = exports.Platform || (exports.Platform = {}));
let _platform = Platform.Web;
if (_isNative) {
    if (_isMacintosh) {
        _platform = Platform.Mac;
    }
    else if (_isWindows) {
        _platform = Platform.Windows;
    }
    else if (_isLinux) {
        _platform = Platform.Linux;
    }
}
exports.isWindows = _isWindows;
exports.isMacintosh = _isMacintosh;
exports.isLinux = _isLinux;
exports.isNative = _isNative;
exports.isWeb = _isWeb;
exports.platform = _platform;
const _globals = typeof self === 'object'
    ? self
    : typeof global === 'object'
        ? global
        : {};
exports.globals = _globals;
exports.OS = _isMacintosh
    ? 2 /* Macintosh */
    : _isWindows
        ? 1 /* Windows */
        : 3 /* Linux */;
//# sourceMappingURL=platform.js.map

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const Is = tslib_1.__importStar(__webpack_require__(250));
function deepClone(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    if (obj instanceof RegExp) {
        // See https://github.com/Microsoft/TypeScript/issues/10990
        return obj;
    }
    const result = Array.isArray(obj) ? [] : {};
    Object.keys(obj).forEach(key => {
        if (obj[key] && typeof obj[key] === 'object') {
            result[key] = deepClone(obj[key]);
        }
        else {
            result[key] = obj[key];
        }
    });
    return result;
}
exports.deepClone = deepClone;
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function deepFreeze(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    const stack = [obj];
    while (stack.length > 0) {
        let obj = stack.shift();
        Object.freeze(obj);
        for (const key in obj) {
            if (_hasOwnProperty.call(obj, key)) {
                let prop = obj[key];
                if (typeof prop === 'object' && !Object.isFrozen(prop)) {
                    stack.push(prop);
                }
            }
        }
    }
    return obj;
}
exports.deepFreeze = deepFreeze;
/**
 * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
 * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
 */
function mixin(destination, source, overwrite = true) {
    if (!Is.objectLiteral(destination)) {
        return source;
    }
    if (Is.objectLiteral(source)) {
        Object.keys(source).forEach(key => {
            if (key in destination) {
                if (overwrite) {
                    if (Is.objectLiteral(destination[key]) && Is.objectLiteral(source[key])) {
                        mixin(destination[key], source[key], overwrite);
                    }
                    else {
                        destination[key] = source[key];
                    }
                }
            }
            else {
                destination[key] = source[key];
            }
        });
    }
    return destination;
}
exports.mixin = mixin;
function equals(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null ||
        one === undefined ||
        other === null ||
        other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if (Array.isArray(one) !== Array.isArray(other)) {
        return false;
    }
    let i;
    let key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!equals(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        const oneKeys = [];
        for (key in one) {
            oneKeys.push(key);
        }
        oneKeys.sort();
        const otherKeys = [];
        for (key in other) {
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!equals(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
exports.equals = equals;
//# sourceMappingURL=object.js.map

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable id-blacklist */
const hasOwnProperty = Object.prototype.hasOwnProperty;
function boolean(value) {
    return typeof value === 'boolean';
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string';
}
exports.string = string;
function number(value) {
    return typeof value === 'number';
}
exports.number = number;
function array(array) {
    return Array.isArray(array);
}
exports.array = array;
function func(value) {
    return typeof value == 'function';
}
exports.func = func;
function objectLiteral(obj) {
    return (obj != null &&
        typeof obj === 'object' &&
        !Array.isArray(obj) &&
        !(obj instanceof RegExp) &&
        !(obj instanceof Date));
}
exports.objectLiteral = objectLiteral;
function emptyObject(obj) {
    if (!objectLiteral(obj)) {
        return false;
    }
    for (let key in obj) {
        if (hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}
exports.emptyObject = emptyObject;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
//# sourceMappingURL=is.js.map

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const events_1 = __webpack_require__(198);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_languageserver_types_1 = __webpack_require__(223);
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const completion_1 = tslib_1.__importDefault(__webpack_require__(331));
const cursors_1 = tslib_1.__importDefault(__webpack_require__(613));
const manager_1 = tslib_1.__importDefault(__webpack_require__(253));
const extensions_1 = tslib_1.__importDefault(__webpack_require__(333));
const handler_1 = tslib_1.__importDefault(__webpack_require__(615));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const manager_2 = tslib_1.__importDefault(__webpack_require__(541));
const services_1 = tslib_1.__importDefault(__webpack_require__(525));
const manager_3 = tslib_1.__importDefault(__webpack_require__(256));
const sources_1 = tslib_1.__importDefault(__webpack_require__(332));
const types_1 = __webpack_require__(295);
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const vscode_uri_1 = __webpack_require__(243);
const logger = __webpack_require__(64)('plugin');
class Plugin extends events_1.EventEmitter {
    constructor(nvim) {
        super();
        this.nvim = nvim;
        this._ready = false;
        this.actions = new Map();
        Object.defineProperty(workspace_1.default, 'nvim', {
            get: () => this.nvim
        });
        this.cursors = new cursors_1.default(nvim);
        this.addAction('hasProvider', (id) => this.handler.hasProvider(id));
        this.addAction('getTagList', async () => await this.handler.getTagList());
        this.addAction('hasSelected', () => completion_1.default.hasSelected());
        this.addAction('listNames', () => manager_2.default.names);
        this.addAction('listDescriptions', () => manager_2.default.descriptions);
        this.addAction('listLoadItems', async (name) => await manager_2.default.loadItems(name));
        this.addAction('search', (...args) => this.handler.search(args));
        this.addAction('cursorsSelect', (bufnr, kind, mode) => this.cursors.select(bufnr, kind, mode));
        this.addAction('codeActionRange', (start, end, only) => this.handler.codeActionRange(start, end, only));
        this.addAction('fillDiagnostics', (bufnr) => manager_1.default.setLocationlist(bufnr));
        this.addAction('getConfig', async (key) => {
            let document = await workspace_1.default.document;
            // eslint-disable-next-line id-blacklist
            return workspace_1.default.getConfiguration(key, document ? document.uri : undefined);
        });
        this.addAction('rootPatterns', bufnr => {
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc)
                return null;
            return {
                buffer: workspace_1.default.getRootPatterns(doc, types_1.PatternType.Buffer),
                server: workspace_1.default.getRootPatterns(doc, types_1.PatternType.LanguageServer),
                global: workspace_1.default.getRootPatterns(doc, types_1.PatternType.Global)
            };
        });
        this.addAction('installExtensions', async (...list) => {
            await extensions_1.default.installExtensions(list);
        });
        this.addAction('saveRefactor', async (bufnr) => {
            await this.handler.saveRefactor(bufnr);
        });
        this.addAction('updateExtensions', async (sync) => {
            await extensions_1.default.updateExtensions(sync);
        });
        this.addAction('commandList', () => commands_1.default.commandList.map(o => o.id));
        this.addAction('openList', async (...args) => {
            await this.ready;
            await manager_2.default.start(args);
        });
        this.addAction('selectSymbolRange', (inner, visualmode, supportedSymbols) => this.handler.selectSymbolRange(inner, visualmode, supportedSymbols));
        this.addAction('listResume', (name) => manager_2.default.resume(name));
        this.addAction('listPrev', (name) => manager_2.default.previous(name));
        this.addAction('listNext', (name) => manager_2.default.next(name));
        this.addAction('listFirst', (name) => manager_2.default.first(name));
        this.addAction('listLast', (name) => manager_2.default.last(name));
        this.addAction('sendRequest', (id, method, params) => services_1.default.sendRequest(id, method, params));
        this.addAction('sendNotification', (id, method, params) => {
            return services_1.default.sendNotification(id, method, params);
        });
        this.addAction('registNotification', (id, method) => {
            return services_1.default.registNotification(id, method);
        });
        this.addAction('doAutocmd', async (id, ...args) => {
            let autocmd = workspace_1.default.autocmds.get(id);
            if (autocmd) {
                try {
                    await Promise.resolve(autocmd.callback.apply(autocmd.thisArg, args));
                }
                catch (e) {
                    logger.error(`Error on autocmd ${autocmd.event}`, e);
                    workspace_1.default.showMessage(`Error on autocmd ${autocmd.event}: ${e.message}`);
                }
            }
        });
        this.addAction('updateConfig', (section, val) => {
            workspace_1.default.configurations.updateUserConfig({ [section]: val });
        });
        this.addAction('snippetNext', async () => {
            await manager_3.default.nextPlaceholder();
            return '';
        });
        this.addAction('snippetPrev', async () => {
            await manager_3.default.previousPlaceholder();
            return '';
        });
        this.addAction('snippetCancel', () => {
            manager_3.default.cancel();
        });
        this.addAction('openLocalConfig', async () => {
            await workspace_1.default.openLocalConfig();
        });
        this.addAction('openLog', async () => {
            let file = logger.getLogFile();
            await workspace_1.default.jumpTo(vscode_uri_1.URI.file(file).toString());
        });
        this.addAction('attach', () => {
            return workspace_1.default.attach();
        });
        this.addAction('detach', () => {
            return workspace_1.default.detach();
        });
        this.addAction('doKeymap', async (key, defaultReturn = '') => {
            let keymap = workspace_1.default.keymaps.get(key);
            if (!keymap) {
                logger.error(`keymap for ${key} not found`);
                return defaultReturn;
            }
            let [fn, repeat] = keymap;
            let res = await Promise.resolve(fn());
            if (repeat)
                await nvim.command(`silent! call repeat#set("\\<Plug>(coc-${key})", -1)`);
            return res || defaultReturn;
        });
        this.addAction('registExtensions', async (...folders) => {
            for (let folder of folders) {
                await extensions_1.default.loadExtension(folder);
            }
        });
        this.addAction('snippetCheck', async (checkExpand, checkJump) => {
            if (checkExpand && !extensions_1.default.has('coc-snippets')) {
                console.error('coc-snippets required for check expand status!');
                return false;
            }
            if (checkJump) {
                let jumpable = manager_3.default.jumpable();
                if (jumpable)
                    return true;
            }
            if (checkExpand) {
                let api = extensions_1.default.getExtensionApi('coc-snippets');
                if (api && api.hasOwnProperty('expandable')) {
                    let expandable = await Promise.resolve(api.expandable());
                    if (expandable)
                        return true;
                }
            }
            return false;
        });
        this.addAction('showInfo', async () => {
            if (!this.infoChannel) {
                this.infoChannel = workspace_1.default.createOutputChannel('info');
            }
            else {
                this.infoChannel.clear();
            }
            let channel = this.infoChannel;
            channel.appendLine('## versions');
            channel.appendLine('');
            let out = await this.nvim.call('execute', ['version']);
            let first = out.trim().split('\n', 2)[0].replace(/\(.*\)/, '').trim();
            channel.appendLine('vim version: ' + first + `${workspace_1.default.isVim ? ' ' + workspace_1.default.env.version : ''}`);
            channel.appendLine('node version: ' + process.version);
            channel.appendLine('coc.nvim version: ' + this.version);
            channel.appendLine('coc.nvim directory: ' + path_1.default.dirname(__dirname));
            channel.appendLine('term: ' + (process.env.TERM_PROGRAM || process.env.TERM));
            channel.appendLine('platform: ' + process.platform);
            channel.appendLine('');
            for (let ch of workspace_1.default.outputChannels.values()) {
                if (ch.name !== 'info') {
                    channel.appendLine(`## Output channel: ${ch.name}\n`);
                    channel.append(ch.content);
                    channel.appendLine('');
                }
            }
            channel.show();
        });
        this.addAction('findLocations', (id, method, params, openCommand) => {
            return this.handler.findLocations(id, method, params, openCommand);
        });
        this.addAction('links', () => {
            return this.handler.links();
        });
        this.addAction('openLink', () => {
            return this.handler.openLink();
        });
        this.addAction('pickColor', () => {
            return this.handler.pickColor();
        });
        this.addAction('colorPresentation', () => {
            return this.handler.pickPresentation();
        });
        this.addAction('highlight', async () => {
            await this.handler.highlight();
        });
        this.addAction('fold', (kind) => {
            return this.handler.fold(kind);
        });
        this.addAction('startCompletion', async (option) => {
            await completion_1.default.startCompletion(option);
        });
        this.addAction('sourceStat', () => {
            return sources_1.default.sourceStats();
        });
        this.addAction('refreshSource', async (name) => {
            await sources_1.default.refresh(name);
        });
        this.addAction('toggleSource', name => {
            sources_1.default.toggleSource(name);
        });
        this.addAction('diagnosticInfo', async () => {
            await manager_1.default.echoMessage();
        });
        this.addAction('diagnosticToggle', () => {
            manager_1.default.toggleDiagnostic();
        });
        this.addAction('diagnosticNext', async (severity) => {
            await manager_1.default.jumpNext(severity);
        });
        this.addAction('diagnosticPrevious', async (severity) => {
            await manager_1.default.jumpPrevious(severity);
        });
        this.addAction('diagnosticPreview', async () => {
            await manager_1.default.preview();
        });
        this.addAction('diagnosticList', () => {
            return manager_1.default.getDiagnosticList();
        });
        this.addAction('jumpDefinition', openCommand => {
            return this.handler.gotoDefinition(openCommand);
        });
        this.addAction('jumpDeclaration', openCommand => {
            return this.handler.gotoDeclaration(openCommand);
        });
        this.addAction('jumpImplementation', openCommand => {
            return this.handler.gotoImplementation(openCommand);
        });
        this.addAction('jumpTypeDefinition', openCommand => {
            return this.handler.gotoTypeDefinition(openCommand);
        });
        this.addAction('jumpReferences', openCommand => {
            return this.handler.gotoReferences(openCommand);
        });
        this.addAction('doHover', () => {
            return this.handler.onHover();
        });
        this.addAction('showSignatureHelp', () => {
            return this.handler.showSignatureHelp();
        });
        this.addAction('documentSymbols', () => {
            return this.handler.getDocumentSymbols();
        });
        this.addAction('symbolRanges', () => {
            return this.handler.getSymbolsRanges();
        });
        this.addAction('selectionRanges', () => {
            return this.handler.getSelectionRanges();
        });
        this.addAction('rangeSelect', (visualmode, forward) => {
            return this.handler.selectRange(visualmode, forward);
        });
        this.addAction('rename', newName => {
            return this.handler.rename(newName);
        });
        this.addAction('getWorkspaceSymbols', async (input, bufnr) => {
            if (!bufnr)
                bufnr = await this.nvim.eval('bufnr("%")');
            let document = workspace_1.default.getDocument(bufnr);
            if (!document)
                return;
            return await languages_1.default.getWorkspaceSymbols(document.textDocument, input);
        });
        this.addAction('formatSelected', mode => {
            return this.handler.documentRangeFormatting(mode);
        });
        this.addAction('format', () => {
            return this.handler.documentFormatting();
        });
        this.addAction('commands', () => {
            return this.handler.getCommands();
        });
        this.addAction('services', () => {
            return services_1.default.getServiceStats();
        });
        this.addAction('toggleService', name => {
            return services_1.default.toggle(name);
        });
        this.addAction('codeAction', (mode, only) => {
            return this.handler.doCodeAction(mode, only);
        });
        this.addAction('organizeImport', () => {
            return this.handler.doCodeAction(null, [vscode_languageserver_types_1.CodeActionKind.SourceOrganizeImports]);
        });
        this.addAction('fixAll', () => {
            return this.handler.doCodeAction(null, [vscode_languageserver_types_1.CodeActionKind.SourceFixAll]);
        });
        this.addAction('doCodeAction', codeAction => {
            return this.handler.applyCodeAction(codeAction);
        });
        this.addAction('codeActions', (mode, only) => {
            return this.handler.getCurrentCodeActions(mode, only);
        });
        this.addAction('quickfixes', mode => {
            return this.handler.getCurrentCodeActions(mode, [vscode_languageserver_types_1.CodeActionKind.QuickFix]);
        });
        this.addAction('codeLensAction', () => {
            return this.handler.doCodeLensAction();
        });
        this.addAction('runCommand', (...args) => {
            return this.handler.runCommand(...args);
        });
        this.addAction('doQuickfix', () => {
            return this.handler.doQuickfix();
        });
        this.addAction('refactor', () => {
            return this.handler.doRefactor();
        });
        this.addAction('repeatCommand', () => {
            return commands_1.default.repeatCommand();
        });
        this.addAction('extensionStats', () => {
            return extensions_1.default.getExtensionStates();
        });
        this.addAction('activeExtension', name => {
            return extensions_1.default.activate(name);
        });
        this.addAction('deactivateExtension', name => {
            return extensions_1.default.deactivate(name);
        });
        this.addAction('reloadExtension', name => {
            return extensions_1.default.reloadExtension(name);
        });
        this.addAction('toggleExtension', name => {
            return extensions_1.default.toggleExtension(name);
        });
        this.addAction('uninstallExtension', (...args) => {
            return extensions_1.default.uninstallExtension(args);
        });
        this.addAction('getCurrentFunctionSymbol', () => {
            return this.handler.getCurrentFunctionSymbol();
        });
        this.addAction('getWordEdit', () => {
            return this.handler.getWordEdit();
        });
        this.addAction('addRanges', async (ranges) => {
            await this.cursors.addRanges(ranges);
        });
        this.addAction('currentWorkspacePath', () => {
            return workspace_1.default.rootPath;
        });
        this.addAction('addCommand', cmd => {
            this.addCommand(cmd);
        });
        workspace_1.default.onDidChangeWorkspaceFolders(() => {
            nvim.setVar('WorkspaceFolders', workspace_1.default.folderPaths, true);
        });
        commands_1.default.init(nvim, this);
    }
    addAction(key, fn) {
        if (this.actions.has(key)) {
            throw new Error(`Action ${key} already exists`);
        }
        this.actions.set(key, fn);
    }
    addCommand(cmd) {
        let id = `vim.${cmd.id}`;
        commands_1.default.registerCommand(id, async () => {
            await this.nvim.command(cmd.cmd);
        });
        if (cmd.title)
            commands_1.default.titles.set(id, cmd.title);
    }
    async init() {
        let { nvim } = this;
        let s = Date.now();
        try {
            await extensions_1.default.init();
            await workspace_1.default.init();
            for (let item of workspace_1.default.env.vimCommands) {
                this.addCommand(item);
            }
            manager_3.default.init();
            completion_1.default.init();
            manager_1.default.init();
            manager_2.default.init(nvim);
            nvim.setVar('coc_workspace_initialized', 1, true);
            nvim.setVar('WorkspaceFolders', workspace_1.default.folderPaths, true);
            sources_1.default.init();
            this.handler = new handler_1.default(nvim);
            services_1.default.init();
            await extensions_1.default.activateExtensions();
            workspace_1.default.setupDynamicAutocmd(true);
            nvim.setVar('coc_service_initialized', 1, true);
            nvim.call('coc#util#do_autocmd', ['CocNvimInit'], true);
            this._ready = true;
            logger.info(`coc.nvim ${this.version} initialized with node: ${process.version} after ${Date.now() - s}ms`);
            this.emit('ready');
        }
        catch (e) {
            console.error(`Error on initialize: ${e.stack}`);
            logger.error(e.stack);
        }
        workspace_1.default.onDidOpenTextDocument(async (doc) => {
            if (!doc.uri.endsWith(util_1.CONFIG_FILE_NAME))
                return;
            if (extensions_1.default.has('coc-json'))
                return;
            workspace_1.default.showMessage(`Run :CocInstall coc-json for json intellisense`, 'more');
        });
    }
    get isReady() {
        return this._ready;
    }
    get ready() {
        if (this._ready)
            return Promise.resolve();
        return new Promise(resolve => {
            this.once('ready', () => {
                resolve();
            });
        });
    }
    get version() {
        return workspace_1.default.version + ( true ? '-' + "d2a3186309" : undefined);
    }
    hasAction(method) {
        return this.actions.has(method);
    }
    async cocAction(method, ...args) {
        let fn = this.actions.get(method);
        return await Promise.resolve(fn.apply(null, args));
    }
    dispose() {
        this.removeAllListeners();
        extensions_1.default.dispose();
        manager_2.default.dispose();
        workspace_1.default.dispose();
        sources_1.default.dispose();
        services_1.default.stopAll();
        services_1.default.dispose();
        if (this.handler) {
            this.handler.dispose();
        }
        manager_3.default.dispose();
        commands_1.default.dispose();
        completion_1.default.dispose();
        manager_1.default.dispose();
    }
}
exports.default = Plugin;
//# sourceMappingURL=plugin.js.map

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const manager_1 = tslib_1.__importDefault(__webpack_require__(253));
const manager_2 = tslib_1.__importDefault(__webpack_require__(256));
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('commands');
class CommandItem {
    constructor(id, impl, thisArg, internal = false) {
        this.id = id;
        this.impl = impl;
        this.thisArg = thisArg;
        this.internal = internal;
    }
    execute(...args) {
        let { impl, thisArg } = this;
        return impl.apply(thisArg, args || []);
    }
    dispose() {
        this.thisArg = null;
        this.impl = null;
    }
}
class CommandManager {
    constructor() {
        this.commands = new Map();
        this.titles = new Map();
    }
    init(nvim, plugin) {
        this.mru = workspace_1.default.createMru('commands');
        this.register({
            id: 'vscode.open',
            execute: async (url) => {
                nvim.call('coc#util#open_url', url.toString(), true);
            }
        }, true);
        this.register({
            id: 'workbench.action.reloadWindow',
            execute: () => {
                nvim.command('CocRestart', true);
            }
        }, true);
        this.register({
            id: 'editor.action.insertSnippet',
            execute: async (edit) => {
                let doc = workspace_1.default.getDocument(workspace_1.default.bufnr);
                if (!doc)
                    return;
                await nvim.call('coc#_cancel', []);
                if (doc.dirty)
                    doc.forceSync();
                await manager_2.default.insertSnippet(edit.newText, true, edit.range);
            }
        }, true);
        this.register({
            id: 'editor.action.doCodeAction',
            execute: async (action) => {
                await plugin.cocAction('doCodeAction', action);
            }
        }, true);
        this.register({
            id: 'editor.action.triggerSuggest',
            execute: async () => {
                await util_1.wait(100);
                nvim.call('coc#start', [], true);
            }
        }, true);
        this.register({
            id: 'editor.action.triggerParameterHints',
            execute: async () => {
                await util_1.wait(60);
                await plugin.cocAction('showSignatureHelp');
            }
        }, true);
        this.register({
            id: 'editor.action.addRanges',
            execute: async (ranges) => {
                await plugin.cocAction('addRanges', ranges);
            }
        }, true);
        this.register({
            id: 'editor.action.restart',
            execute: async () => {
                await util_1.wait(30);
                nvim.command('CocRestart', true);
            }
        }, true);
        this.register({
            id: 'editor.action.showReferences',
            execute: async (_filepath, _position, references) => {
                await workspace_1.default.showLocations(references);
            }
        }, true);
        this.register({
            id: 'editor.action.rename',
            execute: async (uri, position) => {
                await workspace_1.default.jumpTo(uri, position);
                await plugin.cocAction('rename');
            }
        }, true);
        this.register({
            id: 'editor.action.format',
            execute: async () => {
                await plugin.cocAction('format');
            }
        }, true);
        this.register({
            id: 'workspace.diffDocument',
            execute: async () => {
                let document = await workspace_1.default.document;
                if (!document)
                    return;
                let lines = document.content.split('\n');
                await nvim.call('coc#util#diff_content', [lines]);
            }
        }, true);
        this.register({
            id: 'workspace.clearWatchman',
            execute: async () => {
                if (global.hasOwnProperty('__TEST__'))
                    return;
                let res = await workspace_1.default.runTerminalCommand('watchmann watch-del-all');
                if (res.success)
                    workspace_1.default.showMessage('Cleared watchman watching directories.');
            }
        }, false, 'run watch-del-all for watchman to free up memory.');
        this.register({
            id: 'workspace.workspaceFolders',
            execute: async () => {
                let folders = workspace_1.default.workspaceFolders;
                let lines = folders.map(folder => vscode_uri_1.URI.parse(folder.uri).fsPath);
                await workspace_1.default.echoLines(lines);
            }
        }, false, 'show opened workspaceFolders.');
        this.register({
            id: 'workspace.renameCurrentFile',
            execute: async () => {
                await workspace_1.default.renameCurrent();
            }
        }, false, 'change current filename to a new name and reload it.');
        this.register({
            id: 'extensions.toggleAutoUpdate',
            execute: async () => {
                let config = workspace_1.default.getConfiguration('coc.preferences');
                let interval = config.get('extensionUpdateCheck', 'daily');
                if (interval == 'never') {
                    config.update('extensionUpdateCheck', 'daily', true);
                    workspace_1.default.showMessage('Extension auto update enabled.', 'more');
                }
                else {
                    config.update('extensionUpdateCheck', 'never', true);
                    workspace_1.default.showMessage('Extension auto update disabled.', 'more');
                }
            }
        }, false, 'toggle auto update of extensions.');
        this.register({
            id: 'workspace.diagnosticRelated',
            execute: () => manager_1.default.jumpRelated()
        }, false, 'jump to related locations of current diagnostic.');
        this.register({
            id: 'workspace.showOutput',
            execute: async (name) => {
                if (name) {
                    workspace_1.default.showOutputChannel(name);
                }
                else {
                    let names = workspace_1.default.channelNames;
                    if (names.length == 0)
                        return;
                    if (names.length == 1) {
                        workspace_1.default.showOutputChannel(names[0]);
                    }
                    else {
                        let idx = await workspace_1.default.showQuickpick(names);
                        if (idx == -1)
                            return;
                        let name = names[idx];
                        workspace_1.default.showOutputChannel(name);
                    }
                }
            }
        }, false, 'open output buffer to show output from languageservers or extensions.');
        this.register({
            id: 'document.echoFiletype',
            execute: async () => {
                let bufnr = await nvim.call('bufnr', '%');
                let doc = workspace_1.default.getDocument(bufnr);
                if (!doc)
                    return;
                await workspace_1.default.echoLines([doc.filetype]);
            }
        }, false, 'echo the mapped filetype of the current buffer');
        this.register({
            id: 'document.renameCurrentWord',
            execute: async () => {
                let bufnr = await nvim.call('bufnr', '%');
                let doc = workspace_1.default.getDocument(bufnr);
                if (!doc)
                    return;
                let edit = await plugin.cocAction('getWordEdit');
                if (!edit) {
                    workspace_1.default.showMessage('Invalid position', 'warning');
                    return;
                }
                let ranges = [];
                let { changes, documentChanges } = edit;
                if (changes) {
                    let edits = changes[doc.uri];
                    if (edits)
                        ranges = edits.map(e => e.range);
                }
                else if (documentChanges) {
                    for (let c of documentChanges) {
                        if (vscode_languageserver_protocol_1.TextDocumentEdit.is(c) && c.textDocument.uri == doc.uri) {
                            ranges = c.edits.map(e => e.range);
                        }
                    }
                }
                if (ranges.length) {
                    await plugin.cocAction('addRanges', ranges);
                }
            }
        }, false, 'rename word under cursor in current buffer by use multiple cursors.');
        this.register({
            id: 'document.jumpToNextSymbol',
            execute: async () => {
                let doc = await workspace_1.default.document;
                if (!doc)
                    return;
                let ranges = await plugin.cocAction('symbolRanges');
                if (!ranges)
                    return;
                let { textDocument } = doc;
                let offset = await workspace_1.default.getOffset();
                ranges.sort((a, b) => {
                    if (a.start.line != b.start.line) {
                        return a.start.line - b.start.line;
                    }
                    return a.start.character - b.start.character;
                });
                for (let i = 0; i <= ranges.length - 1; i++) {
                    if (textDocument.offsetAt(ranges[i].start) > offset) {
                        await workspace_1.default.moveTo(ranges[i].start);
                        return;
                    }
                }
                await workspace_1.default.moveTo(ranges[0].start);
            }
        }, false, 'Jump to next symbol highlight position.');
        this.register({
            id: 'document.jumpToPrevSymbol',
            execute: async () => {
                let doc = await workspace_1.default.document;
                if (!doc)
                    return;
                let ranges = await plugin.cocAction('symbolRanges');
                if (!ranges)
                    return;
                let { textDocument } = doc;
                let offset = await workspace_1.default.getOffset();
                ranges.sort((a, b) => {
                    if (a.start.line != b.start.line) {
                        return a.start.line - b.start.line;
                    }
                    return a.start.character - b.start.character;
                });
                for (let i = ranges.length - 1; i >= 0; i--) {
                    if (textDocument.offsetAt(ranges[i].end) < offset) {
                        await workspace_1.default.moveTo(ranges[i].start);
                        return;
                    }
                }
                await workspace_1.default.moveTo(ranges[ranges.length - 1].start);
            }
        }, false, 'Jump to previous symbol highlight position.');
    }
    get commandList() {
        let res = [];
        for (let item of this.commands.values()) {
            if (!item.internal)
                res.push(item);
        }
        return res;
    }
    dispose() {
        for (const registration of this.commands.values()) {
            registration.dispose();
        }
        this.commands.clear();
    }
    execute(command) {
        let args = [command.command];
        let arr = command.arguments;
        if (arr)
            args.push(...arr);
        this.executeCommand.apply(this, args);
    }
    register(command, internal = false, description) {
        for (const id of Array.isArray(command.id) ? command.id : [command.id]) {
            this.registerCommand(id, command.execute, command, internal);
            if (description)
                this.titles.set(id, description);
        }
        return command;
    }
    has(id) {
        return this.commands.has(id);
    }
    unregister(id) {
        let item = this.commands.get(id);
        if (!item)
            return;
        item.dispose();
        this.commands.delete(id);
    }
    /**
     * Registers a command that can be invoked via a keyboard shortcut,
     * a menu item, an action, or directly.
     *
     * Registering a command with an existing command identifier twice
     * will cause an error.
     *
     * @param command A unique identifier for the command.
     * @param impl A command handler function.
     * @param thisArg The `this` context used when invoking the handler function.
     * @return Disposable which unregisters this command on disposal.
     */
    registerCommand(id, impl, thisArg, internal = false) {
        if (id.startsWith("_"))
            internal = true;
        this.commands.set(id, new CommandItem(id, impl, thisArg, internal));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.commands.delete(id);
        });
    }
    /**
     * Executes the command denoted by the given command identifier.
     *
     * * *Note 1:* When executing an editor command not all types are allowed to
     * be passed as arguments. Allowed are the primitive types `string`, `boolean`,
     * `number`, `undefined`, and `null`, as well as [`Position`](#Position), [`Range`](#Range), [`URI`](#URI) and [`Location`](#Location).
     * * *Note 2:* There are no restrictions when executing commands that have been contributed
     * by extensions.
     *
     * @param command Identifier of the command to execute.
     * @param rest Parameters passed to the command function.
     * @return A promise that resolves to the returned value of the given command. `undefined` when
     * the command handler function doesn't return anything.
     */
    executeCommand(command, ...rest) {
        let cmd = this.commands.get(command);
        if (!cmd) {
            workspace_1.default.showMessage(`Command: ${command} not found`, 'error');
            return;
        }
        return Promise.resolve(cmd.execute.apply(cmd, rest)).catch(e => {
            workspace_1.default.showMessage(`Command error: ${e.message}`, 'error');
            logger.error(e.stack);
        });
    }
    async addRecent(cmd) {
        await this.mru.add(cmd);
        await workspace_1.default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
    }
    async repeatCommand() {
        let mruList = await this.mru.load();
        let first = mruList[0];
        if (first) {
            await this.executeCommand(first);
            await workspace_1.default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
        }
    }
}
exports.CommandManager = CommandManager;
exports.default = new CommandManager();
//# sourceMappingURL=commands.js.map

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const semver_1 = tslib_1.__importDefault(__webpack_require__(1));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const floatFactory_1 = tslib_1.__importDefault(__webpack_require__(254));
const util_1 = __webpack_require__(238);
const position_1 = __webpack_require__(311);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const buffer_1 = __webpack_require__(610);
const collection_1 = tslib_1.__importDefault(__webpack_require__(612));
const util_2 = __webpack_require__(611);
const logger = __webpack_require__(64)('diagnostic-manager');
class DiagnosticManager {
    constructor() {
        this.enabled = true;
        this.buffers = new Map();
        this.lastMessage = '';
        this.collections = [];
        this.disposables = [];
    }
    init() {
        this.setConfiguration();
        let { nvim } = workspace_1.default;
        let { maxWindowHeight, maxWindowWidth } = this.config;
        this.floatFactory = new floatFactory_1.default(nvim, workspace_1.default.env, false, maxWindowHeight, maxWindowWidth);
        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            if (this.timer)
                clearTimeout(this.timer);
        }));
        events_1.default.on('CursorMoved', () => {
            if (this.config.enableMessage != 'always')
                return;
            if (this.timer)
                clearTimeout(this.timer);
            this.timer = setTimeout(async () => {
                await this.echoMessage(true);
            }, this.config.messageDelay);
        }, null, this.disposables);
        let fn = debounce_1.default((bufnr, cursor) => {
            if (!this.config.virtualText || !this.config.virtualTextCurrentLineOnly) {
                return;
            }
            let buf = this.buffers.get(bufnr);
            if (buf) {
                let diagnostics = this.getDiagnostics(buf.uri);
                buf.showVirtualText(diagnostics, cursor[0]);
            }
        }, 100);
        events_1.default.on('CursorMoved', fn, null, this.disposables);
        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            fn.clear();
        }));
        events_1.default.on('InsertEnter', () => {
            if (this.timer)
                clearTimeout(this.timer);
            this.floatFactory.close();
        }, null, this.disposables);
        events_1.default.on('InsertLeave', async (bufnr) => {
            this.floatFactory.close();
            if (!this.buffers.has(bufnr))
                return;
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc)
                return;
            doc.forceSync();
            let { refreshOnInsertMode, refreshAfterSave } = this.config;
            if (!refreshOnInsertMode && !refreshAfterSave) {
                this.refreshBuffer(doc.uri);
            }
        }, null, this.disposables);
        events_1.default.on('BufEnter', async () => {
            if (this.timer)
                clearTimeout(this.timer);
        }, null, this.disposables);
        events_1.default.on('BufWritePost', async (bufnr) => {
            let buf = this.buffers.get(bufnr);
            if (!buf)
                return;
            await buf.checkSigns();
            if (!this.config.refreshAfterSave)
                return;
            this.refreshBuffer(buf.uri);
        }, null, this.disposables);
        workspace_1.default.onDidChangeConfiguration(e => {
            this.setConfiguration(e);
        }, null, this.disposables);
        // create buffers
        for (let doc of workspace_1.default.documents) {
            this.createDiagnosticBuffer(doc);
        }
        workspace_1.default.onDidOpenTextDocument(textDocument => {
            let doc = workspace_1.default.getDocument(textDocument.uri);
            this.createDiagnosticBuffer(doc);
        }, null, this.disposables);
        workspace_1.default.onDidCloseTextDocument(({ uri }) => {
            let doc = workspace_1.default.getDocument(uri);
            if (!doc)
                return;
            this.disposeBuffer(doc.bufnr);
        }, null, this.disposables);
        this.setConfigurationErrors(true);
        workspace_1.default.configurations.onError(() => {
            this.setConfigurationErrors();
        }, null, this.disposables);
        let { enableHighlightLineNumber } = this.config;
        if (!workspace_1.default.isNvim || semver_1.default.lt(workspace_1.default.env.version, 'v0.3.2')) {
            enableHighlightLineNumber = false;
        }
        nvim.pauseNotification();
        if (this.config.enableSign) {
            for (let kind of ['Error', 'Warning', 'Info', 'Hint']) {
                let signText = this.config[kind.toLowerCase() + 'Sign'];
                let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;
                if (signText)
                    cmd += ` texthl=Coc${kind}Sign text=${signText}`;
                if (enableHighlightLineNumber)
                    cmd += ` numhl=Coc${kind}Sign`;
                nvim.command(cmd, true);
            }
        }
        nvim.resumeNotification(false, true).logError();
    }
    createDiagnosticBuffer(doc) {
        if (!this.shouldValidate(doc))
            return;
        let { bufnr } = doc;
        let buf = this.buffers.get(bufnr);
        if (buf)
            return;
        buf = new buffer_1.DiagnosticBuffer(bufnr, doc.uri, this.config);
        this.buffers.set(bufnr, buf);
        buf.onDidRefresh(() => {
            if (this.config.enableMessage == 'never')
                return;
            this.echoMessage(true).logError();
        });
    }
    async setLocationlist(bufnr) {
        let buf = this.buffers.get(bufnr);
        let diagnostics = buf ? this.getDiagnostics(buf.uri) : [];
        let items = [];
        for (let diagnostic of diagnostics) {
            let item = util_2.getLocationListItem(bufnr, diagnostic);
            items.push(item);
        }
        let curr = await this.nvim.call('getloclist', [0, { title: 1 }]);
        let action = curr.title && curr.title.indexOf('Diagnostics of coc') != -1 ? 'r' : ' ';
        await this.nvim.call('setloclist', [0, [], action, { title: 'Diagnostics of coc', items }]);
    }
    setConfigurationErrors(init) {
        let collections = this.collections;
        let collection = collections.find(o => o.name == 'config');
        if (!collection) {
            collection = this.create('config');
        }
        else {
            collection.clear();
        }
        let { errorItems } = workspace_1.default.configurations;
        if (errorItems && errorItems.length) {
            if (init)
                workspace_1.default.showMessage(`settings file parse error, run ':CocList diagnostics'`, 'error');
            let entries = new Map();
            for (let item of errorItems) {
                let { uri } = item.location;
                let diagnostics = entries.get(uri) || [];
                diagnostics.push(vscode_languageserver_protocol_1.Diagnostic.create(item.location.range, item.message, vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
                entries.set(uri, diagnostics);
            }
            collection.set(Array.from(entries));
        }
    }
    /**
     * Create collection by name
     */
    create(name) {
        let collection = new collection_1.default(name);
        this.collections.push(collection);
        // Used for refresh diagnostics on buferEnter when refreshAfterSave is true
        // Note we can't make sure it work as expected when there're multiple sources
        let createTime = Date.now();
        let refreshed = false;
        collection.onDidDiagnosticsChange(uri => {
            if (this.config.refreshAfterSave &&
                (refreshed || Date.now() - createTime > 5000))
                return;
            refreshed = true;
            this.refreshBuffer(uri);
        });
        collection.onDidDiagnosticsClear(uris => {
            for (let uri of uris) {
                this.refreshBuffer(uri, true);
            }
        });
        collection.onDispose(() => {
            let idx = this.collections.findIndex(o => o == collection);
            if (idx !== -1)
                this.collections.splice(idx, 1);
        });
        return collection;
    }
    /**
     * Get diagnostics ranges from document
     */
    getSortedRanges(uri, severity) {
        let collections = this.getCollections(uri);
        let res = [];
        let level = severity ? util_2.severityLevel(severity) : 0;
        for (let collection of collections) {
            let diagnostics = collection.get(uri);
            if (level)
                diagnostics = diagnostics.filter(o => o.severity == level);
            let ranges = diagnostics.map(o => o.range);
            res.push(...ranges);
        }
        res.sort((a, b) => {
            if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
            }
            return a.start.character - b.start.character;
        });
        return res;
    }
    /**
     * Get readonly diagnostics for a buffer
     */
    getDiagnostics(uri) {
        let collections = this.getCollections(uri);
        let { level } = this.config;
        let res = [];
        for (let collection of collections) {
            let items = collection.get(uri);
            if (!items)
                continue;
            if (level && level < vscode_languageserver_protocol_1.DiagnosticSeverity.Hint) {
                items = items.filter(s => s.severity == null || s.severity <= level);
            }
            res.push(...items);
        }
        res.sort((a, b) => {
            if (a.severity == b.severity) {
                let d = position_1.comparePosition(a.range.start, b.range.start);
                if (d != 0)
                    return d;
                if (a.source == b.source)
                    return a.message > b.message ? 1 : -1;
                return a.source > b.source ? 1 : -1;
            }
            return a.severity - b.severity;
        });
        return res;
    }
    getDiagnosticsInRange(document, range) {
        let collections = this.getCollections(document.uri);
        let res = [];
        for (let collection of collections) {
            let items = collection.get(document.uri);
            if (!items)
                continue;
            for (let item of items) {
                if (position_1.rangeIntersect(item.range, range)) {
                    res.push(item);
                }
            }
        }
        return res;
    }
    /**
     * Show diagnostics under curosr in preview window
     */
    async preview() {
        let [bufnr, cursor] = await this.nvim.eval('[bufnr("%"),coc#util#cursor()]');
        let { nvim } = this;
        let diagnostics = this.getDiagnosticsAt(bufnr, cursor);
        if (diagnostics.length == 0) {
            nvim.command('pclose', true);
            workspace_1.default.showMessage(`Empty diagnostics`, 'warning');
            return;
        }
        let lines = [];
        for (let diagnostic of diagnostics) {
            let { source, code, severity, message } = diagnostic;
            let s = util_2.getSeverityName(severity)[0];
            lines.push(`[${source}${code ? ' ' + code : ''}] [${s}]`);
            lines.push(...message.split(/\r?\n/));
            lines.push('');
        }
        lines = lines.slice(0, -1);
        // let content = lines.join('\n').trim()
        nvim.call('coc#util#preview_info', [lines, 'txt'], true);
    }
    /**
     * Jump to previous diagnostic position
     */
    async jumpPrevious(severity) {
        let buffer = await this.nvim.buffer;
        let document = workspace_1.default.getDocument(buffer.id);
        if (!document)
            return;
        let offset = await workspace_1.default.getOffset();
        if (offset == null)
            return;
        let ranges = this.getSortedRanges(document.uri, severity);
        if (ranges.length == 0) {
            workspace_1.default.showMessage('Empty diagnostics', 'warning');
            return;
        }
        let { textDocument } = document;
        let pos;
        for (let i = ranges.length - 1; i >= 0; i--) {
            if (textDocument.offsetAt(ranges[i].end) < offset) {
                pos = ranges[i].start;
                break;
            }
            else if (i == 0) {
                let wrapscan = await this.nvim.getOption('wrapscan');
                if (wrapscan)
                    pos = ranges[ranges.length - 1].start;
            }
        }
        if (pos) {
            await workspace_1.default.moveTo(pos);
            if (this.config.enableMessage == 'never')
                return;
            await this.echoMessage(false);
        }
    }
    /**
     * Jump to next diagnostic position
     */
    async jumpNext(severity) {
        let buffer = await this.nvim.buffer;
        let document = workspace_1.default.getDocument(buffer.id);
        let offset = await workspace_1.default.getOffset();
        let ranges = this.getSortedRanges(document.uri, severity);
        if (ranges.length == 0) {
            workspace_1.default.showMessage('Empty diagnostics', 'warning');
            return;
        }
        let { textDocument } = document;
        let pos;
        for (let i = 0; i <= ranges.length - 1; i++) {
            if (textDocument.offsetAt(ranges[i].start) > offset) {
                pos = ranges[i].start;
                break;
            }
            else if (i == ranges.length - 1) {
                let wrapscan = await this.nvim.getOption('wrapscan');
                if (wrapscan)
                    pos = ranges[0].start;
            }
        }
        if (pos) {
            await workspace_1.default.moveTo(pos);
            if (this.config.enableMessage == 'never')
                return;
            await this.echoMessage(false);
        }
    }
    /**
     * All diagnostics of current workspace
     */
    getDiagnosticList() {
        let res = [];
        for (let collection of this.collections) {
            collection.forEach((uri, diagnostics) => {
                let file = vscode_uri_1.URI.parse(uri).fsPath;
                for (let diagnostic of diagnostics) {
                    let { start } = diagnostic.range;
                    let o = {
                        file,
                        lnum: start.line + 1,
                        col: start.character + 1,
                        message: `[${diagnostic.source || collection.name}${diagnostic.code ? ' ' + diagnostic.code : ''}] ${diagnostic.message}`,
                        severity: util_2.getSeverityName(diagnostic.severity),
                        level: diagnostic.severity || 0,
                        location: vscode_languageserver_protocol_1.Location.create(uri, diagnostic.range)
                    };
                    res.push(o);
                }
            });
        }
        res.sort((a, b) => {
            if (a.level !== b.level) {
                return a.level - b.level;
            }
            if (a.file !== b.file) {
                return a.file > b.file ? 1 : -1;
            }
            else {
                if (a.lnum != b.lnum) {
                    return a.lnum - b.lnum;
                }
                return a.col - b.col;
            }
        });
        return res;
    }
    getDiagnosticsAt(bufnr, cursor) {
        let pos = vscode_languageserver_protocol_1.Position.create(cursor[0], cursor[1]);
        let buffer = this.buffers.get(bufnr);
        if (!buffer)
            return [];
        let diagnostics = this.getDiagnostics(buffer.uri);
        let { checkCurrentLine } = this.config;
        if (checkCurrentLine) {
            diagnostics = diagnostics.filter(o => position_1.lineInRange(pos.line, o.range));
        }
        else {
            diagnostics = diagnostics.filter(o => position_1.positionInRange(pos, o.range) == 0);
        }
        diagnostics.sort((a, b) => a.severity - b.severity);
        return diagnostics;
    }
    async getCurrentDiagnostics() {
        let [bufnr, cursor] = await this.nvim.eval('[bufnr("%"),coc#util#cursor()]');
        return this.getDiagnosticsAt(bufnr, cursor);
    }
    /**
     * Echo diagnostic message of currrent position
     */
    async echoMessage(truncate = false) {
        const config = this.config;
        if (!this.enabled)
            return;
        if (this.timer)
            clearTimeout(this.timer);
        let useFloat = config.messageTarget == 'float';
        let [bufnr, cursor, filetype, mode, disabled] = await this.nvim.eval('[bufnr("%"),coc#util#cursor(),&filetype,mode(),get(b:,"coc_diagnostic_disable",0)]');
        if (mode != 'n' || bufnr == this.floatFactory.bufnr || disabled)
            return;
        let diagnostics = this.getDiagnosticsAt(bufnr, cursor);
        if (diagnostics.length == 0) {
            if (useFloat) {
                this.floatFactory.close();
            }
            else {
                let echoLine = await this.nvim.call('coc#util#echo_line');
                if (this.lastMessage && echoLine.startsWith(this.lastMessage)) {
                    this.nvim.command('echo ""', true);
                }
            }
            return;
        }
        if (truncate && workspace_1.default.insertMode)
            return;
        let docs = [];
        let ft = '';
        if (Object.keys(config.filetypeMap).length > 0) {
            const defaultFiletype = config.filetypeMap['default'] || '';
            ft = config.filetypeMap[filetype] || (defaultFiletype == 'bufferType' ? filetype : defaultFiletype);
        }
        diagnostics.forEach(diagnostic => {
            let { source, code, severity, message } = diagnostic;
            let s = util_2.getSeverityName(severity)[0];
            const codeStr = code ? ' ' + code : '';
            const str = config.format.replace('%source', source).replace('%code', codeStr).replace('%severity', s).replace('%message', message);
            let filetype = 'Error';
            if (ft === '') {
                switch (severity) {
                    case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:
                        filetype = 'Hint';
                        break;
                    case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:
                        filetype = 'Warning';
                        break;
                    case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:
                        filetype = 'Info';
                        break;
                }
            }
            else {
                filetype = ft;
            }
            docs.push({ filetype, content: str });
        });
        if (useFloat) {
            await this.floatFactory.create(docs);
        }
        else {
            let lines = docs.map(d => d.content).join('\n').split(/\r?\n/);
            if (lines.length) {
                await this.nvim.command('echo ""');
                this.lastMessage = lines[0].slice(0, 30);
                await workspace_1.default.echoLines(lines, truncate);
            }
        }
    }
    async jumpRelated() {
        let diagnostics = await this.getCurrentDiagnostics();
        if (!diagnostics)
            return;
        let diagnostic = diagnostics.find(o => o.relatedInformation != null);
        if (!diagnostic)
            return;
        let locations = diagnostic.relatedInformation.map(o => o.location);
        if (locations.length == 1) {
            await workspace_1.default.jumpTo(locations[0].uri, locations[0].range.start);
        }
        else if (locations.length > 1) {
            await workspace_1.default.showLocations(locations);
        }
    }
    disposeBuffer(bufnr) {
        let buf = this.buffers.get(bufnr);
        if (!buf)
            return;
        buf.clear().logError();
        buf.dispose();
        this.buffers.delete(bufnr);
        for (let collection of this.collections) {
            collection.delete(buf.uri);
        }
    }
    hideFloat() {
        if (this.floatFactory) {
            this.floatFactory.close();
        }
    }
    dispose() {
        for (let buf of this.buffers.values()) {
            buf.clear().logError();
            buf.dispose();
        }
        for (let collection of this.collections) {
            collection.dispose();
        }
        this.hideFloat();
        this.buffers.clear();
        this.collections = [];
        util_1.disposeAll(this.disposables);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    setConfiguration(event) {
        if (event && !event.affectsConfiguration('diagnostic'))
            return;
        let config = workspace_1.default.getConfiguration('diagnostic');
        let messageTarget = config.get('messageTarget', 'float');
        if (messageTarget == 'float' && !workspace_1.default.env.floating && !workspace_1.default.env.textprop) {
            messageTarget = 'echo';
        }
        this.config = {
            messageTarget,
            srcId: workspace_1.default.createNameSpace('coc-diagnostic') || 1000,
            virtualTextSrcId: workspace_1.default.createNameSpace('diagnostic-virtualText'),
            checkCurrentLine: config.get('checkCurrentLine', false),
            enableSign: config.get('enableSign', true),
            locationlistUpdate: config.get('locationlistUpdate', true),
            enableHighlightLineNumber: config.get('enableHighlightLineNumber', true),
            maxWindowHeight: config.get('maxWindowHeight', 10),
            maxWindowWidth: config.get('maxWindowWidth', 80),
            enableMessage: config.get('enableMessage', 'always'),
            messageDelay: config.get('messageDelay', 200),
            virtualText: config.get('virtualText', false) && this.nvim.hasFunction('nvim_buf_set_virtual_text'),
            virtualTextCurrentLineOnly: config.get('virtualTextCurrentLineOnly', true),
            virtualTextPrefix: config.get('virtualTextPrefix', " "),
            virtualTextLineSeparator: config.get('virtualTextLineSeparator', " \\ "),
            virtualTextLines: config.get('virtualTextLines', 3),
            displayByAle: config.get('displayByAle', false),
            level: util_2.severityLevel(config.get('level', 'hint')),
            signOffset: config.get('signOffset', 1000),
            errorSign: config.get('errorSign', '>>'),
            warningSign: config.get('warningSign', '>>'),
            infoSign: config.get('infoSign', '>>'),
            hintSign: config.get('hintSign', '>>'),
            refreshAfterSave: config.get('refreshAfterSave', false),
            refreshOnInsertMode: config.get('refreshOnInsertMode', false),
            filetypeMap: config.get('filetypeMap', {}),
            format: config.get('format', '[%source%code] [%severity] %message')
        };
        this.enabled = config.get('enable', true);
        if (this.config.displayByAle) {
            this.enabled = false;
        }
        if (event) {
            for (let severity of ['error', 'info', 'warning', 'hint']) {
                let key = `diagnostic.${severity}Sign`;
                if (event.affectsConfiguration(key)) {
                    let text = config.get(`${severity}Sign`, '>>');
                    let name = severity[0].toUpperCase() + severity.slice(1);
                    this.nvim.command(`sign define Coc${name}   text=${text}   linehl=Coc${name}Line texthl=Coc${name}Sign`, true);
                }
            }
        }
    }
    getCollections(uri) {
        return this.collections.filter(c => c.has(uri));
    }
    shouldValidate(doc) {
        return doc != null && doc.buftype == '' && doc.attached;
    }
    clearDiagnostic(bufnr) {
        let buf = this.buffers.get(bufnr);
        if (!buf)
            return;
        for (let collection of this.collections) {
            collection.delete(buf.uri);
        }
        buf.clear().logError();
    }
    toggleDiagnostic() {
        let { enabled } = this;
        this.enabled = !enabled;
        for (let buf of this.buffers.values()) {
            if (this.enabled) {
                let diagnostics = this.getDiagnostics(buf.uri);
                buf.forceRefresh(diagnostics);
            }
            else {
                buf.clear().logError();
            }
        }
    }
    refreshBuffer(uri, force = false) {
        let buf = Array.from(this.buffers.values()).find(o => o.uri == uri);
        if (!buf)
            return false;
        let { displayByAle, refreshOnInsertMode } = this.config;
        if (!displayByAle) {
            if (!refreshOnInsertMode && workspace_1.default.insertMode)
                return false;
            let diagnostics = this.getDiagnostics(uri);
            if (this.enabled) {
                if (force) {
                    buf.forceRefresh(diagnostics);
                }
                else {
                    buf.refresh(diagnostics);
                }
                return true;
            }
        }
        else {
            let { nvim } = this;
            nvim.pauseNotification();
            for (let collection of this.collections) {
                let diagnostics = collection.get(uri);
                const { level } = this.config;
                if (level) {
                    diagnostics = diagnostics.filter(o => o.severity && o.severity <= level);
                }
                let aleItems = diagnostics.map(o => {
                    let { range } = o;
                    return {
                        text: o.message,
                        code: o.code,
                        lnum: range.start.line + 1,
                        col: range.start.character + 1,
                        end_lnum: range.end.line + 1,
                        end_col: range.end.character,
                        type: util_2.getSeverityType(o.severity)
                    };
                });
                nvim.call('ale#other_source#ShowResults', [buf.bufnr, collection.name, aleItems], true);
            }
            nvim.resumeNotification(false, true).logError();
        }
        return false;
    }
}
exports.DiagnosticManager = DiagnosticManager;
exports.default = new DiagnosticManager();
//# sourceMappingURL=manager.js.map

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const events_1 = __webpack_require__(198);
const mutex_1 = __webpack_require__(255);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const events_2 = tslib_1.__importDefault(__webpack_require__(210));
const manager_1 = tslib_1.__importDefault(__webpack_require__(256));
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const floatBuffer_1 = tslib_1.__importDefault(__webpack_require__(520));
const object_1 = __webpack_require__(249);
const string_1 = __webpack_require__(310);
const logger = __webpack_require__(64)('model-float');
// factory class for floating window
class FloatFactory extends events_1.EventEmitter {
    constructor(nvim, env, preferTop = false, maxHeight = 999, maxWidth, autoHide = true) {
        super();
        this.nvim = nvim;
        this.env = env;
        this.preferTop = preferTop;
        this.maxHeight = maxHeight;
        this.maxWidth = maxWidth;
        this.autoHide = autoHide;
        this.winid = 0;
        this._bufnr = 0;
        this.disposables = [];
        this.alignTop = false;
        this.pumAlignTop = false;
        if (!workspace_1.default.floatSupported)
            return;
        this.mutex = new mutex_1.Mutex();
        this.floatBuffer = new floatBuffer_1.default(nvim);
        events_2.default.on('BufEnter', bufnr => {
            if (bufnr == this._bufnr
                || bufnr == this.targetBufnr)
                return;
            this.close();
        }, null, this.disposables);
        events_2.default.on('InsertEnter', bufnr => {
            if (bufnr == this._bufnr)
                return;
            this.close();
        });
        events_2.default.on('MenuPopupChanged', (ev, cursorline) => {
            let pumAlignTop = this.pumAlignTop = cursorline > ev.row;
            if (pumAlignTop == this.alignTop) {
                this.close();
            }
        }, null, this.disposables);
        this.onCursorMoved = debounce_1.default(this._onCursorMoved.bind(this), 200);
        events_2.default.on('CursorMoved', this.onCursorMoved, null, this.disposables);
        events_2.default.on('CursorMovedI', this.onCursorMoved, null, this.disposables);
        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            this.onCursorMoved.clear();
            this.cancel();
        }));
    }
    _onCursorMoved(bufnr, cursor) {
        let { insertMode } = workspace_1.default;
        if (bufnr == this._bufnr)
            return;
        if (bufnr == this.targetBufnr && object_1.equals(cursor, this.cursor)) {
            // cursor not moved
            return;
        }
        if (this.autoHide) {
            this.close();
            return;
        }
        if (!insertMode || bufnr != this.targetBufnr) {
            this.close();
            return;
        }
    }
    getWindowConfig(docs, win_position, offsetX = 0) {
        let { columns } = this.env;
        let lines = this.env.lines - this.env.cmdheight - 1;
        let { preferTop } = this;
        let alignTop = false;
        let [row, col] = win_position;
        let max = this.getMaxWindowHeight(docs);
        if (preferTop && row >= max) {
            alignTop = true;
        }
        else if (!preferTop && lines - row - 1 >= max) {
            alignTop = false;
        }
        else if ((preferTop && row >= 3) || (!preferTop && row >= lines - row - 1)) {
            alignTop = true;
        }
        let maxHeight = alignTop ? row : lines - row - 1;
        maxHeight = Math.min(maxHeight, this.maxHeight || lines);
        let maxWidth = Math.min(this.maxWidth || 80, 80, columns);
        let { width, height } = floatBuffer_1.default.getDimension(docs, maxWidth, maxHeight);
        if (col - offsetX + width > columns) {
            offsetX = col + width - columns;
        }
        this.alignTop = alignTop;
        return {
            height,
            width,
            row: alignTop ? -height : 1,
            col: offsetX == 0 ? 0 : -offsetX,
            relative: 'cursor'
        };
    }
    async create(docs, allowSelection = false, offsetX = 0) {
        if (!workspace_1.default.floatSupported)
            return;
        this.onCursorMoved.clear();
        if (docs.length == 0 || docs.every(doc => doc.content.length == 0)) {
            this.close();
            return;
        }
        this.cancel();
        let release = await this.mutex.acquire();
        try {
            await this.createPopup(docs, allowSelection, offsetX);
            release();
        }
        catch (e) {
            logger.error(`Error on create popup:`, e.message);
            this.close();
            release();
        }
    }
    async createPopup(docs, allowSelection = false, offsetX = 0) {
        let tokenSource = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        let { nvim, alignTop, pumAlignTop, floatBuffer } = this;
        // get options
        let arr = await this.nvim.call('coc#util#get_float_mode', [allowSelection, alignTop, pumAlignTop]);
        if (!arr || token.isCancellationRequested)
            return;
        let [mode, targetBufnr, win_position, cursor] = arr;
        this.targetBufnr = targetBufnr;
        this.cursor = cursor;
        let config = this.getWindowConfig(docs, win_position, offsetX);
        // calculat highlights
        await floatBuffer.setDocuments(docs, config.width);
        if (token.isCancellationRequested)
            return;
        if (mode == 's')
            nvim.call('feedkeys', ['\x1b', "in"], true);
        // create window
        let res = await this.nvim.call('coc#util#create_float_win', [this.winid, this._bufnr, config]);
        if (!res)
            return;
        this.onCursorMoved.clear();
        let winid = this.winid = res[0];
        let bufnr = this._bufnr = res[1];
        if (token.isCancellationRequested)
            return;
        nvim.pauseNotification();
        if (workspace_1.default.isNvim) {
            nvim.command(`noa call win_gotoid(${winid})`, true);
            this.floatBuffer.setLines(bufnr);
            nvim.command(`noa normal! gg0`, true);
            nvim.command('noa wincmd p', true);
        }
        else {
            // no need to change cursor position
            this.floatBuffer.setLines(bufnr, winid);
            nvim.call('win_execute', [winid, `noa normal! gg0`], true);
            nvim.command('redraw', true);
        }
        this.emit('show', winid, bufnr);
        let [, err] = await nvim.resumeNotification();
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        if (err)
            throw new Error(`Error on ${err[0]}: ${err[1]} - ${err[2]}`);
        if (mode == 's' && !token.isCancellationRequested) {
            await manager_1.default.selectCurrentPlaceholder(false);
            await util_1.wait(50);
        }
        this.onCursorMoved.clear();
    }
    /**
     * Close float window
     */
    close() {
        let { winid } = this;
        this.cancel();
        if (winid) {
            // TODO: sometimes this won't work at all
            this.nvim.call('coc#util#close_win', [winid], true);
            this.winid = 0;
            if (workspace_1.default.isVim)
                this.nvim.command('redraw', true);
        }
    }
    cancel() {
        let { tokenSource } = this;
        if (tokenSource) {
            tokenSource.cancel();
            this.tokenSource = null;
        }
    }
    dispose() {
        this.removeAllListeners();
        util_1.disposeAll(this.disposables);
    }
    get bufnr() {
        return this._bufnr;
    }
    get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;
    }
    get window() {
        return this.winid ? this.nvim.createWindow(this.winid) : null;
    }
    async activated() {
        if (!this.winid)
            return false;
        return await this.nvim.call('coc#util#valid_float_win', [this.winid]) != 0;
    }
    getMaxWindowHeight(docs) {
        let maxWidth = Math.min(this.maxWidth || 80, 80, this.env.columns);
        let w = maxWidth - 2;
        let h = 0;
        for (let doc of docs) {
            let lines = doc.content.split(/\r?\n/);
            for (let s of lines) {
                if (s.length == 0) {
                    h = h + 1;
                }
                else {
                    h = h + Math.ceil(string_1.byteLength(s.replace(/\t/g, '  ')) / w);
                }
            }
        }
        return Math.min(this.maxHeight, h);
    }
}
exports.default = FloatFactory;
//# sourceMappingURL=floatFactory.js.map

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Mutex {
    constructor() {
        this.tasks = [];
        this.count = 1;
    }
    sched() {
        if (this.count > 0 && this.tasks.length > 0) {
            this.count--;
            let next = this.tasks.shift();
            next();
        }
    }
    get busy() {
        return this.count == 0;
    }
    acquire() {
        return new Promise(res => {
            let task = () => {
                let released = false;
                res(() => {
                    if (!released) {
                        released = true;
                        this.count++;
                        this.sched();
                    }
                });
            };
            this.tasks.push(task);
            process.nextTick(this.sched.bind(this));
        });
    }
    use(f) {
        return this.acquire()
            .then(release => f()
            .then(res => {
            release();
            return res;
        })
            .catch(err => {
            release();
            throw err;
        }));
    }
}
exports.Mutex = Mutex;
//# sourceMappingURL=mutex.js.map

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const Snippets = tslib_1.__importStar(__webpack_require__(329));
const session_1 = __webpack_require__(330);
const variableResolve_1 = __webpack_require__(609);
const logger = __webpack_require__(64)('snippets-manager');
class SnippetManager {
    constructor() {
        this.sessionMap = new Map();
        this.disposables = [];
        workspace_1.default.onDidChangeTextDocument(async (e) => {
            let session = this.getSession(e.bufnr);
            if (session) {
                await session.synchronizeUpdatedPlaceholders(e.contentChanges[0]);
            }
        }, null, this.disposables);
        workspace_1.default.onDidCloseTextDocument(textDocument => {
            let doc = workspace_1.default.getDocument(textDocument.uri);
            if (!doc)
                return;
            let session = this.getSession(doc.bufnr);
            if (session)
                session.deactivate();
        }, null, this.disposables);
        events_1.default.on('BufEnter', async (bufnr) => {
            let session = this.getSession(bufnr);
            if (!this.statusItem)
                return;
            if (session && session.isActive) {
                this.statusItem.show();
            }
            else {
                this.statusItem.hide();
            }
        }, null, this.disposables);
        events_1.default.on('InsertEnter', async () => {
            let { session } = this;
            if (!session)
                return;
            await session.checkPosition();
        }, null, this.disposables);
    }
    init() {
        let config = workspace_1.default.getConfiguration('coc.preferences');
        this.statusItem = workspace_1.default.createStatusBarItem(0);
        this.statusItem.text = config.get('snippetStatusText', 'SNIP');
    }
    /**
     * Insert snippet at current cursor position
     */
    async insertSnippet(snippet, select = true, range) {
        let { bufnr } = workspace_1.default;
        let session = this.getSession(bufnr);
        if (!session) {
            session = new session_1.SnippetSession(workspace_1.default.nvim, bufnr);
            this.sessionMap.set(bufnr, session);
            session.onCancel(() => {
                this.sessionMap.delete(bufnr);
                if (workspace_1.default.bufnr == bufnr) {
                    this.statusItem.hide();
                }
            });
        }
        let isActive = await session.start(snippet, select, range);
        if (isActive)
            this.statusItem.show();
        return isActive;
    }
    async selectCurrentPlaceholder(triggerAutocmd = true) {
        let { session } = this;
        if (session)
            return await session.selectCurrentPlaceholder(triggerAutocmd);
    }
    async nextPlaceholder() {
        let { session } = this;
        if (session)
            return await session.nextPlaceholder();
        workspace_1.default.nvim.call('coc#snippet#disable', [], true);
        this.statusItem.hide();
    }
    async previousPlaceholder() {
        let { session } = this;
        if (session)
            return await session.previousPlaceholder();
        workspace_1.default.nvim.call('coc#snippet#disable', [], true);
        this.statusItem.hide();
    }
    cancel() {
        let session = this.getSession(workspace_1.default.bufnr);
        if (session)
            return session.deactivate();
        workspace_1.default.nvim.call('coc#snippet#disable', [], true);
        if (this.statusItem)
            this.statusItem.hide();
    }
    get session() {
        let session = this.getSession(workspace_1.default.bufnr);
        return session && session.isActive ? session : null;
    }
    isActived(bufnr) {
        let session = this.getSession(bufnr);
        return session && session.isActive;
    }
    jumpable() {
        let { session } = this;
        if (!session)
            return false;
        let placeholder = session.placeholder;
        if (placeholder && !placeholder.isFinalTabstop) {
            return true;
        }
        return false;
    }
    getSession(bufnr) {
        return this.sessionMap.get(bufnr);
    }
    async resolveSnippet(body) {
        let parser = new Snippets.SnippetParser();
        const snippet = parser.parse(body, true);
        const resolver = new variableResolve_1.SnippetVariableResolver();
        snippet.resolveVariables(resolver);
        return snippet;
    }
    dispose() {
        this.cancel();
        for (let d of this.disposables) {
            d.dispose();
        }
    }
}
exports.SnippetManager = SnippetManager;
exports.default = new SnippetManager();
//# sourceMappingURL=manager.js.map

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const bytes_1 = tslib_1.__importDefault(__webpack_require__(258));
const fast_diff_1 = tslib_1.__importDefault(__webpack_require__(259));
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const mkdirp_1 = tslib_1.__importDefault(__webpack_require__(260));
const os_1 = tslib_1.__importDefault(__webpack_require__(76));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const rimraf_1 = tslib_1.__importDefault(__webpack_require__(267));
const util_1 = tslib_1.__importDefault(__webpack_require__(74));
const uuid_1 = __webpack_require__(283);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_languageserver_textdocument_1 = __webpack_require__(293);
const vscode_uri_1 = __webpack_require__(243);
const which_1 = tslib_1.__importDefault(__webpack_require__(244));
const configuration_1 = tslib_1.__importDefault(__webpack_require__(294));
const shape_1 = tslib_1.__importDefault(__webpack_require__(305));
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const db_1 = tslib_1.__importDefault(__webpack_require__(306));
const document_1 = tslib_1.__importDefault(__webpack_require__(307));
const fileSystemWatcher_1 = tslib_1.__importDefault(__webpack_require__(313));
const mru_1 = tslib_1.__importDefault(__webpack_require__(314));
const outputChannel_1 = tslib_1.__importDefault(__webpack_require__(315));
const resolver_1 = tslib_1.__importDefault(__webpack_require__(317));
const status_1 = tslib_1.__importDefault(__webpack_require__(319));
const task_1 = tslib_1.__importDefault(__webpack_require__(320));
const terminal_1 = tslib_1.__importDefault(__webpack_require__(321));
const willSaveHandler_1 = tslib_1.__importDefault(__webpack_require__(322));
const types_1 = __webpack_require__(295);
const array_1 = __webpack_require__(308);
const fs_2 = __webpack_require__(304);
const index_1 = __webpack_require__(238);
const match_1 = __webpack_require__(323);
const mutex_1 = __webpack_require__(255);
const position_1 = __webpack_require__(311);
const string_1 = __webpack_require__(310);
const watchman_1 = tslib_1.__importDefault(__webpack_require__(324));
const object_1 = __webpack_require__(249);
const logger = __webpack_require__(64)('workspace');
let NAME_SPACE = 1080;
class Workspace {
    constructor() {
        this.keymaps = new Map();
        this.mutex = new mutex_1.Mutex();
        this.resolver = new resolver_1.default();
        this.rootPatterns = new Map();
        this._workspaceFolders = [];
        this._insertMode = false;
        this._cwd = process.cwd();
        this._initialized = false;
        this._attached = false;
        this.buffers = new Map();
        this.autocmdMaxId = 0;
        this.autocmds = new Map();
        this.terminals = new Map();
        this.creatingSources = new Map();
        this.outputChannels = new Map();
        this.schemeProviderMap = new Map();
        this.namespaceMap = new Map();
        this.disposables = [];
        this.watchedOptions = new Set();
        this._dynAutocmd = false;
        this._disposed = false;
        this._onDidOpenDocument = new vscode_languageserver_protocol_1.Emitter();
        this._onDidCloseDocument = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChangeDocument = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSaveDocument = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSaveDocument = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChangeConfiguration = new vscode_languageserver_protocol_1.Emitter();
        this._onDidWorkspaceInitialized = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpenTerminal = new vscode_languageserver_protocol_1.Emitter();
        this._onDidCloseTerminal = new vscode_languageserver_protocol_1.Emitter();
        this._onDidRuntimePathChange = new vscode_languageserver_protocol_1.Emitter();
        this.onDidCloseTerminal = this._onDidCloseTerminal.event;
        this.onDidOpenTerminal = this._onDidOpenTerminal.event;
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this.onDidOpenTextDocument = this._onDidOpenDocument.event;
        this.onDidCloseTextDocument = this._onDidCloseDocument.event;
        this.onDidChangeTextDocument = this._onDidChangeDocument.event;
        this.onWillSaveTextDocument = this._onWillSaveDocument.event;
        this.onDidSaveTextDocument = this._onDidSaveDocument.event;
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this.onDidWorkspaceInitialized = this._onDidWorkspaceInitialized.event;
        this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;
        let json = __webpack_require__(328);
        this.version = json.version;
        this.configurations = this.createConfigurations();
        this.willSaveUntilHandler = new willSaveHandler_1.default(this);
        let cwd = process.cwd();
        if (cwd != os_1.default.homedir() && fs_2.inDirectory(cwd, ['.vim'])) {
            this._workspaceFolders.push({
                uri: vscode_uri_1.URI.file(cwd).toString(),
                name: path_1.default.basename(cwd)
            });
        }
        this.setMessageLevel();
    }
    async init() {
        let { nvim } = this;
        this.statusLine = new status_1.default(nvim);
        this._env = await nvim.call('coc#util#vim_info');
        this._insertMode = this._env.mode.startsWith('insert');
        let preferences = this.getConfiguration('coc.preferences');
        let maxFileSize = preferences.get('maxFileSize', '10MB');
        this.maxFileSize = bytes_1.default.parse(maxFileSize);
        if (this._env.workspaceFolders) {
            this._workspaceFolders = this._env.workspaceFolders.map(f => ({
                uri: vscode_uri_1.URI.file(f).toString(),
                name: path_1.default.dirname(f)
            }));
        }
        this.configurations.updateUserConfig(this._env.config);
        events_1.default.on('InsertEnter', () => {
            this._insertMode = true;
        }, null, this.disposables);
        events_1.default.on('InsertLeave', () => {
            this._insertMode = false;
        }, null, this.disposables);
        events_1.default.on('BufWinLeave', (_, winid) => {
            this.nvim.call('coc#util#clear_pos_matches', ['^Coc', winid], true);
        }, null, this.disposables);
        events_1.default.on('BufEnter', this.onBufEnter, this, this.disposables);
        events_1.default.on('CursorMoved', this.checkCurrentBuffer, this, this.disposables);
        events_1.default.on('CursorMovedI', this.checkCurrentBuffer, this, this.disposables);
        events_1.default.on('DirChanged', this.onDirChanged, this, this.disposables);
        events_1.default.on('BufCreate', this.onBufCreate, this, this.disposables);
        events_1.default.on('BufUnload', this.onBufUnload, this, this.disposables);
        events_1.default.on('TermOpen', this.onBufCreate, this, this.disposables);
        events_1.default.on('TermClose', this.onBufUnload, this, this.disposables);
        events_1.default.on('BufWritePost', this.onBufWritePost, this, this.disposables);
        events_1.default.on('BufWritePre', this.onBufWritePre, this, this.disposables);
        events_1.default.on('FileType', this.onFileTypeChange, this, this.disposables);
        events_1.default.on('CursorHold', this.checkCurrentBuffer, this, this.disposables);
        events_1.default.on('TextChanged', this.checkBuffer, this, this.disposables);
        events_1.default.on('BufReadCmd', this.onBufReadCmd, this, this.disposables);
        events_1.default.on('VimResized', (columns, lines) => {
            Object.assign(this._env, { columns, lines });
        }, null, this.disposables);
        await this.attach();
        this.attachChangedEvents();
        this.configurations.onDidChange(e => {
            this._onDidChangeConfiguration.fire(e);
        }, null, this.disposables);
        this.watchOption('runtimepath', (oldValue, newValue) => {
            let result = fast_diff_1.default(oldValue, newValue);
            for (let [changeType, value] of result) {
                if (changeType == 1) {
                    let paths = value.replace(/,$/, '').split(',');
                    this._onDidRuntimePathChange.fire(paths);
                }
            }
            this._env.runtimepath = newValue;
        }, this.disposables);
        this.watchOption('iskeyword', (_, newValue) => {
            let doc = this.getDocument(this.bufnr);
            if (doc)
                doc.setIskeyword(newValue);
        }, this.disposables);
        this.watchOption('completeopt', async (_, newValue) => {
            this.env.completeOpt = newValue;
            if (!this._attached)
                return;
            if (this.insertMode) {
                let suggest = this.getConfiguration('suggest');
                if (suggest.get('autoTrigger') == 'always') {
                    let content = await this.nvim.call('execute', ['verbose set completeopt']);
                    let lines = content.split(/\r?\n/);
                    console.error(`Some plugin change completeopt on insert mode: ${lines[lines.length - 1].trim()}!`);
                }
            }
        }, this.disposables);
        this.watchGlobal('coc_sources_disable_map', async (_, newValue) => {
            this.env.disabledSources = newValue;
        });
        let provider = {
            onDidChange: null,
            provideTextDocumentContent: async (uri) => {
                let channel = this.outputChannels.get(uri.path.slice(1));
                if (!channel)
                    return '';
                nvim.pauseNotification();
                nvim.command('setlocal nospell nofoldenable nowrap noswapfile', true);
                nvim.command('setlocal buftype=nofile bufhidden=hide', true);
                nvim.command('setfiletype log', true);
                await nvim.resumeNotification();
                return channel.content;
            }
        };
        this.disposables.push(this.registerTextDocumentContentProvider('output', provider));
    }
    getConfigFile(target) {
        return this.configurations.getConfigFile(target);
    }
    /**
     * Register autocmd on vim.
     */
    registerAutocmd(autocmd) {
        this.autocmdMaxId += 1;
        let id = this.autocmdMaxId;
        this.autocmds.set(id, autocmd);
        this.setupDynamicAutocmd();
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.autocmds.delete(id);
            this.setupDynamicAutocmd();
        });
    }
    /**
     * Watch for option change.
     */
    watchOption(key, callback, disposables) {
        let watching = this.watchedOptions.has(key);
        if (!watching) {
            this.watchedOptions.add(key);
            this.setupDynamicAutocmd();
        }
        let disposable = events_1.default.on('OptionSet', async (changed, oldValue, newValue) => {
            if (changed == key && callback) {
                await Promise.resolve(callback(oldValue, newValue));
            }
        });
        if (disposables) {
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                disposable.dispose();
                if (watching)
                    return;
                this.watchedOptions.delete(key);
                this.setupDynamicAutocmd();
            }));
        }
    }
    /**
     * Watch global variable, works on neovim only.
     */
    watchGlobal(key, callback, disposables) {
        let { nvim } = this;
        nvim.call('coc#_watch', key, true);
        let disposable = events_1.default.on('GlobalChange', async (changed, oldValue, newValue) => {
            if (changed == key && callback) {
                await Promise.resolve(callback(oldValue, newValue));
            }
        });
        if (disposables) {
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                disposable.dispose();
                nvim.call('coc#_unwatch', key, true);
            }));
        }
    }
    get cwd() {
        return this._cwd;
    }
    get env() {
        return this._env;
    }
    get root() {
        return this._root || this.cwd;
    }
    get rootPath() {
        return this.root;
    }
    get workspaceFolders() {
        return this._workspaceFolders;
    }
    /**
     * uri of current file, could be null
     */
    get uri() {
        let { bufnr } = this;
        if (bufnr) {
            let document = this.getDocument(bufnr);
            if (document && document.schema == 'file') {
                return document.uri;
            }
        }
        return null;
    }
    get workspaceFolder() {
        let { rootPath } = this;
        if (rootPath == os_1.default.homedir())
            return null;
        return {
            uri: vscode_uri_1.URI.file(rootPath).toString(),
            name: path_1.default.basename(rootPath)
        };
    }
    async openLocalConfig() {
        let { root } = this;
        if (root == os_1.default.homedir()) {
            this.showMessage(`Can't create local config in home directory`, 'warning');
            return;
        }
        let dir = path_1.default.join(root, '.vim');
        if (!fs_1.default.existsSync(dir)) {
            let res = await this.showPrompt(`Would you like to create folder'${root}/.vim'?`);
            if (!res)
                return;
            fs_1.default.mkdirSync(dir);
        }
        await this.jumpTo(vscode_uri_1.URI.file(path_1.default.join(dir, index_1.CONFIG_FILE_NAME)).toString());
    }
    get textDocuments() {
        let docs = [];
        for (let b of this.buffers.values()) {
            docs.push(b.textDocument);
        }
        return docs;
    }
    get documents() {
        return Array.from(this.buffers.values());
    }
    createNameSpace(name = '') {
        if (this.namespaceMap.has(name))
            return this.namespaceMap.get(name);
        NAME_SPACE = NAME_SPACE + 1;
        this.namespaceMap.set(name, NAME_SPACE);
        return NAME_SPACE;
    }
    get channelNames() {
        return Array.from(this.outputChannels.keys());
    }
    get pluginRoot() {
        return path_1.default.dirname(__dirname);
    }
    get isVim() {
        return this._env.isVim;
    }
    get isNvim() {
        return !this._env.isVim;
    }
    get completeOpt() {
        return this._env.completeOpt;
    }
    get initialized() {
        return this._initialized;
    }
    get ready() {
        if (this._initialized)
            return Promise.resolve();
        return new Promise(resolve => {
            let disposable = this.onDidWorkspaceInitialized(() => {
                disposable.dispose();
                resolve();
            });
        });
    }
    /**
     * Current filetypes.
     */
    get filetypes() {
        let res = new Set();
        for (let doc of this.documents) {
            res.add(doc.filetype);
        }
        return res;
    }
    /**
     * Check if selector match document.
     */
    match(selector, document) {
        return match_1.score(selector, document.uri, document.languageId);
    }
    /**
     * Findup for filename or filenames from current filepath or root.
     */
    async findUp(filename) {
        let { cwd } = this;
        let filepath = await this.nvim.call('expand', '%:p');
        filepath = path_1.default.normalize(filepath);
        let isFile = filepath && path_1.default.isAbsolute(filepath);
        if (isFile && !fs_2.isParentFolder(cwd, filepath, true)) {
            // can't use cwd
            return fs_2.findUp(filename, path_1.default.dirname(filepath));
        }
        let res = fs_2.findUp(filename, cwd);
        if (res && res != os_1.default.homedir())
            return res;
        if (isFile)
            return fs_2.findUp(filename, path_1.default.dirname(filepath));
        return null;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async resolveRootFolder(uri, patterns) {
        let { cwd } = this;
        if (uri.scheme != 'file')
            return cwd;
        let filepath = path_1.default.normalize(uri.fsPath);
        let dir = path_1.default.dirname(filepath);
        return fs_2.resolveRoot(dir, patterns) || dir;
    }
    /**
     * Create a FileSystemWatcher instance,
     * doesn't fail when watchman not found.
     */
    createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {
        let watchmanPath = global.hasOwnProperty('__TEST__') ? null : this.getWatchmanPath();
        let channel = watchmanPath ? this.createOutputChannel('watchman') : null;
        let promise = watchmanPath ? watchman_1.default.createClient(watchmanPath, this.root, channel) : Promise.resolve(null);
        let watcher = new fileSystemWatcher_1.default(promise, globPattern, !!ignoreCreate, !!ignoreChange, !!ignoreDelete);
        return watcher;
    }
    getWatchmanPath() {
        const preferences = this.getConfiguration('coc.preferences');
        let watchmanPath = preferences.get('watchmanPath', 'watchman');
        try {
            return which_1.default.sync(watchmanPath);
        }
        catch (e) {
            return null;
        }
    }
    /**
     * Get configuration by section and optional resource uri.
     */
    getConfiguration(section, resource) {
        return this.configurations.getConfiguration(section, resource);
    }
    /**
     * Get created document by uri or bufnr.
     */
    getDocument(uri) {
        if (typeof uri === 'number') {
            return this.buffers.get(uri);
        }
        const caseInsensitive = index_1.platform.isWindows || index_1.platform.isMacintosh;
        uri = vscode_uri_1.URI.parse(uri).toString();
        for (let doc of this.buffers.values()) {
            if (!doc)
                continue;
            if (doc.uri === uri)
                return doc;
            if (caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase())
                return doc;
        }
        return null;
    }
    /**
     * Get current cursor offset in document.
     */
    async getOffset() {
        let document = await this.document;
        let pos = await this.getCursorPosition();
        let doc = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', '', 0, document.getDocumentContent());
        return doc.offsetAt(pos);
    }
    /**
     * Apply WorkspaceEdit.
     */
    async applyEdit(edit) {
        let { nvim } = this;
        let { documentChanges, changes } = edit;
        let [bufnr, cursor] = await nvim.eval('[bufnr("%"),coc#util#cursor()]');
        let document = this.getDocument(bufnr);
        let uri = document ? document.uri : null;
        let currEdits = null;
        let locations = [];
        let changeCount = 0;
        const preferences = this.getConfiguration('coc.preferences');
        let promptUser = !global.hasOwnProperty('__TEST__') && preferences.get('promptWorkspaceEdit', true);
        let listTarget = preferences.get('listOfWorkspaceEdit', 'quickfix');
        try {
            if (documentChanges && documentChanges.length) {
                let changedUris = this.getChangedUris(documentChanges);
                changeCount = changedUris.length;
                if (promptUser) {
                    let diskCount = 0;
                    for (let uri of changedUris) {
                        if (!this.getDocument(uri)) {
                            diskCount = diskCount + 1;
                        }
                    }
                    if (diskCount) {
                        let res = await this.showPrompt(`${diskCount} documents on disk would be loaded for change, confirm?`);
                        if (!res)
                            return;
                    }
                }
                let changedMap = new Map();
                // let changes: Map<string, TextEdit[]> = new Map()
                let textEdits = [];
                for (let i = 0; i < documentChanges.length; i++) {
                    let change = documentChanges[i];
                    if (index_1.isDocumentEdit(change)) {
                        let { textDocument, edits } = change;
                        let next = documentChanges[i + 1];
                        textEdits.push(...edits);
                        if (next && index_1.isDocumentEdit(next) && object_1.equals(next.textDocument, textDocument)) {
                            continue;
                        }
                        let doc = await this.loadFile(textDocument.uri);
                        if (textDocument.uri == uri)
                            currEdits = textEdits;
                        await doc.applyEdits(textEdits);
                        for (let edit of textEdits) {
                            locations.push({ uri: doc.uri, range: edit.range });
                        }
                        textEdits = [];
                    }
                    else if (vscode_languageserver_protocol_1.CreateFile.is(change)) {
                        let file = vscode_uri_1.URI.parse(change.uri).fsPath;
                        await this.createFile(file, change.options);
                    }
                    else if (vscode_languageserver_protocol_1.RenameFile.is(change)) {
                        changedMap.set(change.oldUri, change.newUri);
                        await this.renameFile(vscode_uri_1.URI.parse(change.oldUri).fsPath, vscode_uri_1.URI.parse(change.newUri).fsPath, change.options);
                    }
                    else if (vscode_languageserver_protocol_1.DeleteFile.is(change)) {
                        await this.deleteFile(vscode_uri_1.URI.parse(change.uri).fsPath, change.options);
                    }
                }
                // fix location uris on renameFile
                if (changedMap.size) {
                    locations.forEach(location => {
                        let newUri = changedMap.get(location.uri);
                        if (newUri)
                            location.uri = newUri;
                    });
                }
            }
            else if (changes) {
                let uris = Object.keys(changes);
                let unloaded = uris.filter(uri => this.getDocument(uri) == null);
                if (unloaded.length) {
                    if (promptUser) {
                        let res = await this.showPrompt(`${unloaded.length} documents on disk would be loaded for change, confirm?`);
                        if (!res)
                            return;
                    }
                    await this.loadFiles(unloaded);
                }
                for (let uri of Object.keys(changes)) {
                    let document = this.getDocument(uri);
                    if (vscode_uri_1.URI.parse(uri).toString() == uri)
                        currEdits = changes[uri];
                    let edits = changes[uri];
                    for (let edit of edits) {
                        locations.push({ uri: document.uri, range: edit.range });
                    }
                    await document.applyEdits(edits);
                }
                changeCount = uris.length;
            }
            if (currEdits) {
                let changed = position_1.getChangedFromEdits({ line: cursor[0], character: cursor[1] }, currEdits);
                if (changed)
                    await this.moveTo({
                        line: cursor[0] + changed.line,
                        character: cursor[1] + changed.character
                    });
            }
            if (locations.length) {
                let items = await Promise.all(locations.map(loc => this.getQuickfixItem(loc)));
                let silent = locations.every(l => l.uri == uri);
                if (listTarget == 'quickfix') {
                    await this.nvim.call('setqflist', [items]);
                    if (!silent)
                        this.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :copen to open quickfix list`, 'more');
                }
                else if (listTarget == 'location') {
                    await nvim.setVar('coc_jump_locations', items);
                    if (!silent)
                        this.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :CocList location to manage changed locations`, 'more');
                }
            }
        }
        catch (e) {
            logger.error(e);
            this.showMessage(`Error on applyEdits: ${e.message}`, 'error');
            return false;
        }
        await index_1.wait(50);
        return true;
    }
    /**
     * Convert location to quickfix item.
     */
    async getQuickfixItem(loc, text, type = '', module) {
        if (vscode_languageserver_protocol_1.LocationLink.is(loc)) {
            loc = vscode_languageserver_protocol_1.Location.create(loc.targetUri, loc.targetRange);
        }
        let doc = this.getDocument(loc.uri);
        let { uri, range } = loc;
        let { line, character } = range.start;
        let u = vscode_uri_1.URI.parse(uri);
        let bufnr = doc ? doc.bufnr : -1;
        if (!text && u.scheme == 'file') {
            text = await this.getLine(uri, line);
            character = string_1.byteIndex(text, character);
        }
        let item = {
            uri,
            filename: u.scheme == 'file' ? u.fsPath : uri,
            lnum: line + 1,
            col: character + 1,
            text: text || '',
            range
        };
        if (module)
            item.module = module;
        if (type)
            item.type = type;
        if (bufnr != -1)
            item.bufnr = bufnr;
        return item;
    }
    /**
     * Create persistence Mru instance.
     */
    createMru(name) {
        return new mru_1.default(name);
    }
    /**
     * Get selected range for current document
     */
    async getSelectedRange(mode, document) {
        let { nvim } = this;
        if (mode == 'n') {
            let line = await nvim.call('line', ['.']);
            let content = document.getline(line - 1);
            if (!content.length)
                return null;
            return vscode_languageserver_protocol_1.Range.create(line - 1, 0, line - 1, content.length);
        }
        if (!['v', 'V', 'char', 'line', '\x16'].includes(mode)) {
            throw new Error(`Mode '${mode}' not supported`);
        }
        let isVisual = ['v', 'V', '\x16'].includes(mode);
        let [, sl, sc] = await nvim.call('getpos', isVisual ? `'<` : `'[`);
        let [, el, ec] = await nvim.call('getpos', isVisual ? `'>` : `']`);
        let range = vscode_languageserver_protocol_1.Range.create(document.getPosition(sl, sc), document.getPosition(el, ec));
        if (mode == 'v' || mode == '\x16') {
            range.end.character = range.end.character + 1;
        }
        return range;
    }
    /**
     * Visual select range of current document
     */
    async selectRange(range) {
        let { nvim } = this;
        let { start, end } = range;
        let [bufnr, ve, selection] = await nvim.eval(`[bufnr('%'), &virtualedit, &selection, mode()]`);
        let document = this.getDocument(bufnr);
        if (!document)
            return;
        let line = document.getline(start.line);
        let col = line ? string_1.byteLength(line.slice(0, start.character)) : 0;
        let endLine = document.getline(end.line);
        let endCol = endLine ? string_1.byteLength(endLine.slice(0, end.character)) : 0;
        let move_cmd = '';
        let resetVirtualEdit = false;
        move_cmd += 'v';
        endCol = await nvim.eval(`virtcol([${end.line + 1}, ${endCol}])`);
        if (selection == 'inclusive') {
            if (end.character == 0) {
                move_cmd += `${end.line}G`;
            }
            else {
                move_cmd += `${end.line + 1}G${endCol}|`;
            }
        }
        else if (selection == 'old') {
            move_cmd += `${end.line + 1}G${endCol}|`;
        }
        else {
            move_cmd += `${end.line + 1}G${endCol + 1}|`;
        }
        col = await nvim.eval(`virtcol([${start.line + 1}, ${col}])`);
        move_cmd += `o${start.line + 1}G${col + 1}|o`;
        nvim.pauseNotification();
        if (ve != 'onemore') {
            resetVirtualEdit = true;
            nvim.setOption('virtualedit', 'onemore', true);
        }
        nvim.command(`noa call cursor(${start.line + 1},${col + (move_cmd == 'a' ? 0 : 1)})`, true);
        // nvim.call('eval', [`feedkeys("${move_cmd}", 'in')`], true)
        nvim.command(`normal! ${move_cmd}`, true);
        if (resetVirtualEdit)
            nvim.setOption('virtualedit', ve, true);
        if (this.isVim)
            nvim.command('redraw', true);
        await nvim.resumeNotification();
    }
    /**
     * Populate locations to UI.
     */
    async showLocations(locations) {
        let items = await Promise.all(locations.map(loc => this.getQuickfixItem(loc)));
        let { nvim } = this;
        const preferences = this.getConfiguration('coc.preferences');
        if (preferences.get('useQuickfixForLocations', false)) {
            let openCommand = await nvim.getVar('coc_quickfix_open_command');
            nvim.command(typeof openCommand === 'string' ? openCommand : 'copen', true);
            nvim.pauseNotification();
            nvim.call('setqflist', [items], true);
            nvim.command(openCommand, true);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            nvim.resumeNotification(false, true);
        }
        else {
            await nvim.setVar('coc_jump_locations', items);
            if (this.env.locationlist) {
                nvim.command('CocList --normal --auto-preview location', true);
            }
            else {
                nvim.call('coc#util#do_autocmd', ['CocLocationsChange'], true);
            }
        }
    }
    /**
     * Get content of line by uri and line.
     */
    async getLine(uri, line) {
        let document = this.getDocument(uri);
        if (document)
            return document.getline(line) || '';
        if (!uri.startsWith('file:'))
            return '';
        return await fs_2.readFileLine(vscode_uri_1.URI.parse(uri).fsPath, line);
    }
    /**
     * Get position for matchaddpos from range & uri
     */
    async getHighlightPositions(uri, range) {
        let res = [];
        if (position_1.comparePosition(range.start, range.end) == 0)
            return [];
        let arr = [];
        for (let i = range.start.line; i <= range.end.line; i++) {
            let curr = await this.getLine(uri, range.start.line);
            if (!curr)
                continue;
            let sc = i == range.start.line ? range.start.character : 0;
            let ec = i == range.end.line ? range.end.character : curr.length;
            if (sc == ec)
                continue;
            arr.push([vscode_languageserver_protocol_1.Range.create(i, sc, i, ec), curr]);
        }
        for (let [r, line] of arr) {
            let start = string_1.byteIndex(line, r.start.character) + 1;
            let end = string_1.byteIndex(line, r.end.character) + 1;
            res.push([r.start.line + 1, start, end - start]);
        }
        return res;
    }
    /**
     * Get WorkspaceFolder of uri
     */
    getWorkspaceFolder(uri) {
        this.workspaceFolders.sort((a, b) => b.uri.length - a.uri.length);
        let filepath = vscode_uri_1.URI.parse(uri).fsPath;
        return this.workspaceFolders.find(folder => fs_2.isParentFolder(vscode_uri_1.URI.parse(folder.uri).fsPath, filepath, true));
    }
    /**
     * Get content from buffer of file by uri.
     */
    async readFile(uri) {
        let document = this.getDocument(uri);
        if (document) {
            await document.patchChange();
            return document.content;
        }
        let u = vscode_uri_1.URI.parse(uri);
        if (u.scheme != 'file')
            return '';
        let encoding = await this.getFileEncoding();
        return await fs_2.readFile(u.fsPath, encoding);
    }
    getFilepath(filepath) {
        let { cwd } = this;
        let rel = path_1.default.relative(cwd, filepath);
        return rel.startsWith('..') ? filepath : rel;
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    onWillSaveUntil(callback, thisArg, clientId) {
        return this.willSaveUntilHandler.addCallback(callback, thisArg, clientId);
    }
    /**
     * Echo lines.
     */
    async echoLines(lines, truncate = false) {
        let { nvim } = this;
        let cmdHeight = this.env.cmdheight;
        if (lines.length > cmdHeight && truncate) {
            lines = lines.slice(0, cmdHeight);
        }
        let maxLen = this.env.columns - 12;
        lines = lines.map(line => {
            line = line.replace(/\n/g, ' ');
            if (truncate)
                line = line.slice(0, maxLen);
            return line;
        });
        if (truncate && lines.length == cmdHeight) {
            let last = lines[lines.length - 1];
            lines[cmdHeight - 1] = `${last.length == maxLen ? last.slice(0, -4) : last} ...`;
        }
        await nvim.call('coc#util#echo_lines', [lines]);
    }
    /**
     * Show message in vim.
     */
    showMessage(msg, identify = 'more') {
        if (this.mutex.busy || !this.nvim)
            return;
        let { messageLevel } = this;
        let method = process.env.VIM_NODE_RPC == '1' ? 'callTimer' : 'call';
        let hl = 'Error';
        let level = types_1.MessageLevel.Error;
        switch (identify) {
            case 'more':
                level = types_1.MessageLevel.More;
                hl = 'MoreMsg';
                break;
            case 'warning':
                level = types_1.MessageLevel.Warning;
                hl = 'WarningMsg';
                break;
        }
        if (level >= messageLevel) {
            this.nvim[method]('coc#util#echo_messages', [hl, ('[coc.nvim] ' + msg).split('\n')], true);
        }
    }
    /**
     * Current document.
     */
    get document() {
        let { bufnr } = this;
        if (bufnr == null)
            return null;
        if (this.buffers.has(bufnr)) {
            return Promise.resolve(this.buffers.get(bufnr));
        }
        if (!this.creatingSources.has(bufnr)) {
            this.onBufCreate(bufnr).logError();
        }
        return new Promise(resolve => {
            let disposable = this.onDidOpenTextDocument(doc => {
                disposable.dispose();
                resolve(this.getDocument(doc.uri));
            });
        });
    }
    /**
     * Get current cursor position.
     */
    async getCursorPosition() {
        let [line, character] = await this.nvim.call('coc#util#cursor');
        return vscode_languageserver_protocol_1.Position.create(line, character);
    }
    /**
     * Get current document and position.
     */
    async getCurrentState() {
        let document = await this.document;
        let position = await this.getCursorPosition();
        return {
            document: document.textDocument,
            position
        };
    }
    /**
     * Get format options
     */
    async getFormatOptions(uri) {
        let doc;
        if (uri)
            doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : 0;
        let [tabSize, insertSpaces] = await this.nvim.call('coc#util#get_format_opts', [bufnr]);
        return {
            tabSize,
            insertSpaces: insertSpaces == 1
        };
    }
    /**
     * Jump to location.
     */
    async jumpTo(uri, position, openCommand) {
        const preferences = this.getConfiguration('coc.preferences');
        let jumpCommand = openCommand || preferences.get('jumpCommand', 'edit');
        let { nvim } = this;
        let doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : -1;
        if (bufnr != -1 && jumpCommand == 'edit') {
            // use buffer command since edit command would reload the buffer
            nvim.pauseNotification();
            nvim.command(`silent! normal! m'`, true);
            nvim.command(`buffer ${bufnr}`, true);
            if (position) {
                let line = doc.getline(position.line);
                let col = string_1.byteLength(line.slice(0, position.character)) + 1;
                nvim.call('cursor', [position.line + 1, col], true);
            }
            if (this.isVim)
                nvim.command('redraw', true);
            await nvim.resumeNotification();
        }
        else {
            let { fsPath, scheme } = vscode_uri_1.URI.parse(uri);
            let pos = position == null ? null : [position.line, position.character];
            if (scheme == 'file') {
                let bufname = fs_2.fixDriver(path_1.default.normalize(fsPath));
                await this.nvim.call('coc#util#jump', [jumpCommand, bufname, pos]);
            }
            else {
                await this.nvim.call('coc#util#jump', [jumpCommand, uri, pos]);
            }
        }
    }
    /**
     * Move cursor to position.
     */
    async moveTo(position) {
        await this.nvim.call('coc#util#jumpTo', [position.line, position.character]);
        if (this.isVim)
            this.nvim.command('redraw', true);
    }
    /**
     * Create a file in vim and disk
     */
    async createFile(filepath, opts = {}) {
        let stat = await fs_2.statAsync(filepath);
        if (stat && !opts.overwrite && !opts.ignoreIfExists) {
            this.showMessage(`${filepath} already exists!`, 'error');
            return;
        }
        if (!stat || opts.overwrite) {
            // directory
            if (filepath.endsWith('/')) {
                try {
                    filepath = this.expand(filepath);
                    await mkdirp_1.default(filepath);
                }
                catch (e) {
                    this.showMessage(`Can't create ${filepath}: ${e.message}`, 'error');
                }
            }
            else {
                let uri = vscode_uri_1.URI.file(filepath).toString();
                let doc = this.getDocument(uri);
                if (doc)
                    return;
                let encoding = await this.getFileEncoding();
                fs_1.default.writeFileSync(filepath, '', encoding || '');
                await this.loadFile(uri);
            }
        }
    }
    /**
     * Load uri as document.
     */
    async loadFile(uri) {
        let doc = this.getDocument(uri);
        if (doc)
            return doc;
        let { nvim } = this;
        let filepath = uri.startsWith('file') ? vscode_uri_1.URI.parse(uri).fsPath : uri;
        nvim.call('coc#util#open_files', [[filepath]], true);
        return await new Promise((resolve, reject) => {
            let disposable = this.onDidOpenTextDocument(textDocument => {
                let fsPath = vscode_uri_1.URI.parse(textDocument.uri).fsPath;
                if (textDocument.uri == uri || fsPath == filepath) {
                    clearTimeout(timer);
                    disposable.dispose();
                    resolve(this.getDocument(uri));
                }
            });
            let timer = setTimeout(() => {
                disposable.dispose();
                reject(new Error(`Create document ${uri} timeout after 1s.`));
            }, 1000);
        });
    }
    /**
     * Load the files that not loaded
     */
    async loadFiles(uris) {
        uris = uris.filter(uri => this.getDocument(uri) == null);
        if (!uris.length)
            return;
        let bufnrs = await this.nvim.call('coc#util#open_files', [uris.map(u => vscode_uri_1.URI.parse(u).fsPath)]);
        let create = bufnrs.filter(bufnr => this.getDocument(bufnr) == null);
        if (!create.length)
            return;
        create.map(bufnr => this.onBufCreate(bufnr).logError());
        return new Promise((resolve, reject) => {
            let timer = setTimeout(() => {
                disposable.dispose();
                reject(new Error(`Create document timeout after 2s.`));
            }, 2000);
            let disposable = this.onDidOpenTextDocument(() => {
                if (uris.every(uri => this.getDocument(uri) != null)) {
                    clearTimeout(timer);
                    disposable.dispose();
                    resolve();
                }
            });
        });
    }
    /**
     * Rename file in vim and disk
     */
    async renameFile(oldPath, newPath, opts = {}) {
        let { overwrite, ignoreIfExists } = opts;
        let { nvim } = this;
        try {
            let stat = await fs_2.statAsync(newPath);
            if (stat && !overwrite && !ignoreIfExists) {
                throw new Error(`${newPath} already exists`);
            }
            if (!stat || overwrite) {
                let uri = vscode_uri_1.URI.file(oldPath).toString();
                let newUri = vscode_uri_1.URI.file(newPath).toString();
                let doc = this.getDocument(uri);
                let isCurrent = doc.bufnr == this.bufnr;
                let newDoc = this.getDocument(newUri);
                if (newDoc)
                    await this.nvim.command(`silent ${newDoc.bufnr}bwipeout!`);
                if (doc != null) {
                    let content = doc.getDocumentContent();
                    let encoding = await doc.buffer.getOption('fileencoding');
                    await util_1.default.promisify(fs_1.default.writeFile)(newPath, content, { encoding });
                    // open renamed file
                    if (!isCurrent) {
                        await nvim.call('coc#util#open_files', [[newPath]]);
                        await nvim.command(`silent ${doc.bufnr}bwipeout!`);
                    }
                    else {
                        let view = await nvim.call('winsaveview');
                        nvim.pauseNotification();
                        nvim.call('coc#util#open_file', ['keepalt edit', newPath], true);
                        nvim.command(`silent ${doc.bufnr}bwipeout!`, true);
                        nvim.call('winrestview', [view], true);
                        await nvim.resumeNotification();
                    }
                    // avoid vim detect file unlink
                    await util_1.default.promisify(fs_1.default.unlink)(oldPath);
                }
                else {
                    await fs_2.renameAsync(oldPath, newPath);
                }
            }
        }
        catch (e) {
            this.showMessage(`Rename error: ${e.message}`, 'error');
        }
    }
    /**
     * Delete file from vim and disk.
     */
    async deleteFile(filepath, opts = {}) {
        let { ignoreIfNotExists, recursive } = opts;
        let stat = await fs_2.statAsync(filepath.replace(/\/$/, ''));
        let isDir = stat && stat.isDirectory();
        if (filepath.endsWith('/') && !isDir) {
            this.showMessage(`${filepath} is not directory`, 'error');
            return;
        }
        if (!stat && !ignoreIfNotExists) {
            this.showMessage(`${filepath} not exists`, 'error');
            return;
        }
        if (stat == null)
            return;
        if (isDir && !recursive) {
            this.showMessage(`Can't remove directory, recursive not set`, 'error');
            return;
        }
        try {
            if (isDir && recursive) {
                rimraf_1.default.sync(filepath);
            }
            else if (isDir) {
                await util_1.default.promisify(fs_1.default.rmdir)(filepath);
            }
            else {
                await util_1.default.promisify(fs_1.default.unlink)(filepath);
            }
            if (!isDir) {
                let uri = vscode_uri_1.URI.file(filepath).toString();
                let doc = this.getDocument(uri);
                if (doc)
                    await this.nvim.command(`silent! bwipeout! ${doc.bufnr}`);
            }
        }
        catch (e) {
            this.showMessage(`Error on delete ${filepath}: ${e.message}`, 'error');
        }
    }
    /**
     * Open resource by uri
     */
    async openResource(uri) {
        let { nvim } = this;
        // not supported
        if (uri.startsWith('http')) {
            await nvim.call('coc#util#open_url', uri);
            return;
        }
        let wildignore = await nvim.getOption('wildignore');
        await nvim.setOption('wildignore', '');
        await this.jumpTo(uri);
        await nvim.setOption('wildignore', wildignore);
    }
    /**
     * Create a new output channel
     */
    createOutputChannel(name) {
        if (this.outputChannels.has(name))
            return this.outputChannels.get(name);
        let channel = new outputChannel_1.default(name, this.nvim);
        this.outputChannels.set(name, channel);
        return channel;
    }
    /**
     * Reveal buffer of output channel.
     */
    showOutputChannel(name, preserveFocus) {
        let channel = this.outputChannels.get(name);
        if (!channel) {
            this.showMessage(`Channel "${name}" not found`, 'error');
            return;
        }
        channel.show(preserveFocus);
    }
    /**
     * Resovle module from yarn or npm.
     */
    async resolveModule(name) {
        return await this.resolver.resolveModule(name);
    }
    /**
     * Run nodejs command
     */
    async runCommand(cmd, cwd, timeout) {
        cwd = cwd || this.cwd;
        return index_1.runCommand(cmd, { cwd }, timeout);
    }
    /**
     * Run command in vim terminal for result
     */
    async runTerminalCommand(cmd, cwd = this.cwd, keepfocus = false) {
        return await this.nvim.callAsync('coc#util#run_terminal', { cmd, cwd, keepfocus: keepfocus ? 1 : 0 });
    }
    /**
     * Open terminal buffer with cmd & opts
     */
    async openTerminal(cmd, opts = {}) {
        let bufnr = await this.nvim.call('coc#util#open_terminal', Object.assign({ cmd }, opts));
        return bufnr;
    }
    /**
     * Expand filepath with `~` and/or environment placeholders
     */
    expand(filepath) {
        if (!filepath)
            return filepath;
        if (filepath.startsWith('~')) {
            filepath = os_1.default.homedir() + filepath.slice(1);
        }
        if (filepath.includes('$')) {
            let doc = this.getDocument(this.bufnr);
            let fsPath = doc ? vscode_uri_1.URI.parse(doc.uri).fsPath : '';
            filepath = filepath.replace(/\$\{(.*?)\}/g, (match, name) => {
                if (name.startsWith('env:')) {
                    let key = name.split(':')[1];
                    let val = key ? process.env[key] : '';
                    return val;
                }
                switch (name) {
                    case 'workspace':
                    case 'workspaceRoot':
                    case 'workspaceFolder':
                        return this.root;
                    case 'workspaceFolderBasename':
                        return path_1.default.dirname(this.root);
                    case 'cwd':
                        return this.cwd;
                    case 'file':
                        return fsPath;
                    case 'fileDirname':
                        return fsPath ? path_1.default.dirname(fsPath) : '';
                    case 'fileExtname':
                        return fsPath ? path_1.default.extname(fsPath) : '';
                    case 'fileBasename':
                        return fsPath ? path_1.default.basename(fsPath) : '';
                    case 'fileBasenameNoExtension': {
                        let basename = fsPath ? path_1.default.basename(fsPath) : '';
                        return basename ? basename.slice(0, basename.length - path_1.default.extname(basename).length) : '';
                    }
                    default:
                        return match;
                }
            });
            filepath = filepath.replace(/\$[\w]+/g, match => {
                if (match == '$HOME')
                    return os_1.default.homedir();
                return process.env[match.slice(1)] || match;
            });
        }
        return filepath;
    }
    async createTerminal(opts) {
        let cmd = opts.shellPath;
        let args = opts.shellArgs;
        if (!cmd)
            cmd = await this.nvim.getOption('shell');
        let terminal = new terminal_1.default(cmd, args || [], this.nvim, opts.name);
        await terminal.start(opts.cwd || this.cwd, opts.env);
        this.terminals.set(terminal.bufnr, terminal);
        this._onDidOpenTerminal.fire(terminal);
        return terminal;
    }
    /**
     * Show quickpick
     */
    async showQuickpick(items, placeholder = 'Choose by number') {
        let release = await this.mutex.acquire();
        try {
            let title = placeholder + ':';
            items = items.map((s, idx) => `${idx + 1}. ${s}`);
            let res = await this.nvim.callAsync('coc#util#quickpick', [title, items]);
            release();
            let n = parseInt(res, 10);
            if (isNaN(n) || n <= 0 || n > items.length)
                return -1;
            return n - 1;
        }
        catch (e) {
            release();
            return -1;
        }
    }
    /**
     * Prompt for confirm action.
     */
    async showPrompt(title) {
        let release = await this.mutex.acquire();
        try {
            let res = await this.nvim.callAsync('coc#util#prompt', [title]);
            release();
            return !!res;
        }
        catch (e) {
            release();
            return false;
        }
    }
    async callAsync(method, args) {
        if (this.isNvim)
            return await this.nvim.call(method, args);
        return await this.nvim.callAsync('coc#util#with_callback', [method, args]);
    }
    /**
     * Request input from user
     */
    async requestInput(title, defaultValue) {
        let { nvim } = this;
        let res = await this.callAsync('input', [title + ': ', defaultValue || '']);
        nvim.command('normal! :<C-u>', true);
        if (!res) {
            this.showMessage('Empty word, canceled', 'warning');
            return null;
        }
        return res;
    }
    /**
     * registerTextDocumentContentProvider
     */
    registerTextDocumentContentProvider(scheme, provider) {
        this.schemeProviderMap.set(scheme, provider);
        this.setupDynamicAutocmd();
        let disposables = [];
        if (provider.onDidChange) {
            provider.onDidChange(async (uri) => {
                let doc = this.getDocument(uri.toString());
                if (doc) {
                    let { buffer } = doc;
                    let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
                    let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));
                    await buffer.setLines(content.split('\n'), {
                        start: 0,
                        end: -1,
                        strictIndexing: false
                    });
                }
            }, null, disposables);
        }
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.schemeProviderMap.delete(scheme);
            index_1.disposeAll(disposables);
            this.setupDynamicAutocmd();
        });
    }
    /**
     * Register unique keymap uses `<Plug>(coc-{key})` as lhs
     * Throw error when {key} already exists.
     *
     * @param {MapMode[]} modes - array of 'n' | 'i' | 'v' | 'x' | 's' | 'o'
     * @param {string} key - unique name
     * @param {Function} fn - callback function
     * @param {Partial} opts
     * @returns {Disposable}
     */
    registerKeymap(modes, key, fn, opts = {}) {
        if (!key)
            throw new Error(`Invalid key ${key} of registerKeymap`);
        if (this.keymaps.has(key))
            throw new Error(`${key} already exists.`);
        opts = Object.assign({ sync: true, cancel: true, silent: true, repeat: false }, opts);
        let { nvim } = this;
        this.keymaps.set(key, [fn, !!opts.repeat]);
        let method = opts.sync ? 'request' : 'notify';
        let silent = opts.silent ? '<silent>' : '';
        for (let m of modes) {
            if (m == 'i') {
                nvim.command(`inoremap ${silent}<expr> <Plug>(coc-${key}) coc#_insert_key('${method}', '${key}', ${opts.cancel ? 1 : 0})`, true);
            }
            else {
                let modify = index_1.getKeymapModifier(m);
                nvim.command(`${m}noremap ${silent} <Plug>(coc-${key}) :${modify}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, true);
            }
        }
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.keymaps.delete(key);
            for (let m of modes) {
                nvim.command(`${m}unmap <Plug>(coc-${key})`, true);
            }
        });
    }
    /**
     * Register expr keymap.
     */
    registerExprKeymap(mode, key, fn, buffer = false) {
        if (!key)
            return;
        let id = uuid_1.v1();
        let { nvim } = this;
        this.keymaps.set(id, [fn, false]);
        if (mode == 'i') {
            nvim.command(`inoremap <silent><expr>${buffer ? '<nowait><buffer>' : ''} ${key} coc#_insert_key('request', '${id}')`, true);
        }
        else {
            nvim.command(`${mode}noremap <silent><expr>${buffer ? '<nowait><buffer>' : ''} ${key} coc#rpc#request('doKeymap', ['${id}'])`, true);
        }
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.keymaps.delete(id);
            nvim.command(`${mode}unmap ${buffer ? '<buffer>' : ''} ${key}`, true);
        });
    }
    registerLocalKeymap(mode, key, fn, notify = false) {
        let id = uuid_1.v1();
        let { nvim } = this;
        this.keymaps.set(id, [fn, false]);
        let modify = index_1.getKeymapModifier(mode);
        nvim.command(`${mode}noremap <silent><nowait><buffer> ${key} :${modify}call coc#rpc#${notify ? 'notify' : 'request'}('doKeymap', ['${id}'])<CR>`, true);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.keymaps.delete(id);
            nvim.command(`${mode}unmap <buffer> ${key}`, true);
        });
    }
    /**
     * Create StatusBarItem
     */
    createStatusBarItem(priority = 0, opt = {}) {
        if (!this.statusLine) {
            let fn = () => { };
            return { text: '', show: fn, dispose: fn, hide: fn, priority: 0, isProgress: false };
        }
        return this.statusLine.createStatusBarItem(priority, opt.progress || false);
    }
    dispose() {
        this._disposed = true;
        for (let ch of this.outputChannels.values()) {
            ch.dispose();
        }
        for (let doc of this.documents) {
            doc.detach();
        }
        index_1.disposeAll(this.disposables);
        watchman_1.default.dispose();
        this.configurations.dispose();
        this.buffers.clear();
        if (this.statusLine)
            this.statusLine.dispose();
    }
    async detach() {
        if (!this._attached)
            return;
        this._attached = false;
        for (let bufnr of this.buffers.keys()) {
            await events_1.default.fire('BufUnload', [bufnr]);
        }
    }
    /**
     * Create DB instance at extension root.
     */
    createDatabase(name) {
        let root;
        if (global.hasOwnProperty('__TEST__')) {
            root = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}`);
            fs_1.default.mkdirSync(root, { recursive: true });
        }
        else {
            root = path_1.default.dirname(this.env.extensionRoot);
        }
        let filepath = path_1.default.join(root, name + '.json');
        return new db_1.default(filepath);
    }
    /**
     * Create Task instance that runs in vim.
     */
    createTask(id) {
        return new task_1.default(this.nvim, id);
    }
    setupDynamicAutocmd(initialize = false) {
        if (!initialize && !this._dynAutocmd)
            return;
        this._dynAutocmd = true;
        let schemes = this.schemeProviderMap.keys();
        let cmds = [];
        for (let scheme of schemes) {
            cmds.push(`autocmd BufReadCmd,FileReadCmd,SourceCmd ${scheme}://* call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<amatch>')])`);
        }
        for (let [id, autocmd] of this.autocmds.entries()) {
            let args = autocmd.arglist && autocmd.arglist.length ? ', ' + autocmd.arglist.join(', ') : '';
            let event = Array.isArray(autocmd.event) ? autocmd.event.join(',') : autocmd.event;
            let pattern = autocmd.pattern != null ? autocmd.pattern : '*';
            if (/\buser\b/i.test(event)) {
                pattern = '';
            }
            cmds.push(`autocmd ${event} ${pattern} call coc#rpc#${autocmd.request ? 'request' : 'notify'}('doAutocmd', [${id}${args}])`);
        }
        for (let key of this.watchedOptions) {
            cmds.push(`autocmd OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`);
        }
        let content = `
augroup coc_dynamic_autocmd
  autocmd!
  ${cmds.join('\n  ')}
augroup end`;
        try {
            let dir = path_1.default.join(process.env.TMPDIR, `coc.nvim-${process.pid}`);
            if (!fs_1.default.existsSync(dir))
                fs_1.default.mkdirSync(dir, { recursive: true });
            let filepath = path_1.default.join(dir, `coc-${process.pid}.vim`);
            fs_1.default.writeFileSync(filepath, content, 'utf8');
            let cmd = `source ${filepath}`;
            if (this.env.isCygwin && index_1.platform.isWindows) {
                cmd = `execute "source" . substitute(system('cygpath ${filepath.replace(/\\/g, '/')}'), '\\n', '', 'g')`;
            }
            this.nvim.command(cmd).logError();
        }
        catch (e) {
            this.showMessage(`Can't create tmp file: ${e.message}`, 'error');
        }
    }
    async onBufReadCmd(scheme, uri) {
        let provider = this.schemeProviderMap.get(scheme);
        if (!provider) {
            this.showMessage(`Provider for ${scheme} not found`, 'error');
            return;
        }
        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let content = await Promise.resolve(provider.provideTextDocumentContent(vscode_uri_1.URI.parse(uri), tokenSource.token));
        let buf = await this.nvim.buffer;
        await buf.setLines(content.split('\n'), {
            start: 0,
            end: -1,
            strictIndexing: false
        });
        setTimeout(async () => {
            await events_1.default.fire('BufCreate', [buf.id]);
        }, 30);
    }
    async attach() {
        if (this._attached)
            return;
        this._attached = true;
        let buffers = await this.nvim.buffers;
        let bufnr = this.bufnr = await this.nvim.call('bufnr', '%');
        await Promise.all(buffers.map(buf => this.onBufCreate(buf)));
        if (!this._initialized) {
            this._onDidWorkspaceInitialized.fire(void 0);
            this._initialized = true;
        }
        await events_1.default.fire('BufEnter', [bufnr]);
        let winid = await this.nvim.call('win_getid');
        await events_1.default.fire('BufWinEnter', [bufnr, winid]);
    }
    // count of document need change
    getChangedUris(documentChanges) {
        let uris = new Set();
        let newUris = new Set();
        for (let change of documentChanges) {
            if (index_1.isDocumentEdit(change)) {
                let { textDocument } = change;
                let { uri, version } = textDocument;
                if (!newUris.has(uri)) {
                    uris.add(uri);
                }
                if (version != null && version > 0) {
                    let doc = this.getDocument(uri);
                    if (!doc) {
                        throw new Error(`${uri} not loaded`);
                    }
                    if (doc.version != version) {
                        throw new Error(`${uri} changed before apply edit`);
                    }
                }
                else if (fs_2.isFile(uri) && !this.getDocument(uri)) {
                    let file = vscode_uri_1.URI.parse(uri).fsPath;
                    if (!fs_1.default.existsSync(file)) {
                        throw new Error(`file "${file}" not exists`);
                    }
                }
            }
            else if (vscode_languageserver_protocol_1.CreateFile.is(change) || vscode_languageserver_protocol_1.DeleteFile.is(change)) {
                if (!fs_2.isFile(change.uri)) {
                    throw new Error(`change of scheme ${change.uri} not supported`);
                }
                uris.add(change.uri);
            }
            else if (vscode_languageserver_protocol_1.RenameFile.is(change)) {
                if (!fs_2.isFile(change.oldUri) || !fs_2.isFile(change.newUri)) {
                    throw new Error(`change of scheme ${change.oldUri} not supported`);
                }
                let newFile = vscode_uri_1.URI.parse(change.newUri).fsPath;
                if (fs_1.default.existsSync(newFile)) {
                    throw new Error(`file "${newFile}" already exists for rename`);
                }
                uris.add(change.oldUri);
                newUris.add(change.newUri);
            }
            else {
                throw new Error(`Invalid document change: ${JSON.stringify(change, null, 2)}`);
            }
        }
        return Array.from(uris);
    }
    createConfigurations() {
        let home = path_1.default.normalize(process.env.COC_VIMCONFIG) || path_1.default.join(os_1.default.homedir(), '.vim');
        let userConfigFile = path_1.default.join(home, index_1.CONFIG_FILE_NAME);
        return new configuration_1.default(userConfigFile, new shape_1.default(this));
    }
    // events for sync buffer of vim
    attachChangedEvents() {
        if (this.isVim) {
            const onChange = (bufnr) => {
                let doc = this.getDocument(bufnr);
                if (doc && doc.attached)
                    doc.fetchContent();
            };
            events_1.default.on('TextChangedI', onChange, null, this.disposables);
            events_1.default.on('TextChanged', onChange, null, this.disposables);
        }
    }
    async onBufCreate(buf) {
        let buffer = typeof buf === 'number' ? this.nvim.createBuffer(buf) : buf;
        let bufnr = buffer.id;
        if (this.creatingSources.has(bufnr))
            return;
        let document = this.getDocument(bufnr);
        let source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        try {
            if (document)
                this.onBufUnload(bufnr, true);
            document = new document_1.default(buffer, this._env, this.maxFileSize);
            let token = source.token;
            this.creatingSources.set(bufnr, source);
            let created = await document.init(this.nvim, token);
            if (!created)
                document = null;
        }
        catch (e) {
            logger.error('Error on create buffer:', e);
            document = null;
        }
        if (this.creatingSources.get(bufnr) == source) {
            source.dispose();
            this.creatingSources.delete(bufnr);
        }
        if (!document || !document.textDocument)
            return;
        this.buffers.set(bufnr, document);
        if (document.enabled) {
            document.onDocumentDetach(bufnr => {
                let doc = this.getDocument(bufnr);
                if (doc)
                    this.onBufUnload(doc.bufnr);
            });
        }
        if (document.buftype == '' && document.schema == 'file') {
            let config = this.getConfiguration('workspace');
            let filetypes = config.get('ignoredFiletypes', []);
            if (!filetypes.includes(document.filetype)) {
                let root = this.resolveRoot(document);
                if (root) {
                    this.addWorkspaceFolder(root);
                    if (this.bufnr == buffer.id) {
                        this._root = root;
                    }
                }
            }
            this.configurations.checkFolderConfiguration(document.uri);
        }
        if (document.enabled) {
            this._onDidOpenDocument.fire(document.textDocument);
            document.onDocumentChange(e => this._onDidChangeDocument.fire(e));
        }
        logger.debug('buffer created', buffer.id);
    }
    onBufEnter(bufnr) {
        this.bufnr = bufnr;
        let doc = this.getDocument(bufnr);
        if (doc) {
            this.configurations.setFolderConfiguration(doc.uri);
            let workspaceFolder = this.getWorkspaceFolder(doc.uri);
            if (workspaceFolder)
                this._root = vscode_uri_1.URI.parse(workspaceFolder.uri).fsPath;
        }
    }
    async checkCurrentBuffer(bufnr) {
        this.bufnr = bufnr;
        await this.checkBuffer(bufnr);
    }
    onBufWritePost(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc)
            return;
        this._onDidSaveDocument.fire(doc.textDocument);
    }
    onBufUnload(bufnr, recreate = false) {
        logger.debug('buffer unload', bufnr);
        if (!recreate) {
            let source = this.creatingSources.get(bufnr);
            if (source) {
                source.cancel();
                this.creatingSources.delete(bufnr);
            }
        }
        if (this.terminals.has(bufnr)) {
            let terminal = this.terminals.get(bufnr);
            this._onDidCloseTerminal.fire(terminal);
            this.terminals.delete(bufnr);
        }
        let doc = this.buffers.get(bufnr);
        if (doc) {
            this._onDidCloseDocument.fire(doc.textDocument);
            this.buffers.delete(bufnr);
            doc.detach();
        }
    }
    async onBufWritePre(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc)
            return;
        let event = {
            document: doc.textDocument,
            reason: vscode_languageserver_protocol_1.TextDocumentSaveReason.Manual
        };
        this._onWillSaveDocument.fire(event);
        if (this.willSaveUntilHandler.hasCallback) {
            await this.willSaveUntilHandler.handeWillSaveUntil(event);
        }
    }
    onDirChanged(cwd) {
        if (cwd == this._cwd)
            return;
        this._cwd = cwd;
    }
    onFileTypeChange(filetype, bufnr) {
        let doc = this.getDocument(bufnr);
        if (!doc)
            return;
        let converted = doc.convertFiletype(filetype);
        if (converted == doc.filetype)
            return;
        this._onDidCloseDocument.fire(doc.textDocument);
        doc.setFiletype(filetype);
        this._onDidOpenDocument.fire(doc.textDocument);
    }
    async checkBuffer(bufnr) {
        if (this._disposed || !bufnr)
            return;
        let doc = this.getDocument(bufnr);
        if (!doc && !this.creatingSources.has(bufnr))
            await this.onBufCreate(bufnr);
    }
    async getFileEncoding() {
        let encoding = await this.nvim.getOption('fileencoding');
        return encoding ? encoding : 'utf-8';
    }
    resolveRoot(document) {
        let types = [types_1.PatternType.Buffer, types_1.PatternType.LanguageServer, types_1.PatternType.Global];
        let u = vscode_uri_1.URI.parse(document.uri);
        let dir = path_1.default.dirname(u.fsPath);
        let { cwd } = this;
        for (let patternType of types) {
            let patterns = this.getRootPatterns(document, patternType);
            if (patterns && patterns.length) {
                let root = fs_2.resolveRoot(dir, patterns, cwd);
                if (root)
                    return root;
            }
        }
        if (this.cwd != os_1.default.homedir() && fs_2.isParentFolder(this.cwd, dir, true))
            return this.cwd;
        return null;
    }
    getRootPatterns(document, patternType) {
        let { uri } = document;
        if (patternType == types_1.PatternType.Buffer)
            return document.getVar('root_patterns', []) || [];
        if (patternType == types_1.PatternType.LanguageServer)
            return this.getServerRootPatterns(document.filetype);
        const preferences = this.getConfiguration('coc.preferences', uri);
        return preferences.get('rootPatterns', ['.git', '.hg', '.projections.json']).slice();
    }
    async renameCurrent() {
        let { nvim } = this;
        let bufnr = await nvim.call('bufnr', '%');
        let cwd = await nvim.call('getcwd');
        let doc = this.getDocument(bufnr);
        if (!doc || doc.buftype != '' || doc.schema != 'file') {
            nvim.errWriteLine('current buffer is not file.');
            return;
        }
        let oldPath = vscode_uri_1.URI.parse(doc.uri).fsPath;
        // await nvim.callAsync()
        let newPath = await nvim.callAsync('coc#util#with_callback', ['input', ['New path: ', oldPath, 'file']]);
        newPath = newPath ? newPath.trim() : null;
        if (newPath == oldPath || !newPath)
            return;
        let lines = await doc.buffer.lines;
        let exists = fs_1.default.existsSync(oldPath);
        if (exists) {
            let modified = await nvim.eval('&modified');
            if (modified)
                await nvim.command('noa w');
            if (oldPath.toLowerCase() != newPath.toLowerCase() && fs_1.default.existsSync(newPath)) {
                let overwrite = await this.showPrompt(`${newPath} exists, overwrite?`);
                if (!overwrite)
                    return;
                fs_1.default.unlinkSync(newPath);
            }
            fs_1.default.renameSync(oldPath, newPath);
        }
        let filepath = fs_2.isParentFolder(cwd, newPath) ? path_1.default.relative(cwd, newPath) : newPath;
        let view = await nvim.call('winsaveview');
        nvim.pauseNotification();
        if (oldPath.toLowerCase() == newPath.toLowerCase()) {
            nvim.command(`keepalt ${bufnr}bwipeout!`, true);
            nvim.call('coc#util#open_file', ['keepalt edit', filepath], true);
        }
        else {
            nvim.call('coc#util#open_file', ['keepalt edit', filepath], true);
            nvim.command(`${bufnr}bwipeout!`, true);
        }
        if (!exists && lines.join('\n') != '\n') {
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
        }
        nvim.call('winrestview', [view], true);
        await nvim.resumeNotification();
    }
    setMessageLevel() {
        let config = this.getConfiguration('coc.preferences');
        let level = config.get('messageLevel', 'more');
        switch (level) {
            case 'error':
                this.messageLevel = types_1.MessageLevel.Error;
                break;
            case 'warning':
                this.messageLevel = types_1.MessageLevel.Warning;
                break;
            default:
                this.messageLevel = types_1.MessageLevel.More;
        }
    }
    get folderPaths() {
        return this.workspaceFolders.map(f => vscode_uri_1.URI.parse(f.uri).fsPath);
    }
    get floatSupported() {
        let { env } = this;
        return env.floating || env.textprop;
    }
    removeWorkspaceFolder(fsPath) {
        let idx = this._workspaceFolders.findIndex(f => vscode_uri_1.URI.parse(f.uri).fsPath == fsPath);
        if (idx != -1) {
            let folder = this._workspaceFolders[idx];
            this._workspaceFolders.splice(idx, 1);
            this._onDidChangeWorkspaceFolders.fire({
                removed: [folder],
                added: []
            });
        }
    }
    renameWorkspaceFolder(oldPath, newPath) {
        let idx = this._workspaceFolders.findIndex(f => vscode_uri_1.URI.parse(f.uri).fsPath == oldPath);
        if (idx == -1)
            return;
        let removed = this._workspaceFolders[idx];
        let added = {
            uri: vscode_uri_1.URI.file(newPath).toString(),
            name: path_1.default.dirname(newPath)
        };
        this._workspaceFolders.splice(idx, 1);
        this._workspaceFolders.push(added);
        this._onDidChangeWorkspaceFolders.fire({
            removed: [removed],
            added: [added]
        });
    }
    addRootPattern(filetype, rootPatterns) {
        let patterns = this.rootPatterns.get(filetype) || [];
        for (let p of rootPatterns) {
            if (!patterns.includes(p)) {
                patterns.push(p);
            }
        }
        this.rootPatterns.set(filetype, patterns);
    }
    get insertMode() {
        return this._insertMode;
    }
    addWorkspaceFolder(rootPath) {
        if (rootPath == os_1.default.homedir())
            return;
        let { _workspaceFolders } = this;
        let uri = vscode_uri_1.URI.file(rootPath).toString();
        let workspaceFolder = { uri, name: path_1.default.basename(rootPath) };
        if (_workspaceFolders.findIndex(o => o.uri == uri) == -1) {
            _workspaceFolders.push(workspaceFolder);
            if (this._initialized) {
                this._onDidChangeWorkspaceFolders.fire({
                    added: [workspaceFolder],
                    removed: []
                });
            }
        }
        return workspaceFolder;
    }
    getServerRootPatterns(filetype) {
        let lspConfig = this.getConfiguration().get('languageserver', {});
        let patterns = [];
        for (let key of Object.keys(lspConfig)) {
            let config = lspConfig[key];
            let { filetypes, rootPatterns } = config;
            if (filetypes && rootPatterns && filetypes.includes(filetype)) {
                patterns.push(...rootPatterns);
            }
        }
        patterns = patterns.concat(this.rootPatterns.get(filetype) || []);
        return patterns.length ? array_1.distinct(patterns) : null;
    }
}
exports.Workspace = Workspace;
exports.default = new Workspace();
//# sourceMappingURL=workspace.js.map

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b:  1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: Math.pow(1024, 4),
  pb: Math.pow(1024, 5),
};

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */

function bytes(value, options) {
  if (typeof value === 'string') {
    return parse(value);
  }

  if (typeof value === 'number') {
    return format(value, options);
  }

  return null;
}

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */

function format(value, options) {
  if (!Number.isFinite(value)) {
    return null;
  }

  var mag = Math.abs(value);
  var thousandsSeparator = (options && options.thousandsSeparator) || '';
  var unitSeparator = (options && options.unitSeparator) || '';
  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = (options && options.unit) || '';

  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.pb) {
      unit = 'PB';
    } else if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'KB';
    } else {
      unit = 'B';
    }
  }

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, '$1');
  }

  if (thousandsSeparator) {
    str = str.replace(formatThousandsRegExp, thousandsSeparator);
  }

  return str + unitSeparator + unit;
}

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */

function parse(val) {
  if (typeof val === 'number' && !isNaN(val)) {
    return val;
  }

  if (typeof val !== 'string') {
    return null;
  }

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) {
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b'
  } else {
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  return Math.floor(map[unit] * floatValue);
}


/***/ }),
/* 259 */
/***/ (function(module, exports) {

/**
 * This library modifies the diff-patch-match library by Neil Fraser
 * by removing the patch and match functionality and certain advanced
 * options in the diff function. The original license is as follows:
 *
 * ===
 *
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info
 * @return {Array} Array of diff tuples.
 */
function diff_main(text1, text2, cursor_pos, _fix_unicode) {
  // Check for equality
  if (text1 === text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (cursor_pos != null) {
    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
    if (editdiff) {
      return editdiff;
    }
  }

  // Trim off common prefix (speedup).
  var commonlength = diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = diff_compute_(text1, text2);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diff_cleanupMerge(diffs, _fix_unicode);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_compute_(text1, text2) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i !== -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [
      [DIFF_INSERT, longtext.substring(0, i)],
      [DIFF_EQUAL, shorttext],
      [DIFF_INSERT, longtext.substring(i + shorttext.length)]
    ];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length === 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = diff_main(text1_a, text2_a);
    var diffs_b = diff_main(text1_b, text2_b);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  return diff_bisect_(text1, text2);
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
function diff_bisect_(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 !== 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (
        x1 < text1_length && y1 < text2_length &&
        text1.charAt(x1) === text2.charAt(y1)
      ) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (
        x2 < text1_length && y2 < text2_length &&
        text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)
      ) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
function diff_bisectSplit_(text1, text2, x, y) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = diff_main(text1a, text2a);
  var diffsb = diff_main(text1b, text2b);

  return diffs.concat(diffsb);
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
function diff_commonPrefix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (
      text1.substring(pointerstart, pointermid) ==
      text2.substring(pointerstart, pointermid)
    ) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }

  if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
    pointermid--;
  }

  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
function diff_commonSuffix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (
      text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)
    ) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }

  if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
    pointermid--;
  }

  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
function diff_halfMatch_(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
      var prefixLength = diff_commonPrefix(
        longtext.substring(i), shorttext.substring(j));
      var suffixLength = diff_commonSuffix(
        longtext.substring(0, i), shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(
          j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [
        best_longtext_a, best_longtext_b,
        best_shorttext_a, best_shorttext_b, best_common
      ];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff
 */
function diff_cleanupMerge(diffs, fix_unicode) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
      diffs.splice(pointer, 1);
      continue;
    }
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:

        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        var previous_equality = pointer - count_insert - count_delete - 1;
        if (fix_unicode) {
          // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,
          // we assume that the old and new text in the diff are complete and correct
          // unicode-encoded JS strings, but the tuple boundaries may fall between
          // surrogate pairs.  we fix this by shaving off stray surrogates from the end
          // of the previous equality and the beginning of this equality.  this may create
          // empty equalities or a common prefix or suffix.  for example, if AB and AC are
          // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and
          // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this
          // particular case, both equalities go away, we absorb any previous inequalities,
          // and we keep scanning for the next equality before rewriting the tuples.
          if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
            var stray = diffs[previous_equality][1].slice(-1);
            diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
            text_delete = stray + text_delete;
            text_insert = stray + text_insert;
            if (!diffs[previous_equality][1]) {
              // emptied out previous equality, so delete it and include previous delete/insert
              diffs.splice(previous_equality, 1);
              pointer--;
              var k = previous_equality - 1;
              if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                count_insert++;
                text_insert = diffs[k][1] + text_insert;
                k--;
              }
              if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                count_delete++;
                text_delete = diffs[k][1] + text_delete;
                k--;
              }
              previous_equality = k;
            }
          }
          if (starts_with_pair_end(diffs[pointer][1])) {
            var stray = diffs[pointer][1].charAt(0);
            diffs[pointer][1] = diffs[pointer][1].slice(1);
            text_delete += stray;
            text_insert += stray;
          }
        }
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          // for empty equality not at end, wait for next equality
          diffs.splice(pointer, 1);
          break;
        }
        if (text_delete.length > 0 || text_insert.length > 0) {
          // note that diff_commonPrefix and diff_commonSuffix are unicode-aware
          if (text_delete.length > 0 && text_insert.length > 0) {
            // Factor out any common prefixes.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (previous_equality >= 0) {
                diffs[previous_equality][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixes.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] =
                text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          var n = count_insert + count_delete;
          if (text_delete.length === 0 && text_insert.length === 0) {
            diffs.splice(pointer - n, n);
            pointer = pointer - n;
          } else if (text_delete.length === 0) {
            diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
            pointer = pointer - n + 1;
          } else if (text_insert.length === 0) {
            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
            pointer = pointer - n + 1;
          } else {
            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
            pointer = pointer - n + 2;
          }
        }
        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL &&
      diffs[pointer + 1][0] === DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
        diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
          diffs[pointer][1].substring(0, diffs[pointer][1].length -
            diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
        diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
          diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    diff_cleanupMerge(diffs, fix_unicode);
  }
};

function is_surrogate_pair_start(charCode) {
  return charCode >= 0xD800 && charCode <= 0xDBFF;
}

function is_surrogate_pair_end(charCode) {
  return charCode >= 0xDC00 && charCode <= 0xDFFF;
}

function starts_with_pair_end(str) {
  return is_surrogate_pair_end(str.charCodeAt(0));
}

function ends_with_pair_start(str) {
  return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
}

function remove_empty_tuples(tuples) {
  var ret = [];
  for (var i = 0; i < tuples.length; i++) {
    if (tuples[i][1].length > 0) {
      ret.push(tuples[i]);
    }
  }
  return ret;
}

function make_edit_splice(before, oldMiddle, newMiddle, after) {
  if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
    return null;
  }
  return remove_empty_tuples([
    [DIFF_EQUAL, before],
    [DIFF_DELETE, oldMiddle],
    [DIFF_INSERT, newMiddle],
    [DIFF_EQUAL, after]
  ]);
}

function find_cursor_edit_diff(oldText, newText, cursor_pos) {
  // note: this runs after equality check has ruled out exact equality
  var oldRange = typeof cursor_pos === 'number' ?
    { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
  var newRange = typeof cursor_pos === 'number' ?
    null : cursor_pos.newRange;
  // take into account the old and new selection to generate the best diff
  // possible for a text edit.  for example, a text change from "xxx" to "xx"
  // could be a delete or forwards-delete of any one of the x's, or the
  // result of selecting two of the x's and typing "x".
  var oldLength = oldText.length;
  var newLength = newText.length;
  if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
    // see if we have an insert or delete before or after cursor
    var oldCursor = oldRange.index;
    var oldBefore = oldText.slice(0, oldCursor);
    var oldAfter = oldText.slice(oldCursor);
    var maybeNewCursor = newRange ? newRange.index : null;
    editBefore: {
      // is this an insert or delete right before oldCursor?
      var newCursor = oldCursor + newLength - oldLength;
      if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
        break editBefore;
      }
      if (newCursor < 0 || newCursor > newLength) {
        break editBefore;
      }
      var newBefore = newText.slice(0, newCursor);
      var newAfter = newText.slice(newCursor);
      if (newAfter !== oldAfter) {
        break editBefore;
      }
      var prefixLength = Math.min(oldCursor, newCursor);
      var oldPrefix = oldBefore.slice(0, prefixLength);
      var newPrefix = newBefore.slice(0, prefixLength);
      if (oldPrefix !== newPrefix) {
        break editBefore;
      }
      var oldMiddle = oldBefore.slice(prefixLength);
      var newMiddle = newBefore.slice(prefixLength);
      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
    }
    editAfter: {
      // is this an insert or delete right after oldCursor?
      if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
        break editAfter;
      }
      var cursor = oldCursor;
      var newBefore = newText.slice(0, cursor);
      var newAfter = newText.slice(cursor);
      if (newBefore !== oldBefore) {
        break editAfter;
      }
      var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
      var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
      var newSuffix = newAfter.slice(newAfter.length - suffixLength);
      if (oldSuffix !== newSuffix) {
        break editAfter;
      }
      var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
      var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
      return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
    }
  }
  if (oldRange.length > 0 && newRange && newRange.length === 0) {
    replaceRange: {
      // see if diff could be a splice of the old selection range
      var oldPrefix = oldText.slice(0, oldRange.index);
      var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
      var prefixLength = oldPrefix.length;
      var suffixLength = oldSuffix.length;
      if (newLength < prefixLength + suffixLength) {
        break replaceRange;
      }
      var newPrefix = newText.slice(0, prefixLength);
      var newSuffix = newText.slice(newLength - suffixLength);
      if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
        break replaceRange;
      }
      var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
      var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
    }
  }

  return null;
}

function diff(text1, text2, cursor_pos) {
  // only pass fix_unicode=true at the top level, not when diff_main is
  // recursively invoked
  return diff_main(text1, text2, cursor_pos, true);
}

diff.INSERT = DIFF_INSERT;
diff.DELETE = DIFF_DELETE;
diff.EQUAL = DIFF_EQUAL;

module.exports = diff;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

const optsArg = __webpack_require__(261)
const pathArg = __webpack_require__(262)

const {mkdirpNative, mkdirpNativeSync} = __webpack_require__(263)
const {mkdirpManual, mkdirpManualSync} = __webpack_require__(265)
const {useNative, useNativeSync} = __webpack_require__(266)


const mkdirp = (path, opts) => {
  path = pathArg(path)
  opts = optsArg(opts)
  return useNative(opts)
    ? mkdirpNative(path, opts)
    : mkdirpManual(path, opts)
}

const mkdirpSync = (path, opts) => {
  path = pathArg(path)
  opts = optsArg(opts)
  return useNativeSync(opts)
    ? mkdirpNativeSync(path, opts)
    : mkdirpManualSync(path, opts)
}

mkdirp.sync = mkdirpSync
mkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))
mkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))
mkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))
mkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))

module.exports = mkdirp


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

const { promisify } = __webpack_require__(74)
const fs = __webpack_require__(66)
const optsArg = opts => {
  if (!opts)
    opts = { mode: 0o777, fs }
  else if (typeof opts === 'object')
    opts = { mode: 0o777, fs, ...opts }
  else if (typeof opts === 'number')
    opts = { mode: opts, fs }
  else if (typeof opts === 'string')
    opts = { mode: parseInt(opts, 8), fs }
  else
    throw new TypeError('invalid options argument')

  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir
  opts.mkdirAsync = promisify(opts.mkdir)
  opts.stat = opts.stat || opts.fs.stat || fs.stat
  opts.statAsync = promisify(opts.stat)
  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync
  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync
  return opts
}
module.exports = optsArg


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform
const { resolve, parse } = __webpack_require__(82)
const pathArg = path => {
  if (/\0/.test(path)) {
    // simulate same failure that node raises
    throw Object.assign(
      new TypeError('path must be a string without null bytes'),
      {
        path,
        code: 'ERR_INVALID_ARG_VALUE',
      }
    )
  }

  path = resolve(path)
  if (platform === 'win32') {
    const badWinChars = /[*|"<>?:]/
    const {root} = parse(path)
    if (badWinChars.test(path.substr(root.length))) {
      throw Object.assign(new Error('Illegal characters in path.'), {
        path,
        code: 'EINVAL',
      })
    }
  }

  return path
}
module.exports = pathArg


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

const {dirname} = __webpack_require__(82)
const {findMade, findMadeSync} = __webpack_require__(264)
const {mkdirpManual, mkdirpManualSync} = __webpack_require__(265)

const mkdirpNative = (path, opts) => {
  opts.recursive = true
  const parent = dirname(path)
  if (parent === path)
    return opts.mkdirAsync(path, opts)

  return findMade(opts, path).then(made =>
    opts.mkdirAsync(path, opts).then(() => made)
    .catch(er => {
      if (er.code === 'ENOENT')
        return mkdirpManual(path, opts)
      else
        throw er
    }))
}

const mkdirpNativeSync = (path, opts) => {
  opts.recursive = true
  const parent = dirname(path)
  if (parent === path)
    return opts.mkdirSync(path, opts)

  const made = findMadeSync(opts, path)
  try {
    opts.mkdirSync(path, opts)
    return made
  } catch (er) {
    if (er.code === 'ENOENT')
      return mkdirpManualSync(path, opts)
    else
      throw er
  }
}

module.exports = {mkdirpNative, mkdirpNativeSync}


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

const {dirname} = __webpack_require__(82)

const findMade = (opts, parent, path = undefined) => {
  // we never want the 'made' return value to be a root directory
  if (path === parent)
    return Promise.resolve()

  return opts.statAsync(parent).then(
    st => st.isDirectory() ? path : undefined, // will fail later
    er => er.code === 'ENOENT'
      ? findMade(opts, dirname(parent), parent)
      : undefined
  )
}

const findMadeSync = (opts, parent, path = undefined) => {
  if (path === parent)
    return undefined

  try {
    return opts.statSync(parent).isDirectory() ? path : undefined
  } catch (er) {
    return er.code === 'ENOENT'
      ? findMadeSync(opts, dirname(parent), parent)
      : undefined
  }
}

module.exports = {findMade, findMadeSync}


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

const {dirname} = __webpack_require__(82)

const mkdirpManual = (path, opts, made) => {
  opts.recursive = false
  const parent = dirname(path)
  if (parent === path) {
    return opts.mkdirAsync(path, opts).catch(er => {
      // swallowed by recursive implementation on posix systems
      // any other error is a failure
      if (er.code !== 'EISDIR')
        throw er
    })
  }

  return opts.mkdirAsync(path, opts).then(() => made || path, er => {
    if (er.code === 'ENOENT')
      return mkdirpManual(parent, opts)
        .then(made => mkdirpManual(path, opts, made))
    if (er.code !== 'EEXIST' && er.code !== 'EROFS')
      throw er
    return opts.statAsync(path).then(st => {
      if (st.isDirectory())
        return made
      else
        throw er
    }, () => { throw er })
  })
}

const mkdirpManualSync = (path, opts, made) => {
  const parent = dirname(path)
  opts.recursive = false

  if (parent === path) {
    try {
      return opts.mkdirSync(path, opts)
    } catch (er) {
      // swallowed by recursive implementation on posix systems
      // any other error is a failure
      if (er.code !== 'EISDIR')
        throw er
      else
        return
    }
  }

  try {
    opts.mkdirSync(path, opts)
    return made || path
  } catch (er) {
    if (er.code === 'ENOENT')
      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))
    if (er.code !== 'EEXIST' && er.code !== 'EROFS')
      throw er
    try {
      if (!opts.statSync(path).isDirectory())
        throw er
    } catch (_) {
      throw er
    }
  }
}

module.exports = {mkdirpManual, mkdirpManualSync}


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

const fs = __webpack_require__(66)

const version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version
const versArr = version.replace(/^v/, '').split('.')
const hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12

const useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir
const useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync

module.exports = {useNative, useNativeSync}


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

const assert = __webpack_require__(108)
const path = __webpack_require__(82)
const fs = __webpack_require__(66)
let glob = undefined
try {
  glob = __webpack_require__(268)
} catch (_err) {
  // treat glob as optional.
}

const defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
let timeout = 0

const isWindows = (process.platform === "win32")

const defaults = options => {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  if (options.disableGlob !== true && glob === undefined) {
    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

const rimraf = (p, options, cb) => {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  let busyTries = 0
  let errState = null
  let n = 0

  const next = (er) => {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  const afterGlob = (er, results) => {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(p => {
      const CB = (er) => {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            // try again, with the same exact callback as this one.
            return setTimeout(() => rimraf_(p, options, CB), busyTries * 100)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(() => rimraf_(p, options, CB), timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      }
      rimraf_(p, options, CB)
    })
  }

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, (er, stat) => {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
const rimraf_ = (p, options, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, er => {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

const fixWinEPERM = (p, options, er, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.chmod(p, 0o666, er2 => {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, (er3, stats) => {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

const fixWinEPERMSync = (p, options, er) => {
  assert(p)
  assert(options)

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  let stats
  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

const rmdir = (p, options, originalEr, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

const rmkids = (p, options, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er)
      return cb(er)
    let n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    let errState
    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
const rimrafSync = (p, options) => {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  let results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (let i = 0; i < results.length; i++) {
    const p = results[i]

    let st
    try {
      st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

const rmdirSync = (p, options, originalEr) => {
  assert(p)
  assert(options)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

const rmkidsSync = (p, options) => {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1
  let i = 0
  do {
    let threw = true
    try {
      const ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}

module.exports = rimraf
rimraf.sync = rimrafSync


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __webpack_require__(66)
var rp = __webpack_require__(269)
var minimatch = __webpack_require__(271)
var Minimatch = minimatch.Minimatch
var inherits = __webpack_require__(275)
var EE = __webpack_require__(198).EventEmitter
var path = __webpack_require__(82)
var assert = __webpack_require__(108)
var isAbsolute = __webpack_require__(277)
var globSync = __webpack_require__(278)
var common = __webpack_require__(279)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __webpack_require__(280)
var util = __webpack_require__(74)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __webpack_require__(282)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __webpack_require__(66)
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __webpack_require__(270)

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __webpack_require__(82);
var isWindows = process.platform === 'win32';
var fs = __webpack_require__(66);

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(82)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(272)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var concatMap = __webpack_require__(273);
var balanced = __webpack_require__(274);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),
/* 273 */
/***/ (function(module, exports) {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__(74);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(276);
}


/***/ }),
/* 276 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __webpack_require__(66)
var rp = __webpack_require__(269)
var minimatch = __webpack_require__(271)
var Minimatch = minimatch.Minimatch
var Glob = __webpack_require__(268).Glob
var util = __webpack_require__(74)
var path = __webpack_require__(82)
var assert = __webpack_require__(108)
var isAbsolute = __webpack_require__(277)
var common = __webpack_require__(279)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __webpack_require__(82)
var minimatch = __webpack_require__(271)
var isAbsolute = __webpack_require__(277)
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var wrappy = __webpack_require__(281)
var reqs = Object.create(null)
var once = __webpack_require__(282)

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),
/* 281 */
/***/ (function(module, exports) {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

var wrappy = __webpack_require__(281)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(284);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v1", function() { return _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(287);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v3", function() { return _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(290);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v4", function() { return _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v5", function() { return _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });






/***/ }),
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(285);
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ __webpack_exports__["default"] = (v1);

/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rng; });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(221);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);

function rng() {
  return crypto__WEBPACK_IMPORTED_MODULE_0___default.a.randomBytes(16);
}

/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

/* harmony default export */ __webpack_exports__["default"] = (bytesToUuid);

/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(288);
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(289);


const v3 = Object(_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (v3);

/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DNS", function() { return DNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URL", function() { return URL; });
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(286);


function uuidToBytes(uuid) {
  // Note: We assume we're being passed a valid uuid string
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = new Array(str.length);

  for (var i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ __webpack_exports__["default"] = (function (name, version, hashfunc) {
  var generateUUID = function (value, namespace, buf, offset) {
    var off = buf && offset || 0;
    if (typeof value == 'string') value = stringToBytes(value);
    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3

    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }

    return buf || Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_0__["default"])(bytes);
  }; // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name;
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
});

/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(221);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);


function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto__WEBPACK_IMPORTED_MODULE_0___default.a.createHash('md5').update(bytes).digest();
}

/* harmony default export */ __webpack_exports__["default"] = (md5);

/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(285);
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);



function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ __webpack_exports__["default"] = (v4);

/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(288);
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(292);


const v5 = Object(_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (v5);

/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(221);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);


function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto__WEBPACK_IMPORTED_MODULE_0___default.a.createHash('sha1').update(bytes).digest();
}

/* harmony default export */ __webpack_exports__["default"] = (sha1);

/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocument", function() { return TextDocument; });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (changes, version) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                var range = getWellformedRange(change.range);
                // update content
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return { line: line, character: offset - lineOffsets[line] };
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.isIncremental = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    };
    FullTextDocument.isFull = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    };
    return FullTextDocument;
}());
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifing its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = 0;
        var spans = [];
        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
            var e = sortedEdits_1[_i];
            var startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    var p = (data.length / 2) | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
    if (textOffset === void 0) { textOffset = 0; }
    var result = isAtLineStart ? [textOffset] : [];
    for (var i = 0; i < text.length; i++) {
        var ch = text.charCodeAt(i);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function getWellformedRange(range) {
    var start = range.start;
    var end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    var range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range: range };
    }
    return textEdit;
}


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const os_1 = tslib_1.__importDefault(__webpack_require__(76));
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const types_1 = __webpack_require__(295);
const object_1 = __webpack_require__(249);
const util_1 = __webpack_require__(238);
const configuration_1 = __webpack_require__(296);
const model_1 = __webpack_require__(297);
const util_2 = __webpack_require__(298);
const is_1 = __webpack_require__(250);
const fs_2 = __webpack_require__(304);
const logger = __webpack_require__(64)('configurations');
function lookUp(tree, key) {
    if (key) {
        if (tree && tree.hasOwnProperty(key))
            return tree[key];
        const parts = key.split('.');
        let node = tree;
        for (let i = 0; node && i < parts.length; i++) {
            node = node[parts[i]];
        }
        return node;
    }
    return tree;
}
class Configurations {
    constructor(userConfigFile, _proxy) {
        this.userConfigFile = userConfigFile;
        this._proxy = _proxy;
        this._errorItems = [];
        this._folderConfigurations = new Map();
        this._onError = new vscode_languageserver_protocol_1.Emitter();
        this._onChange = new vscode_languageserver_protocol_1.Emitter();
        this.disposables = [];
        this.onError = this._onError.event;
        this.onDidChange = this._onChange.event;
        let user = this.parseContentFromFile(userConfigFile);
        let data = {
            defaults: util_2.loadDefaultConfigurations(),
            user,
            workspace: { contents: {} }
        };
        this._configuration = Configurations.parse(data);
        this.watchFile(userConfigFile, types_1.ConfigurationTarget.User);
        let folderConfigFile = path_1.default.join(process.cwd(), `.vim/${util_1.CONFIG_FILE_NAME}`);
        if (folderConfigFile != userConfigFile && fs_1.default.existsSync(folderConfigFile)) {
            this.addFolderFile(folderConfigFile);
        }
    }
    parseContentFromFile(filepath) {
        if (!filepath)
            return { contents: {} };
        let uri = vscode_uri_1.URI.file(filepath).toString();
        this._errorItems = this._errorItems.filter(o => o.location.uri != uri);
        let res = util_2.parseContentFromFile(filepath, errors => {
            this._errorItems.push(...errors);
        });
        this._onError.fire(this._errorItems);
        return res;
    }
    get errorItems() {
        return this._errorItems;
    }
    get foldConfigurations() {
        return this._folderConfigurations;
    }
    // used for extensions, no change event fired
    extendsDefaults(props) {
        let { defaults } = this._configuration;
        let { contents } = defaults;
        contents = object_1.deepClone(contents);
        Object.keys(props).forEach(key => {
            util_2.addToValueTree(contents, key, props[key], msg => {
                logger.error(msg);
            });
        });
        let data = {
            defaults: { contents },
            user: this._configuration.user,
            workspace: this._configuration.workspace
        };
        this._configuration = Configurations.parse(data);
    }
    // change user configuration, without change file
    updateUserConfig(props) {
        if (!props || Object.keys(props).length == 0)
            return;
        let { user } = this._configuration;
        let model = user.clone();
        Object.keys(props).forEach(key => {
            let val = props[key];
            if (val === undefined) {
                model.removeValue(key);
            }
            else if (is_1.objectLiteral(val)) {
                for (let k of Object.keys(val)) {
                    model.setValue(`${key}.${k}`, val[k]);
                }
            }
            else {
                model.setValue(key, val);
            }
        });
        this.changeConfiguration(types_1.ConfigurationTarget.User, model);
    }
    get defaults() {
        return this._configuration.defaults;
    }
    get user() {
        return this._configuration.user;
    }
    get workspace() {
        return this._configuration.workspace;
    }
    addFolderFile(filepath) {
        let { _folderConfigurations } = this;
        if (_folderConfigurations.has(filepath))
            return;
        if (path_1.default.resolve(filepath, '../..') == os_1.default.homedir())
            return;
        let model = this.parseContentFromFile(filepath);
        this.watchFile(filepath, types_1.ConfigurationTarget.Workspace);
        this.changeConfiguration(types_1.ConfigurationTarget.Workspace, model, filepath);
    }
    watchFile(filepath, target) {
        if (!fs_1.default.existsSync(filepath) || global.hasOwnProperty('__TEST__'))
            return;
        let disposable = util_1.watchFile(filepath, () => {
            let model = this.parseContentFromFile(filepath);
            this.changeConfiguration(target, model, filepath);
        });
        this.disposables.push(disposable);
    }
    // create new configuration and fire change event
    changeConfiguration(target, model, configFile) {
        let { defaults, user, workspace } = this._configuration;
        let { workspaceConfigFile } = this;
        let data = {
            defaults: target == types_1.ConfigurationTarget.Global ? model : defaults,
            user: target == types_1.ConfigurationTarget.User ? model : user,
            workspace: target == types_1.ConfigurationTarget.Workspace ? model : workspace,
        };
        let configuration = Configurations.parse(data);
        let changed = util_2.getChangedKeys(this._configuration.getValue(), configuration.getValue());
        if (target == types_1.ConfigurationTarget.Workspace && configFile) {
            this._folderConfigurations.set(configFile, new model_1.ConfigurationModel(model.contents));
            this.workspaceConfigFile = configFile;
        }
        if (changed.length == 0)
            return;
        this._configuration = configuration;
        this._onChange.fire({
            affectsConfiguration: (section, resource) => {
                if (!resource || target != types_1.ConfigurationTarget.Workspace)
                    return changed.includes(section);
                let u = vscode_uri_1.URI.parse(resource);
                if (u.scheme !== 'file')
                    return changed.includes(section);
                let filepath = u.fsPath;
                let preRoot = workspaceConfigFile ? path_1.default.resolve(workspaceConfigFile, '../..') : '';
                if (configFile && !fs_2.isParentFolder(preRoot, filepath, true) && !fs_2.isParentFolder(path_1.default.resolve(configFile, '../..'), filepath)) {
                    return false;
                }
                return changed.includes(section);
            }
        });
    }
    setFolderConfiguration(uri) {
        let u = vscode_uri_1.URI.parse(uri);
        if (u.scheme != 'file')
            return;
        let filepath = u.fsPath;
        for (let [configFile, model] of this.foldConfigurations) {
            let root = path_1.default.resolve(configFile, '../..');
            if (fs_2.isParentFolder(root, filepath, true) && this.workspaceConfigFile != configFile) {
                this.changeConfiguration(types_1.ConfigurationTarget.Workspace, model, configFile);
                break;
            }
        }
    }
    hasFolderConfiguration(filepath) {
        let { folders } = this;
        return folders.findIndex(f => fs_2.isParentFolder(f, filepath, true)) !== -1;
    }
    getConfigFile(target) {
        if (target == types_1.ConfigurationTarget.Global)
            return null;
        if (target == types_1.ConfigurationTarget.User)
            return this.userConfigFile;
        return this.workspaceConfigFile;
    }
    get folders() {
        let res = [];
        let { _folderConfigurations } = this;
        for (let folder of _folderConfigurations.keys()) {
            res.push(path_1.default.resolve(folder, '../..'));
        }
        return res;
    }
    get configuration() {
        return this._configuration;
    }
    /**
     * getConfiguration
     *
     * @public
     * @param {string} section
     * @returns {WorkspaceConfiguration}
     */
    getConfiguration(section, resource) {
        let configuration;
        if (resource) {
            let { defaults, user } = this._configuration;
            configuration = new configuration_1.Configuration(defaults, user, this.getFolderConfiguration(resource));
        }
        else {
            configuration = this._configuration;
        }
        const config = Object.freeze(lookUp(configuration.getValue(null), section));
        const result = {
            has(key) {
                return typeof lookUp(config, key) !== 'undefined';
            },
            get: (key, defaultValue) => {
                let result = lookUp(config, key);
                if (result == null)
                    return defaultValue;
                return result;
            },
            update: (key, value, isUser = false) => {
                let s = section ? `${section}.${key}` : key;
                let target = isUser ? types_1.ConfigurationTarget.User : types_1.ConfigurationTarget.Workspace;
                let model = target == types_1.ConfigurationTarget.User ? this.user.clone() : this.workspace.clone();
                if (value == undefined) {
                    model.removeValue(s);
                }
                else {
                    model.setValue(s, value);
                }
                if (target == types_1.ConfigurationTarget.Workspace && !this.workspaceConfigFile && this._proxy) {
                    let file = this.workspaceConfigFile = this._proxy.workspaceConfigFile;
                    if (!fs_1.default.existsSync(file)) {
                        let folder = path_1.default.dirname(file);
                        if (!fs_1.default.existsSync(folder))
                            fs_1.default.mkdirSync(folder);
                        fs_1.default.writeFileSync(file, '{}', { encoding: 'utf8' });
                    }
                }
                this.changeConfiguration(target, model, target == types_1.ConfigurationTarget.Workspace ? this.workspaceConfigFile : this.userConfigFile);
                if (this._proxy && !global.hasOwnProperty('__TEST__')) {
                    if (value == undefined) {
                        this._proxy.$removeConfigurationOption(target, s);
                    }
                    else {
                        this._proxy.$updateConfigurationOption(target, s, value);
                    }
                }
            },
            inspect: (key) => {
                key = section ? `${section}.${key}` : key;
                const config = this._configuration.inspect(key);
                if (config) {
                    return {
                        key,
                        defaultValue: config.default,
                        globalValue: config.user,
                        workspaceValue: config.workspace,
                    };
                }
                return undefined;
            }
        };
        Object.defineProperty(result, 'has', {
            enumerable: false
        });
        Object.defineProperty(result, 'get', {
            enumerable: false
        });
        Object.defineProperty(result, 'update', {
            enumerable: false
        });
        Object.defineProperty(result, 'inspect', {
            enumerable: false
        });
        if (typeof config === 'object') {
            object_1.mixin(result, config, false);
        }
        return object_1.deepFreeze(result);
    }
    getFolderConfiguration(uri) {
        let u = vscode_uri_1.URI.parse(uri);
        if (u.scheme != 'file')
            return new model_1.ConfigurationModel();
        let filepath = u.fsPath;
        for (let [configFile, model] of this.foldConfigurations) {
            let root = path_1.default.resolve(configFile, '../..');
            if (fs_2.isParentFolder(root, filepath, true))
                return model;
        }
        return new model_1.ConfigurationModel();
    }
    checkFolderConfiguration(uri) {
        let u = vscode_uri_1.URI.parse(uri);
        if (u.scheme != 'file')
            return;
        let rootPath = path_1.default.dirname(u.fsPath);
        if (!this.hasFolderConfiguration(rootPath)) {
            let folder = fs_2.findUp('.vim', rootPath);
            if (folder && folder != os_1.default.homedir()) {
                let file = path_1.default.join(folder, util_1.CONFIG_FILE_NAME);
                if (fs_1.default.existsSync(file)) {
                    this.addFolderFile(file);
                }
            }
        }
        else {
            this.setFolderConfiguration(uri);
        }
    }
    static parse(data) {
        const defaultConfiguration = new model_1.ConfigurationModel(data.defaults.contents);
        const userConfiguration = new model_1.ConfigurationModel(data.user.contents);
        const workspaceConfiguration = new model_1.ConfigurationModel(data.workspace.contents);
        return new configuration_1.Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, new model_1.ConfigurationModel());
    }
    dispose() {
        util_1.disposeAll(this.disposables);
    }
}
exports.default = Configurations;
//# sourceMappingURL=index.js.map

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var PatternType;
(function (PatternType) {
    PatternType[PatternType["Buffer"] = 0] = "Buffer";
    PatternType[PatternType["LanguageServer"] = 1] = "LanguageServer";
    PatternType[PatternType["Global"] = 2] = "Global";
})(PatternType = exports.PatternType || (exports.PatternType = {}));
var ExtensionType;
(function (ExtensionType) {
    ExtensionType[ExtensionType["Global"] = 0] = "Global";
    ExtensionType[ExtensionType["Local"] = 1] = "Local";
    ExtensionType[ExtensionType["SingleFile"] = 2] = "SingleFile";
    ExtensionType[ExtensionType["Internal"] = 3] = "Internal";
})(ExtensionType = exports.ExtensionType || (exports.ExtensionType = {}));
var SourceType;
(function (SourceType) {
    SourceType[SourceType["Native"] = 0] = "Native";
    SourceType[SourceType["Remote"] = 1] = "Remote";
    SourceType[SourceType["Service"] = 2] = "Service";
})(SourceType = exports.SourceType || (exports.SourceType = {}));
var MessageLevel;
(function (MessageLevel) {
    MessageLevel[MessageLevel["More"] = 0] = "More";
    MessageLevel[MessageLevel["Warning"] = 1] = "Warning";
    MessageLevel[MessageLevel["Error"] = 2] = "Error";
})(MessageLevel = exports.MessageLevel || (exports.MessageLevel = {}));
var ConfigurationTarget;
(function (ConfigurationTarget) {
    ConfigurationTarget[ConfigurationTarget["Global"] = 0] = "Global";
    ConfigurationTarget[ConfigurationTarget["User"] = 1] = "User";
    ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
})(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
var DiagnosticKind;
(function (DiagnosticKind) {
    DiagnosticKind[DiagnosticKind["Syntax"] = 0] = "Syntax";
    DiagnosticKind[DiagnosticKind["Semantic"] = 1] = "Semantic";
    DiagnosticKind[DiagnosticKind["Suggestion"] = 2] = "Suggestion";
})(DiagnosticKind = exports.DiagnosticKind || (exports.DiagnosticKind = {}));
var ServiceStat;
(function (ServiceStat) {
    ServiceStat[ServiceStat["Initial"] = 0] = "Initial";
    ServiceStat[ServiceStat["Starting"] = 1] = "Starting";
    ServiceStat[ServiceStat["StartFailed"] = 2] = "StartFailed";
    ServiceStat[ServiceStat["Running"] = 3] = "Running";
    ServiceStat[ServiceStat["Stopping"] = 4] = "Stopping";
    ServiceStat[ServiceStat["Stopped"] = 5] = "Stopped";
})(ServiceStat = exports.ServiceStat || (exports.ServiceStat = {}));
//# sourceMappingURL=types.js.map

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = __webpack_require__(297);
class Configuration {
    constructor(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _memoryConfiguration = new model_1.ConfigurationModel()) {
        this._defaultConfiguration = _defaultConfiguration;
        this._userConfiguration = _userConfiguration;
        this._workspaceConfiguration = _workspaceConfiguration;
        this._memoryConfiguration = _memoryConfiguration;
    }
    getConsolidateConfiguration() {
        if (!this._consolidateConfiguration) {
            this._consolidateConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
            this._consolidateConfiguration = this._consolidateConfiguration.freeze();
        }
        return this._consolidateConfiguration;
    }
    getValue(section) {
        let configuration = this.getConsolidateConfiguration();
        return configuration.getValue(section);
    }
    inspect(key) {
        const consolidateConfigurationModel = this.getConsolidateConfiguration();
        const { _workspaceConfiguration, _memoryConfiguration } = this;
        return {
            default: this._defaultConfiguration.freeze().getValue(key),
            user: this._userConfiguration.freeze().getValue(key),
            workspace: _workspaceConfiguration.freeze().getValue(key),
            memory: _memoryConfiguration.freeze().getValue(key),
            value: consolidateConfigurationModel.getValue(key)
        };
    }
    get defaults() {
        return this._defaultConfiguration;
    }
    get user() {
        return this._userConfiguration;
    }
    get workspace() {
        return this._workspaceConfiguration;
    }
    toData() {
        return {
            defaults: {
                contents: this._defaultConfiguration.contents
            },
            user: {
                contents: this._userConfiguration.contents
            },
            workspace: {
                contents: this._workspaceConfiguration.contents
            }
        };
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const is_1 = __webpack_require__(250);
const object_1 = __webpack_require__(249);
const util_1 = __webpack_require__(298);
class ConfigurationModel {
    constructor(_contents = {}) {
        this._contents = _contents;
    }
    get contents() {
        return this._contents;
    }
    clone() {
        return new ConfigurationModel(object_1.deepClone(this._contents));
    }
    getValue(section) {
        let res = section
            ? util_1.getConfigurationValue(this.contents, section)
            : this.contents;
        return res;
    }
    merge(...others) {
        const contents = object_1.deepClone(this.contents);
        for (const other of others) {
            this.mergeContents(contents, other.contents);
        }
        return new ConfigurationModel(contents);
    }
    freeze() {
        if (!Object.isFrozen(this._contents)) {
            Object.freeze(this._contents);
        }
        return this;
    }
    mergeContents(source, target) {
        for (const key of Object.keys(target)) {
            if (key in source) {
                if (is_1.objectLiteral(source[key]) && is_1.objectLiteral(target[key])) {
                    this.mergeContents(source[key], target[key]);
                    continue;
                }
            }
            source[key] = object_1.deepClone(target[key]);
        }
    }
    // Update methods
    setValue(key, value) {
        util_1.addToValueTree(this.contents, key, value, message => {
            console.error(message);
        });
    }
    removeValue(key) {
        util_1.removeFromValueTree(this.contents, key);
    }
}
exports.ConfigurationModel = ConfigurationModel;
//# sourceMappingURL=model.js.map

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_languageserver_textdocument_1 = __webpack_require__(293);
const jsonc_parser_1 = __webpack_require__(299);
const is_1 = __webpack_require__(250);
const object_1 = __webpack_require__(249);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const vscode_uri_1 = __webpack_require__(243);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const logger = __webpack_require__(64)('configuration-util');
const isWebpack = typeof __webpack_require__ === "function";
const pluginRoot = isWebpack ? path_1.default.dirname(__dirname) : path_1.default.resolve(__dirname, '../..');
function parseContentFromFile(filepath, onError) {
    if (!filepath || !fs_1.default.existsSync(filepath))
        return { contents: {} };
    let content;
    let uri = vscode_uri_1.URI.file(filepath).toString();
    try {
        content = fs_1.default.readFileSync(filepath, 'utf8');
    }
    catch (_e) {
        content = '';
    }
    let [errors, contents] = parseConfiguration(content);
    if (errors && errors.length) {
        onError(convertErrors(uri, content, errors));
    }
    return { contents };
}
exports.parseContentFromFile = parseContentFromFile;
function parseConfiguration(content) {
    if (content.length == 0)
        return [[], {}];
    let errors = [];
    let data = jsonc_parser_1.parse(content, errors, { allowTrailingComma: true });
    function addProperty(current, key, remains, value) {
        if (remains.length == 0) {
            current[key] = convert(value);
        }
        else {
            if (!current[key])
                current[key] = {};
            let o = current[key];
            let first = remains.shift();
            addProperty(o, first, remains, value);
        }
    }
    function convert(obj, split = false) {
        if (!is_1.objectLiteral(obj))
            return obj;
        if (is_1.emptyObject(obj))
            return {};
        let dest = {};
        for (let key of Object.keys(obj)) {
            if (split && key.includes('.')) {
                let parts = key.split('.');
                let first = parts.shift();
                addProperty(dest, first, parts, obj[key]);
            }
            else {
                dest[key] = convert(obj[key]);
            }
        }
        return dest;
    }
    return [errors, convert(data, true)];
}
exports.parseConfiguration = parseConfiguration;
function convertErrors(uri, content, errors) {
    let items = [];
    let document = vscode_languageserver_textdocument_1.TextDocument.create(uri, 'json', 0, content);
    for (let err of errors) {
        let msg = 'parse error';
        switch (err.error) {
            case 2:
                msg = 'invalid number';
                break;
            case 8:
                msg = 'close brace expected';
                break;
            case 5:
                msg = 'colon expected';
                break;
            case 6:
                msg = 'comma expected';
                break;
            case 9:
                msg = 'end of file expected';
                break;
            case 16:
                msg = 'invaliad character';
                break;
            case 10:
                msg = 'invalid commment token';
                break;
            case 15:
                msg = 'invalid escape character';
                break;
            case 1:
                msg = 'invalid symbol';
                break;
            case 14:
                msg = 'invalid unicode';
                break;
            case 3:
                msg = 'property name expected';
                break;
            case 13:
                msg = 'unexpected end of number';
                break;
            case 12:
                msg = 'unexpected end of string';
                break;
            case 11:
                msg = 'unexpected end of comment';
                break;
            case 4:
                msg = 'value expected';
                break;
            default:
                msg = 'Unknwn error';
                break;
        }
        let range = {
            start: document.positionAt(err.offset),
            end: document.positionAt(err.offset + err.length),
        };
        let loc = vscode_languageserver_protocol_1.Location.create(uri, range);
        items.push({ location: loc, message: msg });
    }
    return items;
}
exports.convertErrors = convertErrors;
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
    const segments = key.split('.');
    const last = segments.pop();
    let curr = settingsTreeRoot;
    for (let i = 0; i < segments.length; i++) {
        let s = segments[i];
        let obj = curr[s];
        switch (typeof obj) {
            case 'function': {
                obj = curr[s] = {};
                break;
            }
            case 'undefined': {
                obj = curr[s] = {};
                break;
            }
            case 'object':
                break;
            default:
                conflictReporter(`Ignoring ${key} as ${segments
                    .slice(0, i + 1)
                    .join('.')} is ${JSON.stringify(obj)}`);
                return;
        }
        curr = obj;
    }
    if (typeof curr === 'object') {
        curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606
    }
    else {
        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);
    }
}
exports.addToValueTree = addToValueTree;
function removeFromValueTree(valueTree, key) {
    const segments = key.split('.');
    doRemoveFromValueTree(valueTree, segments);
}
exports.removeFromValueTree = removeFromValueTree;
function doRemoveFromValueTree(valueTree, segments) {
    const first = segments.shift();
    if (segments.length === 0) {
        // Reached last segment
        delete valueTree[first];
        return;
    }
    if (Object.keys(valueTree).includes(first)) {
        const value = valueTree[first];
        if (typeof value === 'object' && !Array.isArray(value)) {
            doRemoveFromValueTree(value, segments);
            if (Object.keys(value).length === 0) {
                delete valueTree[first];
            }
        }
    }
}
function getConfigurationValue(config, settingPath, defaultValue) {
    function accessSetting(config, path) {
        let current = config;
        for (let i = 0; i < path.length; i++) {
            if (typeof current !== 'object' || current === null) {
                return undefined;
            }
            current = current[path[i]];
        }
        return current;
    }
    const path = settingPath.split('.');
    const result = accessSetting(config, path);
    return typeof result === 'undefined' ? defaultValue : result;
}
exports.getConfigurationValue = getConfigurationValue;
function loadDefaultConfigurations() {
    let file = path_1.default.join(pluginRoot, 'data/schema.json');
    if (!fs_1.default.existsSync(file)) {
        console.error('schema.json not found, reinstall coc.nvim to fix this!');
        return { contents: {} };
    }
    let content = fs_1.default.readFileSync(file, 'utf8');
    let { properties } = JSON.parse(content);
    let config = {};
    Object.keys(properties).forEach(key => {
        let value = properties[key].default;
        if (value !== undefined) {
            addToValueTree(config, key, value, message => {
                logger.error(message);
            });
        }
    });
    return { contents: config };
}
exports.loadDefaultConfigurations = loadDefaultConfigurations;
function getKeys(obj, curr) {
    let keys = [];
    for (let key of Object.keys(obj)) {
        let val = obj[key];
        let newKey = curr ? `${curr}.${key}` : key;
        keys.push(newKey);
        if (is_1.objectLiteral(val)) {
            keys.push(...getKeys(val, newKey));
        }
    }
    return keys;
}
exports.getKeys = getKeys;
function getChangedKeys(from, to) {
    let keys = [];
    let fromKeys = getKeys(from);
    let toKeys = getKeys(to);
    const added = toKeys.filter(key => !fromKeys.includes(key));
    const removed = fromKeys.filter(key => !toKeys.includes(key));
    keys.push(...added);
    keys.push(...removed);
    for (const key of fromKeys) {
        if (!toKeys.includes(key))
            continue;
        const value1 = getConfigurationValue(from, key);
        const value2 = getConfigurationValue(to, key);
        if (!object_1.equals(value1, value2)) {
            keys.push(key);
        }
    }
    return keys;
}
exports.getChangedKeys = getChangedKeys;
//# sourceMappingURL=util.js.map

/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createScanner", function() { return createScanner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocation", function() { return getLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseTree", function() { return parseTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNodeAtLocation", function() { return findNodeAtLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNodeAtOffset", function() { return findNodeAtOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNodePath", function() { return getNodePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNodeValue", function() { return getNodeValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visit", function() { return visit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripComments", function() { return stripComments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "printParseErrorCode", function() { return printParseErrorCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modify", function() { return modify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyEdits", function() { return applyEdits; });
/* harmony import */ var _impl_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(300);
/* harmony import */ var _impl_edit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(302);
/* harmony import */ var _impl_scanner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(301);
/* harmony import */ var _impl_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(303);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
var createScanner = _impl_scanner__WEBPACK_IMPORTED_MODULE_2__["createScanner"];
/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
var getLocation = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["getLocation"];
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore, always check the errors list to find out if the input was valid.
 */
var parse = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["parse"];
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
var parseTree = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["parseTree"];
/**
 * Finds the node at the given path in a JSON DOM.
 */
var findNodeAtLocation = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["findNodeAtLocation"];
/**
 * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
var findNodeAtOffset = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["findNodeAtOffset"];
/**
 * Gets the JSON path of the given JSON DOM node
 */
var getNodePath = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["getNodePath"];
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
var getNodeValue = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["getNodeValue"];
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
var visit = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["visit"];
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
var stripComments = _impl_parser__WEBPACK_IMPORTED_MODULE_3__["stripComments"];
function printParseErrorCode(code) {
    switch (code) {
        case 1 /* InvalidSymbol */: return 'InvalidSymbol';
        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';
        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';
        case 4 /* ValueExpected */: return 'ValueExpected';
        case 5 /* ColonExpected */: return 'ColonExpected';
        case 6 /* CommaExpected */: return 'CommaExpected';
        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';
        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';
        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';
        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';
        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';
        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';
        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';
        case 14 /* InvalidUnicode */: return 'InvalidUnicode';
        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';
        case 16 /* InvalidCharacter */: return 'InvalidCharacter';
    }
    return '<unknown ParseErrorCode>';
}
/**
 * Computes the edits needed to format a JSON document.
 *
 * @param documentText The input text
 * @param range The range to format or `undefined` to format the full content
 * @param options The formatting options
 * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or
 * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of
 * text in the original document. However, multiple edits can have
 * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.
 * To apply edits to an input, you can use `applyEdits`.
 */
function format(documentText, range, options) {
    return _impl_format__WEBPACK_IMPORTED_MODULE_0__["format"](documentText, range, options);
}
/**
 * Computes the edits needed to modify a value in the JSON document.
 *
 * @param documentText The input text
 * @param path The path of the value to change. The path represents either to the document root, a property or an array item.
 * If the path points to an non-existing property or item, it will be created.
 * @param value The new value for the specified property or item. If the value is undefined,
 * the property or item will be removed.
 * @param options Options
 * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or
 * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of
 * text in the original document. However, multiple edits can have
 * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.
 * To apply edits to an input, you can use `applyEdits`.
 */
function modify(text, path, value, options) {
    return _impl_edit__WEBPACK_IMPORTED_MODULE_1__["setProperty"](text, path, value, options);
}
/**
 * Applies edits to a input string.
 */
function applyEdits(text, edits) {
    for (var i = edits.length - 1; i >= 0; i--) {
        text = _impl_edit__WEBPACK_IMPORTED_MODULE_1__["applyEdit"](text, edits[i]);
    }
    return text;
}


/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEOL", function() { return isEOL; });
/* harmony import */ var _scanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(301);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function format(documentText, range, options) {
    var initialIndentLevel;
    var formatText;
    var formatTextStart;
    var rangeStart;
    var rangeEnd;
    if (range) {
        rangeStart = range.offset;
        rangeEnd = rangeStart + range.length;
        formatTextStart = rangeStart;
        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
            formatTextStart--;
        }
        var endOffset = rangeEnd;
        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
            endOffset++;
        }
        formatText = documentText.substring(formatTextStart, endOffset);
        initialIndentLevel = computeIndentLevel(formatText, options);
    }
    else {
        formatText = documentText;
        initialIndentLevel = 0;
        formatTextStart = 0;
        rangeStart = 0;
        rangeEnd = documentText.length;
    }
    var eol = getEOL(options, documentText);
    var lineBreak = false;
    var indentLevel = 0;
    var indentValue;
    if (options.insertSpaces) {
        indentValue = repeat(' ', options.tabSize || 4);
    }
    else {
        indentValue = '\t';
    }
    var scanner = Object(_scanner__WEBPACK_IMPORTED_MODULE_0__["createScanner"])(formatText, false);
    var hasError = false;
    function newLineAndIndent() {
        return eol + repeat(indentValue, initialIndentLevel + indentLevel);
    }
    function scanNext() {
        var token = scanner.scan();
        lineBreak = false;
        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {
            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);
            token = scanner.scan();
        }
        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;
        return token;
    }
    var editOperations = [];
    function addEdit(text, startOffset, endOffset) {
        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {
            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
        }
    }
    var firstToken = scanNext();
    if (firstToken !== 17 /* EOF */) {
        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;
        var initialIndent = repeat(indentValue, initialIndentLevel);
        addEdit(initialIndent, formatTextStart, firstTokenStart);
    }
    while (firstToken !== 17 /* EOF */) {
        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
        var secondToken = scanNext();
        var replaceContent = '';
        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
            // comments on the same line: keep them on the same line, but ignore them otherwise
            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;
            addEdit(' ', firstTokenEnd, commentTokenStart);
            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';
            secondToken = scanNext();
        }
        if (secondToken === 2 /* CloseBraceToken */) {
            if (firstToken !== 1 /* OpenBraceToken */) {
                indentLevel--;
                replaceContent = newLineAndIndent();
            }
        }
        else if (secondToken === 4 /* CloseBracketToken */) {
            if (firstToken !== 3 /* OpenBracketToken */) {
                indentLevel--;
                replaceContent = newLineAndIndent();
            }
        }
        else {
            switch (firstToken) {
                case 3 /* OpenBracketToken */:
                case 1 /* OpenBraceToken */:
                    indentLevel++;
                    replaceContent = newLineAndIndent();
                    break;
                case 5 /* CommaToken */:
                case 12 /* LineCommentTrivia */:
                    replaceContent = newLineAndIndent();
                    break;
                case 13 /* BlockCommentTrivia */:
                    if (lineBreak) {
                        replaceContent = newLineAndIndent();
                    }
                    else {
                        // symbol following comment on the same line: keep on same line, separate with ' '
                        replaceContent = ' ';
                    }
                    break;
                case 6 /* ColonToken */:
                    replaceContent = ' ';
                    break;
                case 10 /* StringLiteral */:
                    if (secondToken === 6 /* ColonToken */) {
                        replaceContent = '';
                        break;
                    }
                // fall through
                case 7 /* NullKeyword */:
                case 8 /* TrueKeyword */:
                case 9 /* FalseKeyword */:
                case 11 /* NumericLiteral */:
                case 2 /* CloseBraceToken */:
                case 4 /* CloseBracketToken */:
                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {
                        replaceContent = ' ';
                    }
                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {
                        hasError = true;
                    }
                    break;
                case 16 /* Unknown */:
                    hasError = true;
                    break;
            }
            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
                replaceContent = newLineAndIndent();
            }
        }
        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;
        addEdit(replaceContent, firstTokenEnd, secondTokenStart);
        firstToken = secondToken;
    }
    return editOperations;
}
function repeat(s, count) {
    var result = '';
    for (var i = 0; i < count; i++) {
        result += s;
    }
    return result;
}
function computeIndentLevel(content, options) {
    var i = 0;
    var nChars = 0;
    var tabSize = options.tabSize || 4;
    while (i < content.length) {
        var ch = content.charAt(i);
        if (ch === ' ') {
            nChars++;
        }
        else if (ch === '\t') {
            nChars += tabSize;
        }
        else {
            break;
        }
        i++;
    }
    return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
    for (var i = 0; i < text.length; i++) {
        var ch = text.charAt(i);
        if (ch === '\r') {
            if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                return '\r\n';
            }
            return '\r';
        }
        else if (ch === '\n') {
            return '\n';
        }
    }
    return (options && options.eol) || '\n';
}
function isEOL(text, offset) {
    return '\r\n'.indexOf(text.charAt(offset)) !== -1;
}


/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createScanner", function() { return createScanner; });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
function createScanner(text, ignoreTrivia) {
    if (ignoreTrivia === void 0) { ignoreTrivia = false; }
    var len = text.length;
    var pos = 0, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;
    function scanHexDigits(count, exact) {
        var digits = 0;
        var value = 0;
        while (digits < count || !exact) {
            var ch = text.charCodeAt(pos);
            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                value = value * 16 + ch - 48 /* _0 */;
            }
            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                value = value * 16 + ch - 65 /* A */ + 10;
            }
            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                value = value * 16 + ch - 97 /* a */ + 10;
            }
            else {
                break;
            }
            pos++;
            digits++;
        }
        if (digits < count) {
            value = -1;
        }
        return value;
    }
    function setPosition(newPosition) {
        pos = newPosition;
        value = '';
        tokenOffset = 0;
        token = 16 /* Unknown */;
        scanError = 0 /* None */;
    }
    function scanNumber() {
        var start = pos;
        if (text.charCodeAt(pos) === 48 /* _0 */) {
            pos++;
        }
        else {
            pos++;
            while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
            }
        }
        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
            pos++;
            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            else {
                scanError = 3 /* UnexpectedEndOfNumber */;
                return text.substring(start, pos);
            }
        }
        var end = pos;
        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
            pos++;
            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                pos++;
            }
            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
                end = pos;
            }
            else {
                scanError = 3 /* UnexpectedEndOfNumber */;
            }
        }
        return text.substring(start, end);
    }
    function scanString() {
        var result = '', start = pos;
        while (true) {
            if (pos >= len) {
                result += text.substring(start, pos);
                scanError = 2 /* UnexpectedEndOfString */;
                break;
            }
            var ch = text.charCodeAt(pos);
            if (ch === 34 /* doubleQuote */) {
                result += text.substring(start, pos);
                pos++;
                break;
            }
            if (ch === 92 /* backslash */) {
                result += text.substring(start, pos);
                pos++;
                if (pos >= len) {
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                var ch2 = text.charCodeAt(pos++);
                switch (ch2) {
                    case 34 /* doubleQuote */:
                        result += '\"';
                        break;
                    case 92 /* backslash */:
                        result += '\\';
                        break;
                    case 47 /* slash */:
                        result += '/';
                        break;
                    case 98 /* b */:
                        result += '\b';
                        break;
                    case 102 /* f */:
                        result += '\f';
                        break;
                    case 110 /* n */:
                        result += '\n';
                        break;
                    case 114 /* r */:
                        result += '\r';
                        break;
                    case 116 /* t */:
                        result += '\t';
                        break;
                    case 117 /* u */:
                        var ch3 = scanHexDigits(4, true);
                        if (ch3 >= 0) {
                            result += String.fromCharCode(ch3);
                        }
                        else {
                            scanError = 4 /* InvalidUnicode */;
                        }
                        break;
                    default:
                        scanError = 5 /* InvalidEscapeCharacter */;
                }
                start = pos;
                continue;
            }
            if (ch >= 0 && ch <= 0x1f) {
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                else {
                    scanError = 6 /* InvalidCharacter */;
                    // mark as error but continue with string
                }
            }
            pos++;
        }
        return result;
    }
    function scanNext() {
        value = '';
        scanError = 0 /* None */;
        tokenOffset = pos;
        lineStartOffset = lineNumber;
        prevTokenLineStartOffset = tokenLineStartOffset;
        if (pos >= len) {
            // at the end
            tokenOffset = len;
            return token = 17 /* EOF */;
        }
        var code = text.charCodeAt(pos);
        // trivia: whitespace
        if (isWhiteSpace(code)) {
            do {
                pos++;
                value += String.fromCharCode(code);
                code = text.charCodeAt(pos);
            } while (isWhiteSpace(code));
            return token = 15 /* Trivia */;
        }
        // trivia: newlines
        if (isLineBreak(code)) {
            pos++;
            value += String.fromCharCode(code);
            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                pos++;
                value += '\n';
            }
            lineNumber++;
            tokenLineStartOffset = pos;
            return token = 14 /* LineBreakTrivia */;
        }
        switch (code) {
            // tokens: []{}:,
            case 123 /* openBrace */:
                pos++;
                return token = 1 /* OpenBraceToken */;
            case 125 /* closeBrace */:
                pos++;
                return token = 2 /* CloseBraceToken */;
            case 91 /* openBracket */:
                pos++;
                return token = 3 /* OpenBracketToken */;
            case 93 /* closeBracket */:
                pos++;
                return token = 4 /* CloseBracketToken */;
            case 58 /* colon */:
                pos++;
                return token = 6 /* ColonToken */;
            case 44 /* comma */:
                pos++;
                return token = 5 /* CommaToken */;
            // strings
            case 34 /* doubleQuote */:
                pos++;
                value = scanString();
                return token = 10 /* StringLiteral */;
            // comments
            case 47 /* slash */:
                var start = pos - 1;
                // Single-line comment
                if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                    pos += 2;
                    while (pos < len) {
                        if (isLineBreak(text.charCodeAt(pos))) {
                            break;
                        }
                        pos++;
                    }
                    value = text.substring(start, pos);
                    return token = 12 /* LineCommentTrivia */;
                }
                // Multi-line comment
                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                    pos += 2;
                    var safeLength = len - 1; // For lookahead.
                    var commentClosed = false;
                    while (pos < safeLength) {
                        var ch = text.charCodeAt(pos);
                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            commentClosed = true;
                            break;
                        }
                        pos++;
                        if (isLineBreak(ch)) {
                            if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                                pos++;
                            }
                            lineNumber++;
                            tokenLineStartOffset = pos;
                        }
                    }
                    if (!commentClosed) {
                        pos++;
                        scanError = 1 /* UnexpectedEndOfComment */;
                    }
                    value = text.substring(start, pos);
                    return token = 13 /* BlockCommentTrivia */;
                }
                // just a single slash
                value += String.fromCharCode(code);
                pos++;
                return token = 16 /* Unknown */;
            // numbers
            case 45 /* minus */:
                value += String.fromCharCode(code);
                pos++;
                if (pos === len || !isDigit(text.charCodeAt(pos))) {
                    return token = 16 /* Unknown */;
                }
            // found a minus, followed by a number so
            // we fall through to proceed with scanning
            // numbers
            case 48 /* _0 */:
            case 49 /* _1 */:
            case 50 /* _2 */:
            case 51 /* _3 */:
            case 52 /* _4 */:
            case 53 /* _5 */:
            case 54 /* _6 */:
            case 55 /* _7 */:
            case 56 /* _8 */:
            case 57 /* _9 */:
                value += scanNumber();
                return token = 11 /* NumericLiteral */;
            // literals and unknown symbols
            default:
                // is a literal? Read the full word.
                while (pos < len && isUnknownContentCharacter(code)) {
                    pos++;
                    code = text.charCodeAt(pos);
                }
                if (tokenOffset !== pos) {
                    value = text.substring(tokenOffset, pos);
                    // keywords: true, false, null
                    switch (value) {
                        case 'true': return token = 8 /* TrueKeyword */;
                        case 'false': return token = 9 /* FalseKeyword */;
                        case 'null': return token = 7 /* NullKeyword */;
                    }
                    return token = 16 /* Unknown */;
                }
                // some
                value += String.fromCharCode(code);
                pos++;
                return token = 16 /* Unknown */;
        }
    }
    function isUnknownContentCharacter(code) {
        if (isWhiteSpace(code) || isLineBreak(code)) {
            return false;
        }
        switch (code) {
            case 125 /* closeBrace */:
            case 93 /* closeBracket */:
            case 123 /* openBrace */:
            case 91 /* openBracket */:
            case 34 /* doubleQuote */:
            case 58 /* colon */:
            case 44 /* comma */:
            case 47 /* slash */:
                return false;
        }
        return true;
    }
    function scanNextNonTrivia() {
        var result;
        do {
            result = scanNext();
        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);
        return result;
    }
    return {
        setPosition: setPosition,
        getPosition: function () { return pos; },
        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
        getToken: function () { return token; },
        getTokenValue: function () { return value; },
        getTokenOffset: function () { return tokenOffset; },
        getTokenLength: function () { return pos - tokenOffset; },
        getTokenStartLine: function () { return lineStartOffset; },
        getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },
        getTokenError: function () { return scanError; },
    };
}
function isWhiteSpace(ch) {
    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
}
function isLineBreak(ch) {
    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
}
function isDigit(ch) {
    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
}


/***/ }),
/* 302 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeProperty", function() { return removeProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setProperty", function() { return setProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyEdit", function() { return applyEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWS", function() { return isWS; });
/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(300);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(303);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



function removeProperty(text, path, options) {
    return setProperty(text, path, void 0, options);
}
function setProperty(text, originalPath, value, options) {
    var _a;
    var path = originalPath.slice();
    var errors = [];
    var root = Object(_parser__WEBPACK_IMPORTED_MODULE_1__["parseTree"])(text, errors);
    var parent = void 0;
    var lastSegment = void 0;
    while (path.length > 0) {
        lastSegment = path.pop();
        parent = Object(_parser__WEBPACK_IMPORTED_MODULE_1__["findNodeAtLocation"])(root, path);
        if (parent === void 0 && value !== void 0) {
            if (typeof lastSegment === 'string') {
                value = (_a = {}, _a[lastSegment] = value, _a);
            }
            else {
                value = [value];
            }
        }
        else {
            break;
        }
    }
    if (!parent) {
        // empty document
        if (value === void 0) { // delete
            throw new Error('Can not delete in empty document');
        }
        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);
    }
    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {
        var existing = Object(_parser__WEBPACK_IMPORTED_MODULE_1__["findNodeAtLocation"])(parent, [lastSegment]);
        if (existing !== void 0) {
            if (value === void 0) { // delete
                if (!existing.parent) {
                    throw new Error('Malformed AST');
                }
                var propertyIndex = parent.children.indexOf(existing.parent);
                var removeBegin = void 0;
                var removeEnd = existing.parent.offset + existing.parent.length;
                if (propertyIndex > 0) {
                    // remove the comma of the previous node
                    var previous = parent.children[propertyIndex - 1];
                    removeBegin = previous.offset + previous.length;
                }
                else {
                    removeBegin = parent.offset + 1;
                    if (parent.children.length > 1) {
                        // remove the comma of the next node
                        var next = parent.children[1];
                        removeEnd = next.offset;
                    }
                }
                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);
            }
            else {
                // set value of existing property
                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);
            }
        }
        else {
            if (value === void 0) { // delete
                return []; // property does not exist, nothing to do
            }
            var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
            var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;
            var edit = void 0;
            if (index > 0) {
                var previous = parent.children[index - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            else if (parent.children.length === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty };
            }
            else {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };
            }
            return withFormatting(text, edit, options);
        }
    }
    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {
        var insertIndex = lastSegment;
        if (insertIndex === -1) {
            // Insert
            var newProperty = "" + JSON.stringify(value);
            var edit = void 0;
            if (parent.children.length === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty };
            }
            else {
                var previous = parent.children[parent.children.length - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            return withFormatting(text, edit, options);
        }
        else if (value === void 0 && parent.children.length >= 0) {
            // Removal
            var removalIndex = lastSegment;
            var toRemove = parent.children[removalIndex];
            var edit = void 0;
            if (parent.children.length === 1) {
                // only item
                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };
            }
            else if (parent.children.length - 1 === removalIndex) {
                // last item
                var previous = parent.children[removalIndex - 1];
                var offset = previous.offset + previous.length;
                var parentEndOffset = parent.offset + parent.length;
                edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };
            }
            else {
                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };
            }
            return withFormatting(text, edit, options);
        }
        else if (value !== void 0) {
            var edit = void 0;
            var newProperty = "" + JSON.stringify(value);
            if (!options.isArrayInsertion && parent.children.length > lastSegment) {
                var toModify = parent.children[lastSegment];
                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };
            }
            else if (parent.children.length === 0 || lastSegment === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };
            }
            else {
                var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
                var previous = parent.children[index - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            return withFormatting(text, edit, options);
        }
        else {
            throw new Error("Can not " + (value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify')) + " Array index " + insertIndex + " as length is not sufficient");
        }
    }
    else {
        throw new Error("Can not add " + (typeof lastSegment !== 'number' ? 'index' : 'property') + " to parent of type " + parent.type);
    }
}
function withFormatting(text, edit, options) {
    if (!options.formattingOptions) {
        return [edit];
    }
    // apply the edit
    var newText = applyEdit(text, edit);
    // format the new text
    var begin = edit.offset;
    var end = edit.offset + edit.content.length;
    if (edit.length === 0 || edit.content.length === 0) { // insert or remove
        while (begin > 0 && !Object(_format__WEBPACK_IMPORTED_MODULE_0__["isEOL"])(newText, begin - 1)) {
            begin--;
        }
        while (end < newText.length && !Object(_format__WEBPACK_IMPORTED_MODULE_0__["isEOL"])(newText, end)) {
            end++;
        }
    }
    var edits = Object(_format__WEBPACK_IMPORTED_MODULE_0__["format"])(newText, { offset: begin, length: end - begin }, options.formattingOptions);
    // apply the formatting edits and track the begin and end offsets of the changes
    for (var i = edits.length - 1; i >= 0; i--) {
        var edit_1 = edits[i];
        newText = applyEdit(newText, edit_1);
        begin = Math.min(begin, edit_1.offset);
        end = Math.max(end, edit_1.offset + edit_1.length);
        end += edit_1.content.length - edit_1.length;
    }
    // create a single edit with all changes
    var editLength = text.length - (newText.length - end) - begin;
    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit) {
    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
}
function isWS(text, offset) {
    return '\r\n \t'.indexOf(text.charAt(offset)) !== -1;
}


/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocation", function() { return getLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseTree", function() { return parseTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNodeAtLocation", function() { return findNodeAtLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNodePath", function() { return getNodePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNodeValue", function() { return getNodeValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return contains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNodeAtOffset", function() { return findNodeAtOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visit", function() { return visit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripComments", function() { return stripComments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNodeType", function() { return getNodeType; });
/* harmony import */ var _scanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(301);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var ParseOptions;
(function (ParseOptions) {
    ParseOptions.DEFAULT = {
        allowTrailingComma: false
    };
})(ParseOptions || (ParseOptions = {}));
/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
function getLocation(text, position) {
    var segments = []; // strings or numbers
    var earlyReturnException = new Object();
    var previousNode = undefined;
    var previousNodeInst = {
        value: {},
        offset: 0,
        length: 0,
        type: 'object',
        parent: undefined
    };
    var isAtPropertyKey = false;
    function setPreviousNode(value, offset, length, type) {
        previousNodeInst.value = value;
        previousNodeInst.offset = offset;
        previousNodeInst.length = length;
        previousNodeInst.type = type;
        previousNodeInst.colonOffset = undefined;
        previousNode = previousNodeInst;
    }
    try {
        visit(text, {
            onObjectBegin: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                isAtPropertyKey = position > offset;
                segments.push(''); // push a placeholder (will be replaced)
            },
            onObjectProperty: function (name, offset, length) {
                if (position < offset) {
                    throw earlyReturnException;
                }
                setPreviousNode(name, offset, length, 'property');
                segments[segments.length - 1] = name;
                if (position <= offset + length) {
                    throw earlyReturnException;
                }
            },
            onObjectEnd: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.pop();
            },
            onArrayBegin: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.push(0);
            },
            onArrayEnd: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.pop();
            },
            onLiteralValue: function (value, offset, length) {
                if (position < offset) {
                    throw earlyReturnException;
                }
                setPreviousNode(value, offset, length, getNodeType(value));
                if (position <= offset + length) {
                    throw earlyReturnException;
                }
            },
            onSeparator: function (sep, offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                if (sep === ':' && previousNode && previousNode.type === 'property') {
                    previousNode.colonOffset = offset;
                    isAtPropertyKey = false;
                    previousNode = undefined;
                }
                else if (sep === ',') {
                    var last = segments[segments.length - 1];
                    if (typeof last === 'number') {
                        segments[segments.length - 1] = last + 1;
                    }
                    else {
                        isAtPropertyKey = true;
                        segments[segments.length - 1] = '';
                    }
                    previousNode = undefined;
                }
            }
        });
    }
    catch (e) {
        if (e !== earlyReturnException) {
            throw e;
        }
    }
    return {
        path: segments,
        previousNode: previousNode,
        isAtPropertyKey: isAtPropertyKey,
        matches: function (pattern) {
            var k = 0;
            for (var i = 0; k < pattern.length && i < segments.length; i++) {
                if (pattern[k] === segments[i] || pattern[k] === '*') {
                    k++;
                }
                else if (pattern[k] !== '**') {
                    return false;
                }
            }
            return k === pattern.length;
        }
    };
}
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore always check the errors list to find out if the input was valid.
 */
function parse(text, errors, options) {
    if (errors === void 0) { errors = []; }
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var currentProperty = null;
    var currentParent = [];
    var previousParents = [];
    function onValue(value) {
        if (Array.isArray(currentParent)) {
            currentParent.push(value);
        }
        else if (currentProperty !== null) {
            currentParent[currentProperty] = value;
        }
    }
    var visitor = {
        onObjectBegin: function () {
            var object = {};
            onValue(object);
            previousParents.push(currentParent);
            currentParent = object;
            currentProperty = null;
        },
        onObjectProperty: function (name) {
            currentProperty = name;
        },
        onObjectEnd: function () {
            currentParent = previousParents.pop();
        },
        onArrayBegin: function () {
            var array = [];
            onValue(array);
            previousParents.push(currentParent);
            currentParent = array;
            currentProperty = null;
        },
        onArrayEnd: function () {
            currentParent = previousParents.pop();
        },
        onLiteralValue: onValue,
        onError: function (error, offset, length) {
            errors.push({ error: error, offset: offset, length: length });
        }
    };
    visit(text, visitor, options);
    return currentParent[0];
}
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
function parseTree(text, errors, options) {
    if (errors === void 0) { errors = []; }
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root
    function ensurePropertyComplete(endOffset) {
        if (currentParent.type === 'property') {
            currentParent.length = endOffset - currentParent.offset;
            currentParent = currentParent.parent;
        }
    }
    function onValue(valueNode) {
        currentParent.children.push(valueNode);
        return valueNode;
    }
    var visitor = {
        onObjectBegin: function (offset) {
            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
        },
        onObjectProperty: function (name, offset, length) {
            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
        },
        onObjectEnd: function (offset, length) {
            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onArrayBegin: function (offset, length) {
            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
        },
        onArrayEnd: function (offset, length) {
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onLiteralValue: function (value, offset, length) {
            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
            ensurePropertyComplete(offset + length);
        },
        onSeparator: function (sep, offset, length) {
            if (currentParent.type === 'property') {
                if (sep === ':') {
                    currentParent.colonOffset = offset;
                }
                else if (sep === ',') {
                    ensurePropertyComplete(offset);
                }
            }
        },
        onError: function (error, offset, length) {
            errors.push({ error: error, offset: offset, length: length });
        }
    };
    visit(text, visitor, options);
    var result = currentParent.children[0];
    if (result) {
        delete result.parent;
    }
    return result;
}
/**
 * Finds the node at the given path in a JSON DOM.
 */
function findNodeAtLocation(root, path) {
    if (!root) {
        return undefined;
    }
    var node = root;
    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
        var segment = path_1[_i];
        if (typeof segment === 'string') {
            if (node.type !== 'object' || !Array.isArray(node.children)) {
                return undefined;
            }
            var found = false;
            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                var propertyNode = _b[_a];
                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
                    node = propertyNode.children[1];
                    found = true;
                    break;
                }
            }
            if (!found) {
                return undefined;
            }
        }
        else {
            var index = segment;
            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                return undefined;
            }
            node = node.children[index];
        }
    }
    return node;
}
/**
 * Gets the JSON path of the given JSON DOM node
 */
function getNodePath(node) {
    if (!node.parent || !node.parent.children) {
        return [];
    }
    var path = getNodePath(node.parent);
    if (node.parent.type === 'property') {
        var key = node.parent.children[0].value;
        path.push(key);
    }
    else if (node.parent.type === 'array') {
        var index = node.parent.children.indexOf(node);
        if (index !== -1) {
            path.push(index);
        }
    }
    return path;
}
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
function getNodeValue(node) {
    switch (node.type) {
        case 'array':
            return node.children.map(getNodeValue);
        case 'object':
            var obj = Object.create(null);
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var prop = _a[_i];
                var valueNode = prop.children[1];
                if (valueNode) {
                    obj[prop.children[0].value] = getNodeValue(valueNode);
                }
            }
            return obj;
        case 'null':
        case 'string':
        case 'number':
        case 'boolean':
            return node.value;
        default:
            return undefined;
    }
}
function contains(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));
}
/**
 * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
function findNodeAtOffset(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    if (contains(node, offset, includeRightBound)) {
        var children = node.children;
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {
                var item = findNodeAtOffset(children[i], offset, includeRightBound);
                if (item) {
                    return item;
                }
            }
        }
        return node;
    }
    return undefined;
}
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
function visit(text, visitor, options) {
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var _scanner = Object(_scanner__WEBPACK_IMPORTED_MODULE_0__["createScanner"])(text, false);
    function toNoArgVisit(visitFunction) {
        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };
    }
    function toOneArgVisit(visitFunction) {
        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };
    }
    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
    var disallowComments = options && options.disallowComments;
    var allowTrailingComma = options && options.allowTrailingComma;
    function scanNext() {
        while (true) {
            var token = _scanner.scan();
            switch (_scanner.getTokenError()) {
                case 4 /* InvalidUnicode */:
                    handleError(14 /* InvalidUnicode */);
                    break;
                case 5 /* InvalidEscapeCharacter */:
                    handleError(15 /* InvalidEscapeCharacter */);
                    break;
                case 3 /* UnexpectedEndOfNumber */:
                    handleError(13 /* UnexpectedEndOfNumber */);
                    break;
                case 1 /* UnexpectedEndOfComment */:
                    if (!disallowComments) {
                        handleError(11 /* UnexpectedEndOfComment */);
                    }
                    break;
                case 2 /* UnexpectedEndOfString */:
                    handleError(12 /* UnexpectedEndOfString */);
                    break;
                case 6 /* InvalidCharacter */:
                    handleError(16 /* InvalidCharacter */);
                    break;
            }
            switch (token) {
                case 12 /* LineCommentTrivia */:
                case 13 /* BlockCommentTrivia */:
                    if (disallowComments) {
                        handleError(10 /* InvalidCommentToken */);
                    }
                    else {
                        onComment();
                    }
                    break;
                case 16 /* Unknown */:
                    handleError(1 /* InvalidSymbol */);
                    break;
                case 15 /* Trivia */:
                case 14 /* LineBreakTrivia */:
                    break;
                default:
                    return token;
            }
        }
    }
    function handleError(error, skipUntilAfter, skipUntil) {
        if (skipUntilAfter === void 0) { skipUntilAfter = []; }
        if (skipUntil === void 0) { skipUntil = []; }
        onError(error);
        if (skipUntilAfter.length + skipUntil.length > 0) {
            var token = _scanner.getToken();
            while (token !== 17 /* EOF */) {
                if (skipUntilAfter.indexOf(token) !== -1) {
                    scanNext();
                    break;
                }
                else if (skipUntil.indexOf(token) !== -1) {
                    break;
                }
                token = scanNext();
            }
        }
    }
    function parseString(isValue) {
        var value = _scanner.getTokenValue();
        if (isValue) {
            onLiteralValue(value);
        }
        else {
            onObjectProperty(value);
        }
        scanNext();
        return true;
    }
    function parseLiteral() {
        switch (_scanner.getToken()) {
            case 11 /* NumericLiteral */:
                var value = 0;
                try {
                    value = JSON.parse(_scanner.getTokenValue());
                    if (typeof value !== 'number') {
                        handleError(2 /* InvalidNumberFormat */);
                        value = 0;
                    }
                }
                catch (e) {
                    handleError(2 /* InvalidNumberFormat */);
                }
                onLiteralValue(value);
                break;
            case 7 /* NullKeyword */:
                onLiteralValue(null);
                break;
            case 8 /* TrueKeyword */:
                onLiteralValue(true);
                break;
            case 9 /* FalseKeyword */:
                onLiteralValue(false);
                break;
            default:
                return false;
        }
        scanNext();
        return true;
    }
    function parseProperty() {
        if (_scanner.getToken() !== 10 /* StringLiteral */) {
            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            return false;
        }
        parseString(false);
        if (_scanner.getToken() === 6 /* ColonToken */) {
            onSeparator(':');
            scanNext(); // consume colon
            if (!parseValue()) {
                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
        }
        else {
            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
        }
        return true;
    }
    function parseObject() {
        onObjectBegin();
        scanNext(); // consume open brace
        var needsComma = false;
        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {
            if (_scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    handleError(4 /* ValueExpected */, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(6 /* CommaExpected */, [], []);
            }
            if (!parseProperty()) {
                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
            needsComma = true;
        }
        onObjectEnd();
        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {
            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);
        }
        else {
            scanNext(); // consume close brace
        }
        return true;
    }
    function parseArray() {
        onArrayBegin();
        scanNext(); // consume open bracket
        var needsComma = false;
        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {
            if (_scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    handleError(4 /* ValueExpected */, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(6 /* CommaExpected */, [], []);
            }
            if (!parseValue()) {
                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);
            }
            needsComma = true;
        }
        onArrayEnd();
        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {
            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);
        }
        else {
            scanNext(); // consume close bracket
        }
        return true;
    }
    function parseValue() {
        switch (_scanner.getToken()) {
            case 3 /* OpenBracketToken */:
                return parseArray();
            case 1 /* OpenBraceToken */:
                return parseObject();
            case 10 /* StringLiteral */:
                return parseString(true);
            default:
                return parseLiteral();
        }
    }
    scanNext();
    if (_scanner.getToken() === 17 /* EOF */) {
        if (options.allowEmptyContent) {
            return true;
        }
        handleError(4 /* ValueExpected */, [], []);
        return false;
    }
    if (!parseValue()) {
        handleError(4 /* ValueExpected */, [], []);
        return false;
    }
    if (_scanner.getToken() !== 17 /* EOF */) {
        handleError(9 /* EndOfFileExpected */, [], []);
    }
    return true;
}
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
function stripComments(text, replaceCh) {
    var _scanner = Object(_scanner__WEBPACK_IMPORTED_MODULE_0__["createScanner"])(text), parts = [], kind, offset = 0, pos;
    do {
        pos = _scanner.getPosition();
        kind = _scanner.scan();
        switch (kind) {
            case 12 /* LineCommentTrivia */:
            case 13 /* BlockCommentTrivia */:
            case 17 /* EOF */:
                if (offset !== pos) {
                    parts.push(text.substring(offset, pos));
                }
                if (replaceCh !== undefined) {
                    parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                }
                offset = _scanner.getPosition();
                break;
        }
    } while (kind !== 17 /* EOF */);
    return parts.join('');
}
function getNodeType(value) {
    switch (typeof value) {
        case 'boolean': return 'boolean';
        case 'number': return 'number';
        case 'string': return 'string';
        case 'object': {
            if (!value) {
                return 'null';
            }
            else if (Array.isArray(value)) {
                return 'array';
            }
            return 'object';
        }
        default: return 'null';
    }
}


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const child_process_1 = __webpack_require__(239);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const net_1 = tslib_1.__importDefault(__webpack_require__(157));
const os_1 = tslib_1.__importDefault(__webpack_require__(76));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const readline_1 = tslib_1.__importDefault(__webpack_require__(206));
const util_1 = tslib_1.__importDefault(__webpack_require__(74));
const minimatch_1 = tslib_1.__importDefault(__webpack_require__(271));
const logger = __webpack_require__(64)('util-fs');
async function statAsync(filepath) {
    let stat = null;
    try {
        stat = await util_1.default.promisify(fs_1.default.stat)(filepath);
    }
    catch (e) { }
    return stat;
}
exports.statAsync = statAsync;
async function isDirectory(filepath) {
    let stat = await statAsync(filepath);
    return stat && stat.isDirectory();
}
exports.isDirectory = isDirectory;
async function unlinkAsync(filepath) {
    try {
        await util_1.default.promisify(fs_1.default.unlink)(filepath);
    }
    catch (e) { }
}
exports.unlinkAsync = unlinkAsync;
function renameAsync(oldPath, newPath) {
    return new Promise((resolve, reject) => {
        fs_1.default.rename(oldPath, newPath, err => {
            if (err)
                return reject(err);
            resolve();
        });
    });
}
exports.renameAsync = renameAsync;
async function isGitIgnored(fullpath) {
    if (!fullpath)
        return false;
    let stat = await statAsync(fullpath);
    if (!stat || !stat.isFile())
        return false;
    let root = null;
    try {
        let { stdout } = await util_1.default.promisify(child_process_1.exec)('git rev-parse --show-toplevel', { cwd: path_1.default.dirname(fullpath) });
        root = stdout.trim();
    }
    catch (e) { }
    if (!root)
        return false;
    let file = path_1.default.relative(root, fullpath);
    try {
        let { stdout } = await util_1.default.promisify(child_process_1.exec)(`git check-ignore ${file}`, { cwd: root });
        return stdout.trim() == file;
    }
    catch (e) { }
    return false;
}
exports.isGitIgnored = isGitIgnored;
function resolveRoot(folder, subs, cwd) {
    let home = os_1.default.homedir();
    let dir = fixDriver(folder);
    if (isParentFolder(dir, home, true))
        return null;
    if (cwd && isParentFolder(cwd, dir, true) && inDirectory(cwd, subs))
        return cwd;
    let parts = dir.split(path_1.default.sep);
    let curr = [parts.shift()];
    for (let part of parts) {
        curr.push(part);
        let dir = curr.join(path_1.default.sep);
        if (dir != home && inDirectory(dir, subs)) {
            return dir;
        }
    }
    return null;
}
exports.resolveRoot = resolveRoot;
function inDirectory(dir, subs) {
    try {
        let files = fs_1.default.readdirSync(dir);
        for (let pattern of subs) {
            // note, only '*' expanded
            let is_wildcard = (pattern.includes('*'));
            let res = is_wildcard ?
                (minimatch_1.default.match(files, pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }).length !== 0) :
                (files.includes(pattern));
            if (res)
                return true;
        }
    }
    catch (e) {
        // could be failed without permission
    }
    return false;
}
exports.inDirectory = inDirectory;
function findUp(name, cwd) {
    let root = path_1.default.parse(cwd).root;
    let subs = Array.isArray(name) ? name : [name];
    while (cwd && cwd !== root) {
        let find = inDirectory(cwd, subs);
        if (find) {
            for (let sub of subs) {
                let filepath = path_1.default.join(cwd, sub);
                if (fs_1.default.existsSync(filepath)) {
                    return filepath;
                }
            }
        }
        cwd = path_1.default.dirname(cwd);
    }
    return null;
}
exports.findUp = findUp;
function readFile(fullpath, encoding) {
    return new Promise((resolve, reject) => {
        fs_1.default.readFile(fullpath, encoding, (err, content) => {
            if (err)
                reject(err);
            resolve(content);
        });
    });
}
exports.readFile = readFile;
function getFileLineCount(filepath) {
    let i;
    let count = 0;
    return new Promise((resolve, reject) => {
        fs_1.default.createReadStream(filepath)
            .on('error', e => reject(e))
            .on('data', chunk => {
            for (i = 0; i < chunk.length; ++i)
                if (chunk[i] == 10)
                    count++;
        })
            .on('end', () => resolve(count));
    });
}
exports.getFileLineCount = getFileLineCount;
function readFileLines(fullpath, start, end) {
    if (!fs_1.default.existsSync(fullpath)) {
        return Promise.reject(new Error(`file does not exist: ${fullpath}`));
    }
    let res = [];
    const rl = readline_1.default.createInterface({
        input: fs_1.default.createReadStream(fullpath, { encoding: 'utf8' }),
        crlfDelay: Infinity,
        terminal: false
    });
    let n = 0;
    return new Promise((resolve, reject) => {
        rl.on('line', line => {
            if (n == 0 && line.startsWith('\uFEFF')) {
                // handle BOM
                line = line.slice(1);
            }
            if (n >= start && n <= end) {
                res.push(line);
            }
            if (n == end) {
                rl.close();
            }
            n = n + 1;
        });
        rl.on('close', () => {
            resolve(res);
        });
        rl.on('error', reject);
    });
}
exports.readFileLines = readFileLines;
function readFileLine(fullpath, count) {
    if (!fs_1.default.existsSync(fullpath)) {
        return Promise.reject(new Error(`file does not exist: ${fullpath}`));
    }
    const rl = readline_1.default.createInterface({
        input: fs_1.default.createReadStream(fullpath, { encoding: 'utf8' }),
        crlfDelay: Infinity,
        terminal: false
    });
    let n = 0;
    return new Promise((resolve, reject) => {
        rl.on('line', line => {
            if (n == count) {
                if (n == 0 && line.startsWith('\uFEFF')) {
                    // handle BOM
                    line = line.slice(1);
                }
                rl.close();
                resolve(line);
                return;
            }
            n = n + 1;
        });
        rl.on('error', reject);
    });
}
exports.readFileLine = readFileLine;
async function writeFile(fullpath, content) {
    await util_1.default.promisify(fs_1.default.writeFile)(fullpath, content, { encoding: 'utf8' });
}
exports.writeFile = writeFile;
function validSocket(path) {
    let clientSocket = new net_1.default.Socket();
    return new Promise(resolve => {
        clientSocket.on('error', () => {
            resolve(false);
        });
        clientSocket.connect({ path }, () => {
            clientSocket.unref();
            resolve(true);
        });
    });
}
exports.validSocket = validSocket;
function isFile(uri) {
    return uri.startsWith('file:');
}
exports.isFile = isFile;
exports.readdirAsync = util_1.default.promisify(fs_1.default.readdir);
exports.realpathAsync = util_1.default.promisify(fs_1.default.realpath);
function parentDirs(pth) {
    let { root, dir } = path_1.default.parse(pth);
    if (dir === root)
        return [root];
    const dirs = [root];
    const parts = dir.slice(root.length).split(path_1.default.sep);
    for (let i = 1; i <= parts.length; i++) {
        dirs.push(path_1.default.join(root, parts.slice(0, i).join(path_1.default.sep)));
    }
    return dirs;
}
exports.parentDirs = parentDirs;
function isParentFolder(folder, filepath, checkEqual = false) {
    let pdir = fixDriver(path_1.default.resolve(path_1.default.normalize(folder)));
    let dir = fixDriver(path_1.default.resolve(path_1.default.normalize(filepath)));
    if (pdir == '//')
        pdir = '/';
    if (pdir == dir)
        return checkEqual ? true : false;
    if (pdir.endsWith(path_1.default.sep))
        return dir.startsWith(pdir);
    return dir.startsWith(pdir) && dir[pdir.length] == path_1.default.sep;
}
exports.isParentFolder = isParentFolder;
// use uppercase for windows driver
function fixDriver(filepath) {
    if (os_1.default.platform() != 'win32' || filepath[1] != ':')
        return filepath;
    return filepath[0].toUpperCase() + filepath.slice(1);
}
exports.fixDriver = fixDriver;
//# sourceMappingURL=fs.js.map

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const jsonc_parser_1 = __webpack_require__(299);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_uri_1 = __webpack_require__(243);
const util_1 = __webpack_require__(238);
const logger = __webpack_require__(64)('configuration-shape');
class ConfigurationProxy {
    constructor(workspace) {
        this.workspace = workspace;
    }
    get nvim() {
        return this.workspace.nvim;
    }
    async modifyConfiguration(target, key, value) {
        let { nvim, workspace } = this;
        let file = workspace.getConfigFile(target);
        if (!file)
            return;
        let formattingOptions = { tabSize: 2, insertSpaces: true };
        let content = fs_1.default.readFileSync(file, 'utf8');
        value = value == null ? undefined : value;
        let edits = jsonc_parser_1.modify(content, [key], value, { formattingOptions });
        content = jsonc_parser_1.applyEdits(content, edits);
        fs_1.default.writeFileSync(file, content, 'utf8');
        let doc = workspace.getDocument(vscode_uri_1.URI.file(file).toString());
        if (doc)
            nvim.command('checktime', true);
        return;
    }
    get workspaceConfigFile() {
        let folder = path_1.default.join(this.workspace.root, '.vim');
        return path_1.default.join(folder, util_1.CONFIG_FILE_NAME);
    }
    $updateConfigurationOption(target, key, value) {
        this.modifyConfiguration(target, key, value).logError();
    }
    $removeConfigurationOption(target, key) {
        this.modifyConfiguration(target, key).logError();
    }
}
exports.default = ConfigurationProxy;
//# sourceMappingURL=shape.js.map

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const mkdirp_1 = tslib_1.__importDefault(__webpack_require__(260));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
class DB {
    constructor(filepath) {
        this.filepath = filepath;
    }
    /**
     * Get data by key.
     *
     * @param {string} key unique key allows dot notation.
     * @returns {any}
     */
    fetch(key) {
        let obj = this.load();
        if (!key)
            return obj;
        let parts = key.split('.');
        for (let part of parts) {
            if (typeof obj[part] == 'undefined') {
                return undefined;
            }
            obj = obj[part];
        }
        return obj;
    }
    /**
     * Check if key exists
     *
     * @param {string} key unique key allows dot notation.
     */
    exists(key) {
        let obj = this.load();
        let parts = key.split('.');
        for (let part of parts) {
            if (typeof obj[part] == 'undefined') {
                return false;
            }
            obj = obj[part];
        }
        return true;
    }
    /**
     * Delete data by key
     *
     * @param {string} key unique key allows dot notation.
     */
    delete(key) {
        let obj = this.load();
        let origin = obj;
        let parts = key.split('.');
        let len = parts.length;
        for (let i = 0; i < len; i++) {
            if (typeof obj[parts[i]] == 'undefined') {
                break;
            }
            if (i == len - 1) {
                delete obj[parts[i]];
                fs_1.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2), 'utf8');
                break;
            }
            obj = obj[parts[i]];
        }
    }
    /**
     * Save data with key
     *
     * @param {string} key unique string that allows dot notation.
     * @param {number|null|boolean|string|{[index} data saved data.
     */
    push(key, data) {
        let origin = this.load() || {};
        let obj = origin;
        let parts = key.split('.');
        let len = parts.length;
        if (obj == null) {
            let dir = path_1.default.dirname(this.filepath);
            mkdirp_1.default.sync(dir);
            obj = origin;
        }
        for (let i = 0; i < len; i++) {
            let key = parts[i];
            if (i == len - 1) {
                obj[key] = data;
                fs_1.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2));
                break;
            }
            if (typeof obj[key] == 'undefined') {
                obj[key] = {};
                obj = obj[key];
            }
            else {
                obj = obj[key];
            }
        }
    }
    load() {
        let dir = path_1.default.dirname(this.filepath);
        let stat = fs_1.default.statSync(dir);
        if (!stat || !stat.isDirectory()) {
            mkdirp_1.default.sync(dir);
            fs_1.default.writeFileSync(this.filepath, '{}', 'utf8');
            return {};
        }
        try {
            let content = fs_1.default.readFileSync(this.filepath, 'utf8');
            return JSON.parse(content.trim());
        }
        catch (e) {
            fs_1.default.writeFileSync(this.filepath, '{}', 'utf8');
            return {};
        }
    }
    /**
     * Empty db file.
     */
    clear() {
        let stat = fs_1.default.statSync(this.filepath);
        if (!stat || !stat.isFile())
            return;
        fs_1.default.writeFileSync(this.filepath, '{}', 'utf8');
    }
    /**
     * Remove db file.
     */
    destroy() {
        if (fs_1.default.existsSync(this.filepath)) {
            fs_1.default.unlinkSync(this.filepath);
        }
    }
}
exports.default = DB;
//# sourceMappingURL=db.js.map

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_languageserver_textdocument_1 = __webpack_require__(293);
const vscode_uri_1 = __webpack_require__(243);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const array_1 = __webpack_require__(308);
const diff_1 = __webpack_require__(309);
const fs_1 = __webpack_require__(304);
const index_1 = __webpack_require__(238);
const position_1 = __webpack_require__(311);
const string_1 = __webpack_require__(310);
const chars_1 = __webpack_require__(312);
const logger = __webpack_require__(64)('model-document');
// wrapper class of TextDocument
class Document {
    constructor(buffer, env, maxFileSize) {
        this.buffer = buffer;
        this.env = env;
        this.maxFileSize = maxFileSize;
        this.isIgnored = false;
        // start id for matchaddpos
        this.colorId = 1080;
        this.size = 0;
        this.eol = true;
        // real current lines
        this.lines = [];
        this._attached = false;
        this._previewwindow = false;
        this._winid = -1;
        this._words = [];
        this._onDocumentChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDocumentDetach = new vscode_languageserver_protocol_1.Emitter();
        this.disposables = [];
        this.onDocumentChange = this._onDocumentChange.event;
        this.onDocumentDetach = this._onDocumentDetach.event;
        this.fireContentChanges = debounce_1.default(() => {
            this._fireContentChanges();
        }, 200);
        this.fetchContent = debounce_1.default(() => {
            this._fetchContent().logError();
        }, 100);
    }
    /**
     * Check if current document should be attached for changes.
     *
     * Currently only attach for empty and `acwrite` buftype.
     */
    get shouldAttach() {
        let { buftype, maxFileSize } = this;
        if (!this.getVar('enabled', true))
            return false;
        if (this.uri.endsWith('%5BCommand%20Line%5D'))
            return true;
        // too big
        if (this.size == -2)
            return false;
        if (maxFileSize && this.size > maxFileSize)
            return false;
        return buftype == '' || buftype == 'acwrite';
    }
    get isCommandLine() {
        return this.uri && this.uri.endsWith('%5BCommand%20Line%5D');
    }
    get enabled() {
        return this.getVar('enabled', true);
    }
    /**
     * All words, extracted by `iskeyword` option.
     */
    get words() {
        return this._words;
    }
    /**
     * Map filetype for languageserver.
     */
    convertFiletype(filetype) {
        let map = this.env.filetypeMap;
        if (filetype == 'javascript.jsx')
            return 'javascriptreact';
        if (filetype == 'typescript.jsx' || filetype == 'typescript.tsx')
            return 'typescriptreact';
        return map[filetype] || filetype;
    }
    /**
     * Get current buffer changedtick.
     */
    get changedtick() {
        return this._changedtick;
    }
    /**
     * Scheme of document.
     */
    get schema() {
        return vscode_uri_1.URI.parse(this.uri).scheme;
    }
    /**
     * Line count of current buffer.
     */
    get lineCount() {
        return this.lines.length;
    }
    /**
     * Window ID when buffer create, could be -1 when no window associated.
     */
    get winid() {
        return this._winid;
    }
    /**
     * Returns if current document is opended with previewwindow
     */
    get previewwindow() {
        return this._previewwindow;
    }
    /**
     * Initialize document model.
     *
     * @internal
     */
    async init(nvim, token) {
        this.nvim = nvim;
        let { buffer } = this;
        let opts = await nvim.call('coc#util#get_bufoptions', buffer.id);
        if (opts == null)
            return false;
        let buftype = this.buftype = opts.buftype;
        this._previewwindow = opts.previewwindow;
        this._winid = opts.winid;
        this.size = typeof opts.size == 'number' ? opts.size : 0;
        this.variables = opts.variables;
        this._changedtick = opts.changedtick;
        this.eol = opts.eol == 1;
        let uri = this._uri = index_1.getUri(opts.fullpath, buffer.id, buftype, this.env.isCygwin);
        if (token.isCancellationRequested)
            return false;
        if (this.shouldAttach) {
            let res = await this.attach();
            if (!res)
                return false;
            this._attached = true;
        }
        this._filetype = this.convertFiletype(opts.filetype);
        this.textDocument = vscode_languageserver_textdocument_1.TextDocument.create(uri, this.filetype, 1, this.getDocumentContent());
        this.setIskeyword(opts.iskeyword);
        this.gitCheck();
        if (token.isCancellationRequested) {
            this.detach();
            return false;
        }
        return true;
    }
    async attach() {
        if (this.env.isVim) {
            this.lines = await this.nvim.call('getbufline', [this.bufnr, 1, '$']);
            return true;
        }
        let attached = await this.buffer.attach(false);
        if (!attached)
            return false;
        this.lines = await this.buffer.lines;
        let lastChange;
        this.buffer.listen('lines', (...args) => {
            // avoid neovim send same change multiple times after checktime
            if (lastChange == args[1])
                return;
            lastChange = args[1];
            this.onChange.apply(this, args);
        }, this.disposables);
        this.buffer.listen('detach', async (buf) => {
            this._onDocumentDetach.fire(buf.id);
        }, this.disposables);
        this.buffer.listen('changedtick', (_buf, tick) => {
            this._changedtick = tick;
        }, this.disposables);
        if (this.textDocument) {
            this.fireContentChanges();
        }
        return true;
    }
    onChange(buf, tick, firstline, lastline, linedata
    // more:boolean
    ) {
        if (buf.id !== this.buffer.id || tick == null)
            return;
        this._changedtick = tick;
        let lines = this.lines.slice(0, firstline);
        lines = lines.concat(linedata, this.lines.slice(lastline));
        this.lines = lines;
        this.fireContentChanges();
    }
    /**
     * Make sure current document synced correctly
     */
    async checkDocument() {
        let { buffer } = this;
        this._changedtick = await buffer.changedtick;
        this.lines = await buffer.lines;
        this.fireContentChanges.clear();
        this._fireContentChanges();
    }
    /**
     * Check if document changed after last synchronize
     */
    get dirty() {
        return this.content != this.getDocumentContent();
    }
    _fireContentChanges() {
        let { textDocument } = this;
        let { cursor } = events_1.default;
        try {
            let content = this.getDocumentContent();
            let endOffset = null;
            if (cursor && cursor.bufnr == this.bufnr) {
                endOffset = this.getEndOffset(cursor.lnum, cursor.col, cursor.insert);
            }
            let change = diff_1.getChange(this.content, content, endOffset);
            if (change == null)
                return;
            this.createDocument();
            let { version, uri } = this;
            let start = textDocument.positionAt(change.start);
            let end = textDocument.positionAt(change.end);
            let original = textDocument.getText(vscode_languageserver_protocol_1.Range.create(start, end));
            let changes = [{
                    range: { start, end },
                    rangeLength: change.end - change.start,
                    text: change.newText
                }];
            this._onDocumentChange.fire({
                bufnr: this.bufnr,
                original,
                textDocument: { version, uri },
                contentChanges: changes
            });
            this._words = this.chars.matchKeywords(this.textDocument.getText());
        }
        catch (e) {
            logger.error(e.message);
        }
    }
    /**
     * Buffer number
     */
    get bufnr() {
        return this.buffer.id;
    }
    /**
     * Content of textDocument.
     */
    get content() {
        return this.textDocument.getText();
    }
    /**
     * Coverted filetype.
     */
    get filetype() {
        return this._filetype;
    }
    get uri() {
        return this._uri;
    }
    get version() {
        return this.textDocument ? this.textDocument.version : null;
    }
    async applyEdits(edits) {
        if (!Array.isArray(arguments[0]) && Array.isArray(arguments[1])) {
            edits = arguments[1];
        }
        if (edits.length == 0)
            return;
        edits.forEach(edit => {
            edit.newText = edit.newText.replace(/\r/g, '');
        });
        let current = this.lines.join('\n') + (this.eol ? '\n' : '');
        let textDocument = vscode_languageserver_textdocument_1.TextDocument.create(this.uri, this.filetype, 1, current);
        // apply edits to current textDocument
        let applied = vscode_languageserver_textdocument_1.TextDocument.applyEdits(textDocument, edits);
        // could be equal sometimes
        if (current !== applied) {
            let newLines = applied.split('\n');
            if (this.eol && newLines[newLines.length - 1] == '') {
                newLines = newLines.slice(0, -1);
            }
            let d = diff_1.diffLines(this.lines, newLines);
            await this.buffer.setLines(d.replacement, {
                start: d.start,
                end: d.end,
                strictIndexing: false
            });
            // can't wait vim sync buffer
            this.lines = newLines;
            this.forceSync();
        }
    }
    changeLines(lines, sync = true, check = false) {
        let { nvim } = this;
        let filtered = [];
        for (let [lnum, text] of lines) {
            if (check && this.lines[lnum] != text) {
                filtered.push([lnum, text]);
            }
            this.lines[lnum] = text;
        }
        if (check && !filtered.length)
            return;
        nvim.call('coc#util#change_lines', [this.bufnr, check ? filtered : lines], true);
        if (sync)
            this.forceSync();
    }
    /**
     * Force document synchronize and emit change event when necessary.
     */
    forceSync() {
        this.fireContentChanges.clear();
        this._fireContentChanges();
    }
    /**
     * Get offset from lnum & col
     */
    getOffset(lnum, col) {
        return this.textDocument.offsetAt({
            line: lnum - 1,
            character: col
        });
    }
    /**
     * Check string is word.
     */
    isWord(word) {
        return this.chars.isKeyword(word);
    }
    /**
     * Generate more words by split word with `-`
     */
    getMoreWords() {
        let res = [];
        let { words, chars } = this;
        if (!chars.isKeywordChar('-'))
            return res;
        for (let word of words) {
            word = word.replace(/^-+/, '');
            if (word.includes('-')) {
                let parts = word.split('-');
                for (let part of parts) {
                    if (part.length > 2 &&
                        !res.includes(part) &&
                        !words.includes(part)) {
                        res.push(part);
                    }
                }
            }
        }
        return res;
    }
    /**
     * Current word for replacement
     */
    getWordRangeAtPosition(position, extraChars, current = true) {
        let chars = this.chars.clone();
        if (extraChars && extraChars.length) {
            for (let ch of extraChars) {
                chars.addKeyword(ch);
            }
        }
        let line = this.getline(position.line, current);
        if (line.length == 0 || position.character >= line.length)
            return null;
        if (!chars.isKeywordChar(line[position.character]))
            return null;
        let start = position.character;
        let end = position.character + 1;
        if (!chars.isKeywordChar(line[start])) {
            return vscode_languageserver_protocol_1.Range.create(position, { line: position.line, character: position.character + 1 });
        }
        while (start >= 0) {
            let ch = line[start - 1];
            if (!ch || !chars.isKeyword(ch))
                break;
            start = start - 1;
        }
        while (end <= line.length) {
            let ch = line[end];
            if (!ch || !chars.isKeywordChar(ch))
                break;
            end = end + 1;
        }
        return vscode_languageserver_protocol_1.Range.create(position.line, start, position.line, end);
    }
    gitCheck() {
        let { uri } = this;
        if (!uri.startsWith('file') || this.buftype != '')
            return;
        let filepath = vscode_uri_1.URI.parse(uri).fsPath;
        fs_1.isGitIgnored(filepath).then(isIgnored => {
            this.isIgnored = isIgnored;
        }, () => {
            this.isIgnored = false;
        });
    }
    createDocument(changeCount = 1) {
        let { version, uri, filetype } = this;
        version = version + changeCount;
        this.textDocument = vscode_languageserver_textdocument_1.TextDocument.create(uri, filetype, version, this.getDocumentContent());
    }
    async _fetchContent() {
        if (!this.env.isVim || !this._attached)
            return;
        let { nvim, buffer } = this;
        let { id } = buffer;
        let o = (await nvim.call('coc#util#get_content', id));
        if (!o)
            return;
        let { content, changedtick } = o;
        if (this._changedtick == changedtick)
            return;
        this._changedtick = changedtick;
        let newLines = content.split('\n');
        this.lines = newLines;
        this.fireContentChanges.clear();
        this._fireContentChanges();
    }
    /**
     * Get and synchronize change
     */
    async patchChange(currentLine) {
        if (!this._attached)
            return;
        if (this.env.isVim) {
            if (currentLine) {
                let change = await this.nvim.call('coc#util#get_changeinfo', []);
                if (change.changedtick == this._changedtick)
                    return;
                let { lines } = this;
                let { lnum, line, changedtick } = change;
                this._changedtick = changedtick;
                lines[lnum - 1] = line;
                this.forceSync();
            }
            else {
                this.fetchContent.clear();
                await this._fetchContent();
            }
        }
        else {
            // we have latest lines aftet TextChange on neovim
            this.forceSync();
        }
    }
    /**
     * Get ranges of word in textDocument.
     */
    getSymbolRanges(word) {
        this.forceSync();
        let { textDocument } = this;
        let res = [];
        let content = textDocument.getText();
        let str = '';
        for (let i = 0, l = content.length; i < l; i++) {
            let ch = content[i];
            if ('-' == ch && str.length == 0) {
                continue;
            }
            let isKeyword = this.chars.isKeywordChar(ch);
            if (isKeyword) {
                str = str + ch;
            }
            if (str.length > 0 && !isKeyword && str == word) {
                res.push(vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
            }
            if (!isKeyword) {
                str = '';
            }
        }
        return res;
    }
    /**
     * Adjust col with new valid character before position.
     */
    fixStartcol(position, valids) {
        let line = this.getline(position.line);
        if (!line)
            return null;
        let { character } = position;
        let start = line.slice(0, character);
        let col = string_1.byteLength(start);
        let { chars } = this;
        for (let i = start.length - 1; i >= 0; i--) {
            let c = start[i];
            if (c == ' ')
                break;
            if (!chars.isKeywordChar(c) && !valids.includes(c)) {
                break;
            }
            col = col - string_1.byteLength(c);
        }
        return col;
    }
    /**
     * Use matchaddpos for highlight ranges, must use `redraw` command on vim
     */
    matchAddRanges(ranges, hlGroup, priority = 10) {
        let res = [];
        let arr = [];
        let splited = ranges.reduce((p, c) => {
            for (let i = c.start.line; i <= c.end.line; i++) {
                let curr = this.getline(i) || '';
                let sc = i == c.start.line ? c.start.character : 0;
                let ec = i == c.end.line ? c.end.character : curr.length;
                if (sc == ec)
                    continue;
                p.push(vscode_languageserver_protocol_1.Range.create(i, sc, i, ec));
            }
            return p;
        }, []);
        for (let range of splited) {
            let { start, end } = range;
            let line = this.getline(start.line);
            if (start.character == end.character)
                continue;
            arr.push([start.line + 1, string_1.byteIndex(line, start.character) + 1, string_1.byteLength(line.slice(start.character, end.character))]);
        }
        for (let grouped of array_1.group(arr, 8)) {
            let id = this.colorId;
            this.colorId = this.colorId + 1;
            this.nvim.call('matchaddpos', [hlGroup, grouped, priority, id], true);
            res.push(id);
        }
        return res;
    }
    /**
     * Highlight ranges in document, return match id list.
     *
     * Note: match id could by namespace id or vim's match id.
     */
    highlightRanges(ranges, hlGroup, srcId, priority = 10) {
        let res = [];
        if (this.env.isVim && !this.env.textprop) {
            res = this.matchAddRanges(ranges, hlGroup, priority);
        }
        else {
            let lineRanges = [];
            for (let range of ranges) {
                if (range.start.line == range.end.line) {
                    lineRanges.push(range);
                }
                else {
                    // split range by lines
                    for (let i = range.start.line; i < range.end.line; i++) {
                        let line = this.getline(i);
                        if (i == range.start.line) {
                            lineRanges.push(vscode_languageserver_protocol_1.Range.create(i, range.start.character, i, line.length));
                        }
                        else if (i == range.end.line) {
                            lineRanges.push(vscode_languageserver_protocol_1.Range.create(i, Math.min(line.match(/^\s*/)[0].length, range.end.character), i, range.end.character));
                        }
                        else {
                            lineRanges.push(vscode_languageserver_protocol_1.Range.create(i, Math.min(line.match(/^\s*/)[0].length, line.length), i, line.length));
                        }
                    }
                }
            }
            for (let range of lineRanges) {
                let { start, end } = range;
                if (position_1.comparePosition(start, end) == 0)
                    continue;
                let line = this.getline(start.line);
                this.buffer.addHighlight({
                    hlGroup,
                    srcId,
                    line: start.line,
                    colStart: string_1.byteIndex(line, start.character),
                    colEnd: end.line - start.line == 1 && end.character == 0 ? -1 : string_1.byteIndex(line, end.character)
                }).logError();
            }
            res.push(srcId);
        }
        return res;
    }
    /**
     * Clear match id list, for vim support namespace, list should be namespace id list.
     */
    clearMatchIds(ids) {
        if (this.env.isVim && !this.env.textprop) {
            this.nvim.call('coc#util#clear_buf_matches', [Array.from(ids), this.bufnr], true);
        }
        else {
            ids = array_1.distinct(Array.from(ids));
            let hasNamesapce = this.nvim.hasFunction('nvim_create_namespace');
            ids.forEach(id => {
                if (hasNamesapce) {
                    this.buffer.clearNamespace(id);
                }
                else {
                    this.buffer.clearHighlight({ srcId: id });
                }
            });
        }
    }
    /**
     * Get cwd of this document.
     */
    async getcwd() {
        let wid = await this.nvim.call('bufwinid', this.buffer.id);
        if (wid == -1)
            return await this.nvim.call('getcwd');
        return await this.nvim.call('getcwd', wid);
    }
    /**
     * Real current line
     */
    getline(line, current = true) {
        if (current)
            return this.lines[line] || '';
        let lines = this.textDocument.getText().split(/\r?\n/);
        return lines[line] || '';
    }
    /**
     * Get lines, zero indexed, end exclude.
     */
    getLines(start, end) {
        return this.lines.slice(start, end);
    }
    /**
     * Get current content text.
     */
    getDocumentContent() {
        let content = this.lines.join('\n');
        return this.eol ? content + '\n' : content;
    }
    /**
     * Get variable value by key, defined by `b:coc_{key}`
     */
    getVar(key, defaultValue) {
        let val = this.variables[`coc_${key}`];
        return val === undefined ? defaultValue : val;
    }
    /**
     * Get position from lnum & col
     */
    getPosition(lnum, col) {
        let line = this.getline(lnum - 1);
        if (!line || col == 0)
            return { line: lnum - 1, character: 0 };
        let pre = string_1.byteSlice(line, 0, col - 1);
        return { line: lnum - 1, character: pre.length };
    }
    /**
     * Get end offset from cursor position.
     * For normal mode, use offset -1 when possible
     */
    getEndOffset(lnum, col, insert) {
        let total = 0;
        let len = this.lines.length;
        for (let i = lnum - 1; i < len; i++) {
            let line = this.lines[i];
            let l = line.length;
            if (i == lnum - 1 && l != 0) {
                // current
                let buf = global.Buffer.from(line, 'utf8');
                let isEnd = buf.byteLength <= col - 1;
                if (!isEnd) {
                    total = total + buf.slice(col - 1, buf.length).toString('utf8').length;
                    if (!insert)
                        total = total - 1;
                }
            }
            else {
                total = total + l;
            }
            if (!this.eol && i == len - 1)
                break;
            total = total + 1;
        }
        return total;
    }
    /**
     * Recreate document with new filetype.
     *
     * @internal
     */
    setFiletype(filetype) {
        let { uri, version } = this;
        this._filetype = this.convertFiletype(filetype);
        version = version ? version + 1 : 1;
        let textDocument = vscode_languageserver_textdocument_1.TextDocument.create(uri, this.filetype, version, this.content);
        this.textDocument = textDocument;
    }
    /**
     * Change iskeyword option of document
     *
     * @internal
     */
    setIskeyword(iskeyword) {
        let chars = this.chars = new chars_1.Chars(iskeyword);
        let additional = this.getVar('additional_keywords', []);
        if (additional && Array.isArray(additional)) {
            for (let ch of additional) {
                chars.addKeyword(ch);
            }
        }
        let lines = this.lines.length > 30000 ? this.lines.slice(0, 30000) : this.lines;
        this._words = this.chars.matchKeywords(lines.join('\n'));
    }
    /**
     * Detach document.
     *
     * @internal
     */
    detach() {
        this._attached = false;
        index_1.disposeAll(this.disposables);
        this.buffer.detach().catch(() => {
            // ignore invalid buffer error
        });
        this.disposables = [];
        this.fetchContent.clear();
        this.fireContentChanges.clear();
        this._onDocumentChange.dispose();
        this._onDocumentDetach.dispose();
    }
    get attached() {
        return this._attached;
    }
    /**
     * Get localify bonus map.
     *
     * @internal
     */
    getLocalifyBonus(sp, ep) {
        let res = new Map();
        let { chars } = this;
        let startLine = Math.max(0, sp.line - 100);
        let endLine = Math.min(this.lineCount, sp.line + 100);
        let content = this.lines.slice(startLine, endLine).join('\n');
        sp = vscode_languageserver_protocol_1.Position.create(sp.line - startLine, sp.character);
        ep = vscode_languageserver_protocol_1.Position.create(ep.line - startLine, ep.character);
        let doc = vscode_languageserver_textdocument_1.TextDocument.create(this.uri, this.filetype, 1, content);
        let headCount = doc.offsetAt(sp);
        let len = content.length;
        let tailCount = len - doc.offsetAt(ep);
        let start = 0;
        let preKeyword = false;
        for (let i = 0; i < headCount; i++) {
            let iskeyword = chars.isKeyword(content[i]);
            if (!preKeyword && iskeyword) {
                start = i;
            }
            else if (preKeyword && (!iskeyword || i == headCount - 1)) {
                if (i - start > 1) {
                    let str = content.slice(start, i);
                    res.set(str, i / headCount);
                }
            }
            preKeyword = iskeyword;
        }
        start = len - tailCount;
        preKeyword = false;
        for (let i = start; i < content.length; i++) {
            let iskeyword = chars.isKeyword(content[i]);
            if (!preKeyword && iskeyword) {
                start = i;
            }
            else if (preKeyword && (!iskeyword || i == len - 1)) {
                if (i - start > 1) {
                    let end = i == len - 1 ? i + 1 : i;
                    let str = content.slice(start, end);
                    let score = res.get(str) || 0;
                    res.set(str, Math.max(score, (len - i + (end - start)) / tailCount));
                }
            }
            preKeyword = iskeyword;
        }
        return res;
    }
}
exports.default = Document;
//# sourceMappingURL=document.js.map

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function intersect(array, other) {
    for (let item of other) {
        if (array.includes(item)) {
            return true;
        }
    }
    return false;
}
exports.intersect = intersect;
function splitArray(array, fn) {
    let res = [[], []];
    for (let item of array) {
        if (fn(item)) {
            res[0].push(item);
        }
        else {
            res[1].push(item);
        }
    }
    return res;
}
exports.splitArray = splitArray;
function tail(array, n = 0) {
    return array[array.length - (1 + n)];
}
exports.tail = tail;
function group(array, size) {
    let len = array.length;
    let res = [];
    for (let i = 0; i < Math.ceil(len / size); i++) {
        res.push(array.slice(i * size, (i + 1) * size));
    }
    return res;
}
exports.group = group;
/**
 * Removes duplicates from the given array. The optional keyFn allows to specify
 * how elements are checked for equalness by returning a unique string for each.
 */
function distinct(array, keyFn) {
    if (!keyFn) {
        return array.filter((element, position) => array.indexOf(element) === position);
    }
    const seen = Object.create(null);
    return array.filter(elem => {
        const key = keyFn(elem);
        if (seen[key]) {
            return false;
        }
        seen[key] = true;
        return true;
    });
}
exports.distinct = distinct;
function lastIndex(array, fn) {
    let i = array.length - 1;
    while (i >= 0) {
        if (fn(array[i])) {
            break;
        }
        i--;
    }
    return i;
}
exports.lastIndex = lastIndex;
exports.flatMap = (xs, f) => xs.reduce((x, y) => [...x, ...f(y)], []);
//# sourceMappingURL=array.js.map

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fast_diff_1 = tslib_1.__importDefault(__webpack_require__(259));
const string_1 = __webpack_require__(310);
const logger = __webpack_require__(64)('util-diff');
function diffLines(oldLines, newLines) {
    let start = 0;
    let end = oldLines.length;
    let oldLen = end;
    let len = newLines.length;
    for (let i = 0; i <= end; i++) {
        if (newLines[i] !== oldLines[i]) {
            start = i;
            break;
        }
        if (i == end) {
            start = end;
        }
    }
    if (start != newLines.length) {
        let maxRemain = Math.min(end - start, len - start);
        for (let j = 0; j < maxRemain; j++) {
            if (oldLines[oldLen - j - 1] != newLines[len - j - 1]) {
                break;
            }
            end = end - 1;
        }
    }
    return {
        start,
        end,
        replacement: newLines.slice(start, len - (oldLen - end))
    };
}
exports.diffLines = diffLines;
function getChange(oldStr, newStr, cursorEnd) {
    let ol = oldStr.length;
    let nl = newStr.length;
    let max = Math.min(ol, nl);
    let newText = '';
    let startOffset = 0;
    let endOffset = -1;
    let shouldLimit = false;
    // find first endOffset, could <= this. one
    for (let i = 0; i <= max; i++) {
        if (cursorEnd != null && i == cursorEnd) {
            endOffset = i;
            shouldLimit = true;
            break;
        }
        if (oldStr[ol - i - 1] != newStr[nl - i - 1]) {
            endOffset = i;
            break;
        }
    }
    if (endOffset == -1)
        return null;
    // find start offset
    let remain = max - endOffset;
    if (remain == 0) {
        startOffset = 0;
    }
    else {
        for (let i = 0; i <= remain; i++) {
            if (oldStr[i] != newStr[i] || i == remain) {
                startOffset = i;
                break;
            }
        }
    }
    // limit to minimal change
    remain = remain - startOffset;
    if (shouldLimit && remain > 0) {
        let end = endOffset;
        for (let i = 0; i < remain; i++) {
            let oc = oldStr[ol - end - 1 - i];
            let nc = newStr[nl - end - 1 - i];
            if (oc == nc) {
                endOffset = endOffset + 1;
            }
            else {
                break;
            }
        }
    }
    let end = ol - endOffset;
    if (ol == nl && startOffset == end)
        return null;
    newText = newStr.slice(startOffset, nl - endOffset);
    // optimize for add new line(s)
    if (startOffset == end) {
        let pre = startOffset == 0 ? '' : newStr[startOffset - 1];
        if (pre && pre != '\n'
            && oldStr[startOffset] == '\n'
            && newText.startsWith('\n')) {
            return { start: startOffset + 1, end: end + 1, newText: newText.slice(1) + '\n' };
        }
    }
    return { start: startOffset, end, newText };
}
exports.getChange = getChange;
function patchLine(from, to, fill = ' ') {
    if (from == to)
        return to;
    let idx = to.indexOf(from);
    if (idx !== -1)
        return fill.repeat(idx) + from;
    let result = fast_diff_1.default(from, to);
    let str = '';
    for (let item of result) {
        if (item[0] == fast_diff_1.default.DELETE) {
            // not allowed
            return to;
        }
        else if (item[0] == fast_diff_1.default.INSERT) {
            str = str + fill.repeat(string_1.byteLength(item[1]));
        }
        else {
            str = str + item[1];
        }
    }
    return str;
}
exports.patchLine = patchLine;
//# sourceMappingURL=diff.js.map

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// nvim use utf8
function byteLength(str) {
    return Buffer.byteLength(str);
}
exports.byteLength = byteLength;
function upperFirst(str) {
    return str ? str[0].toUpperCase() + str.slice(1) : '';
}
exports.upperFirst = upperFirst;
function byteIndex(content, index) {
    let s = content.slice(0, index);
    return Buffer.byteLength(s);
}
exports.byteIndex = byteIndex;
function indexOf(str, ch, count = 1) {
    let curr = 0;
    for (let i = 0; i < str.length; i++) {
        if (str[i] == ch) {
            curr = curr + 1;
            if (curr == count) {
                return i;
            }
        }
    }
    return -1;
}
exports.indexOf = indexOf;
function characterIndex(content, byteIndex) {
    let buf = Buffer.from(content, 'utf8');
    return buf.slice(0, byteIndex).toString('utf8').length;
}
exports.characterIndex = characterIndex;
function byteSlice(content, start, end) {
    let buf = Buffer.from(content, 'utf8');
    return buf.slice(start, end).toString('utf8');
}
exports.byteSlice = byteSlice;
function isWord(character) {
    let code = character.charCodeAt(0);
    if (code > 128)
        return false;
    if (code == 95)
        return true;
    if (code >= 48 && code <= 57)
        return true;
    if (code >= 65 && code <= 90)
        return true;
    if (code >= 97 && code <= 122)
        return true;
    return false;
}
exports.isWord = isWord;
function isTriggerCharacter(character) {
    if (!character)
        return false;
    let code = character.charCodeAt(0);
    if (code > 128)
        return false;
    if (code >= 65 && code <= 90)
        return false;
    if (code >= 97 && code <= 122)
        return false;
    return true;
}
exports.isTriggerCharacter = isTriggerCharacter;
function isAsciiLetter(code) {
    if (code >= 65 && code <= 90)
        return true;
    if (code >= 97 && code <= 122)
        return true;
    return false;
}
exports.isAsciiLetter = isAsciiLetter;
function doEqualsIgnoreCase(a, b, stopAt = a.length) {
    if (typeof a !== 'string' || typeof b !== 'string') {
        return false;
    }
    for (let i = 0; i < stopAt; i++) {
        const codeA = a.charCodeAt(i);
        const codeB = b.charCodeAt(i);
        if (codeA === codeB) {
            continue;
        }
        // a-z A-Z
        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
            const diff = Math.abs(codeA - codeB);
            if (diff !== 0 && diff !== 32) {
                return false;
            }
        }
        // Any other charcode
        else {
            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                return false;
            }
        }
    }
    return true;
}
function equalsIgnoreCase(a, b) {
    const len1 = a ? a.length : 0;
    const len2 = b ? b.length : 0;
    if (len1 !== len2) {
        return false;
    }
    return doEqualsIgnoreCase(a, b);
}
exports.equalsIgnoreCase = equalsIgnoreCase;
//# sourceMappingURL=string.js.map

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function rangeInRange(r, range) {
    return positionInRange(r.start, range) === 0 && positionInRange(r.end, range) === 0;
}
exports.rangeInRange = rangeInRange;
/**
 * Check if two ranges have overlap character.
 */
function rangeOverlap(r, range) {
    let { start, end } = r;
    if (comparePosition(end, range.start) <= 0) {
        return false;
    }
    if (comparePosition(start, range.end) >= 0) {
        return false;
    }
    return true;
}
exports.rangeOverlap = rangeOverlap;
/**
 * Check if two ranges have overlap or nested
 */
function rangeIntersect(r, range) {
    if (positionInRange(r.start, range) == 0) {
        return true;
    }
    if (positionInRange(r.end, range) == 0) {
        return true;
    }
    if (rangeInRange(range, r)) {
        return true;
    }
    return false;
}
exports.rangeIntersect = rangeIntersect;
function lineInRange(line, range) {
    let { start, end } = range;
    return line >= start.line && line <= end.line;
}
exports.lineInRange = lineInRange;
function emptyRange(range) {
    let { start, end } = range;
    return start.line == end.line && start.character == end.character;
}
exports.emptyRange = emptyRange;
function positionInRange(position, range) {
    let { start, end } = range;
    if (comparePosition(position, start) < 0)
        return -1;
    if (comparePosition(position, end) > 0)
        return 1;
    return 0;
}
exports.positionInRange = positionInRange;
function comparePosition(position, other) {
    if (position.line > other.line)
        return 1;
    if (other.line == position.line && position.character > other.character)
        return 1;
    if (other.line == position.line && position.character == other.character)
        return 0;
    return -1;
}
exports.comparePosition = comparePosition;
function isSingleLine(range) {
    return range.start.line == range.end.line;
}
exports.isSingleLine = isSingleLine;
function getChangedPosition(start, edit) {
    let { range, newText } = edit;
    if (comparePosition(range.end, start) <= 0) {
        let lines = newText.split('\n');
        let lineCount = lines.length - (range.end.line - range.start.line) - 1;
        let characterCount = 0;
        if (range.end.line == start.line) {
            let single = isSingleLine(range) && lineCount == 0;
            let removed = single ? range.end.character - range.start.character : range.end.character;
            let added = single ? newText.length : lines[lines.length - 1].length;
            characterCount = added - removed;
        }
        return { line: lineCount, character: characterCount };
    }
    return { line: 0, character: 0 };
}
exports.getChangedPosition = getChangedPosition;
function adjustPosition(pos, edit) {
    let { range, newText } = edit;
    if (comparePosition(range.start, pos) > 1)
        return pos;
    let { start, end } = range;
    let newLines = newText.split('\n');
    let delta = (end.line - start.line) - newLines.length + 1;
    let lastLine = newLines[newLines.length - 1];
    let line = pos.line - delta;
    if (pos.line != end.line)
        return { line, character: pos.character };
    let pre = newLines.length == 1 && start.line != end.line ? start.character : 0;
    let removed = start.line == end.line && newLines.length == 1 ? end.character - start.character : end.character;
    let character = pre + pos.character + lastLine.length - removed;
    return {
        line,
        character
    };
}
exports.adjustPosition = adjustPosition;
function positionToOffset(lines, line, character) {
    let offset = 0;
    for (let i = 0; i <= line; i++) {
        if (i == line) {
            offset += character;
        }
        else {
            offset += lines[i].length + 1;
        }
    }
    return offset;
}
exports.positionToOffset = positionToOffset;
// edit a range to newText
function editRange(range, text, edit) {
    // outof range
    if (!rangeInRange(edit.range, range))
        return text;
    let { start, end } = edit.range;
    let lines = text.split('\n');
    let character = start.line == range.start.line ? start.character - range.start.character : start.character;
    let startOffset = positionToOffset(lines, start.line - range.start.line, character);
    character = end.line == range.start.line ? end.character - range.start.character : end.character;
    let endOffset = positionToOffset(lines, end.line - range.start.line, character);
    return `${text.slice(0, startOffset)}${edit.newText}${text.slice(endOffset, text.length)}`;
}
exports.editRange = editRange;
function getChangedFromEdits(start, edits) {
    let changed = { line: 0, character: 0 };
    for (let edit of edits) {
        let d = getChangedPosition(start, edit);
        changed = { line: changed.line + d.line, character: changed.character + d.character };
    }
    return changed.line == 0 && changed.character == 0 ? null : changed;
}
exports.getChangedFromEdits = getChangedFromEdits;
//# sourceMappingURL=position.js.map

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logger = __webpack_require__(64)('model-chars');
class Range {
    constructor(start, end) {
        this.start = start;
        this.end = end ? end : start;
    }
    static fromKeywordOption(keywordOption) {
        let parts = keywordOption.split(',');
        let ranges = [];
        for (let part of parts) {
            if (part == '@') {
                // isalpha() of c
                ranges.push(new Range(65, 90));
                ranges.push(new Range(97, 122));
            }
            else if (part == '@-@') {
                ranges.push(new Range(64));
            }
            else if (/^([A-Za-z])-([A-Za-z])$/.test(part)) {
                let ms = part.match(/^([A-Za-z])-([A-Za-z])$/);
                ranges.push(new Range(ms[1].charCodeAt(0), ms[2].charCodeAt(0)));
            }
            else if (/^\d+-\d+$/.test(part)) {
                let ms = part.match(/^(\d+)-(\d+)$/);
                ranges.push(new Range(Number(ms[1]), Number(ms[2])));
            }
            else if (/^\d+$/.test(part)) {
                ranges.push(new Range(Number(part)));
            }
            else {
                let c = part.charCodeAt(0);
                if (!ranges.some(o => o.contains(c))) {
                    ranges.push(new Range(c));
                }
            }
        }
        return ranges;
    }
    contains(c) {
        return c >= this.start && c <= this.end;
    }
}
exports.Range = Range;
class Chars {
    constructor(keywordOption) {
        this.ranges = [];
        if (keywordOption)
            this.ranges = Range.fromKeywordOption(keywordOption);
    }
    addKeyword(ch) {
        let c = ch.charCodeAt(0);
        let { ranges } = this;
        if (!ranges.some(o => o.contains(c))) {
            ranges.push(new Range(c));
        }
    }
    clone() {
        let chars = new Chars();
        chars.ranges = this.ranges.slice();
        return chars;
    }
    setKeywordOption(keywordOption) {
        this.ranges = Range.fromKeywordOption(keywordOption);
    }
    matchKeywords(content, min = 3) {
        let length = content.length;
        if (length == 0)
            return [];
        let res = new Set();
        let str = '';
        let len = 0;
        for (let i = 0; i < length; i++) {
            let ch = content[i];
            let code = ch.codePointAt(0);
            if (len == 0 && code == 45)
                continue;
            let isKeyword = this.isKeywordCode(code);
            if (isKeyword) {
                if (len == 48)
                    continue;
                str = str + ch;
                len = len + 1;
            }
            else {
                if (len >= min && len < 48)
                    res.add(str);
                str = '';
                len = 0;
            }
        }
        if (len != 0)
            res.add(str);
        return Array.from(res);
    }
    isKeywordCode(code) {
        if (code > 255)
            return true;
        if (code < 33)
            return false;
        return this.ranges.some(r => r.contains(code));
    }
    isKeywordChar(ch) {
        let { ranges } = this;
        let c = ch.charCodeAt(0);
        if (c > 255)
            return true;
        if (c < 33)
            return false;
        return ranges.some(r => r.contains(c));
    }
    isKeyword(word) {
        let { ranges } = this;
        for (let i = 0, l = word.length; i < l; i++) {
            let ch = word.charCodeAt(i);
            // for speed
            if (ch > 255)
                return false;
            if (ranges.some(r => r.contains(ch)))
                continue;
            return false;
        }
        return true;
    }
}
exports.Chars = Chars;
//# sourceMappingURL=chars.js.map

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const minimatch_1 = tslib_1.__importDefault(__webpack_require__(271));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const util_1 = __webpack_require__(238);
const array_1 = __webpack_require__(308);
const logger = __webpack_require__(64)('filesystem-watcher');
class FileSystemWatcher {
    constructor(clientPromise, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        this.globPattern = globPattern;
        this.ignoreCreateEvents = ignoreCreateEvents;
        this.ignoreChangeEvents = ignoreChangeEvents;
        this.ignoreDeleteEvents = ignoreDeleteEvents;
        this._onDidCreate = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidDelete = new vscode_languageserver_protocol_1.Emitter();
        this._onDidRename = new vscode_languageserver_protocol_1.Emitter();
        this.onDidCreate = this._onDidCreate.event;
        this.onDidChange = this._onDidChange.event;
        this.onDidDelete = this._onDidDelete.event;
        this.onDidRename = this._onDidRename.event;
        this.disposables = [];
        if (!clientPromise)
            return;
        clientPromise.then(client => {
            if (client)
                return this.listen(client);
        }).catch(error => {
            logger.error('watchman initialize failed');
            logger.error(error.stack);
        });
    }
    async listen(client) {
        let { globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents } = this;
        let disposable = await client.subscribe(globPattern, (change) => {
            let { root, files } = change;
            files = files.filter(f => f.type == 'f' && minimatch_1.default(f.name, globPattern, { dot: true }));
            for (let file of files) {
                let uri = vscode_uri_1.URI.file(path_1.default.join(root, file.name));
                if (!file.exists) {
                    if (!ignoreDeleteEvents)
                        this._onDidDelete.fire(uri);
                }
                else {
                    if (file.new === true) {
                        if (!ignoreCreateEvents)
                            this._onDidCreate.fire(uri);
                    }
                    else {
                        if (!ignoreChangeEvents)
                            this._onDidChange.fire(uri);
                    }
                }
            }
            // file rename
            if (files.length == 2 && !files[0].exists && files[1].exists) {
                let oldFile = files[0];
                let newFile = files[1];
                if (oldFile.size == newFile.size) {
                    this._onDidRename.fire({
                        oldUri: vscode_uri_1.URI.file(path_1.default.join(root, oldFile.name)),
                        newUri: vscode_uri_1.URI.file(path_1.default.join(root, newFile.name))
                    });
                }
            }
            // detect folder rename
            if (files.length >= 2) {
                let [oldFiles, newFiles] = array_1.splitArray(files, o => o.exists === false);
                if (oldFiles.length == newFiles.length) {
                    for (let oldFile of oldFiles) {
                        let newFile = newFiles.find(o => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);
                        if (newFile) {
                            this._onDidRename.fire({
                                oldUri: vscode_uri_1.URI.file(path_1.default.join(root, oldFile.name)),
                                newUri: vscode_uri_1.URI.file(path_1.default.join(root, newFile.name))
                            });
                        }
                    }
                }
            }
        });
        this.disposables.push(disposable);
        return disposable;
    }
    dispose() {
        util_1.disposeAll(this.disposables);
    }
}
exports.default = FileSystemWatcher;
//# sourceMappingURL=fileSystemWatcher.js.map

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const util_1 = tslib_1.__importDefault(__webpack_require__(74));
const mkdirp_1 = tslib_1.__importDefault(__webpack_require__(260));
/**
 * Mru - manage string items as lines in mru file.
 */
class Mru {
    /**
     * @param {string} name unique name
     * @param {string} base? optional directory name, default to config root of coc.nvim
     */
    constructor(name, base) {
        this.name = name;
        this.file = path_1.default.join(base || process.env.COC_DATA_HOME, name);
    }
    /**
     * Load iems from mru file
     */
    async load() {
        let dir = path_1.default.dirname(this.file);
        try {
            mkdirp_1.default.sync(dir);
            if (!fs_1.default.existsSync(this.file)) {
                fs_1.default.writeFileSync(this.file, '', 'utf8');
            }
            let content = await util_1.default.promisify(fs_1.default.readFile)(this.file, 'utf8');
            content = content.trim();
            return content.length ? content.trim().split('\n') : [];
        }
        catch (e) {
            return [];
        }
    }
    /**
     * Add item to mru file.
     */
    async add(item) {
        let items = await this.load();
        let idx = items.indexOf(item);
        if (idx !== -1)
            items.splice(idx, 1);
        items.unshift(item);
        fs_1.default.writeFileSync(this.file, items.join('\n'), 'utf8');
    }
    /**
     * Remove item from mru file.
     */
    async remove(item) {
        let items = await this.load();
        let idx = items.indexOf(item);
        if (idx !== -1) {
            items.splice(idx, 1);
            fs_1.default.writeFileSync(this.file, items.join('\n'), 'utf8');
        }
    }
    /**
     * Remove the data file.
     */
    async clean() {
        try {
            await util_1.default.promisify(fs_1.default.unlink)(this.file);
        }
        catch (e) {
            // noop
        }
    }
}
exports.default = Mru;
//# sourceMappingURL=mru.js.map

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)("outpubChannel");
const MAX_STRING_LENGTH = __webpack_require__(316).constants.MAX_STRING_LENGTH;
class BufferChannel {
    constructor(name, nvim) {
        this.name = name;
        this.nvim = nvim;
        this._content = '';
        this.disposables = [];
        this._showing = false;
        this.promise = Promise.resolve(void 0);
    }
    get content() {
        return this._content;
    }
    async _append(value, isLine) {
        let { buffer } = this;
        if (!buffer)
            return;
        try {
            if (isLine) {
                await buffer.append(value.split('\n'));
            }
            else {
                let last = await this.nvim.call('getbufline', [buffer.id, '$']);
                let content = last + value;
                if (this.buffer) {
                    await buffer.setLines(content.split('\n'), {
                        start: -2,
                        end: -1,
                        strictIndexing: false
                    });
                }
            }
        }
        catch (e) {
            logger.error(`Error on append output:`, e);
        }
    }
    append(value) {
        if (this._content.length + value.length >= MAX_STRING_LENGTH) {
            this.clear(10);
        }
        this._content += value;
        this.promise = this.promise.then(() => this._append(value, false));
    }
    appendLine(value) {
        if (this._content.length + value.length >= MAX_STRING_LENGTH) {
            this.clear(10);
        }
        this._content += value + '\n';
        this.promise = this.promise.then(() => this._append(value, true));
    }
    clear(keep) {
        let latest = [];
        if (keep) {
            latest = this._content.split('\n').slice(-keep);
        }
        this._content = latest.join('\n');
        let { buffer } = this;
        if (buffer) {
            Promise.resolve(buffer.setLines(latest, {
                start: 0,
                end: -1,
                strictIndexing: false
            })).catch(_e => {
                // noop
            });
        }
    }
    hide() {
        let { nvim, buffer } = this;
        if (buffer)
            nvim.command(`silent! bd! ${buffer.id}`, true);
    }
    dispose() {
        this.hide();
        this._content = '';
        util_1.disposeAll(this.disposables);
    }
    get buffer() {
        let doc = workspace_1.default.getDocument(`output:///${this.name}`);
        return doc ? doc.buffer : null;
    }
    async openBuffer(preserveFocus) {
        let { nvim, buffer } = this;
        if (buffer) {
            let loaded = await nvim.call('bufloaded', buffer.id);
            if (!loaded)
                buffer = null;
        }
        if (!buffer) {
            await nvim.command(`belowright vs output:///${this.name}`);
        }
        else {
            // check shown
            let wnr = await nvim.call('bufwinnr', buffer.id);
            if (wnr != -1)
                return;
            await nvim.command(`vert belowright sb ${buffer.id}`);
        }
        if (preserveFocus) {
            await nvim.command('wincmd p');
        }
    }
    show(preserveFocus) {
        if (this._showing)
            return;
        this._showing = true;
        this.openBuffer(preserveFocus).then(() => {
            this._showing = false;
        }, () => {
            this._showing = false;
        });
    }
}
exports.default = BufferChannel;
//# sourceMappingURL=outputChannel.js.map

/***/ }),
/* 316 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const util_1 = __webpack_require__(238);
const fs_1 = __webpack_require__(304);
const decorator_1 = __webpack_require__(318);
const logger = __webpack_require__(64)('model-resolver');
class Resolver {
    get nodeFolder() {
        if (!util_1.executable('npm'))
            return Promise.resolve('');
        return util_1.runCommand('npm --loglevel silent root -g', {}, 3000).then(root => root.trim());
    }
    get yarnFolder() {
        if (!util_1.executable('yarnpkg'))
            return Promise.resolve('');
        return util_1.runCommand('yarnpkg global dir', {}, 3000).then(root => path_1.default.join(root.trim(), 'node_modules'));
    }
    async resolveModule(mod) {
        let nodeFolder = await this.nodeFolder;
        let yarnFolder = await this.yarnFolder;
        if (yarnFolder) {
            let s = await fs_1.statAsync(path_1.default.join(yarnFolder, mod, 'package.json'));
            if (s && s.isFile())
                return path_1.default.join(yarnFolder, mod);
        }
        if (nodeFolder) {
            let s = await fs_1.statAsync(path_1.default.join(nodeFolder, mod, 'package.json'));
            if (s && s.isFile())
                return path_1.default.join(nodeFolder, mod);
        }
        return null;
    }
}
tslib_1.__decorate([
    decorator_1.memorize
], Resolver.prototype, "nodeFolder", null);
tslib_1.__decorate([
    decorator_1.memorize
], Resolver.prototype, "yarnFolder", null);
exports.default = Resolver;
//# sourceMappingURL=resolver.js.map

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logger = __webpack_require__(64)('util-decorator');
function memorize(_target, key, descriptor) {
    let fn = descriptor.value;
    if (typeof fn !== 'function')
        return;
    let memoKey = '$' + key;
    descriptor.value = function (...args) {
        if (this.hasOwnProperty(memoKey))
            return Promise.resolve(this[memoKey]);
        return new Promise((resolve, reject) => {
            Promise.resolve(fn.apply(this, args)).then(res => {
                this[memoKey] = res;
                resolve(res);
            }, e => {
                reject(e);
            });
        });
    };
}
exports.memorize = memorize;
//# sourceMappingURL=decorator.js.map

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = __webpack_require__(283);
const logger = __webpack_require__(64)('model-status');
exports.frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
class StatusLine {
    constructor(nvim) {
        this.nvim = nvim;
        this.items = new Map();
        this.shownIds = new Set();
        this._text = '';
        this.interval = setInterval(() => {
            this.setStatusText().logError();
        }, 100);
    }
    dispose() {
        clearInterval(this.interval);
    }
    createStatusBarItem(priority = 0, isProgress = false) {
        let uid = uuid_1.v1();
        let item = {
            text: '',
            priority,
            isProgress,
            show: () => {
                this.shownIds.add(uid);
            },
            hide: () => {
                this.shownIds.delete(uid);
            },
            dispose: () => {
                this.shownIds.delete(uid);
                this.items.delete(uid);
            }
        };
        this.items.set(uid, item);
        return item;
    }
    getText() {
        if (this.shownIds.size == 0)
            return '';
        let d = new Date();
        let idx = Math.floor(d.getMilliseconds() / 100);
        let text = '';
        let items = [];
        for (let [id, item] of this.items) {
            if (this.shownIds.has(id)) {
                items.push(item);
            }
        }
        items.sort((a, b) => a.priority - b.priority);
        for (let item of items) {
            if (!item.isProgress) {
                text = `${text} ${item.text}`;
            }
            else {
                text = `${text} ${exports.frames[idx]} ${item.text}`;
            }
        }
        return text;
    }
    async setStatusText() {
        let text = this.getText();
        let { nvim } = this;
        if (text != this._text) {
            this._text = text;
            nvim.pauseNotification();
            this.nvim.setVar('coc_status', text, true);
            this.nvim.call('coc#util#do_autocmd', ['CocStatusChange'], true);
            await nvim.resumeNotification(false, true);
        }
    }
}
exports.default = StatusLine;
//# sourceMappingURL=status.js.map

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const util_1 = __webpack_require__(238);
/**
 * Controls long running task started by vim.
 * Useful to keep the task running after CocRestart.
 *
 * @public
 */
class Task {
    /**
     * @param {Neovim} nvim
     * @param {string} id unique id
     */
    constructor(nvim, id) {
        this.nvim = nvim;
        this.id = id;
        this.disposables = [];
        this._onExit = new vscode_languageserver_protocol_1.Emitter();
        this._onStderr = new vscode_languageserver_protocol_1.Emitter();
        this._onStdout = new vscode_languageserver_protocol_1.Emitter();
        this.onExit = this._onExit.event;
        this.onStdout = this._onStdout.event;
        this.onStderr = this._onStderr.event;
        events_1.default.on('TaskExit', (id, code) => {
            if (id == this.id) {
                this._onExit.fire(code);
            }
        }, null, this.disposables);
        events_1.default.on('TaskStderr', (id, lines) => {
            if (id == this.id) {
                this._onStderr.fire(lines);
            }
        }, null, this.disposables);
        let stdout = [];
        let timer;
        events_1.default.on('TaskStdout', (id, lines) => {
            if (id == this.id) {
                if (timer)
                    clearTimeout(timer);
                stdout.push(...lines);
                timer = setTimeout(() => {
                    this._onStdout.fire(stdout);
                    stdout = [];
                }, 100);
            }
        }, null, this.disposables);
    }
    /**
     * Start task, task will be restarted when already running.
     *
     * @param {TaskOptions} opts
     * @returns {Promise<boolean>}
     */
    async start(opts) {
        let { nvim } = this;
        return await nvim.call('coc#task#start', [this.id, opts]);
    }
    /**
     * Stop task by SIGTERM or SIGKILL
     */
    async stop() {
        let { nvim } = this;
        await nvim.call('coc#task#stop', [this.id]);
    }
    /**
     * Check if the task is running.
     */
    get running() {
        let { nvim } = this;
        return nvim.call('coc#task#running', [this.id]);
    }
    /**
     * Stop task and dispose all events.
     */
    dispose() {
        let { nvim } = this;
        nvim.call('coc#task#stop', [this.id], true);
        this._onStdout.dispose();
        this._onStderr.dispose();
        this._onExit.dispose();
        util_1.disposeAll(this.disposables);
    }
}
exports.default = Task;
//# sourceMappingURL=task.js.map

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const logger = __webpack_require__(64)('model-terminal');
class TerminalModel {
    constructor(cmd, args, nvim, _name) {
        this.cmd = cmd;
        this.args = args;
        this.nvim = nvim;
        this._name = _name;
        this.pid = 0;
    }
    async start(cwd, env) {
        let { nvim } = this;
        let cmd = [this.cmd, ...this.args];
        let [bufnr, pid] = await nvim.call('coc#terminal#start', [cmd, cwd, env || {}]);
        this.bufnr = bufnr;
        this.pid = pid;
    }
    get name() {
        return this._name || this.cmd;
    }
    get processId() {
        return Promise.resolve(this.pid);
    }
    sendText(text, addNewLine = true) {
        if (!this.bufnr)
            return;
        this.nvim.call('coc#terminal#send', [this.bufnr, text, addNewLine], true);
    }
    async show(preserveFocus) {
        let { bufnr, nvim } = this;
        if (!bufnr)
            return;
        let [loaded, winid, curr] = await nvim.eval(`[bufloaded(${bufnr}),bufwinid(${bufnr}),win_getid()]`);
        if (!loaded)
            return false;
        if (curr == winid)
            return true;
        nvim.pauseNotification();
        if (winid == -1) {
            nvim.command(`below ${bufnr}sb`, true);
            nvim.command('resize 8', true);
            nvim.call('coc#util#do_autocmd', ['CocTerminalOpen'], true);
        }
        else {
            nvim.call('win_gotoid', [winid], true);
        }
        nvim.command('normal! G', true);
        if (preserveFocus) {
            nvim.command('wincmd p', true);
        }
        await nvim.resumeNotification();
        return true;
    }
    async hide() {
        let { bufnr, nvim } = this;
        if (!bufnr)
            return;
        let winnr = await nvim.call('bufwinnr', bufnr);
        if (winnr == -1)
            return;
        await nvim.command(`${winnr}close!`);
    }
    dispose() {
        let { bufnr, nvim } = this;
        if (!bufnr)
            return;
        nvim.call('coc#terminal#close', [bufnr], true);
    }
}
exports.default = TerminalModel;
//# sourceMappingURL=terminal.js.map

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const util_1 = __webpack_require__(238);
const logger = __webpack_require__(64)('willSaveHandler');
class WillSaveUntilHandler {
    constructor(workspace) {
        this.workspace = workspace;
        this.callbacks = [];
    }
    addCallback(callback, thisArg, clientId) {
        let fn = (event) => {
            let { workspace } = this;
            let ev = Object.assign({}, event);
            return new Promise(resolve => {
                let called = false;
                ev.waitUntil = (thenable) => {
                    called = true;
                    let { document } = ev;
                    let timer = setTimeout(() => {
                        workspace.showMessage(`${clientId} will save operation timeout after 0.5s`, 'warning');
                        resolve(null);
                    }, 500);
                    Promise.resolve(thenable).then((edits) => {
                        clearTimeout(timer);
                        let doc = workspace.getDocument(document.uri);
                        if (doc && edits && vscode_languageserver_protocol_1.TextEdit.is(edits[0])) {
                            doc.applyEdits(edits).then(() => {
                                // make sure server received ChangedText
                                setTimeout(resolve, 50);
                            }, e => {
                                logger.error(e);
                                workspace.showMessage(`${clientId} error on applyEdits ${e.message}`, 'error');
                                resolve();
                            });
                        }
                        else {
                            resolve();
                        }
                    }, e => {
                        clearTimeout(timer);
                        logger.error(`${clientId} error on willSaveUntil ${e.message}`, 'error');
                        resolve();
                    });
                };
                callback.call(thisArg, ev);
                if (!called) {
                    resolve();
                }
            });
        };
        this.callbacks.push(fn);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            let idx = this.callbacks.indexOf(fn);
            if (idx != -1) {
                this.callbacks.splice(idx, 1);
            }
        });
    }
    get hasCallback() {
        let { callbacks } = this;
        return callbacks.length > 0;
    }
    async handeWillSaveUntil(event) {
        let { callbacks, workspace } = this;
        let { document } = event;
        if (!callbacks.length)
            return;
        let doc = workspace.getDocument(document.uri);
        if (!doc)
            return;
        let now = Date.now();
        await doc.patchChange();
        await util_1.wait(60);
        for (let fn of callbacks) {
            event.document = doc.textDocument;
            try {
                await fn(event);
            }
            catch (e) {
                logger.error(e);
            }
        }
        logger.info(`Will save cost: ${Date.now() - now}`);
    }
}
exports.default = WillSaveUntilHandler;
//# sourceMappingURL=willSaveHandler.js.map

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const minimatch_1 = tslib_1.__importDefault(__webpack_require__(271));
const vscode_uri_1 = __webpack_require__(243);
const platform = tslib_1.__importStar(__webpack_require__(248));
function score(selector, uri, languageId) {
    if (Array.isArray(selector)) {
        // array -> take max individual value
        let ret = 0;
        for (const filter of selector) {
            const value = score(filter, uri, languageId);
            if (value === 10) {
                return value; // already at the highest
            }
            if (value > ret) {
                ret = value;
            }
        }
        return ret;
    }
    else if (typeof selector === 'string') {
        // short-hand notion, desugars to
        // 'fooLang' -> { language: 'fooLang'}
        // '*' -> { language: '*' }
        if (selector === '*') {
            return 5;
        }
        else if (selector === languageId) {
            return 10;
        }
        else {
            return 0;
        }
    }
    else if (selector) {
        let u = vscode_uri_1.URI.parse(uri);
        // filter -> select accordingly, use defaults for scheme
        const { language, pattern, scheme } = selector;
        let ret = 0;
        if (scheme) {
            if (scheme === u.scheme) {
                ret = 5;
            }
            else if (scheme === '*') {
                ret = 3;
            }
            else {
                return 0;
            }
        }
        if (language) {
            if (language === languageId) {
                ret = 10;
            }
            else if (language === '*') {
                ret = Math.max(ret, 5);
            }
            else {
                return 0;
            }
        }
        if (pattern) {
            let caseInsensitive = platform.isWindows || platform.isMacintosh;
            let p = caseInsensitive ? pattern.toLowerCase() : pattern;
            let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;
            if (p === f || minimatch_1.default(f, p, { dot: true })) {
                ret = 5;
            }
            else {
                return 0;
            }
        }
        return ret;
    }
    else {
        return 0;
    }
}
exports.score = score;
//# sourceMappingURL=match.js.map

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fb_watchman_1 = tslib_1.__importDefault(__webpack_require__(325));
const os_1 = tslib_1.__importDefault(__webpack_require__(76));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const uuid_1 = __webpack_require__(283);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const minimatch_1 = tslib_1.__importDefault(__webpack_require__(271));
const fs_1 = __webpack_require__(304);
const logger = __webpack_require__(64)('watchman');
const requiredCapabilities = ['relative_root', 'cmd-watch-project', 'wildmatch', 'field-new'];
const clientsMap = new Map();
/**
 * Watchman wrapper for fb-watchman client
 *
 * @public
 */
class Watchman {
    constructor(binaryPath, channel) {
        this.channel = channel;
        this._disposed = false;
        this.client = new fb_watchman_1.default.Client({
            watchmanBinaryPath: binaryPath
        });
        this.client.setMaxListeners(300);
    }
    checkCapability() {
        let { client } = this;
        return new Promise((resolve, reject) => {
            client.capabilityCheck({
                optional: [],
                required: requiredCapabilities
            }, (error, resp) => {
                if (error)
                    return reject(error);
                let { capabilities } = resp;
                for (let key of Object.keys(capabilities)) {
                    if (!capabilities[key])
                        return resolve(false);
                }
                resolve(true);
            });
        });
    }
    async watchProject(root) {
        try {
            let resp = await this.command(['watch-project', root]);
            let { watch, warning, relative_path } = resp;
            if (warning)
                logger.warn(warning);
            this.watch = watch;
            this.relative_path = relative_path;
            logger.info(`watchman watching project: ${root}`);
            this.appendOutput(`watchman watching project: ${root}`);
        }
        catch (e) {
            logger.error(e);
            return false;
        }
        return true;
    }
    command(args) {
        return new Promise((resolve, reject) => {
            this.client.command(args, (error, resp) => {
                if (error)
                    return reject(error);
                resolve(resp);
            });
        });
    }
    async subscribe(globPattern, cb) {
        let { watch, relative_path } = this;
        if (!watch) {
            this.appendOutput(`watchman not watching: ${watch}`, 'Error');
            return null;
        }
        let { clock } = await this.command(['clock', watch]);
        let uid = uuid_1.v1();
        let sub = {
            expression: ['allof', ['match', '**/*', 'wholename']],
            fields: ['name', 'size', 'new', 'exists', 'type', 'mtime_ms', 'ctime_ms'],
            since: clock,
        };
        let root = watch;
        if (relative_path) {
            sub.relative_root = relative_path;
            root = path_1.default.join(watch, relative_path);
        }
        let { subscribe } = await this.command(['subscribe', watch, uid, sub]);
        if (global.hasOwnProperty('__TEST__'))
            global.subscribe = subscribe;
        this.appendOutput(`subscribing "${globPattern}" in ${root}`);
        this.client.on('subscription', resp => {
            if (!resp || resp.subscription != uid)
                return;
            let { files } = resp;
            if (!files)
                return;
            files = files.filter(f => f.type == 'f' && minimatch_1.default(f.name, globPattern, { dot: true }));
            if (!files.length)
                return;
            let ev = Object.assign({}, resp);
            if (this.relative_path)
                ev.root = path_1.default.resolve(resp.root, this.relative_path);
            this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);
            cb(ev);
        });
        return vscode_languageserver_protocol_1.Disposable.create(() => this.unsubscribe(subscribe));
    }
    unsubscribe(subscription) {
        if (this._disposed)
            return Promise.resolve();
        let { watch } = this;
        if (!watch)
            return;
        this.appendOutput(`unsubscribe "${subscription}" in: ${watch}`);
        return this.command(['unsubscribe', watch, subscription]).catch(e => {
            logger.error(e);
        });
    }
    dispose() {
        this._disposed = true;
        this.client.removeAllListeners();
        this.client.end();
    }
    appendOutput(message, type = "Info") {
        if (this.channel) {
            this.channel.appendLine(`[${type}  - ${(new Date().toLocaleTimeString())}] ${message}`);
        }
    }
    static dispose() {
        for (let promise of clientsMap.values()) {
            promise.then(client => {
                client.dispose();
            }, _e => {
                // noop
            });
        }
    }
    static createClient(binaryPath, root, channel) {
        if (!isValidWatchRoot(root))
            return null;
        let client = clientsMap.get(root);
        if (client)
            return client;
        let promise = new Promise(async (resolve, reject) => {
            try {
                let watchman = new Watchman(binaryPath, channel);
                let valid = await watchman.checkCapability();
                if (!valid)
                    return resolve(null);
                let watching = await watchman.watchProject(root);
                if (!watching)
                    return resolve(null);
                resolve(watchman);
            }
            catch (e) {
                reject(e);
            }
        });
        clientsMap.set(root, promise);
        return promise;
    }
}
exports.default = Watchman;
/**
 * Exclude user's home, driver, tmpdir
 */
function isValidWatchRoot(root) {
    if (root == '/' || root == '/tmp' || root == '/private/tmp')
        return false;
    if (root.toLowerCase() === os_1.default.homedir().toLowerCase())
        return false;
    if (path_1.default.parse(root).base == root)
        return false;
    if (root.startsWith('/tmp/') || root.startsWith('/private/tmp/'))
        return false;
    if (fs_1.isParentFolder(os_1.default.tmpdir(), root, true))
        return false;
    return true;
}
exports.isValidWatchRoot = isValidWatchRoot;
//# sourceMappingURL=watchman.js.map

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright 2014-present Facebook, Inc.
 * Licensed under the Apache License, Version 2.0 */



var net = __webpack_require__(157);
var EE = __webpack_require__(198).EventEmitter;
var util = __webpack_require__(74);
var childProcess = __webpack_require__(239);
var bser = __webpack_require__(326);

// We'll emit the responses to these when they get sent down to us
var unilateralTags = ['subscription', 'log'];

/**
 * @param options An object with the following optional keys:
 *   * 'watchmanBinaryPath' (string) Absolute path to the watchman binary.
 *     If not provided, the Client locates the binary using the PATH specified
 *     by the node child_process's default env.
 */
function Client(options) {
  var self = this;
  EE.call(this);

  this.watchmanBinaryPath = 'watchman';
  if (options && options.watchmanBinaryPath) {
    this.watchmanBinaryPath = options.watchmanBinaryPath.trim();
  };
  this.commands = [];
}
util.inherits(Client, EE);

module.exports.Client = Client;

// Try to send the next queued command, if any
Client.prototype.sendNextCommand = function() {
  if (this.currentCommand) {
    // There's a command pending response, don't send this new one yet
    return;
  }

  this.currentCommand = this.commands.shift();
  if (!this.currentCommand) {
    // No further commands are queued
    return;
  }

  this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));
}

Client.prototype.cancelCommands = function(why) {
  var error = new Error(why);

  // Steal all pending commands before we start cancellation, in
  // case something decides to schedule more commands
  var cmds = this.commands;
  this.commands = [];

  if (this.currentCommand) {
    cmds.unshift(this.currentCommand);
    this.currentCommand = null;
  }

  // Synthesize an error condition for any commands that were queued
  cmds.forEach(function(cmd) {
    cmd.cb(error);
  });
}

Client.prototype.connect = function() {
  var self = this;

  function makeSock(sockname) {
    // bunser will decode the watchman BSER protocol for us
    self.bunser = new bser.BunserBuf();
    // For each decoded line:
    self.bunser.on('value', function(obj) {
      // Figure out if this is a unliteral response or if it is the
      // response portion of a request-response sequence.  At the time
      // of writing, there are only two possible unilateral responses.
      var unilateral = false;
      for (var i = 0; i < unilateralTags.length; i++) {
        var tag = unilateralTags[i];
        if (tag in obj) {
          unilateral = tag;
        }
      }

      if (unilateral) {
        self.emit(unilateral, obj);
      } else if (self.currentCommand) {
        var cmd = self.currentCommand;
        self.currentCommand = null;
        if ('error' in obj) {
          var error = new Error(obj.error);
          error.watchmanResponse = obj;
          cmd.cb(error);
        } else {
          cmd.cb(null, obj);
        }
      }

      // See if we can dispatch the next queued command, if any
      self.sendNextCommand();
    });
    self.bunser.on('error', function(err) {
      self.emit('error', err);
    });

    self.socket = net.createConnection(sockname);
    self.socket.on('connect', function() {
      self.connecting = false;
      self.emit('connect');
      self.sendNextCommand();
    });
    self.socket.on('error', function(err) {
      self.connecting = false;
      self.emit('error', err);
    });
    self.socket.on('data', function(buf) {
      if (self.bunser) {
        self.bunser.append(buf);
      }
    });
    self.socket.on('end', function() {
      self.socket = null;
      self.bunser = null;
      self.cancelCommands('The watchman connection was closed');
      self.emit('end');
    });
  }

  // triggers will export the sock path to the environment.
  // If we're invoked in such a way, we can simply pick up the
  // definition from the environment and avoid having to fork off
  // a process to figure it out
  if (process.env.WATCHMAN_SOCK) {
    makeSock(process.env.WATCHMAN_SOCK);
    return;
  }

  // We need to ask the client binary where to find it.
  // This will cause the service to start for us if it isn't
  // already running.
  var args = ['--no-pretty', 'get-sockname'];

  // We use the more elaborate spawn rather than exec because there
  // are some error cases on Windows where process spawning can hang.
  // It is desirable to pipe stderr directly to stderr live so that
  // we can discover the problem.
  var proc = null;
  var spawnFailed = false;

  function spawnError(error) {
    if (spawnFailed) {
      // For ENOENT, proc 'close' will also trigger with a negative code,
      // let's suppress that second error.
      return;
    }
    spawnFailed = true;
    if (error.errno === 'EACCES') {
      error.message = 'The Watchman CLI is installed but cannot ' +
                      'be spawned because of a permission problem';
    } else if (error.errno === 'ENOENT') {
      error.message = 'Watchman was not found in PATH.  See ' +
          'https://facebook.github.io/watchman/docs/install.html ' +
          'for installation instructions';
    }
    console.error('Watchman: ', error.message);
    self.emit('error', error);
  }

  try {
    proc = childProcess.spawn(this.watchmanBinaryPath, args, {
      stdio: ['ignore', 'pipe', 'pipe']
    });
  } catch (error) {
    spawnError(error);
    return;
  }

  var stdout = [];
  var stderr = [];
  proc.stdout.on('data', function(data) {
    stdout.push(data);
  });
  proc.stderr.on('data', function(data) {
    data = data.toString('utf8');
    stderr.push(data);
    console.error(data);
  });
  proc.on('error', function(error) {
    spawnError(error);
  });

  proc.on('close', function (code, signal) {
    if (code !== 0) {
      spawnError(new Error(
          self.watchmanBinaryPath + ' ' + args.join(' ') +
          ' returned with exit code=' + code + ', signal=' +
          signal + ', stderr= ' + stderr.join('')));
      return;
    }
    try {
      var obj = JSON.parse(stdout.join(''));
      if ('error' in obj) {
        var error = new Error(obj.error);
        error.watchmanResponse = obj;
        self.emit('error', error);
        return;
      }
      makeSock(obj.sockname);
    } catch (e) {
      self.emit('error', e);
    }
  });
}

Client.prototype.command = function(args, done) {
  done = done || function() {};

  // Queue up the command
  this.commands.push({cmd: args, cb: done});

  // Establish a connection if we don't already have one
  if (!this.socket) {
    if (!this.connecting) {
      this.connecting = true;
      this.connect();
      return;
    }
    return;
  }

  // If we're already connected and idle, try sending the command immediately
  this.sendNextCommand();
}

var cap_versions = {
    "cmd-watch-del-all": "3.1.1",
    "cmd-watch-project": "3.1",
    "relative_root": "3.3",
    "term-dirname": "3.1",
    "term-idirname": "3.1",
    "wildmatch": "3.7",
}

// Compares a vs b, returns < 0 if a < b, > 0 if b > b, 0 if a == b
function vers_compare(a, b) {
  a = a.split('.');
  b = b.split('.');
  for (var i = 0; i < 3; i++) {
    var d = parseInt(a[i] || '0') - parseInt(b[i] || '0');
    if (d != 0) {
      return d;
    }
  }
  return 0; // Equal
}

function have_cap(vers, name) {
  if (name in cap_versions) {
    return vers_compare(vers, cap_versions[name]) >= 0;
  }
  return false;
}

// This is a helper that we expose for testing purposes
Client.prototype._synthesizeCapabilityCheck = function(
    resp, optional, required) {
  resp.capabilities = {}
  var version = resp.version;
  optional.forEach(function (name) {
    resp.capabilities[name] = have_cap(version, name);
  });
  required.forEach(function (name) {
    var have = have_cap(version, name);
    resp.capabilities[name] = have;
    if (!have) {
      resp.error = 'client required capability `' + name +
                   '` is not supported by this server';
    }
  });
  return resp;
}

Client.prototype.capabilityCheck = function(caps, done) {
  var optional = caps.optional || [];
  var required = caps.required || [];
  var self = this;
  this.command(['version', {
      optional: optional,
      required: required
  }], function (error, resp) {
    if (error) {
      done(error);
      return;
    }
    if (!('capabilities' in resp)) {
      // Server doesn't support capabilities, so we need to
      // synthesize the results based on the version
      resp = self._synthesizeCapabilityCheck(resp, optional, required);
      if (resp.error) {
        error = new Error(resp.error);
        error.watchmanResponse = resp;
        done(error);
        return;
      }
    }
    done(null, resp);
  });
}

// Close the connection to the service
Client.prototype.end = function() {
  this.cancelCommands('The client was ended');
  if (this.socket) {
    this.socket.end();
    this.socket = null;
  }
  this.bunser = null;
}


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright 2015-present Facebook, Inc.
 * Licensed under the Apache License, Version 2.0 */

var EE = __webpack_require__(198).EventEmitter;
var util = __webpack_require__(74);
var os = __webpack_require__(76);
var assert = __webpack_require__(108);
var Int64 = __webpack_require__(327);

// BSER uses the local endianness to reduce byte swapping overheads
// (the protocol is expressly local IPC only).  We need to tell node
// to use the native endianness when reading various native values.
var isBigEndian = os.endianness() == 'BE';

// Find the next power-of-2 >= size
function nextPow2(size) {
  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
}

// Expandable buffer that we can provide a size hint for
function Accumulator(initsize) {
  this.buf = Buffer.alloc(nextPow2(initsize || 8192));
  this.readOffset = 0;
  this.writeOffset = 0;
}
// For testing
exports.Accumulator = Accumulator

// How much we can write into this buffer without allocating
Accumulator.prototype.writeAvail = function() {
  return this.buf.length - this.writeOffset;
}

// How much we can read
Accumulator.prototype.readAvail = function() {
  return this.writeOffset - this.readOffset;
}

// Ensure that we have enough space for size bytes
Accumulator.prototype.reserve = function(size) {
  if (size < this.writeAvail()) {
    return;
  }

  // If we can make room by shunting down, do so
  if (this.readOffset > 0) {
    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);
    this.writeOffset -= this.readOffset;
    this.readOffset = 0;
  }

  // If we made enough room, no need to allocate more
  if (size < this.writeAvail()) {
    return;
  }

  // Allocate a replacement and copy it in
  var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));
  this.buf.copy(buf);
  this.buf = buf;
}

// Append buffer or string.  Will resize as needed
Accumulator.prototype.append = function(buf) {
  if (Buffer.isBuffer(buf)) {
    this.reserve(buf.length);
    buf.copy(this.buf, this.writeOffset, 0, buf.length);
    this.writeOffset += buf.length;
  } else {
    var size = Buffer.byteLength(buf);
    this.reserve(size);
    this.buf.write(buf, this.writeOffset);
    this.writeOffset += size;
  }
}

Accumulator.prototype.assertReadableSize = function(size) {
  if (this.readAvail() < size) {
    throw new Error("wanted to read " + size +
        " bytes but only have " + this.readAvail());
  }
}

Accumulator.prototype.peekString = function(size) {
  this.assertReadableSize(size);
  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);
}

Accumulator.prototype.readString = function(size) {
  var str = this.peekString(size);
  this.readOffset += size;
  return str;
}

Accumulator.prototype.peekInt = function(size) {
  this.assertReadableSize(size);
  switch (size) {
    case 1:
      return this.buf.readInt8(this.readOffset, size);
    case 2:
      return isBigEndian ?
        this.buf.readInt16BE(this.readOffset, size) :
        this.buf.readInt16LE(this.readOffset, size);
    case 4:
      return isBigEndian ?
        this.buf.readInt32BE(this.readOffset, size) :
        this.buf.readInt32LE(this.readOffset, size);
    case 8:
        var big = this.buf.slice(this.readOffset, this.readOffset + 8);
        if (isBigEndian) {
          // On a big endian system we can simply pass the buffer directly
          return new Int64(big);
        }
        // Otherwise we need to byteswap
        return new Int64(byteswap64(big));
    default:
      throw new Error("invalid integer size " + size);
  }
}

Accumulator.prototype.readInt = function(bytes) {
  var ival = this.peekInt(bytes);
  if (ival instanceof Int64 && isFinite(ival.valueOf())) {
    ival = ival.valueOf();
  }
  this.readOffset += bytes;
  return ival;
}

Accumulator.prototype.peekDouble = function() {
  this.assertReadableSize(8);
  return isBigEndian ?
    this.buf.readDoubleBE(this.readOffset) :
    this.buf.readDoubleLE(this.readOffset);
}

Accumulator.prototype.readDouble = function() {
  var dval = this.peekDouble();
  this.readOffset += 8;
  return dval;
}

Accumulator.prototype.readAdvance = function(size) {
  if (size > 0) {
    this.assertReadableSize(size);
  } else if (size < 0 && this.readOffset + size < 0) {
    throw new Error("advance with negative offset " + size +
        " would seek off the start of the buffer");
  }
  this.readOffset += size;
}

Accumulator.prototype.writeByte = function(value) {
  this.reserve(1);
  this.buf.writeInt8(value, this.writeOffset);
  ++this.writeOffset;
}

Accumulator.prototype.writeInt = function(value, size) {
  this.reserve(size);
  switch (size) {
    case 1:
      this.buf.writeInt8(value, this.writeOffset);
      break;
    case 2:
      if (isBigEndian) {
        this.buf.writeInt16BE(value, this.writeOffset);
      } else {
        this.buf.writeInt16LE(value, this.writeOffset);
      }
      break;
    case 4:
      if (isBigEndian) {
        this.buf.writeInt32BE(value, this.writeOffset);
      } else {
        this.buf.writeInt32LE(value, this.writeOffset);
      }
      break;
    default:
      throw new Error("unsupported integer size " + size);
  }
  this.writeOffset += size;
}

Accumulator.prototype.writeDouble = function(value) {
  this.reserve(8);
  if (isBigEndian) {
    this.buf.writeDoubleBE(value, this.writeOffset);
  } else {
    this.buf.writeDoubleLE(value, this.writeOffset);
  }
  this.writeOffset += 8;
}

var BSER_ARRAY     = 0x00;
var BSER_OBJECT    = 0x01;
var BSER_STRING    = 0x02;
var BSER_INT8      = 0x03;
var BSER_INT16     = 0x04;
var BSER_INT32     = 0x05;
var BSER_INT64     = 0x06;
var BSER_REAL      = 0x07;
var BSER_TRUE      = 0x08;
var BSER_FALSE     = 0x09;
var BSER_NULL      = 0x0a;
var BSER_TEMPLATE  = 0x0b;
var BSER_SKIP      = 0x0c;

var ST_NEED_PDU = 0; // Need to read and decode PDU length
var ST_FILL_PDU = 1; // Know the length, need to read whole content

var MAX_INT8 = 127;
var MAX_INT16 = 32767;
var MAX_INT32 = 2147483647;

function BunserBuf() {
  EE.call(this);
  this.buf = new Accumulator();
  this.state = ST_NEED_PDU;
}
util.inherits(BunserBuf, EE);
exports.BunserBuf = BunserBuf;

BunserBuf.prototype.append = function(buf, synchronous) {
  if (synchronous) {
    this.buf.append(buf);
    return this.process(synchronous);
  }

  try {
    this.buf.append(buf);
  } catch (err) {
    this.emit('error', err);
    return;
  }
  // Arrange to decode later.  This allows the consuming
  // application to make progress with other work in the
  // case that we have a lot of subscription updates coming
  // in from a large tree.
  this.processLater();
}

BunserBuf.prototype.processLater = function() {
  var self = this;
  process.nextTick(function() {
    try {
      self.process(false);
    } catch (err) {
      self.emit('error', err);
    }
  });
}

// Do something with the buffer to advance our state.
// If we're running synchronously we'll return either
// the value we've decoded or undefined if we don't
// yet have enought data.
// If we're running asynchronously, we'll emit the value
// when it becomes ready and schedule another invocation
// of process on the next tick if we still have data we
// can process.
BunserBuf.prototype.process = function(synchronous) {
  if (this.state == ST_NEED_PDU) {
    if (this.buf.readAvail() < 2) {
      return;
    }
    // Validate BSER header
    this.expectCode(0);
    this.expectCode(1);
    this.pduLen = this.decodeInt(true /* relaxed */);
    if (this.pduLen === false) {
      // Need more data, walk backwards
      this.buf.readAdvance(-2);
      return;
    }
    // Ensure that we have a big enough buffer to read the rest of the PDU
    this.buf.reserve(this.pduLen);
    this.state = ST_FILL_PDU;
  }

  if (this.state == ST_FILL_PDU) {
    if (this.buf.readAvail() < this.pduLen) {
      // Need more data
      return;
    }

    // We have enough to decode it
    var val = this.decodeAny();
    if (synchronous) {
      return val;
    }
    this.emit('value', val);
    this.state = ST_NEED_PDU;
  }

  if (!synchronous && this.buf.readAvail() > 0) {
    this.processLater();
  }
}

BunserBuf.prototype.raise = function(reason) {
  throw new Error(reason + ", in Buffer of length " +
      this.buf.buf.length + " (" + this.buf.readAvail() +
      " readable) at offset " + this.buf.readOffset + " buffer: " +
      JSON.stringify(this.buf.buf.slice(
          this.buf.readOffset, this.buf.readOffset + 32).toJSON()));
}

BunserBuf.prototype.expectCode = function(expected) {
  var code = this.buf.readInt(1);
  if (code != expected) {
    this.raise("expected bser opcode " + expected + " but got " + code);
  }
}

BunserBuf.prototype.decodeAny = function() {
  var code = this.buf.peekInt(1);
  switch (code) {
    case BSER_INT8:
    case BSER_INT16:
    case BSER_INT32:
    case BSER_INT64:
      return this.decodeInt();
    case BSER_REAL:
      this.buf.readAdvance(1);
      return this.buf.readDouble();
    case BSER_TRUE:
      this.buf.readAdvance(1);
      return true;
    case BSER_FALSE:
      this.buf.readAdvance(1);
      return false;
    case BSER_NULL:
      this.buf.readAdvance(1);
      return null;
    case BSER_STRING:
      return this.decodeString();
    case BSER_ARRAY:
      return this.decodeArray();
    case BSER_OBJECT:
      return this.decodeObject();
    case BSER_TEMPLATE:
      return this.decodeTemplate();
    default:
      this.raise("unhandled bser opcode " + code);
  }
}

BunserBuf.prototype.decodeArray = function() {
  this.expectCode(BSER_ARRAY);
  var nitems = this.decodeInt();
  var arr = [];
  for (var i = 0; i < nitems; ++i) {
    arr.push(this.decodeAny());
  }
  return arr;
}

BunserBuf.prototype.decodeObject = function() {
  this.expectCode(BSER_OBJECT);
  var nitems = this.decodeInt();
  var res = {};
  for (var i = 0; i < nitems; ++i) {
    var key = this.decodeString();
    var val = this.decodeAny();
    res[key] = val;
  }
  return res;
}

BunserBuf.prototype.decodeTemplate = function() {
  this.expectCode(BSER_TEMPLATE);
  var keys = this.decodeArray();
  var nitems = this.decodeInt();
  var arr = [];
  for (var i = 0; i < nitems; ++i) {
    var obj = {};
    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {
      if (this.buf.peekInt(1) == BSER_SKIP) {
        this.buf.readAdvance(1);
        continue;
      }
      var val = this.decodeAny();
      obj[keys[keyidx]] = val;
    }
    arr.push(obj);
  }
  return arr;
}

BunserBuf.prototype.decodeString = function() {
  this.expectCode(BSER_STRING);
  var len = this.decodeInt();
  return this.buf.readString(len);
}

// This is unusual compared to the other decode functions in that
// we may not have enough data available to satisfy the read, and
// we don't want to throw.  This is only true when we're reading
// the PDU length from the PDU header; we'll set relaxSizeAsserts
// in that case.
BunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {
  if (relaxSizeAsserts && (this.buf.readAvail() < 1)) {
    return false;
  } else {
    this.buf.assertReadableSize(1);
  }
  var code = this.buf.peekInt(1);
  var size = 0;
  switch (code) {
    case BSER_INT8:
      size = 1;
      break;
    case BSER_INT16:
      size = 2;
      break;
    case BSER_INT32:
      size = 4;
      break;
    case BSER_INT64:
      size = 8;
      break;
    default:
      this.raise("invalid bser int encoding " + code);
  }

  if (relaxSizeAsserts && (this.buf.readAvail() < 1 + size)) {
    return false;
  }
  this.buf.readAdvance(1);
  return this.buf.readInt(size);
}

// synchronously BSER decode a string and return the value
function loadFromBuffer(input) {
  var buf = new BunserBuf();
  var result = buf.append(input, true);
  if (buf.buf.readAvail()) {
    throw Error(
        'excess data found after input buffer, use BunserBuf instead');
  }
  if (typeof result === 'undefined') {
    throw Error(
        'no bser found in string and no error raised!?');
  }
  return result;
}
exports.loadFromBuffer = loadFromBuffer

// Byteswap an arbitrary buffer, flipping from one endian
// to the other, returning a new buffer with the resultant data
function byteswap64(buf) {
  var swap = Buffer.alloc(buf.length);
  for (var i = 0; i < buf.length; i++) {
    swap[i] = buf[buf.length -1 - i];
  }
  return swap;
}

function dump_int64(buf, val) {
  // Get the raw bytes.  The Int64 buffer is big endian
  var be = val.toBuffer();

  if (isBigEndian) {
    // We're a big endian system, so the buffer is exactly how we
    // want it to be
    buf.writeByte(BSER_INT64);
    buf.append(be);
    return;
  }
  // We need to byte swap to get the correct representation
  var le = byteswap64(be);
  buf.writeByte(BSER_INT64);
  buf.append(le);
}

function dump_int(buf, val) {
  var abs = Math.abs(val);
  if (abs <= MAX_INT8) {
    buf.writeByte(BSER_INT8);
    buf.writeInt(val, 1);
  } else if (abs <= MAX_INT16) {
    buf.writeByte(BSER_INT16);
    buf.writeInt(val, 2);
  } else if (abs <= MAX_INT32) {
    buf.writeByte(BSER_INT32);
    buf.writeInt(val, 4);
  } else {
    dump_int64(buf, new Int64(val));
  }
}

function dump_any(buf, val) {
  switch (typeof(val)) {
    case 'number':
      // check if it is an integer or a float
      if (isFinite(val) && Math.floor(val) === val) {
        dump_int(buf, val);
      } else {
        buf.writeByte(BSER_REAL);
        buf.writeDouble(val);
      }
      return;
    case 'string':
      buf.writeByte(BSER_STRING);
      dump_int(buf, Buffer.byteLength(val));
      buf.append(val);
      return;
    case 'boolean':
      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);
      return;
    case 'object':
      if (val === null) {
        buf.writeByte(BSER_NULL);
        return;
      }
      if (val instanceof Int64) {
        dump_int64(buf, val);
        return;
      }
      if (Array.isArray(val)) {
        buf.writeByte(BSER_ARRAY);
        dump_int(buf, val.length);
        for (var i = 0; i < val.length; ++i) {
          dump_any(buf, val[i]);
        }
        return;
      }
      buf.writeByte(BSER_OBJECT);
      var keys = Object.keys(val);

      // First pass to compute number of defined keys
      var num_keys = keys.length;
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var v = val[key];
        if (typeof(v) == 'undefined') {
          num_keys--;
        }
      }
      dump_int(buf, num_keys);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var v = val[key];
        if (typeof(v) == 'undefined') {
          // Don't include it
          continue;
        }
        dump_any(buf, key);
        try {
          dump_any(buf, v);
        } catch (e) {
          throw new Error(
            e.message + ' (while serializing object property with name `' +
              key + "')");
        }
      }
      return;

    default:
      throw new Error('cannot serialize type ' + typeof(val) + ' to BSER');
  }
}

// BSER encode value and return a buffer of the contents
function dumpToBuffer(val) {
  var buf = new Accumulator();
  // Build out the header
  buf.writeByte(0);
  buf.writeByte(1);
  // Reserve room for an int32 to hold our PDU length
  buf.writeByte(BSER_INT32);
  buf.writeInt(0, 4); // We'll come back and fill this in at the end

  dump_any(buf, val);

  // Compute PDU length
  var off = buf.writeOffset;
  var len = off - 7 /* the header length */;
  buf.writeOffset = 3; // The length value to fill in
  buf.writeInt(len, 4); // write the length in the space we reserved
  buf.writeOffset = off;

  return buf.buf.slice(0, off);
}
exports.dumpToBuffer = dumpToBuffer


/***/ }),
/* 327 */
/***/ (function(module, exports) {

//     Int64.js
//
//     Copyright (c) 2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

/**
 * Support for handling 64-bit int numbers in Javascript (node.js)
 *
 * JS Numbers are IEEE-754 binary double-precision floats, which limits the
 * range of values that can be represented with integer precision to:
 *
 * 2^^53 <= N <= 2^53
 *
 * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These
 * objects operate directly on the buffer which means that if they are created
 * using an existing buffer then setting the value will modify the Buffer, and
 * vice-versa.
 *
 * Internal Representation
 *
 * The internal buffer format is Big Endian.  I.e. the most-significant byte is
 * at buffer[0], the least-significant at buffer[7].  For the purposes of
 * converting to/from JS native numbers, the value is assumed to be a signed
 * integer stored in 2's complement form.
 *
 * For details about IEEE-754 see:
 * http://en.wikipedia.org/wiki/Double_precision_floating-point_format
 */

// Useful masks and values for bit twiddling
var MASK31 =  0x7fffffff, VAL31 = 0x80000000;
var MASK32 =  0xffffffff, VAL32 = 0x100000000;

// Map for converting hex octets to strings
var _HEX = [];
for (var i = 0; i < 256; i++) {
  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);
}

//
// Int64
//

/**
 * Constructor accepts any of the following argument types:
 *
 * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset
 * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset
 * new Int64(string)             - Hex string (throws if n is outside int64 range)
 * new Int64(number)             - Number (throws if n is outside int64 range)
 * new Int64(hi, lo)             - Raw bits as two 32-bit values
 */
var Int64 = module.exports = function(a1, a2) {
  if (a1 instanceof Buffer) {
    this.buffer = a1;
    this.offset = a2 || 0;
  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {
    // Under Browserify, Buffers can extend Uint8Arrays rather than an
    // instance of Buffer. We could assume the passed in Uint8Array is actually
    // a buffer but that won't handle the case where a raw Uint8Array is passed
    // in. We construct a new Buffer just in case.
    this.buffer = new Buffer(a1);
    this.offset = a2 || 0;
  } else {
    this.buffer = this.buffer || new Buffer(8);
    this.offset = 0;
    this.setValue.apply(this, arguments);
  }
};


// Max integer value that JS can accurately represent
Int64.MAX_INT = Math.pow(2, 53);

// Min integer value that JS can accurately represent
Int64.MIN_INT = -Math.pow(2, 53);

Int64.prototype = {

  constructor: Int64,

  /**
   * Do in-place 2's compliment.  See
   * http://en.wikipedia.org/wiki/Two's_complement
   */
  _2scomp: function() {
    var b = this.buffer, o = this.offset, carry = 1;
    for (var i = o + 7; i >= o; i--) {
      var v = (b[i] ^ 0xff) + carry;
      b[i] = v & 0xff;
      carry = v >> 8;
    }
  },

  /**
   * Set the value. Takes any of the following arguments:
   *
   * setValue(string) - A hexidecimal string
   * setValue(number) - Number (throws if n is outside int64 range)
   * setValue(hi, lo) - Raw bits as two 32-bit values
   */
  setValue: function(hi, lo) {
    var negate = false;
    if (arguments.length == 1) {
      if (typeof(hi) == 'number') {
        // Simplify bitfield retrieval by using abs() value.  We restore sign
        // later
        negate = hi < 0;
        hi = Math.abs(hi);
        lo = hi % VAL32;
        hi = hi / VAL32;
        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');
        hi = hi | 0;
      } else if (typeof(hi) == 'string') {
        hi = (hi + '').replace(/^0x/, '');
        lo = hi.substr(-8);
        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';
        hi = parseInt(hi, 16);
        lo = parseInt(lo, 16);
      } else {
        throw new Error(hi + ' must be a Number or String');
      }
    }

    // Technically we should throw if hi or lo is outside int32 range here, but
    // it's not worth the effort. Anything past the 32'nd bit is ignored.

    // Copy bytes to buffer
    var b = this.buffer, o = this.offset;
    for (var i = 7; i >= 0; i--) {
      b[o+i] = lo & 0xff;
      lo = i == 4 ? hi : lo >>> 8;
    }

    // Restore sign of passed argument
    if (negate) this._2scomp();
  },

  /**
   * Convert to a native JS number.
   *
   * WARNING: Do not expect this value to be accurate to integer precision for
   * large (positive or negative) numbers!
   *
   * @param allowImprecise If true, no check is performed to verify the
   * returned value is accurate to integer precision.  If false, imprecise
   * numbers (very large positive or negative numbers) will be forced to +/-
   * Infinity.
   */
  toNumber: function(allowImprecise) {
    var b = this.buffer, o = this.offset;

    // Running sum of octets, doing a 2's complement
    var negate = b[o] & 0x80, x = 0, carry = 1;
    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {
      var v = b[o+i];

      // 2's complement for negative numbers
      if (negate) {
        v = (v ^ 0xff) + carry;
        carry = v >> 8;
        v = v & 0xff;
      }

      x += v * m;
    }

    // Return Infinity if we've lost integer precision
    if (!allowImprecise && x >= Int64.MAX_INT) {
      return negate ? -Infinity : Infinity;
    }

    return negate ? -x : x;
  },

  /**
   * Convert to a JS Number. Returns +/-Infinity for values that can't be
   * represented to integer precision.
   */
  valueOf: function() {
    return this.toNumber(false);
  },

  /**
   * Return string value
   *
   * @param radix Just like Number#toString()'s radix
   */
  toString: function(radix) {
    return this.valueOf().toString(radix || 10);
  },

  /**
   * Return a string showing the buffer octets, with MSB on the left.
   *
   * @param sep separator string. default is '' (empty string)
   */
  toOctetString: function(sep) {
    var out = new Array(8);
    var b = this.buffer, o = this.offset;
    for (var i = 0; i < 8; i++) {
      out[i] = _HEX[b[o+i]];
    }
    return out.join(sep || '');
  },

  /**
   * Returns the int64's 8 bytes in a buffer.
   *
   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if
   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.
   */
  toBuffer: function(rawBuffer) {
    if (rawBuffer && this.offset === 0) return this.buffer;

    var out = new Buffer(8);
    this.buffer.copy(out, 0, this.offset, this.offset + 8);
    return out;
  },

  /**
   * Copy 8 bytes of int64 into target buffer at target offset.
   *
   * @param {Buffer} targetBuffer       Buffer to copy into.
   * @param {number} [targetOffset=0]   Offset into target buffer.
   */
  copy: function(targetBuffer, targetOffset) {
    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
  },

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other in sort order.
   *
   * @param {Int64} other  Other Int64 to compare.
   */
  compare: function(other) {

    // If sign bits differ ...
    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {
      return other.buffer[other.offset] - this.buffer[this.offset];
    }

    // otherwise, compare bytes lexicographically
    for (var i = 0; i < 8; i++) {
      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {
        return this.buffer[this.offset+i] - other.buffer[other.offset+i];
      }
    }
    return 0;
  },

  /**
   * Returns a boolean indicating if this integer is equal to other.
   *
   * @param {Int64} other  Other Int64 to compare.
   */
  equals: function(other) {
    return this.compare(other) === 0;
  },

  /**
   * Pretty output in console.log
   */
  inspect: function() {
    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';
  }
};


/***/ }),
/* 328 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"coc.nvim\",\"version\":\"0.0.79\",\"description\":\"LSP based intellisense engine for neovim & vim8.\",\"main\":\"./lib/index.js\",\"engines\":{\"node\":\">=8.10.0\"},\"scripts\":{\"clean\":\"rimraf lib build\",\"lint\":\"eslint . --ext .ts --quiet\",\"build\":\"tsc -p tsconfig.json\",\"watch\":\"tsc -p tsconfig.json --watch true --sourceMap\",\"test\":\"node --trace-warnings node_modules/jest/bin/jest.js --runInBand --detectOpenHandles --forceExit\",\"test-build\":\"node --trace-warnings node_modules/jest/bin/jest.js --runInBand --coverage --forceExit\",\"prepare\":\"npm-run-all clean build\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/neoclide/coc.nvim.git\"},\"keywords\":[\"complete\",\"neovim\"],\"author\":\"Qiming Zhao <chemzqm@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/neoclide/coc.nvim/issues\"},\"homepage\":\"https://github.com/neoclide/coc.nvim#readme\",\"jest\":{\"globals\":{\"__TEST__\":true},\"watchman\":false,\"clearMocks\":true,\"globalSetup\":\"./jest.js\",\"testEnvironment\":\"node\",\"moduleFileExtensions\":[\"ts\",\"tsx\",\"json\",\"js\"],\"transform\":{\"^.+\\\\.tsx?$\":\"ts-jest\"},\"testRegex\":\"src/__tests__/.*\\\\.(test|spec)\\\\.ts$\",\"coverageDirectory\":\"./coverage/\"},\"devDependencies\":{\"@types/debounce\":\"^3.0.0\",\"@types/fb-watchman\":\"^2.0.0\",\"@types/glob\":\"^7.1.3\",\"@types/jest\":\"^26.0.13\",\"@types/minimatch\":\"^3.0.3\",\"@types/mkdirp\":\"^1.0.1\",\"@types/node\":\"^10.12.0\",\"@types/semver\":\"^7.3.3\",\"@types/tar\":\"^4.0.3\",\"@types/uuid\":\"^8.3.0\",\"@types/which\":\"^1.3.2\",\"@typescript-eslint/eslint-plugin\":\"^4.1.0\",\"@typescript-eslint/eslint-plugin-tslint\":\"^4.1.0\",\"@typescript-eslint/parser\":\"^4.1.0\",\"colors\":\"^1.4.0\",\"eslint\":\"^7.8.1\",\"eslint-config-prettier\":\"^6.11.0\",\"eslint-plugin-jest\":\"^24.0.0\",\"eslint-plugin-jsdoc\":\"^30.4.1\",\"jest\":\"26.4.2\",\"npm-run-all\":\"^4.1.5\",\"prettier\":\"^2.1.1\",\"ts-jest\":\"^26.3.0\",\"typescript\":\"^4.0.3\",\"vscode-languageserver\":\"^6.1.1\"},\"dependencies\":{\"@chemzqm/neovim\":\"^5.2.6\",\"bser\":\"^2.1.1\",\"bytes\":\"^3.1.0\",\"clipboardy\":\"^2.3.0\",\"content-disposition\":\"^0.5.3\",\"debounce\":\"^1.2.0\",\"fast-diff\":\"^1.2.0\",\"fb-watchman\":\"^2.0.1\",\"follow-redirects\":\"^1.13.0\",\"glob\":\"^7.1.6\",\"http-proxy-agent\":\"^4.0.1\",\"https-proxy-agent\":\"^5.0.0\",\"isuri\":\"^2.0.3\",\"jsonc-parser\":\"^2.3.0\",\"log4js\":\"^6.3.0\",\"minimatch\":\"^3.0.4\",\"mkdirp\":\"^1.0.4\",\"mv\":\"^2.1.1\",\"promise.prototype.finally\":\"^3.1.2\",\"rc\":\"^1.2.8\",\"rimraf\":\"^3.0.2\",\"semver\":\"^7.3.2\",\"tar\":\"^6.0.5\",\"tslib\":\"^2.0.1\",\"unzipper\":\"^0.10.11\",\"uuid\":\"^7.0.3\",\"vscode-languageserver-protocol\":\"^3.15.3\",\"vscode-languageserver-textdocument\":\"^1.0.1\",\"vscode-languageserver-types\":\"^3.15.1\",\"vscode-uri\":\"^2.1.2\",\"which\":\"^2.0.2\"}}");

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_textdocument_1 = __webpack_require__(293);
const logger = __webpack_require__(64)('snippets-parser');
class Scanner {
    constructor() {
        this.text('');
    }
    static isDigitCharacter(ch) {
        return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
    }
    static isVariableCharacter(ch) {
        return ch === 95 /* Underline */
            || (ch >= 97 /* a */ && ch <= 122 /* z */)
            || (ch >= 65 /* A */ && ch <= 90 /* Z */);
    }
    text(value) {
        this.value = value;
        this.pos = 0;
    }
    tokenText(token) {
        return this.value.substr(token.pos, token.len);
    }
    next() {
        if (this.pos >= this.value.length) {
            return { type: 14 /* EOF */, pos: this.pos, len: 0 };
        }
        let pos = this.pos;
        let len = 0;
        let ch = this.value.charCodeAt(pos);
        let type;
        // static types
        type = Scanner._table[ch];
        if (typeof type === 'number') {
            this.pos += 1;
            return { type, pos, len: 1 };
        }
        // number
        if (Scanner.isDigitCharacter(ch)) {
            type = 8 /* Int */;
            do {
                len += 1;
                ch = this.value.charCodeAt(pos + len);
            } while (Scanner.isDigitCharacter(ch));
            this.pos += len;
            return { type, pos, len };
        }
        // variable name
        if (Scanner.isVariableCharacter(ch)) {
            type = 9 /* VariableName */;
            do {
                ch = this.value.charCodeAt(pos + (++len));
            } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));
            this.pos += len;
            return { type, pos, len };
        }
        // format
        type = 10 /* Format */;
        do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch)
            && typeof Scanner._table[ch] === 'undefined' // not static token
            && !Scanner.isDigitCharacter(ch) // not number
            && !Scanner.isVariableCharacter(ch) // not variable
        );
        this.pos += len;
        return { type, pos, len };
    }
}
exports.Scanner = Scanner;
Scanner._table = {
    [36 /* DollarSign */]: 0 /* Dollar */,
    [58 /* Colon */]: 1 /* Colon */,
    [44 /* Comma */]: 2 /* Comma */,
    [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,
    [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,
    [92 /* Backslash */]: 5 /* Backslash */,
    [47 /* Slash */]: 6 /* Forwardslash */,
    [124 /* Pipe */]: 7 /* Pipe */,
    [43 /* Plus */]: 11 /* Plus */,
    [45 /* Dash */]: 12 /* Dash */,
    [63 /* QuestionMark */]: 13 /* QuestionMark */,
};
class Marker {
    constructor() {
        this._children = [];
    }
    appendChild(child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
            // this and previous child are text -> merge them
            this._children[this._children.length - 1].value += child.value;
        }
        else {
            // normal adoption of child
            child.parent = this;
            this._children.push(child);
        }
        return this;
    }
    setOnlyChild(child) {
        child.parent = this;
        this._children = [child];
    }
    replace(child, others) {
        const { parent } = child;
        const idx = parent.children.indexOf(child);
        const newChildren = parent.children.slice(0);
        newChildren.splice(idx, 1, ...others);
        parent._children = newChildren;
        (function _fixParent(children, parent) {
            for (const child of children) {
                child.parent = parent;
                _fixParent(child.children, child);
            }
        })(others, parent);
    }
    get children() {
        return this._children;
    }
    get snippet() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let candidate = this;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (!candidate) {
                return undefined;
            }
            if (candidate instanceof TextmateSnippet) {
                return candidate;
            }
            candidate = candidate.parent;
        }
    }
    toString() {
        return this.children.reduce((prev, cur) => prev + cur.toString(), '');
    }
    len() {
        return 0;
    }
    get next() {
        let { parent } = this;
        let { children } = parent;
        let idx = children.indexOf(this);
        return children[idx + 1];
    }
}
exports.Marker = Marker;
class Text extends Marker {
    constructor(value) {
        super();
        this.value = value;
    }
    static escape(value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    }
    toString() {
        return this.value;
    }
    toTextmateString() {
        return Text.escape(this.value);
    }
    len() {
        return this.value.length;
    }
    clone() {
        return new Text(this.value);
    }
}
exports.Text = Text;
class TransformableMarker extends Marker {
}
exports.TransformableMarker = TransformableMarker;
class Placeholder extends TransformableMarker {
    constructor(index) {
        super();
        this.index = index;
    }
    static compareByIndex(a, b) {
        if (a.index === b.index) {
            return 0;
        }
        else if (a.isFinalTabstop) {
            return 1;
        }
        else if (b.isFinalTabstop) {
            return -1;
        }
        else if (a.index < b.index) {
            return -1;
        }
        else if (a.index > b.index) {
            return 1;
        }
        else {
            return 0;
        }
    }
    get isFinalTabstop() {
        return this.index === 0;
    }
    get choice() {
        return this._children.length === 1 && this._children[0] instanceof Choice
            ? this._children[0]
            : undefined;
    }
    toTextmateString() {
        let transformString = '';
        if (this.transform) {
            transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0 && !this.transform) {
            return `$${this.index}`;
        }
        else if (this.children.length === 0) {
            return `\${${this.index}${transformString}}`;
        }
        else if (this.choice) {
            return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
        }
        else {
            return `\${${this.index}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;
        }
    }
    clone() {
        let ret = new Placeholder(this.index);
        if (this.transform) {
            ret.transform = this.transform.clone();
        }
        ret._children = this.children.map(child => child.clone());
        return ret;
    }
}
exports.Placeholder = Placeholder;
class Choice extends Marker {
    constructor() {
        super(...arguments);
        this.options = [];
    }
    appendChild(marker) {
        if (marker instanceof Text) {
            marker.parent = this;
            this.options.push(marker);
        }
        return this;
    }
    toString() {
        return this.options[0].value;
    }
    toTextmateString() {
        return this.options
            .map(option => option.value.replace(/\||,/g, '\\$&'))
            .join(',');
    }
    len() {
        return this.options[0].len();
    }
    clone() {
        let ret = new Choice();
        for (let opt of this.options) {
            ret.appendChild(opt);
        }
        return ret;
    }
}
exports.Choice = Choice;
class Transform extends Marker {
    resolve(value) {
        let didMatch = false;
        let ret = value.replace(this.regexp, (...args) => {
            didMatch = true;
            return this._replace(args.slice(0, -2));
        });
        // when the regex didn't match and when the transform has
        // else branches, then run those
        if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {
            ret = this._replace([]);
        }
        return ret;
    }
    _replace(groups) {
        let ret = '';
        for (const marker of this._children) {
            if (marker instanceof FormatString) {
                let value = groups[marker.index] || '';
                value = marker.resolve(value);
                ret += value;
            }
            else {
                ret += marker.toString();
            }
        }
        return ret;
    }
    toString() {
        return '';
    }
    toTextmateString() {
        return `/${this.regexp.source}/${this.children.map(c => c.toTextmateString())}/${(this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : '')}`;
    }
    clone() {
        let ret = new Transform();
        ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));
        ret._children = this.children.map(child => child.clone());
        return ret;
    }
}
exports.Transform = Transform;
class FormatString extends Marker {
    constructor(index, shorthandName, ifValue, elseValue) {
        super();
        this.index = index;
        this.shorthandName = shorthandName;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
    }
    resolve(value) {
        if (this.shorthandName === 'upcase') {
            return !value ? '' : value.toLocaleUpperCase();
        }
        else if (this.shorthandName === 'downcase') {
            return !value ? '' : value.toLocaleLowerCase();
        }
        else if (this.shorthandName === 'capitalize') {
            return !value ? '' : (value[0].toLocaleUpperCase() + value.substr(1));
        }
        else if (this.shorthandName === 'pascalcase') {
            return !value ? '' : this._toPascalCase(value);
        }
        else if (Boolean(value) && typeof this.ifValue === 'string') {
            return this.ifValue;
        }
        else if (!value && typeof this.elseValue === 'string') {
            return this.elseValue;
        }
        else {
            return value || '';
        }
    }
    _toPascalCase(value) {
        const match = value.match(/[a-z]+/gi);
        if (!match) {
            return value;
        }
        return match.map(word => word.charAt(0).toUpperCase()
            + word.substr(1).toLowerCase())
            .join('');
    }
    toTextmateString() {
        let value = '${';
        value += this.index;
        if (this.shorthandName) {
            value += `:/${this.shorthandName}`;
        }
        else if (this.ifValue && this.elseValue) {
            value += `:?${this.ifValue}:${this.elseValue}`;
        }
        else if (this.ifValue) {
            value += `:+${this.ifValue}`;
        }
        else if (this.elseValue) {
            value += `:-${this.elseValue}`;
        }
        value += '}';
        return value;
    }
    clone() {
        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
    }
}
exports.FormatString = FormatString;
class Variable extends TransformableMarker {
    constructor(name) {
        super();
        this.name = name;
    }
    resolve(resolver) {
        let value = resolver.resolve(this);
        if (value && value.includes('\n')) {
            // get indent of previous Text child
            let { children } = this.parent;
            let idx = children.indexOf(this);
            let previous = children[idx - 1];
            if (previous && previous instanceof Text) {
                let ms = previous.value.match(/\n([ \t]*)$/);
                if (ms) {
                    let lines = value.split('\n');
                    let indents = lines.filter(s => s.length > 0).map(s => s.match(/^\s*/)[0]);
                    let minIndent = indents.length == 0 ? '' :
                        indents.reduce((p, c) => p.length < c.length ? p : c);
                    let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(minIndent) ? s :
                        ms[1] + s.slice(minIndent.length));
                    value = newLines.join('\n');
                }
            }
        }
        if (this.transform) {
            value = this.transform.resolve(value || '');
        }
        if (value !== undefined) {
            this._children = [new Text(value)];
            return true;
        }
        return false;
    }
    toTextmateString() {
        let transformString = '';
        if (this.transform) {
            transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0) {
            return `\${${this.name}${transformString}}`;
        }
        else {
            return `\${${this.name}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;
        }
    }
    clone() {
        const ret = new Variable(this.name);
        if (this.transform) {
            ret.transform = this.transform.clone();
        }
        ret._children = this.children.map(child => child.clone());
        return ret;
    }
}
exports.Variable = Variable;
function walk(marker, visitor) {
    const stack = [...marker];
    while (stack.length > 0) {
        const marker = stack.shift();
        const recurse = visitor(marker);
        if (!recurse) {
            break;
        }
        stack.unshift(...marker.children);
    }
}
class TextmateSnippet extends Marker {
    get placeholderInfo() {
        if (!this._placeholders) {
            this._variables = [];
            // fill in placeholders
            let all = [];
            let last;
            this.walk(candidate => {
                if (candidate instanceof Placeholder) {
                    all.push(candidate);
                    last = !last || last.index < candidate.index ? candidate : last;
                }
                else if (candidate instanceof Variable) {
                    let first = candidate.name.charCodeAt(0);
                    // not jumpover for uppercase variable.
                    if (first < 65 || first > 90) {
                        this._variables.push(candidate);
                    }
                }
                return true;
            });
            this._placeholders = { all, last };
        }
        return this._placeholders;
    }
    get variables() {
        return this._variables;
    }
    get placeholders() {
        const { all } = this.placeholderInfo;
        return all;
    }
    get maxIndexNumber() {
        let { placeholders } = this;
        return placeholders.reduce((curr, p) => Math.max(curr, p.index), 0);
    }
    get minIndexNumber() {
        let { placeholders } = this;
        let nums = placeholders.map(p => p.index);
        nums.sort((a, b) => a - b);
        if (nums.length > 1 && nums[0] == 0)
            return nums[1];
        return nums[0] || 0;
    }
    insertSnippet(snippet, id, range) {
        let placeholder = this.placeholders[id];
        if (!placeholder)
            return;
        let { index } = placeholder;
        const document = vscode_languageserver_textdocument_1.TextDocument.create('untitled:/1', 'snippet', 0, placeholder.toString());
        snippet = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, [{ range, newText: snippet }]);
        let nested = new SnippetParser().parse(snippet, true);
        let maxIndexAdded = nested.maxIndexNumber + 1;
        let indexes = [];
        for (let p of nested.placeholders) {
            if (p.isFinalTabstop) {
                p.index = maxIndexAdded + index;
            }
            else {
                p.index = p.index + index;
            }
            indexes.push(p.index);
        }
        this.walk(m => {
            if (m instanceof Placeholder && m.index > index) {
                m.index = m.index + maxIndexAdded;
            }
            return true;
        });
        this.replace(placeholder, nested.children);
        return Math.min.apply(null, indexes);
    }
    updatePlaceholder(id, val) {
        const placeholder = this.placeholders[id];
        for (let p of this.placeholders) {
            if (p.index == placeholder.index) {
                let child = p.children[0];
                let newText = p.transform ? p.transform.resolve(val) : val;
                if (child) {
                    p.setOnlyChild(new Text(newText));
                }
                else {
                    p.appendChild(new Text(newText));
                }
            }
        }
        this._placeholders = undefined;
    }
    updateVariable(id, val) {
        const find = this.variables[id - this.maxIndexNumber - 1];
        if (find) {
            let variables = this.variables.filter(o => o.name == find.name);
            for (let variable of variables) {
                let newText = variable.transform ? variable.transform.resolve(val) : val;
                variable.setOnlyChild(new Text(newText));
            }
        }
    }
    /**
     * newText after update with value
     */
    getPlaceholderText(id, value) {
        const placeholder = this.placeholders[id];
        if (!placeholder)
            return value;
        return placeholder.transform ? placeholder.transform.resolve(value) : value;
    }
    offset(marker) {
        let pos = 0;
        let found = false;
        this.walk(candidate => {
            if (candidate === marker) {
                found = true;
                return false;
            }
            pos += candidate.len();
            return true;
        });
        if (!found) {
            return -1;
        }
        return pos;
    }
    fullLen(marker) {
        let ret = 0;
        walk([marker], marker => {
            ret += marker.len();
            return true;
        });
        return ret;
    }
    enclosingPlaceholders(placeholder) {
        let ret = [];
        let { parent } = placeholder;
        while (parent) {
            if (parent instanceof Placeholder) {
                ret.push(parent);
            }
            parent = parent.parent;
        }
        return ret;
    }
    resolveVariables(resolver) {
        this.walk(candidate => {
            if (candidate instanceof Variable) {
                if (candidate.resolve(resolver)) {
                    this._placeholders = undefined;
                }
            }
            return true;
        });
        return this;
    }
    appendChild(child) {
        this._placeholders = undefined;
        return super.appendChild(child);
    }
    replace(child, others) {
        this._placeholders = undefined;
        return super.replace(child, others);
    }
    toTextmateString() {
        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), '');
    }
    clone() {
        let ret = new TextmateSnippet();
        this._children = this.children.map(child => child.clone());
        return ret;
    }
    walk(visitor) {
        walk(this.children, visitor);
    }
}
exports.TextmateSnippet = TextmateSnippet;
class SnippetParser {
    constructor() {
        this._scanner = new Scanner();
    }
    static escape(value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    }
    text(value) {
        return this.parse(value).toString();
    }
    parse(value, insertFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        const snippet = new TextmateSnippet();
        while (this._parse(snippet)) {
            // nothing
        }
        // fill in values for placeholders. the first placeholder of an index
        // that has a value defines the value for all placeholders with that index
        const placeholderDefaultValues = new Map();
        const incompletePlaceholders = [];
        snippet.walk(marker => {
            if (marker instanceof Placeholder) {
                if (marker.isFinalTabstop) {
                    placeholderDefaultValues.set(0, undefined);
                }
                else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
                    placeholderDefaultValues.set(marker.index, marker.children);
                }
                else {
                    incompletePlaceholders.push(marker);
                }
            }
            return true;
        });
        for (const placeholder of incompletePlaceholders) {
            if (placeholderDefaultValues.has(placeholder.index)) {
                const clone = new Placeholder(placeholder.index);
                clone.transform = placeholder.transform;
                for (const child of placeholderDefaultValues.get(placeholder.index)) {
                    let marker = child.clone();
                    if (clone.transform) {
                        if (marker instanceof Text) {
                            marker = new Text(clone.transform.resolve(marker.value));
                        }
                        else {
                            for (let child of marker.children) {
                                if (child instanceof Text) {
                                    marker.replace(child, [new Text(clone.transform.resolve(child.value))]);
                                    break;
                                }
                            }
                        }
                    }
                    clone.appendChild(marker);
                }
                snippet.replace(placeholder, [clone]);
            }
        }
        if (!placeholderDefaultValues.has(0) && insertFinalTabstop) {
            // the snippet uses placeholders but has no
            // final tabstop defined -> insert at the end
            snippet.appendChild(new Placeholder(0));
        }
        return snippet;
    }
    _accept(type, value) {
        if (type === undefined || this._token.type === type) {
            let ret = !value ? true : this._scanner.tokenText(this._token);
            this._token = this._scanner.next();
            return ret;
        }
        return false;
    }
    _backTo(token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
    }
    _until(type) {
        if (this._token.type === 14 /* EOF */) {
            return false;
        }
        let start = this._token;
        while (this._token.type !== type) {
            this._token = this._scanner.next();
            if (this._token.type === 14 /* EOF */) {
                return false;
            }
        }
        let value = this._scanner.value.substring(start.pos, this._token.pos);
        this._token = this._scanner.next();
        return value;
    }
    _parse(marker) {
        return this._parseEscaped(marker)
            || this._parseTabstopOrVariableName(marker)
            || this._parseComplexPlaceholder(marker)
            || this._parseComplexVariable(marker)
            || this._parseAnything(marker);
    }
    // \$, \\, \} -> just text
    _parseEscaped(marker) {
        let value;
        // eslint-disable-next-line no-cond-assign
        if (value = this._accept(5 /* Backslash */, true)) {
            // saw a backslash, append escaped token or that backslash
            value = this._accept(0 /* Dollar */, true)
                || this._accept(4 /* CurlyClose */, true)
                || this._accept(5 /* Backslash */, true)
                || value;
            marker.appendChild(new Text(value));
            return true;
        }
        return false;
    }
    // $foo -> variable, $1 -> tabstop
    _parseTabstopOrVariableName(parent) {
        let value;
        const token = this._token;
        const match = this._accept(0 /* Dollar */)
            && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));
        if (!match) {
            return this._backTo(token);
        }
        parent.appendChild(/^\d+$/.test(value)
            ? new Placeholder(Number(value))
            : new Variable(value));
        return true;
    }
    // ${1:<children>}, ${1} -> placeholder
    _parseComplexPlaceholder(parent) {
        let index;
        const token = this._token;
        const match = this._accept(0 /* Dollar */)
            && this._accept(3 /* CurlyOpen */)
            && (index = this._accept(8 /* Int */, true));
        if (!match) {
            return this._backTo(token);
        }
        const placeholder = new Placeholder(Number(index));
        if (this._accept(1 /* Colon */)) {
            // ${1:<children>}
            // eslint-disable-next-line no-constant-condition
            while (true) {
                // ...} -> done
                if (this._accept(4 /* CurlyClose */)) {
                    parent.appendChild(placeholder);
                    return true;
                }
                if (this._parse(placeholder)) {
                    continue;
                }
                // fallback
                parent.appendChild(new Text('${' + index + ':'));
                placeholder.children.forEach(parent.appendChild, parent);
                return true;
            }
        }
        else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {
            // ${1|one,two,three|}
            const choice = new Choice();
            // eslint-disable-next-line no-constant-condition
            while (true) {
                if (this._parseChoiceElement(choice)) {
                    if (this._accept(2 /* Comma */)) {
                        // opt, -> more
                        continue;
                    }
                    if (this._accept(7 /* Pipe */)) {
                        placeholder.appendChild(choice);
                        if (this._accept(4 /* CurlyClose */)) {
                            // ..|} -> done
                            parent.appendChild(placeholder);
                            return true;
                        }
                    }
                }
                this._backTo(token);
                return false;
            }
        }
        else if (this._accept(6 /* Forwardslash */)) {
            // ${1/<regex>/<format>/<options>}
            if (this._parseTransform(placeholder)) {
                parent.appendChild(placeholder);
                return true;
            }
            this._backTo(token);
            return false;
        }
        else if (this._accept(4 /* CurlyClose */)) {
            // ${1}
            parent.appendChild(placeholder);
            return true;
        }
        else {
            // ${1 <- missing curly or colon
            return this._backTo(token);
        }
    }
    _parseChoiceElement(parent) {
        const token = this._token;
        const values = [];
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {
                break;
            }
            let value;
            // eslint-disable-next-line no-cond-assign
            if (value = this._accept(5 /* Backslash */, true)) {
                // \, \|, or \\
                value = this._accept(2 /* Comma */, true)
                    || this._accept(7 /* Pipe */, true)
                    || this._accept(5 /* Backslash */, true)
                    || value;
            }
            else {
                value = this._accept(undefined, true);
            }
            if (!value) {
                // EOF
                this._backTo(token);
                return false;
            }
            values.push(value);
        }
        if (values.length === 0) {
            this._backTo(token);
            return false;
        }
        parent.appendChild(new Text(values.join('')));
        return true;
    }
    // ${foo:<children>}, ${foo} -> variable
    _parseComplexVariable(parent) {
        let name;
        const token = this._token;
        const match = this._accept(0 /* Dollar */)
            && this._accept(3 /* CurlyOpen */)
            && (name = this._accept(9 /* VariableName */, true));
        if (!match) {
            return this._backTo(token);
        }
        const variable = new Variable(name);
        if (this._accept(1 /* Colon */)) {
            // ${foo:<children>}
            // eslint-disable-next-line no-constant-condition
            while (true) {
                // ...} -> done
                if (this._accept(4 /* CurlyClose */)) {
                    parent.appendChild(variable);
                    return true;
                }
                if (this._parse(variable)) {
                    continue;
                }
                // fallback
                parent.appendChild(new Text('${' + name + ':'));
                variable.children.forEach(parent.appendChild, parent);
                return true;
            }
        }
        else if (this._accept(6 /* Forwardslash */)) {
            // ${foo/<regex>/<format>/<options>}
            if (this._parseTransform(variable)) {
                parent.appendChild(variable);
                return true;
            }
            this._backTo(token);
            return false;
        }
        else if (this._accept(4 /* CurlyClose */)) {
            // ${foo}
            parent.appendChild(variable);
            return true;
        }
        else {
            // ${foo <- missing curly or colon
            return this._backTo(token);
        }
    }
    _parseTransform(parent) {
        // ...<regex>/<format>/<options>}
        let transform = new Transform();
        let regexValue = '';
        let regexOptions = '';
        // (1) /regex
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this._accept(6 /* Forwardslash */)) {
                break;
            }
            let escaped;
            // eslint-disable-next-line no-cond-assign
            if (escaped = this._accept(5 /* Backslash */, true)) {
                escaped = this._accept(6 /* Forwardslash */, true) || escaped;
                regexValue += escaped;
                continue;
            }
            if (this._token.type !== 14 /* EOF */) {
                regexValue += this._accept(undefined, true);
                continue;
            }
            return false;
        }
        // (2) /format
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this._accept(6 /* Forwardslash */)) {
                break;
            }
            let escaped;
            // eslint-disable-next-line no-cond-assign
            if (escaped = this._accept(5 /* Backslash */, true)) {
                escaped = this._accept(6 /* Forwardslash */, true) || escaped;
                transform.appendChild(new Text(escaped));
                continue;
            }
            if (this._parseFormatString(transform) || this._parseAnything(transform)) {
                let text = transform.children[0];
                if (text && text.value && text.value.includes('\\n')) {
                    text.value = text.value.replace(/\\n/g, '\n');
                }
                continue;
            }
            return false;
        }
        // (3) /option
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this._accept(4 /* CurlyClose */)) {
                break;
            }
            if (this._token.type !== 14 /* EOF */) {
                regexOptions += this._accept(undefined, true);
                continue;
            }
            return false;
        }
        try {
            transform.regexp = new RegExp(regexValue, regexOptions);
        }
        catch (e) {
            // invalid regexp
            return false;
        }
        parent.transform = transform;
        return true;
    }
    _parseFormatString(parent) {
        const token = this._token;
        if (!this._accept(0 /* Dollar */)) {
            return false;
        }
        let complex = false;
        if (this._accept(3 /* CurlyOpen */)) {
            complex = true;
        }
        let index = this._accept(8 /* Int */, true);
        if (!index) {
            this._backTo(token);
            return false;
        }
        else if (!complex) {
            // $1
            parent.appendChild(new FormatString(Number(index)));
            return true;
        }
        else if (this._accept(4 /* CurlyClose */)) {
            // ${1}
            parent.appendChild(new FormatString(Number(index)));
            return true;
        }
        else if (!this._accept(1 /* Colon */)) {
            this._backTo(token);
            return false;
        }
        if (this._accept(6 /* Forwardslash */)) {
            // ${1:/upcase}
            let shorthand = this._accept(9 /* VariableName */, true);
            if (!shorthand || !this._accept(4 /* CurlyClose */)) {
                this._backTo(token);
                return false;
            }
            else {
                parent.appendChild(new FormatString(Number(index), shorthand));
                return true;
            }
        }
        else if (this._accept(11 /* Plus */)) {
            // ${1:+<if>}
            let ifValue = this._until(4 /* CurlyClose */);
            if (ifValue) {
                parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));
                return true;
            }
        }
        else if (this._accept(12 /* Dash */)) {
            // ${2:-<else>}
            let elseValue = this._until(4 /* CurlyClose */);
            if (elseValue) {
                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));
                return true;
            }
        }
        else if (this._accept(13 /* QuestionMark */)) {
            // ${2:?<if>:<else>}
            let ifValue = this._until(1 /* Colon */);
            if (ifValue) {
                let elseValue = this._until(4 /* CurlyClose */);
                if (elseValue) {
                    parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));
                    return true;
                }
            }
        }
        else {
            // ${1:<else>}
            let elseValue = this._until(4 /* CurlyClose */);
            if (elseValue) {
                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));
                return true;
            }
        }
        this._backTo(token);
        return false;
    }
    _parseAnything(marker) {
        if (this._token.type !== 14 /* EOF */) {
            let text = this._scanner.tokenText(this._token);
            marker.appendChild(new Text(text));
            this._accept(undefined);
            return true;
        }
        return false;
    }
}
exports.SnippetParser = SnippetParser;
//# sourceMappingURL=parser.js.map

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const completion_1 = tslib_1.__importDefault(__webpack_require__(331));
const position_1 = __webpack_require__(311);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const snippet_1 = __webpack_require__(608);
const variableResolve_1 = __webpack_require__(609);
const logger = __webpack_require__(64)('snippets-session');
class SnippetSession {
    constructor(nvim, bufnr) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this._isActive = false;
        this._currId = 0;
        // Get state of line where we inserted
        this.applying = false;
        this.preferComplete = false;
        this._snippet = null;
        this._onCancelEvent = new vscode_languageserver_protocol_1.Emitter();
        this.onCancel = this._onCancelEvent.event;
        let config = workspace_1.default.getConfiguration('coc.preferences');
        let suggest = workspace_1.default.getConfiguration('suggest');
        this.preferComplete = config.get('preferCompleteThanJumpPlaceholder', suggest.get('preferCompleteThanJumpPlaceholder', false));
    }
    async start(snippetString, select = true, range) {
        const { document } = this;
        if (!document || !document.attached)
            return false;
        if (!range) {
            let position = await workspace_1.default.getCursorPosition();
            range = vscode_languageserver_protocol_1.Range.create(position, position);
        }
        let position = range.start;
        const formatOptions = await workspace_1.default.getFormatOptions(this.document.uri);
        const currentLine = document.getline(position.line);
        const currentIndent = currentLine.match(/^\s*/)[0];
        let inserted = normalizeSnippetString(snippetString, currentIndent, formatOptions);
        const resolver = new variableResolve_1.SnippetVariableResolver();
        await resolver.init(document);
        const snippet = new snippet_1.CocSnippet(inserted, position, resolver);
        const edit = vscode_languageserver_protocol_1.TextEdit.replace(range, snippet.toString());
        if (snippetString.endsWith('\n')
            && currentLine.slice(position.character).length) {
            // make next line same indent
            edit.newText = edit.newText + currentIndent;
            inserted = inserted + currentIndent;
        }
        await document.patchChange();
        this.applying = true;
        await document.applyEdits([edit]);
        this.applying = false;
        if (this._isActive) {
            // find valid placeholder
            let placeholder = this.findPlaceholder(range);
            // insert to placeholder
            if (placeholder && !placeholder.isFinalTabstop) {
                // don't repeat snippet insert
                let index = this.snippet.insertSnippet(placeholder, inserted, range);
                let p = this.snippet.getPlaceholder(index);
                this._currId = p.id;
                if (select)
                    await this.selectPlaceholder(p);
                return true;
            }
        }
        if (snippet.isPlainText) {
            this.deactivate();
            let placeholder = snippet.finalPlaceholder;
            await workspace_1.default.moveTo(placeholder.range.start);
            return false;
        }
        // new snippet
        this._snippet = snippet;
        this._currId = snippet.firstPlaceholder.id;
        if (select)
            await this.selectPlaceholder(snippet.firstPlaceholder);
        this.activate();
        return true;
    }
    activate() {
        if (this._isActive)
            return;
        this._isActive = true;
        this.nvim.call('coc#snippet#enable', [], true);
    }
    deactivate() {
        if (this._isActive) {
            this._isActive = false;
            this._snippet = null;
            this.nvim.call('coc#snippet#disable', [], true);
            logger.debug("[SnippetManager::cancel]");
        }
        this._onCancelEvent.fire(void 0);
        this._onCancelEvent.dispose();
    }
    get isActive() {
        return this._isActive;
    }
    async nextPlaceholder() {
        if (!this.isActive)
            return;
        await this.document.patchChange();
        let curr = this.placeholder;
        let next = this.snippet.getNextPlaceholder(curr.index);
        await this.selectPlaceholder(next);
    }
    async previousPlaceholder() {
        if (!this.isActive)
            return;
        await this.document.patchChange();
        let curr = this.placeholder;
        let prev = this.snippet.getPrevPlaceholder(curr.index);
        await this.selectPlaceholder(prev);
    }
    async synchronizeUpdatedPlaceholders(change) {
        if (!this.isActive || !this.document || this.applying)
            return;
        let edit = { range: change.range, newText: change.text };
        let { snippet } = this;
        // change outside range
        let adjusted = snippet.adjustTextEdit(edit);
        if (adjusted)
            return;
        if (position_1.comparePosition(edit.range.start, snippet.range.end) > 0) {
            if (!edit.newText)
                return;
            logger.info('Content change after snippet, cancelling snippet session');
            this.deactivate();
            return;
        }
        let placeholder = this.findPlaceholder(edit.range);
        if (!placeholder) {
            logger.info('Change outside placeholder, cancelling snippet session');
            this.deactivate();
            return;
        }
        if (placeholder.isFinalTabstop && snippet.finalCount <= 1) {
            logger.info('Change final placeholder, cancelling snippet session');
            this.deactivate();
            return;
        }
        this._currId = placeholder.id;
        let { edits, delta } = snippet.updatePlaceholder(placeholder, edit);
        if (!edits.length)
            return;
        this.applying = true;
        await this.document.applyEdits(edits);
        this.applying = false;
        if (delta) {
            await this.nvim.call('coc#util#move_cursor', delta);
        }
    }
    async selectCurrentPlaceholder(triggerAutocmd = true) {
        let placeholder = this.snippet.getPlaceholderById(this._currId);
        if (placeholder)
            await this.selectPlaceholder(placeholder, triggerAutocmd);
    }
    async selectPlaceholder(placeholder, triggerAutocmd = true) {
        let { nvim, document } = this;
        if (!document || !placeholder)
            return;
        let { start, end } = placeholder.range;
        const len = end.character - start.character;
        const col = string_1.byteLength(document.getline(start.line).slice(0, start.character)) + 1;
        this._currId = placeholder.id;
        if (placeholder.choice) {
            await nvim.call('coc#snippet#show_choices', [start.line + 1, col, len, placeholder.choice]);
            if (triggerAutocmd)
                nvim.call('coc#util#do_autocmd', ['CocJumpPlaceholder'], true);
        }
        else {
            await this.select(placeholder, triggerAutocmd);
        }
    }
    async select(placeholder, triggerAutocmd = true) {
        let { range, value, isFinalTabstop } = placeholder;
        let { document, nvim } = this;
        let { start, end } = range;
        let { textDocument } = document;
        let len = textDocument.offsetAt(end) - textDocument.offsetAt(start);
        let line = document.getline(start.line);
        let col = line ? string_1.byteLength(line.slice(0, start.character)) : 0;
        let endLine = document.getline(end.line);
        let endCol = endLine ? string_1.byteLength(endLine.slice(0, end.character)) : 0;
        nvim.setVar('coc_last_placeholder', {
            current_text: value,
            start: { line: start.line, col },
            end: { line: end.line, col: endCol }
        }, true);
        let [ve, selection, pumvisible, mode] = await nvim.eval('[&virtualedit, &selection, pumvisible(), mode()]');
        let move_cmd = '';
        if (pumvisible && this.preferComplete) {
            let pre = completion_1.default.hasSelected() ? '' : '\\<C-n>';
            await nvim.eval(`feedkeys("${pre}\\<C-y>", 'in')`);
            return;
        }
        // create move cmd
        if (mode != 'n')
            move_cmd += "\\<Esc>";
        if (len == 0) {
            if (col == 0 || (!mode.startsWith('i') && col < string_1.byteLength(line))) {
                move_cmd += 'i';
            }
            else {
                move_cmd += 'a';
            }
        }
        else {
            move_cmd += 'v';
            endCol = await this.getVirtualCol(end.line + 1, endCol);
            if (selection == 'inclusive') {
                if (end.character == 0) {
                    move_cmd += `${end.line}G`;
                }
                else {
                    move_cmd += `${end.line + 1}G${endCol}|`;
                }
            }
            else if (selection == 'old') {
                move_cmd += `${end.line + 1}G${endCol}|`;
            }
            else {
                move_cmd += `${end.line + 1}G${endCol + 1}|`;
            }
            col = await this.getVirtualCol(start.line + 1, col);
            move_cmd += `o${start.line + 1}G${col + 1}|o\\<c-g>`;
        }
        if (mode == 'i' && move_cmd == "\\<Esc>a") {
            move_cmd = '';
        }
        nvim.pauseNotification();
        nvim.setOption('virtualedit', 'onemore', true);
        nvim.call('cursor', [start.line + 1, col + (move_cmd == 'a' ? 0 : 1)], true);
        if (move_cmd) {
            nvim.call('eval', [`feedkeys("${move_cmd}", 'in')`], true);
        }
        if (mode == 'i') {
            nvim.call('coc#_cancel', [], true);
        }
        nvim.setOption('virtualedit', ve, true);
        if (isFinalTabstop) {
            if (this.snippet.finalCount == 1) {
                logger.info('Jump to final placeholder, cancelling snippet session');
                this.deactivate();
            }
            else {
                nvim.call('coc#snippet#disable', [], true);
            }
        }
        if (workspace_1.default.env.isVim)
            nvim.command('redraw', true);
        await nvim.resumeNotification();
        if (triggerAutocmd)
            nvim.call('coc#util#do_autocmd', ['CocJumpPlaceholder'], true);
    }
    async getVirtualCol(line, col) {
        let { nvim } = this;
        return await nvim.eval(`virtcol([${line}, ${col}])`);
    }
    async checkPosition() {
        if (!this.isActive)
            return;
        let position = await workspace_1.default.getCursorPosition();
        if (this.snippet && position_1.positionInRange(position, this.snippet.range) != 0) {
            logger.info('Cursor insert out of range, cancelling snippet session');
            this.deactivate();
        }
    }
    findPlaceholder(range) {
        if (!this.snippet)
            return null;
        let { placeholder } = this;
        if (placeholder && position_1.rangeInRange(range, placeholder.range))
            return placeholder;
        return this.snippet.getPlaceholderByRange(range) || null;
    }
    get placeholder() {
        if (!this.snippet)
            return null;
        return this.snippet.getPlaceholderById(this._currId);
    }
    get snippet() {
        return this._snippet;
    }
    get document() {
        return workspace_1.default.getDocument(this.bufnr);
    }
}
exports.SnippetSession = SnippetSession;
function normalizeSnippetString(snippet, indent, opts) {
    let lines = snippet.split(/\r?\n/);
    let ind = opts.insertSpaces ? ' '.repeat(opts.tabSize) : '\t';
    let tabSize = opts.tabSize || 2;
    lines = lines.map((line, idx) => {
        let space = line.match(/^\s*/)[0];
        let pre = space;
        let isTab = space.startsWith('\t');
        if (isTab && opts.insertSpaces) {
            pre = ind.repeat(space.length);
        }
        else if (!isTab && !opts.insertSpaces) {
            pre = ind.repeat(space.length / tabSize);
        }
        return (idx == 0 || line.length == 0 ? '' : indent) + pre + line.slice(space.length);
    });
    return lines.join('\n');
}
exports.normalizeSnippetString = normalizeSnippetString;
//# sourceMappingURL=session.js.map

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const sources_1 = tslib_1.__importDefault(__webpack_require__(332));
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const complete_1 = tslib_1.__importDefault(__webpack_require__(604));
const floating_1 = tslib_1.__importDefault(__webpack_require__(606));
const throttle_1 = tslib_1.__importDefault(__webpack_require__(607));
const object_1 = __webpack_require__(249);
const string_1 = __webpack_require__(310);
const logger = __webpack_require__(64)('completion');
const completeItemKeys = ['abbr', 'menu', 'info', 'kind', 'icase', 'dup', 'empty', 'user_data'];
class Completion {
    constructor() {
        // current input string
        this.activated = false;
        this.disposables = [];
        this.complete = null;
        this.recentScores = {};
        this.changedTick = 0;
        this.insertCharTs = 0;
        this.insertLeaveTs = 0;
    }
    init() {
        this.config = this.getCompleteConfig();
        this.floating = new floating_1.default();
        events_1.default.on('InsertCharPre', this.onInsertCharPre, this, this.disposables);
        events_1.default.on('InsertLeave', this.onInsertLeave, this, this.disposables);
        events_1.default.on('InsertEnter', this.onInsertEnter, this, this.disposables);
        events_1.default.on('TextChangedP', this.onTextChangedP, this, this.disposables);
        events_1.default.on('TextChangedI', this.onTextChangedI, this, this.disposables);
        let fn = throttle_1.default(this.onPumChange.bind(this), workspace_1.default.isVim ? 200 : 100);
        events_1.default.on('CompleteDone', async (item) => {
            this.currItem = null;
            this.cancelResolve();
            this.floating.close();
            await this.onCompleteDone(item);
        }, this, this.disposables);
        events_1.default.on('MenuPopupChanged', ev => {
            if (!this.activated || this.isCommandLine)
                return;
            let { completed_item } = ev;
            let item = completed_item.hasOwnProperty('word') ? completed_item : null;
            if (object_1.equals(item, this.currItem))
                return;
            this.cancelResolve();
            this.currItem = item;
            fn(ev);
        }, this, this.disposables);
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('suggest')) {
                this.config = this.getCompleteConfig();
            }
        }, null, this.disposables);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    get option() {
        if (!this.complete)
            return null;
        return this.complete.option;
    }
    get isCommandLine() {
        var _a;
        return (_a = this.document) === null || _a === void 0 ? void 0 : _a.uri.endsWith('%5BCommand%20Line%5D');
    }
    addRecent(word, bufnr) {
        if (!word)
            return;
        this.recentScores[`${bufnr}|${word}`] = Date.now();
    }
    get isActivated() {
        return this.activated;
    }
    get document() {
        if (!this.option)
            return null;
        return workspace_1.default.getDocument(this.option.bufnr);
    }
    getCompleteConfig() {
        let suggest = workspace_1.default.getConfiguration('suggest');
        function getConfig(key, defaultValue) {
            return suggest.get(key, suggest.get(key, defaultValue));
        }
        let keepCompleteopt = getConfig('keepCompleteopt', false);
        let autoTrigger = getConfig('autoTrigger', 'always');
        if (keepCompleteopt && autoTrigger != 'none') {
            let { completeOpt } = workspace_1.default;
            if (!completeOpt.includes('noinsert') && !completeOpt.includes('noselect')) {
                autoTrigger = 'none';
            }
        }
        let acceptSuggestionOnCommitCharacter = workspace_1.default.env.pumevent && getConfig('acceptSuggestionOnCommitCharacter', false);
        return {
            autoTrigger,
            keepCompleteopt,
            defaultSortMethod: getConfig('defaultSortMethod', 'length'),
            removeDuplicateItems: getConfig('removeDuplicateItems', false),
            disableMenuShortcut: getConfig('disableMenuShortcut', false),
            acceptSuggestionOnCommitCharacter,
            disableKind: getConfig('disableKind', false),
            disableMenu: getConfig('disableMenu', false),
            previewIsKeyword: getConfig('previewIsKeyword', '@,48-57,_192-255'),
            enablePreview: getConfig('enablePreview', false),
            enablePreselect: getConfig('enablePreselect', false),
            maxPreviewWidth: getConfig('maxPreviewWidth', 80),
            triggerCompletionWait: getConfig('triggerCompletionWait', 50),
            labelMaxLength: getConfig('labelMaxLength', 200),
            triggerAfterInsertEnter: getConfig('triggerAfterInsertEnter', false),
            noselect: getConfig('noselect', true),
            numberSelect: getConfig('numberSelect', false),
            maxItemCount: getConfig('maxCompleteItemCount', 50),
            timeout: getConfig('timeout', 500),
            minTriggerInputLength: getConfig('minTriggerInputLength', 1),
            snippetIndicator: getConfig('snippetIndicator', '~'),
            fixInsertedWord: getConfig('fixInsertedWord', true),
            localityBonus: getConfig('localityBonus', true),
            highPrioritySourceLimit: getConfig('highPrioritySourceLimit', null),
            lowPrioritySourceLimit: getConfig('lowPrioritySourceLimit', null),
            asciiCharactersOnly: getConfig('asciiCharactersOnly', false)
        };
    }
    async startCompletion(option) {
        this.pretext = string_1.byteSlice(option.line, 0, option.colnr - 1);
        try {
            await this._doComplete(option);
        }
        catch (e) {
            this.stop();
            workspace_1.default.showMessage(`Complete error: ${e.message}`, 'error');
            logger.error(e.stack);
        }
    }
    async resumeCompletion(force = false) {
        let { document, complete } = this;
        if (!document
            || complete.isCanceled
            || !complete.results
            || complete.results.length == 0)
            return;
        let search = this.getResumeInput();
        if (search == this.input && !force)
            return;
        if (!search || search.endsWith(' ') || !search.startsWith(complete.input)) {
            this.stop();
            return;
        }
        this.input = search;
        let items = [];
        if (complete.isIncomplete) {
            await document.patchChange();
            let { changedtick } = document;
            items = await complete.completeInComplete(search);
            if (complete.isCanceled || document.changedtick != changedtick)
                return;
        }
        else {
            items = complete.filterResults(search);
        }
        if (!complete.isCompleting && items.length === 0) {
            this.stop();
            return;
        }
        await this.showCompletion(complete.option.col, items);
    }
    hasSelected() {
        if (workspace_1.default.env.pumevent)
            return this.currItem != null;
        if (!this.config.noselect)
            return true;
        return false;
    }
    async showCompletion(col, items) {
        let { nvim, document, option } = this;
        let { numberSelect, disableKind, labelMaxLength, disableMenuShortcut, disableMenu } = this.config;
        let preselect = this.config.enablePreselect ? items.findIndex(o => o.preselect) : -1;
        if (numberSelect && option.input.length && !/^\d/.test(option.input)) {
            items = items.map((item, i) => {
                let idx = i + 1;
                if (i < 9) {
                    return Object.assign({}, item, {
                        abbr: item.abbr ? `${idx} ${item.abbr}` : `${idx} ${item.word}`
                    });
                }
                return item;
            });
            nvim.call('coc#_map', [], true);
        }
        this.changedTick = document.changedtick;
        let validKeys = completeItemKeys.slice();
        if (disableKind)
            validKeys = validKeys.filter(s => s != 'kind');
        if (disableMenu)
            validKeys = validKeys.filter(s => s != 'menu');
        let vimItems = items.map(item => {
            let obj = { word: item.word, equal: 1 };
            for (let key of validKeys) {
                if (item.hasOwnProperty(key)) {
                    if (disableMenuShortcut && key == 'menu') {
                        obj[key] = item[key].replace(/\[.+\]$/, '');
                    }
                    else if (key == 'abbr' && item[key].length > labelMaxLength) {
                        obj[key] = item[key].slice(0, labelMaxLength);
                    }
                    else {
                        obj[key] = item[key];
                    }
                }
            }
            return obj;
        });
        nvim.call('coc#_do_complete', [col, vimItems, preselect], true);
    }
    async _doComplete(option) {
        let { source } = option;
        let { nvim, config } = this;
        let document = workspace_1.default.getDocument(option.bufnr);
        if (!document || !document.attached)
            return;
        // use fixed filetype
        option.filetype = document.filetype;
        // current input
        this.input = option.input;
        let arr = [];
        if (source == null) {
            arr = sources_1.default.getCompleteSources(option);
        }
        else {
            let s = sources_1.default.getSource(source);
            if (s)
                arr.push(s);
        }
        if (!arr.length)
            return;
        await util_1.wait(this.config.triggerCompletionWait);
        await document.patchChange();
        // document get changed, not complete
        if (document.changedtick != option.changedtick)
            return;
        let complete = new complete_1.default(option, document, this.recentScores, config, arr, nvim);
        this.start(complete);
        let items = await this.complete.doComplete();
        if (complete.isCanceled)
            return;
        if (items.length == 0 && !complete.isCompleting) {
            this.stop();
            return;
        }
        complete.onDidComplete(async () => {
            let search = this.getResumeInput();
            if (complete.isCanceled || search == null)
                return;
            if (this.currItem != null && this.completeOpt.includes('noselect'))
                return;
            let { input } = this.option;
            if (search == input) {
                let items = complete.filterResults(search, Math.floor(Date.now() / 1000));
                await this.showCompletion(option.col, items);
            }
            else {
                await this.resumeCompletion();
            }
        });
        if (items.length) {
            let search = this.getResumeInput();
            if (search == option.input) {
                await this.showCompletion(option.col, items);
            }
            else {
                await this.resumeCompletion(true);
            }
        }
    }
    async onTextChangedP(bufnr, info) {
        let { option, document } = this;
        let pretext = this.pretext = info.pre;
        // avoid trigger filter on pumvisible
        if (!option || option.bufnr != bufnr || info.changedtick == this.changedTick)
            return;
        let hasInsert = this.latestInsert != null;
        this.lastInsert = null;
        if (info.pre.match(/^\s*/)[0] !== option.line.match(/^\s*/)[0]) {
            // Can't handle indent change
            this.stop();
            return;
        }
        // not handle when not triggered by character insert
        if (!hasInsert || !pretext)
            return;
        if (sources_1.default.shouldTrigger(pretext, document.filetype)) {
            await this.triggerCompletion(document, pretext, false);
        }
        else {
            await this.resumeCompletion();
        }
    }
    async onTextChangedI(bufnr, info) {
        let { nvim, latestInsertChar, option } = this;
        let noChange = this.pretext == info.pre;
        let pretext = this.pretext = info.pre;
        this.lastInsert = null;
        let document = workspace_1.default.getDocument(bufnr);
        if (!document || !document.attached)
            return;
        // try trigger on character type
        if (!this.activated) {
            if (!latestInsertChar)
                return;
            await this.triggerCompletion(document, this.pretext);
            return;
        }
        // Ignore change with other buffer
        if (!option)
            return;
        if (bufnr != option.bufnr
            || option.linenr != info.lnum
            || option.col >= info.col - 1) {
            this.stop();
            return;
        }
        // Completion is canceled by <C-e>
        if (noChange && !latestInsertChar) {
            this.stop();
            return;
        }
        // Check commit character
        if (pretext
            && this.currItem
            && this.config.acceptSuggestionOnCommitCharacter
            && latestInsertChar) {
            let resolvedItem = this.getCompleteItem(this.currItem);
            let last = pretext[pretext.length - 1];
            if (sources_1.default.shouldCommit(resolvedItem, last)) {
                let { linenr, col, line, colnr } = this.option;
                this.stop();
                let { word } = resolvedItem;
                let newLine = `${line.slice(0, col)}${word}${latestInsertChar}${line.slice(colnr - 1)}`;
                await nvim.call('coc#util#setline', [linenr, newLine]);
                let curcol = col + word.length + 2;
                await nvim.call('cursor', [linenr, curcol]);
                await document.patchChange();
                return;
            }
        }
        // prefer trigger completion
        if (sources_1.default.shouldTrigger(pretext, document.filetype)) {
            await this.triggerCompletion(document, pretext, false);
        }
        else {
            await this.resumeCompletion();
        }
    }
    async triggerCompletion(document, pre, checkTrigger = true) {
        if (this.config.autoTrigger == 'none')
            return;
        // check trigger
        if (checkTrigger) {
            let shouldTrigger = this.shouldTrigger(document, pre);
            if (!shouldTrigger)
                return;
        }
        await document.patchChange();
        let option = await this.nvim.call('coc#util#get_complete_option');
        if (!option)
            return;
        if (pre.length) {
            option.triggerCharacter = pre.slice(-1);
        }
        logger.debug('trigger completion with', option);
        await this.startCompletion(option);
    }
    async onCompleteDone(item) {
        let { document, isActivated } = this;
        if (!isActivated || !document || !item.hasOwnProperty('word'))
            return;
        let opt = Object.assign({}, this.option);
        let resolvedItem = this.getCompleteItem(item);
        this.stop();
        if (!resolvedItem)
            return;
        let timestamp = this.insertCharTs;
        let insertLeaveTs = this.insertLeaveTs;
        try {
            await sources_1.default.doCompleteResolve(resolvedItem, (new vscode_languageserver_protocol_1.CancellationTokenSource()).token);
            this.addRecent(resolvedItem.word, document.bufnr);
            // Wait possible TextChangedI
            await util_1.wait(50);
            if (this.insertCharTs != timestamp
                || this.insertLeaveTs != insertLeaveTs)
                return;
            let [visible, lnum, pre] = await this.nvim.eval(`[pumvisible(),line('.'),strpart(getline('.'), 0, col('.') - 1)]`);
            if (visible || lnum != opt.linenr || this.activated || !pre.endsWith(resolvedItem.word))
                return;
            await document.patchChange();
            await sources_1.default.doCompleteDone(resolvedItem, opt);
        }
        catch (e) {
            logger.error(`error on complete done`, e.stack);
        }
    }
    async onInsertLeave() {
        this.insertLeaveTs = Date.now();
        this.stop();
    }
    async onInsertEnter(bufnr) {
        if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== 'always')
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || !doc.attached)
            return;
        let pre = await this.nvim.eval(`strpart(getline('.'), 0, col('.') - 1)`);
        if (!pre)
            return;
        await this.triggerCompletion(doc, pre);
    }
    async onInsertCharPre(character) {
        this.lastInsert = {
            character,
            timestamp: Date.now(),
        };
        this.insertCharTs = this.lastInsert.timestamp;
    }
    get latestInsert() {
        let { lastInsert } = this;
        if (!lastInsert || Date.now() - lastInsert.timestamp > 500) {
            return null;
        }
        return lastInsert;
    }
    get latestInsertChar() {
        let { latestInsert } = this;
        if (!latestInsert)
            return '';
        return latestInsert.character;
    }
    shouldTrigger(document, pre) {
        if (pre.length == 0 || /\s/.test(pre[pre.length - 1]))
            return false;
        let autoTrigger = this.config.autoTrigger;
        if (autoTrigger == 'none')
            return false;
        if (sources_1.default.shouldTrigger(pre, document.filetype))
            return true;
        if (autoTrigger !== 'always' || this.isActivated)
            return false;
        let last = pre.slice(-1);
        if (last && (document.isWord(pre.slice(-1)) || last.codePointAt(0) > 255)) {
            let minLength = this.config.minTriggerInputLength;
            if (minLength == 1)
                return true;
            let input = this.getInput(document, pre);
            return input.length >= minLength;
        }
        return false;
    }
    async onPumChange(ev) {
        if (!this.activated)
            return;
        let { completed_item, col, row, height, width, scrollbar } = ev;
        let bounding = { col, row, height, width, scrollbar };
        let resolvedItem = this.getCompleteItem(completed_item);
        if (!resolvedItem) {
            this.floating.close();
            return;
        }
        let source = this.resolveTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let { token } = source;
        await sources_1.default.doCompleteResolve(resolvedItem, token);
        if (token.isCancellationRequested)
            return;
        let docs = resolvedItem.documentation;
        if (!docs && resolvedItem.info) {
            let { info } = resolvedItem;
            let isText = /^[\w-\s.,\t]+$/.test(info);
            docs = [{ filetype: isText ? 'txt' : this.document.filetype, content: info }];
        }
        if (!this.isActivated)
            return;
        if (!docs || docs.length == 0) {
            this.floating.close();
        }
        else {
            await this.floating.show(docs, bounding, token);
            if (!this.isActivated) {
                this.floating.close();
            }
        }
    }
    start(complete) {
        let { activated } = this;
        this.activated = true;
        if (activated) {
            this.complete.dispose();
        }
        this.complete = complete;
        if (!this.config.keepCompleteopt) {
            this.nvim.command(`noa set completeopt=${this.completeOpt}`, true);
        }
    }
    cancelResolve() {
        if (this.resolveTokenSource) {
            this.resolveTokenSource.cancel();
            this.resolveTokenSource = null;
        }
    }
    stop() {
        let { nvim } = this;
        if (!this.activated)
            return;
        this.currItem = null;
        this.activated = false;
        if (this.complete) {
            this.complete.dispose();
            this.complete = null;
        }
        nvim.pauseNotification();
        if (this.config.numberSelect) {
            nvim.call('coc#_unmap', [], true);
        }
        if (!this.config.keepCompleteopt) {
            this.nvim.command(`noa set completeopt=${workspace_1.default.completeOpt}`, true);
        }
        nvim.command(`let g:coc#_context['candidates'] = []`, true);
        nvim.call('coc#_hide', [], true);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        nvim.resumeNotification(false, true);
    }
    getInput(document, pre) {
        let input = '';
        for (let i = pre.length - 1; i >= 0; i--) {
            let ch = i == 0 ? null : pre[i - 1];
            if (!ch || !document.isWord(ch)) {
                input = pre.slice(i, pre.length);
                break;
            }
        }
        return input;
    }
    getResumeInput() {
        let { option, pretext } = this;
        if (!option)
            return null;
        let buf = Buffer.from(pretext, 'utf8');
        if (buf.length < option.col)
            return null;
        let input = buf.slice(option.col).toString('utf8');
        if (option.blacklist && option.blacklist.includes(input))
            return null;
        return input;
    }
    get completeOpt() {
        let { noselect, enablePreview } = this.config;
        let preview = enablePreview && !workspace_1.default.env.pumevent ? ',preview' : '';
        if (noselect)
            return `noselect,menuone${preview}`;
        return `noinsert,menuone${preview}`;
    }
    getCompleteItem(item) {
        if (!this.complete || item == null)
            return null;
        return this.complete.resolveCompletionItem(item);
    }
    dispose() {
        util_1.disposeAll(this.disposables);
    }
}
exports.Completion = Completion;
exports.default = new Completion();
//# sourceMappingURL=index.js.map

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fast_diff_1 = tslib_1.__importDefault(__webpack_require__(259));
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const util_1 = tslib_1.__importDefault(__webpack_require__(74));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const extensions_1 = tslib_1.__importDefault(__webpack_require__(333));
const source_1 = tslib_1.__importDefault(__webpack_require__(599));
const source_vim_1 = tslib_1.__importDefault(__webpack_require__(600));
const types_1 = __webpack_require__(295);
const util_2 = __webpack_require__(238);
const fs_2 = __webpack_require__(304);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const string_1 = __webpack_require__(310);
const logger = __webpack_require__(64)('sources');
class Sources {
    constructor() {
        this.sourceMap = new Map();
        this.disposables = [];
        this.remoteSourcePaths = [];
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    createNativeSources() {
        try {
            this.disposables.push((__webpack_require__(601)).regist(this.sourceMap));
            this.disposables.push((__webpack_require__(602)).regist(this.sourceMap));
            this.disposables.push((__webpack_require__(603)).regist(this.sourceMap));
        }
        catch (e) {
            console.error('Create source error:' + e.message);
        }
    }
    async createVimSourceExtension(nvim, filepath) {
        let name = path_1.default.basename(filepath, '.vim');
        try {
            await nvim.command(`source ${filepath}`);
            let fns = await nvim.call('coc#util#remote_fns', name);
            for (let fn of ['init', 'complete']) {
                if (!fns.includes(fn)) {
                    workspace_1.default.showMessage(`${fn} not found for source ${name}`, 'error');
                    return null;
                }
            }
            let props = await nvim.call(`coc#source#${name}#init`, []);
            let packageJSON = {
                name: `coc-source-${name}`,
                engines: {
                    coc: ">= 0.0.1"
                },
                activationEvents: props.filetypes ? props.filetypes.map(f => `onLanguage:${f}`) : ['*'],
                contributes: {
                    configuration: {
                        properties: {
                            [`coc.source.${name}.enable`]: {
                                type: 'boolean',
                                default: true
                            },
                            [`coc.source.${name}.firstMatch`]: {
                                type: 'boolean',
                                default: !!props.firstMatch
                            },
                            [`coc.source.${name}.triggerCharacters`]: {
                                type: 'number',
                                default: props.triggerCharacters || []
                            },
                            [`coc.source.${name}.priority`]: {
                                type: 'number',
                                default: props.priority || 9
                            },
                            [`coc.source.${name}.shortcut`]: {
                                type: 'string',
                                default: props.shortcut || name.slice(0, 3).toUpperCase(),
                                description: 'Shortcut text shown in complete menu.'
                            },
                            [`coc.source.${name}.disableSyntaxes`]: {
                                type: 'array',
                                default: [],
                                items: {
                                    type: 'string'
                                }
                            },
                            [`coc.source.${name}.filetypes`]: {
                                type: 'array',
                                default: props.filetypes || null,
                                description: 'Enabled filetypes.',
                                items: {
                                    type: 'string'
                                }
                            }
                        }
                    }
                }
            };
            let source = new source_vim_1.default({
                name,
                filepath,
                sourceType: types_1.SourceType.Remote,
                optionalFns: fns.filter(n => !['init', 'complete'].includes(n))
            });
            let isActive = false;
            let extension = {
                id: packageJSON.name,
                packageJSON,
                exports: void 0,
                extensionPath: filepath,
                activate: () => {
                    isActive = true;
                    this.addSource(source);
                    return Promise.resolve();
                }
            };
            Object.defineProperty(extension, 'isActive', {
                get: () => isActive
            });
            extensions_1.default.registerExtension(extension, () => {
                isActive = false;
                this.removeSource(source);
            });
        }
        catch (e) {
            workspace_1.default.showMessage(`Error on create vim source ${name}: ${e.message}`, 'error');
        }
    }
    createRemoteSources() {
        let { runtimepath } = workspace_1.default.env;
        let paths = runtimepath.split(',');
        for (let path of paths) {
            this.createVimSources(path).logError();
        }
    }
    async createVimSources(pluginPath) {
        if (this.remoteSourcePaths.includes(pluginPath))
            return;
        this.remoteSourcePaths.push(pluginPath);
        let folder = path_1.default.join(pluginPath, 'autoload/coc/source');
        let stat = await fs_2.statAsync(folder);
        if (stat && stat.isDirectory()) {
            let arr = await util_1.default.promisify(fs_1.default.readdir)(folder);
            arr = arr.filter(s => s.endsWith('.vim'));
            let files = arr.map(s => path_1.default.join(folder, s));
            if (files.length == 0)
                return;
            await Promise.all(files.map(p => this.createVimSourceExtension(this.nvim, p)));
        }
    }
    init() {
        this.createNativeSources();
        this.createRemoteSources();
        events_1.default.on('BufEnter', this.onDocumentEnter, this, this.disposables);
        workspace_1.default.watchOption('runtimepath', async (oldValue, newValue) => {
            let result = fast_diff_1.default(oldValue, newValue);
            for (let [changeType, value] of result) {
                if (changeType == 1) {
                    let paths = value.replace(/,$/, '').split(',');
                    for (let p of paths) {
                        if (p)
                            await this.createVimSources(p);
                    }
                }
            }
        }, this.disposables);
    }
    get names() {
        return Array.from(this.sourceMap.keys());
    }
    get sources() {
        return Array.from(this.sourceMap.values());
    }
    has(name) {
        return this.names.findIndex(o => o == name) != -1;
    }
    getSource(name) {
        if (!name)
            return null;
        return this.sourceMap.get(name) || null;
    }
    async doCompleteResolve(item, token) {
        let source = this.getSource(item.source);
        if (source && typeof source.onCompleteResolve == 'function') {
            try {
                await Promise.resolve(source.onCompleteResolve(item, token));
            }
            catch (e) {
                logger.error('Error on complete resolve:', e.stack);
            }
        }
    }
    async doCompleteDone(item, opt) {
        let data = JSON.parse(item.user_data);
        let source = this.getSource(data.source);
        if (source && typeof source.onCompleteDone === 'function') {
            await Promise.resolve(source.onCompleteDone(item, opt));
        }
    }
    shouldCommit(item, commitCharacter) {
        if (!item || !item.source)
            return false;
        let source = this.getSource(item.source);
        if (source && source.sourceType == types_1.SourceType.Service && typeof source.shouldCommit === 'function') {
            return source.shouldCommit(item, commitCharacter);
        }
        return false;
    }
    getCompleteSources(opt) {
        let { filetype } = opt;
        let pre = string_1.byteSlice(opt.line, 0, opt.colnr - 1);
        let isTriggered = opt.input == '' && !!opt.triggerCharacter;
        if (isTriggered)
            return this.getTriggerSources(pre, filetype);
        return this.getNormalSources(opt.filetype);
    }
    /**
     * Get sources should be used without trigger.
     *
     * @param {string} filetype
     * @returns {ISource[]}
     */
    getNormalSources(filetype) {
        return this.sources.filter(source => {
            let { filetypes, triggerOnly, enable } = source;
            if (!enable || triggerOnly || (filetypes && !filetypes.includes(filetype))) {
                return false;
            }
            if (this.disabledByLanguageId(source, filetype)) {
                return false;
            }
            return true;
        });
    }
    checkTrigger(source, pre, character) {
        let { triggerCharacters, triggerPatterns } = source;
        if (!triggerCharacters && !triggerPatterns)
            return false;
        if (character && triggerCharacters && triggerCharacters.includes(character)) {
            return true;
        }
        if (triggerPatterns && triggerPatterns.findIndex(p => p.test(pre)) !== -1) {
            return true;
        }
        return false;
    }
    shouldTrigger(pre, languageId) {
        let sources = this.getTriggerSources(pre, languageId);
        return sources.length > 0;
    }
    getTriggerSources(pre, languageId) {
        let character = pre.length ? pre[pre.length - 1] : '';
        if (!character)
            return [];
        return this.sources.filter(source => {
            let { filetypes, enable } = source;
            if (!enable || (filetypes && !filetypes.includes(languageId))) {
                return false;
            }
            if (this.disabledByLanguageId(source, languageId))
                return false;
            return this.checkTrigger(source, pre, character);
        });
    }
    addSource(source) {
        let { name } = source;
        if (this.names.includes(name)) {
            workspace_1.default.showMessage(`Source "${name}" recreated`, 'warning');
        }
        this.sourceMap.set(name, source);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.sourceMap.delete(name);
        });
    }
    removeSource(source) {
        let name = typeof source == 'string' ? source : source.name;
        if (source == this.sourceMap.get(name)) {
            this.sourceMap.delete(name);
        }
    }
    async refresh(name) {
        for (let source of this.sources) {
            if (!name || source.name == name) {
                if (typeof source.refresh === 'function') {
                    await Promise.resolve(source.refresh());
                }
            }
        }
    }
    toggleSource(name) {
        if (!name)
            return;
        let source = this.getSource(name);
        if (!source)
            return;
        if (typeof source.toggle === 'function') {
            source.toggle();
        }
    }
    sourceStats() {
        let res = [];
        let items = this.sources;
        for (let item of items) {
            res.push({
                name: item.name,
                priority: item.priority,
                triggerCharacters: item.triggerCharacters || [],
                shortcut: item.shortcut || '',
                filetypes: item.filetypes || [],
                filepath: item.filepath || '',
                type: item.sourceType == types_1.SourceType.Native
                    ? 'native' : item.sourceType == types_1.SourceType.Remote
                    ? 'remote' : 'service',
                disabled: !item.enable
            });
        }
        return res;
    }
    onDocumentEnter(bufnr) {
        let { sources } = this;
        for (let s of sources) {
            if (!s.enable)
                continue;
            if (typeof s.onEnter == 'function') {
                s.onEnter(bufnr);
            }
        }
    }
    createSource(config) {
        if (!config.name || !config.doComplete) {
            console.error(`name and doComplete required for createSource`);
            return;
        }
        let source = new source_1.default(Object.assign({ sourceType: types_1.SourceType.Service }, config));
        return this.addSource(source);
    }
    disabledByLanguageId(source, languageId) {
        let map = workspace_1.default.env.disabledSources;
        let list = map ? map[languageId] : [];
        return Array.isArray(list) && list.includes(source.name);
    }
    dispose() {
        util_2.disposeAll(this.disposables);
    }
}
exports.Sources = Sources;
exports.default = new Sources();
//# sourceMappingURL=sources.js.map

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = __webpack_require__(240);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const isuri_1 = tslib_1.__importDefault(__webpack_require__(241));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const rimraf_1 = tslib_1.__importDefault(__webpack_require__(267));
const semver_1 = tslib_1.__importDefault(__webpack_require__(1));
const util_1 = __webpack_require__(74);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const which_1 = tslib_1.__importDefault(__webpack_require__(244));
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const db_1 = tslib_1.__importDefault(__webpack_require__(306));
const floatFactory_1 = tslib_1.__importDefault(__webpack_require__(254));
const installBuffer_1 = tslib_1.__importDefault(__webpack_require__(334));
const installer_1 = __webpack_require__(335);
const memos_1 = tslib_1.__importDefault(__webpack_require__(490));
const types_1 = __webpack_require__(295);
const util_2 = __webpack_require__(238);
const array_1 = __webpack_require__(308);
__webpack_require__(491);
const factory_1 = __webpack_require__(492);
const fs_2 = __webpack_require__(304);
const is_1 = __webpack_require__(250);
const watchman_1 = tslib_1.__importDefault(__webpack_require__(324));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const mkdirp_1 = tslib_1.__importDefault(__webpack_require__(260));
const createLogger = __webpack_require__(64);
const logger = createLogger('extensions');
function loadJson(file) {
    try {
        let content = fs_1.default.readFileSync(file, 'utf8');
        return JSON.parse(content);
    }
    catch (e) {
        return null;
    }
}
// global local file native
class Extensions {
    constructor() {
        this.extensions = new Map();
        this.disabled = new Set();
        this._onDidLoadExtension = new vscode_languageserver_protocol_1.Emitter();
        this._onDidActiveExtension = new vscode_languageserver_protocol_1.Emitter();
        this._onDidUnloadExtension = new vscode_languageserver_protocol_1.Emitter();
        this._additionalSchemes = {};
        this.activated = false;
        this.disposables = [];
        this.ready = true;
        this.onDidLoadExtension = this._onDidLoadExtension.event;
        this.onDidActiveExtension = this._onDidActiveExtension.event;
        this.onDidUnloadExtension = this._onDidUnloadExtension.event;
        let folder = global.hasOwnProperty('__TEST__') ? path_1.default.join(__dirname, '__tests__') : process.env.COC_DATA_HOME;
        let root = this.root = path_1.default.join(folder, 'extensions');
        if (!fs_1.default.existsSync(root)) {
            mkdirp_1.default.sync(root);
        }
        let jsonFile = path_1.default.join(root, 'package.json');
        if (!fs_1.default.existsSync(jsonFile)) {
            fs_1.default.writeFileSync(jsonFile, '{"dependencies":{}}', 'utf8');
        }
        let filepath = path_1.default.join(root, 'db.json');
        this.db = new db_1.default(filepath);
    }
    async init() {
        let data = loadJson(this.db.filepath) || {};
        let keys = Object.keys(data.extension || {});
        for (let key of keys) {
            if (data.extension[key].disabled == true) {
                this.disabled.add(key);
            }
        }
        if (process.env.COC_NO_PLUGINS)
            return;
        let stats = await this.globalExtensionStats();
        let localStats = await this.localExtensionStats(stats.map(o => o.id));
        stats = stats.concat(localStats);
        this.memos = new memos_1.default(path_1.default.resolve(this.root, '../memos.json'));
        stats.map(stat => {
            let extensionType = stat.isLocal ? types_1.ExtensionType.Local : types_1.ExtensionType.Global;
            try {
                this.createExtension(stat.root, stat.packageJSON, extensionType);
            }
            catch (e) {
                logger.error(`Error on create ${stat.root}:`, e);
            }
        });
        await this.loadFileExtensions();
        commands_1.default.register({
            id: 'extensions.forceUpdateAll',
            execute: async () => {
                let arr = await this.cleanExtensions();
                logger.info(`Force update extensions: ${arr}`);
                await this.installExtensions(arr);
            }
        }, false, 'remove all global extensions and install them');
        workspace_1.default.onDidRuntimePathChange(async (paths) => {
            for (let p of paths) {
                if (p && this.checkDirectory(p) === true) {
                    await this.loadExtension(p);
                }
            }
        }, null, this.disposables);
    }
    async activateExtensions() {
        this.activated = true;
        for (let item of this.extensions.values()) {
            let { id, packageJSON } = item.extension;
            await this.setupActiveEvents(id, packageJSON);
        }
        // make sure workspace.env exists
        let floatFactory = new floatFactory_1.default(workspace_1.default.nvim, workspace_1.default.env);
        events_1.default.on('CursorMoved', debounce_1.debounce(async (bufnr) => {
            if (this.installBuffer && bufnr == this.installBuffer.bufnr) {
                let lnum = await workspace_1.default.nvim.call('line', ['.']);
                let msgs = this.installBuffer.getMessages(lnum - 1);
                let docs = msgs.length ? [{ content: msgs.join('\n'), filetype: 'txt' }] : [];
                await floatFactory.create(docs, false);
            }
        }, 500));
        if (global.hasOwnProperty('__TEST__'))
            return;
        // check extensions need watch & install
        this.checkExtensions().logError();
        let config = workspace_1.default.getConfiguration('coc.preferences');
        let interval = config.get('extensionUpdateCheck', 'never');
        if (interval != 'never') {
            let now = new Date();
            let day = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (interval == 'daily' ? 0 : 7));
            let ts = this.db.fetch('lastUpdate');
            if (ts && Number(ts) > day.getTime())
                return;
            this.updateExtensions(false, true).logError();
        }
    }
    async updateExtensions(sync, silent = false) {
        if (!this.npm)
            return;
        let lockedList = await this.getLockedList();
        let stats = await this.globalExtensionStats();
        stats = stats.filter(o => ![...lockedList, ...this.disabled].includes(o.id));
        this.db.push('lastUpdate', Date.now());
        let installBuffer = this.installBuffer = new installBuffer_1.default(true, sync, silent);
        installBuffer.setExtensions(stats.map(o => o.id));
        await installBuffer.show(workspace_1.default.nvim);
        let createInstaller = installer_1.createInstallerFactory(this.npm, this.modulesFolder);
        let fn = (stat) => {
            let { id } = stat;
            installBuffer.startProgress([id]);
            let url = stat.exotic ? stat.uri : null;
            return createInstaller(id, msg => installBuffer.addMessage(id, msg)).update(url).then(directory => {
                installBuffer.finishProgress(id, true);
                if (directory) {
                    this.loadExtension(directory).logError();
                }
            }, err => {
                installBuffer.addMessage(id, err.message);
                installBuffer.finishProgress(id, false);
            });
        };
        await util_2.concurrent(stats, fn);
    }
    async checkExtensions() {
        let { globalExtensions, watchExtensions } = workspace_1.default.env;
        if (globalExtensions && globalExtensions.length) {
            let names = this.filterGlobalExtensions(globalExtensions);
            this.installExtensions(names).logError();
        }
        // watch for changes
        if (watchExtensions && watchExtensions.length) {
            let watchmanPath = workspace_1.default.getWatchmanPath();
            if (!watchmanPath)
                return;
            for (let name of watchExtensions) {
                let item = this.extensions.get(name);
                if (item && item.directory) {
                    let directory = await util_1.promisify(fs_1.default.realpath)(item.directory);
                    let client = await watchman_1.default.createClient(watchmanPath, directory);
                    if (client) {
                        this.disposables.push(client);
                        client.subscribe('**/*.js', async () => {
                            await this.reloadExtension(name);
                            workspace_1.default.showMessage(`reloaded ${name}`);
                        }).then(disposable => {
                            this.disposables.push(disposable);
                        }, e => {
                            logger.error(e);
                        });
                    }
                }
            }
        }
    }
    /**
     * Install extensions, can be called without initialize.
     */
    async installExtensions(list = []) {
        let { npm } = this;
        if (!npm || !list.length)
            return;
        list = array_1.distinct(list);
        let installBuffer = this.installBuffer = new installBuffer_1.default();
        installBuffer.setExtensions(list);
        await installBuffer.show(workspace_1.default.nvim);
        let createInstaller = installer_1.createInstallerFactory(this.npm, this.modulesFolder);
        let fn = (key) => {
            installBuffer.startProgress([key]);
            return createInstaller(key, msg => installBuffer.addMessage(key, msg)).install().then(name => {
                installBuffer.finishProgress(key, true);
                let directory = path_1.default.join(this.modulesFolder, name);
                this.loadExtension(directory).logError();
            }, err => {
                installBuffer.addMessage(key, err.message);
                installBuffer.finishProgress(key, false);
                logger.error(`Error on install ${key}`, err);
            });
        };
        await util_2.concurrent(list, fn);
    }
    /**
     * Get list of extensions in package.json that not installed
     */
    getMissingExtensions() {
        let json = this.loadJson() || { dependencies: {} };
        let ids = [];
        for (let key of Object.keys(json.dependencies)) {
            let folder = path_1.default.join(this.modulesFolder, key);
            if (!fs_1.default.existsSync(folder)) {
                let val = json.dependencies[key];
                if (val.startsWith('http')) {
                    ids.push(val);
                }
                else {
                    ids.push(key);
                }
            }
        }
        return ids;
    }
    get npm() {
        let npm = workspace_1.default.getConfiguration('npm').get('binPath', 'npm');
        npm = workspace_1.default.expand(npm);
        for (let exe of [npm, 'yarnpkg', 'yarn', 'npm']) {
            try {
                let res = which_1.default.sync(exe);
                return res;
            }
            catch (e) {
                continue;
            }
        }
        workspace_1.default.showMessage(`Can't find npm or yarn in your $PATH`, 'error');
        return null;
    }
    /**
     * Get all loaded extensions.
     */
    get all() {
        return Array.from(this.extensions.values()).map(o => o.extension);
    }
    getExtension(id) {
        return this.extensions.get(id);
    }
    getExtensionState(id) {
        let disabled = this.isDisabled(id);
        if (disabled)
            return 'disabled';
        let item = this.extensions.get(id);
        if (!item)
            return 'unknown';
        let { extension } = item;
        return extension.isActive ? 'activated' : 'loaded';
    }
    async getExtensionStates() {
        let globalStats = await this.globalExtensionStats();
        let localStats = await this.localExtensionStats([]);
        return globalStats.concat(localStats);
    }
    async getLockedList() {
        let obj = await this.db.fetch('extension');
        obj = obj || {};
        return Object.keys(obj).filter(id => obj[id].locked === true);
    }
    async toggleLock(id) {
        let key = `extension.${id}.locked`;
        let locked = await this.db.fetch(key);
        if (locked) {
            this.db.delete(key);
        }
        else {
            this.db.push(key, true);
        }
    }
    async toggleExtension(id) {
        let state = this.getExtensionState(id);
        if (state == null)
            return;
        if (state == 'activated') {
            await this.deactivate(id);
        }
        let key = `extension.${id}.disabled`;
        this.db.push(key, state == 'disabled' ? false : true);
        if (state != 'disabled') {
            this.disabled.add(id);
            await this.unloadExtension(id);
        }
        else {
            this.disabled.delete(id);
            let folder = path_1.default.join(this.modulesFolder, id);
            if (fs_1.default.existsSync(folder)) {
                await this.loadExtension(folder);
            }
        }
        await util_2.wait(200);
    }
    async reloadExtension(id) {
        let item = this.extensions.get(id);
        if (!item) {
            workspace_1.default.showMessage(`Extension ${id} not registered`, 'error');
            return;
        }
        if (item.type == types_1.ExtensionType.Internal) {
            workspace_1.default.showMessage(`Can't reload internal extension "${item.id}"`, 'warning');
            return;
        }
        if (item.type == types_1.ExtensionType.SingleFile) {
            await this.loadExtensionFile(item.filepath);
        }
        else if (item.directory) {
            await this.loadExtension(item.directory);
        }
        else {
            workspace_1.default.showMessage(`Can't reload extension ${item.id}`, 'warning');
        }
    }
    /**
     * Unload & remove all global extensions, return removed extensions.
     */
    async cleanExtensions() {
        let dir = this.modulesFolder;
        if (!fs_1.default.existsSync(dir))
            return [];
        let ids = this.globalExtensions;
        let res = [];
        for (let id of ids) {
            let directory = path_1.default.join(dir, id);
            let stat = await util_1.promisify(fs_1.default.lstat)(directory);
            if (!stat || (stat && stat.isSymbolicLink()))
                continue;
            await this.unloadExtension(id);
            await util_1.promisify(rimraf_1.default)(directory, { glob: false });
            res.push(id);
        }
        return res;
    }
    async uninstallExtension(ids) {
        try {
            if (!ids.length)
                return;
            let [globals, filtered] = array_1.splitArray(ids, id => this.globalExtensions.includes(id));
            if (filtered.length) {
                workspace_1.default.showMessage(`Extensions ${filtered} not global extensions, can't uninstall!`, 'warning');
            }
            let json = this.loadJson() || { dependencies: {} };
            for (let id of globals) {
                await this.unloadExtension(id);
                delete json.dependencies[id];
                // remove directory
                let folder = path_1.default.join(this.modulesFolder, id);
                if (fs_1.default.existsSync(folder)) {
                    await util_1.promisify(rimraf_1.default)(folder, { glob: false });
                }
            }
            // update package.json
            const sortedObj = { dependencies: {} };
            Object.keys(json.dependencies).sort().forEach(k => {
                sortedObj.dependencies[k] = json.dependencies[k];
            });
            let jsonFile = path_1.default.join(this.root, 'package.json');
            fs_1.default.writeFileSync(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: 'utf8' });
            workspace_1.default.showMessage(`Removed: ${globals.join(' ')}`);
        }
        catch (e) {
            workspace_1.default.showMessage(`Uninstall failed: ${e.message}`, 'error');
        }
    }
    isDisabled(id) {
        return this.disabled.has(id);
    }
    has(id) {
        return this.extensions.has(id);
    }
    isActivated(id) {
        let item = this.extensions.get(id);
        if (item && item.extension.isActive) {
            return true;
        }
        return false;
    }
    /**
     * Load extension from folder, folder should contains coc extension.
     */
    async loadExtension(folder) {
        try {
            let parentFolder = path_1.default.dirname(folder);
            let isLocal = path_1.default.normalize(parentFolder) != path_1.default.normalize(this.modulesFolder);
            let jsonFile = path_1.default.join(folder, 'package.json');
            let packageJSON = JSON.parse(fs_1.default.readFileSync(jsonFile, 'utf8'));
            let { name } = packageJSON;
            if (this.isDisabled(name))
                return false;
            // unload if loaded
            await this.unloadExtension(name);
            this.createExtension(folder, Object.freeze(packageJSON), isLocal ? types_1.ExtensionType.Local : types_1.ExtensionType.Global);
            return true;
        }
        catch (e) {
            workspace_1.default.showMessage(`Error on load extension from "${folder}": ${e.message}`, 'error');
            logger.error(`Error on load extension from ${folder}`, e);
            return false;
        }
    }
    async loadFileExtensions() {
        if (!process.env.COC_VIMCONFIG)
            return;
        let folder = path_1.default.join(process.env.COC_VIMCONFIG, 'coc-extensions');
        if (!fs_1.default.existsSync(folder))
            return;
        let files = await fs_2.readdirAsync(folder);
        files = files.filter(f => f.endsWith('.js'));
        for (let file of files) {
            await this.loadExtensionFile(path_1.default.join(folder, file));
        }
        let watchmanPath = workspace_1.default.getWatchmanPath();
        if (!watchmanPath)
            return;
        let client = await watchman_1.default.createClient(watchmanPath, folder);
        if (!client)
            return;
        this.disposables.push(client);
        client.subscribe('*.js', async ({ root, files }) => {
            files = files.filter(f => f.type == 'f');
            for (let file of files) {
                let id = `single-` + path_1.default.basename(file.name, 'js');
                if (file.exists) {
                    let filepath = path_1.default.join(root, file.name);
                    await this.loadExtensionFile(filepath);
                }
                else {
                    await this.unloadExtension(id);
                }
            }
        }).then(disposable => {
            this.disposables.push(disposable);
        }, e => {
            logger.error(e);
        });
    }
    /**
     * Load single javascript file as extension.
     */
    async loadExtensionFile(filepath) {
        let filename = path_1.default.basename(filepath);
        let name = 'single-' + path_1.default.basename(filepath, '.js');
        if (this.isDisabled(name))
            return;
        let root = path_1.default.dirname(filepath);
        let packageJSON = {
            name, main: filename, engines: { coc: '^0.0.79' }
        };
        await this.unloadExtension(name);
        this.createExtension(root, packageJSON, types_1.ExtensionType.SingleFile);
    }
    /**
     * Activate extension, throw error if disabled or not exists
     * Returns true if extension successfully activated.
     */
    async activate(id) {
        if (this.isDisabled(id)) {
            throw new Error(`Extension ${id} is disabled!`);
        }
        let item = this.extensions.get(id);
        if (!item) {
            throw new Error(`Extension ${id} not registered!`);
        }
        let { extension } = item;
        if (extension.isActive)
            return true;
        await Promise.resolve(extension.activate());
        if (extension.isActive) {
            this._onDidActiveExtension.fire(extension);
            return true;
        }
        return false;
    }
    async deactivate(id) {
        let item = this.extensions.get(id);
        if (!item)
            return false;
        await Promise.resolve(item.deactivate());
        return true;
    }
    async call(id, method, args) {
        let item = this.extensions.get(id);
        if (!item)
            throw new Error(`extension ${id} not registered`);
        let { extension } = item;
        if (!extension.isActive) {
            await this.activate(id);
        }
        let { exports } = extension;
        if (!exports || !exports.hasOwnProperty(method)) {
            throw new Error(`method ${method} not found on extension ${id}`);
        }
        return await Promise.resolve(exports[method].apply(null, args));
    }
    getExtensionApi(id) {
        let item = this.extensions.get(id);
        if (!item)
            return null;
        let { extension } = item;
        return extension.isActive ? extension.exports : null;
    }
    registerExtension(extension, deactivate) {
        let { id, packageJSON } = extension;
        this.extensions.set(id, { id, type: types_1.ExtensionType.Internal, extension, deactivate, isLocal: true });
        let { contributes } = packageJSON;
        if (contributes) {
            let { configuration } = contributes;
            if (configuration && configuration.properties) {
                let { properties } = configuration;
                let props = {};
                for (let key of Object.keys(properties)) {
                    let val = properties[key].default;
                    if (val != null)
                        props[key] = val;
                }
                workspace_1.default.configurations.extendsDefaults(props);
            }
        }
        this._onDidLoadExtension.fire(extension);
        this.setupActiveEvents(id, packageJSON).logError();
    }
    get globalExtensions() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
            return [];
        return Object.keys(json.dependencies);
    }
    async globalExtensionStats() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
            return [];
        let { modulesFolder } = this;
        let res = await Promise.all(Object.keys(json.dependencies).map(key => new Promise(async (resolve) => {
            try {
                let val = json.dependencies[key];
                let root = path_1.default.join(modulesFolder, key);
                let res = this.checkDirectory(root);
                if (res instanceof Error) {
                    workspace_1.default.showMessage(`Unable to load global extension at ${root}: ${res.message}`, 'error');
                    logger.error(`Error on load ${root}`, res);
                    return resolve(null);
                }
                let content = await fs_2.readFile(path_1.default.join(root, 'package.json'), 'utf8');
                root = await fs_2.realpathAsync(root);
                let obj = JSON.parse(content);
                let version = obj ? obj.version || '' : '';
                let description = obj ? obj.description || '' : '';
                let uri = isuri_1.default.isValid(val) ? val : '';
                resolve({
                    id: key,
                    isLocal: false,
                    version,
                    description,
                    exotic: /^https?:/.test(val),
                    uri: uri.replace(/\.git(#master)?$/, ''),
                    root,
                    state: this.getExtensionState(key),
                    packageJSON: Object.freeze(obj)
                });
            }
            catch (e) {
                logger.error(e);
                resolve(null);
            }
        })));
        return res.filter(info => info != null);
    }
    async localExtensionStats(excludes) {
        let runtimepath = await workspace_1.default.nvim.eval('&runtimepath');
        let paths = runtimepath.split(',');
        let res = await Promise.all(paths.map(root => new Promise(async (resolve) => {
            try {
                let res = this.checkDirectory(root);
                if (res !== true)
                    return resolve(null);
                let jsonFile = path_1.default.join(root, 'package.json');
                let content = await fs_2.readFile(jsonFile, 'utf8');
                let obj = JSON.parse(content);
                let exist = this.extensions.get(obj.name);
                if (exist && !exist.isLocal) {
                    logger.info(`Extension "${obj.name}" in runtimepath already loaded.`);
                    return resolve(null);
                }
                if (excludes.includes(obj.name)) {
                    logger.info(`Skipped load vim plugin from "${root}", "${obj.name}" already global extension.`);
                    return resolve(null);
                }
                let version = obj ? obj.version || '' : '';
                let description = obj ? obj.description || '' : '';
                resolve({
                    id: obj.name,
                    isLocal: true,
                    version,
                    description,
                    exotic: false,
                    root,
                    state: this.getExtensionState(obj.name),
                    packageJSON: Object.freeze(obj)
                });
            }
            catch (e) {
                logger.error(e);
                resolve(null);
            }
        })));
        return res.filter(info => info != null);
    }
    loadJson() {
        let { root } = this;
        let jsonFile = path_1.default.join(root, 'package.json');
        if (!fs_1.default.existsSync(jsonFile))
            return null;
        return loadJson(jsonFile);
    }
    get schemes() {
        return this._additionalSchemes;
    }
    addSchemeProperty(key, def) {
        this._additionalSchemes[key] = def;
        workspace_1.default.configurations.extendsDefaults({ [key]: def.default });
    }
    async setupActiveEvents(id, packageJSON) {
        let { activationEvents } = packageJSON;
        if (!this.canActivate(id))
            return;
        if (!activationEvents || Array.isArray(activationEvents) && activationEvents.includes('*')) {
            await this.activate(id).catch(e => {
                workspace_1.default.showMessage(`Error on activate extension ${id}: ${e.message}`);
                logger.error(`Error on activate extension ${id}`, e);
            });
            return;
        }
        let disposables = [];
        let active = () => {
            util_2.disposeAll(disposables);
            return new Promise(resolve => {
                if (!this.canActivate(id))
                    return resolve();
                let timer = setTimeout(() => {
                    logger.warn(`Extension ${id} activate cost more than 1s`);
                    resolve();
                }, 1000);
                this.activate(id).then(() => {
                    clearTimeout(timer);
                    resolve();
                }, e => {
                    clearTimeout(timer);
                    workspace_1.default.showMessage(`Error on activate extension ${id}: ${e.message}`);
                    logger.error(`Error on activate extension ${id}`, e);
                    resolve();
                });
            });
        };
        for (let eventName of activationEvents) {
            let parts = eventName.split(':');
            let ev = parts[0];
            if (ev == 'onLanguage') {
                if (workspace_1.default.filetypes.has(parts[1])) {
                    await active();
                    return;
                }
                workspace_1.default.onDidOpenTextDocument(document => {
                    if (document.languageId == parts[1]) {
                        active().logError();
                    }
                }, null, disposables);
            }
            else if (ev == 'onCommand') {
                events_1.default.on('Command', command => {
                    if (command == parts[1]) {
                        active().logError();
                        // wait for service ready
                        return new Promise(resolve => {
                            setTimeout(resolve, 500);
                        });
                    }
                }, null, disposables);
            }
            else if (ev == 'workspaceContains') {
                let check = async () => {
                    let folders = workspace_1.default.workspaceFolders.map(o => vscode_uri_1.URI.parse(o.uri).fsPath);
                    for (let folder of folders) {
                        if (fs_2.inDirectory(folder, parts[1].split(/\s+/))) {
                            await active();
                            return true;
                        }
                    }
                };
                let res = await check();
                if (res)
                    return;
                workspace_1.default.onDidChangeWorkspaceFolders(check, null, disposables);
            }
            else if (ev == 'onFileSystem') {
                for (let doc of workspace_1.default.documents) {
                    let u = vscode_uri_1.URI.parse(doc.uri);
                    if (u.scheme == parts[1]) {
                        await active();
                        return;
                    }
                }
                workspace_1.default.onDidOpenTextDocument(document => {
                    let u = vscode_uri_1.URI.parse(document.uri);
                    if (u.scheme == parts[1]) {
                        active().logError();
                    }
                }, null, disposables);
            }
            else {
                workspace_1.default.showMessage(`Unsupported event ${eventName} of ${id}`, 'error');
            }
        }
    }
    createExtension(root, packageJSON, type) {
        let id = packageJSON.name;
        let isActive = false;
        let exports = null;
        let filename = path_1.default.join(root, packageJSON.main || 'index.js');
        let ext;
        let subscriptions = [];
        let extension = {
            activate: async () => {
                if (isActive)
                    return exports;
                let context = {
                    subscriptions,
                    extensionPath: root,
                    globalState: this.memos.createMemento(`${id}|global`),
                    workspaceState: this.memos.createMemento(`${id}|${workspace_1.default.rootPath}`),
                    asAbsolutePath: relativePath => path_1.default.join(root, relativePath),
                    storagePath: path_1.default.join(this.root, `${id}-data`),
                    logger: createLogger(id)
                };
                isActive = true;
                if (!ext) {
                    try {
                        let isEmpty = !(packageJSON.engines || {}).hasOwnProperty('coc');
                        ext = factory_1.createExtension(id, filename, isEmpty);
                    }
                    catch (e) {
                        logger.error(`Error on createExtension ${id} from ${filename}`, e);
                        return;
                    }
                }
                try {
                    exports = await Promise.resolve(ext.activate(context));
                    logger.debug('activate:', id);
                }
                catch (e) {
                    isActive = false;
                    logger.error(`Error on active extension ${id}: ${e.stack}`, e);
                }
                return exports;
            }
        };
        Object.defineProperties(extension, {
            id: {
                get: () => id
            },
            packageJSON: {
                get: () => packageJSON
            },
            extensionPath: {
                get: () => root
            },
            isActive: {
                get: () => isActive
            },
            exports: {
                get: () => exports
            }
        });
        this.extensions.set(id, {
            id,
            type,
            isLocal: type == types_1.ExtensionType.Local,
            extension,
            directory: root,
            filepath: filename,
            deactivate: () => {
                if (!isActive)
                    return;
                isActive = false;
                util_2.disposeAll(subscriptions);
                subscriptions.splice(0, subscriptions.length);
                subscriptions = [];
                if (ext && ext.deactivate) {
                    try {
                        return Promise.resolve(ext.deactivate()).catch(e => {
                            logger.error(`Error on ${id} deactivate: `, e);
                        });
                    }
                    catch (e) {
                        logger.error(`Error on ${id} deactivate: `, e);
                    }
                }
            }
        });
        let { contributes } = packageJSON;
        if (contributes) {
            let { configuration, rootPatterns, commands } = contributes;
            if (configuration && configuration.properties) {
                let { properties } = configuration;
                let props = {};
                for (let key of Object.keys(properties)) {
                    let val = properties[key].default;
                    if (val != null)
                        props[key] = val;
                }
                workspace_1.default.configurations.extendsDefaults(props);
            }
            if (rootPatterns && rootPatterns.length) {
                for (let item of rootPatterns) {
                    workspace_1.default.addRootPattern(item.filetype, item.patterns);
                }
            }
            if (commands && commands.length) {
                for (let cmd of commands) {
                    commands_1.default.titles.set(cmd.command, cmd.title);
                }
            }
        }
        this._onDidLoadExtension.fire(extension);
        if (this.activated) {
            this.setupActiveEvents(id, packageJSON).logError();
        }
    }
    // extension must exists as folder and in package.json
    filterGlobalExtensions(names) {
        names = names.map(s => s.replace(/@.*$/, ''));
        let filtered = names.filter(name => !this.disabled.has(name));
        filtered = filtered.filter(name => !this.extensions.has(name));
        let json = this.loadJson();
        let urls = [];
        let exists = [];
        if (json && json.dependencies) {
            for (let key of Object.keys(json.dependencies)) {
                let val = json.dependencies[key];
                if (typeof val !== 'string')
                    continue;
                if (fs_1.default.existsSync(path_1.default.join(this.modulesFolder, key, 'package.json'))) {
                    exists.push(key);
                    if (/^https?:/.test(val)) {
                        urls.push(val);
                    }
                }
            }
        }
        filtered = filtered.filter(str => {
            if (/^https?:/.test(str))
                return !urls.some(url => url.startsWith(str));
            return !exists.includes(str);
        });
        return filtered;
    }
    get modulesFolder() {
        return path_1.default.join(this.root, global.hasOwnProperty('__TEST__') ? '' : 'node_modules');
    }
    canActivate(id) {
        return !this.disabled.has(id) && this.extensions.has(id);
    }
    /**
     * Deactive & unregist extension
     */
    async unloadExtension(id) {
        let item = this.extensions.get(id);
        if (item) {
            await this.deactivate(id);
            this.extensions.delete(id);
            this._onDidUnloadExtension.fire(id);
        }
    }
    /**
     * Check if folder contains extension, return Error
     */
    checkDirectory(folder) {
        try {
            let jsonFile = path_1.default.join(folder, 'package.json');
            if (!fs_1.default.existsSync(jsonFile))
                throw new Error('package.json not found');
            let packageJSON = JSON.parse(fs_1.default.readFileSync(jsonFile, 'utf8'));
            let { name, engines, main } = packageJSON;
            if (!name || !engines)
                throw new Error(`can't find name & engines in package.json`);
            if (!engines || !is_1.objectLiteral(engines)) {
                throw new Error(`invalid engines in ${jsonFile}`);
            }
            if (main && !fs_1.default.existsSync(path_1.default.join(folder, main))) {
                throw new Error(`main file ${main} not found, you may need to build the project.`);
            }
            let keys = Object.keys(engines);
            if (!keys.includes('coc') && !keys.includes('vscode')) {
                throw new Error(`Engines in package.json doesn't have coc or vscode`);
            }
            if (keys.includes('coc')) {
                let required = engines['coc'].replace(/^\^/, '>=');
                if (!semver_1.default.satisfies(workspace_1.default.version, required)) {
                    throw new Error(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines['coc']}`);
                }
            }
            return true;
        }
        catch (e) {
            return e;
        }
    }
    dispose() {
        util_2.disposeAll(this.disposables);
    }
}
exports.Extensions = Extensions;
exports.default = new Extensions();
//# sourceMappingURL=extensions.js.map

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const status_1 = __webpack_require__(319);
const events_1 = __webpack_require__(198);
const logger = __webpack_require__(64)('model-installBuffer');
var State;
(function (State) {
    State[State["Waiting"] = 0] = "Waiting";
    State[State["Faild"] = 1] = "Faild";
    State[State["Progressing"] = 2] = "Progressing";
    State[State["Success"] = 3] = "Success";
})(State = exports.State || (exports.State = {}));
class InstallBuffer extends events_1.EventEmitter {
    constructor(isUpdate = false, isSync = false, silent = false) {
        super();
        this.isUpdate = isUpdate;
        this.isSync = isSync;
        this.silent = silent;
        this.statMap = new Map();
        this.messagesMap = new Map();
        this.names = [];
    }
    setExtensions(names) {
        this.statMap.clear();
        this.names = names;
        for (let name of names) {
            this.statMap.set(name, State.Waiting);
        }
    }
    addMessage(name, msg) {
        let lines = this.messagesMap.get(name) || [];
        this.messagesMap.set(name, lines.concat(msg.trim().split(/\r?\n/)));
    }
    startProgress(names) {
        for (let name of names) {
            this.statMap.set(name, State.Progressing);
        }
    }
    finishProgress(name, succeed = true) {
        this.statMap.set(name, succeed ? State.Success : State.Faild);
    }
    get remains() {
        let count = 0;
        for (let name of this.names) {
            let stat = this.statMap.get(name);
            if (![State.Success, State.Faild].includes(stat)) {
                count = count + 1;
            }
        }
        return count;
    }
    getLines() {
        let lines = [];
        for (let name of this.names) {
            let state = this.statMap.get(name);
            let processText = '*';
            switch (state) {
                case State.Progressing: {
                    let d = new Date();
                    let idx = Math.floor(d.getMilliseconds() / 100);
                    processText = status_1.frames[idx];
                    break;
                }
                case State.Faild:
                    processText = '✗';
                    break;
                case State.Success:
                    processText = '✓';
                    break;
            }
            let msgs = this.messagesMap.get(name) || [];
            lines.push(`- ${processText} ${name} ${msgs.length ? msgs[msgs.length - 1] : ''}`);
        }
        return lines;
    }
    getMessages(line) {
        if (line <= 1)
            return [];
        let name = this.names[line - 2];
        if (!name)
            return [];
        return this.messagesMap.get(name);
    }
    // draw frame
    draw(nvim, buffer) {
        let { remains } = this;
        let first = remains == 0 ? `${this.isUpdate ? 'Update' : 'Install'} finished` : `Installing, ${remains} remains...`;
        let lines = [first, '', ...this.getLines()];
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false }, true);
        if (remains == 0 && this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
        if (process.env.VIM_NODE_RPC) {
            nvim.command('redraw', true);
        }
    }
    highlight(nvim) {
        nvim.call('matchadd', ['CocListFgCyan', '^\\-\\s\\zs\\*'], true);
        nvim.call('matchadd', ['CocListFgGreen', '^\\-\\s\\zs✓'], true);
        nvim.call('matchadd', ['CocListFgRed', '^\\-\\s\\zs✗'], true);
        nvim.call('matchadd', ['CocListFgYellow', '^-.\\{3\\}\\zs\\S\\+'], true);
    }
    async show(nvim) {
        let { isSync } = this;
        if (this.silent)
            return;
        nvim.pauseNotification();
        nvim.command(isSync ? 'enew' : 'vs +enew', true);
        nvim.call('bufnr', ['%'], true);
        nvim.command('setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1', true);
        if (!isSync) {
            nvim.command('nnoremap <silent><nowait><buffer> q :q<CR>', true);
        }
        this.highlight(nvim);
        let res = await nvim.resumeNotification();
        let bufnr = res && res[1] == null ? res[0][1] : null;
        if (!bufnr)
            return;
        this.bufnr = bufnr;
        let buffer = nvim.createBuffer(bufnr);
        this.interval = setInterval(() => {
            this.draw(nvim, buffer);
        }, 100);
    }
    dispose() {
        if (this.interval) {
            clearInterval(this.interval);
        }
    }
}
exports.default = InstallBuffer;
//# sourceMappingURL=installBuffer.js.map

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const child_process_1 = __webpack_require__(239);
const readline_1 = tslib_1.__importDefault(__webpack_require__(206));
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const mkdirp_1 = tslib_1.__importDefault(__webpack_require__(260));
const mv_1 = tslib_1.__importDefault(__webpack_require__(336));
const os_1 = tslib_1.__importDefault(__webpack_require__(76));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const rc_1 = tslib_1.__importDefault(__webpack_require__(343));
const semver_1 = tslib_1.__importDefault(__webpack_require__(1));
const util_1 = __webpack_require__(74);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const download_1 = tslib_1.__importDefault(__webpack_require__(349));
const fetch_1 = tslib_1.__importDefault(__webpack_require__(478));
const rimraf_1 = tslib_1.__importDefault(__webpack_require__(267));
const fs_2 = __webpack_require__(304);
const logger = __webpack_require__(64)('model-installer');
function registryUrl(scope = 'coc.nvim') {
    const result = rc_1.default('npm', { registry: 'https://registry.npmjs.org/' });
    const registry = result[`${scope}:registry`] || result.config_registry || result.registry;
    return registry.endsWith('/') ? registry : registry + '/';
}
class Installer {
    constructor(root, npm, 
    // could be url or name@version or name
    def, onMessage) {
        this.root = root;
        this.npm = npm;
        this.def = def;
        this.onMessage = onMessage;
        if (!fs_1.default.existsSync(root))
            mkdirp_1.default.sync(root);
        if (/^https?:/.test(def)) {
            this.url = def;
        }
        else {
            if (def.includes('@')) {
                let [name, version] = def.split('@', 2);
                this.name = name;
                this.version = version;
            }
            else {
                this.name = def;
            }
        }
    }
    async install() {
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        logger.info(`Fetched info of ${this.def}`, info);
        let { name } = info;
        let required = info['engines.coc'] ? info['engines.coc'].replace(/^\^/, '>=') : '';
        if (required && !semver_1.default.satisfies(workspace_1.default.version, required)) {
            throw new Error(`${name} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        await this.doInstall(info);
        return name;
    }
    async update(url) {
        this.url = url;
        let folder = path_1.default.join(this.root, this.name);
        let stat = await util_1.promisify(fs_1.default.lstat)(folder);
        if (stat.isSymbolicLink()) {
            this.log(`Skipped update for symbol link`);
            return;
        }
        let version;
        if (fs_1.default.existsSync(path_1.default.join(folder, 'package.json'))) {
            let content = await util_1.promisify(fs_1.default.readFile)(path_1.default.join(folder, 'package.json'), 'utf8');
            version = JSON.parse(content).version;
        }
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        if (version && info.version && semver_1.default.gte(version, info.version)) {
            this.log(`Current version ${version} is up to date.`);
            return;
        }
        let required = info['engines.coc'] ? info['engines.coc'].replace(/^\^/, '>=') : '';
        if (required && !semver_1.default.satisfies(workspace_1.default.version, required)) {
            throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);
        }
        await this.doInstall(info);
        let jsonFile = path_1.default.join(this.root, info.name, 'package.json');
        if (fs_1.default.existsSync(jsonFile)) {
            this.log(`Updated to v${info.version}`);
            return path_1.default.dirname(jsonFile);
        }
        else {
            throw new Error(`Package.json not found: ${jsonFile}`);
        }
    }
    async doInstall(info) {
        let folder = path_1.default.join(this.root, info.name);
        if (fs_1.default.existsSync(folder)) {
            let stat = fs_1.default.statSync(folder);
            if (!stat.isDirectory()) {
                this.log(`${folder} is not directory skipped install`);
                return;
            }
        }
        let tmpFolder = await util_1.promisify(fs_1.default.mkdtemp)(path_1.default.join(os_1.default.tmpdir(), `${info.name}-`));
        let url = info['dist.tarball'];
        this.log(`Downloading from ${url}`);
        await download_1.default(url, { dest: tmpFolder, onProgress: p => this.log(`Download progress ${p}%`), extract: 'untar' });
        this.log(`Extension download at ${tmpFolder}`);
        let content = await util_1.promisify(fs_1.default.readFile)(path_1.default.join(tmpFolder, 'package.json'), 'utf8');
        let { dependencies } = JSON.parse(content);
        if (dependencies && Object.keys(dependencies).length) {
            let p = new Promise((resolve, reject) => {
                let args = ['install', '--ignore-scripts', '--no-lockfile', '--production'];
                if (url.startsWith('https://github.com')) {
                    args = ['install'];
                }
                this.log(`Installing dependencies by: ${this.npm} ${args.join(' ')}.`);
                const child = child_process_1.spawn(this.npm, args, {
                    cwd: tmpFolder,
                });
                const rl = readline_1.default.createInterface({
                    input: child.stdout
                });
                rl.on('line', line => {
                    this.log(`[npm] ${line}`);
                });
                child.stderr.setEncoding('utf8');
                child.stdout.setEncoding('utf8');
                child.on('error', reject);
                let err = '';
                child.stderr.on('data', data => {
                    err += data;
                });
                child.on('exit', code => {
                    if (code) {
                        if (err)
                            this.log(err);
                        reject(new Error(`${this.npm} install exited with ${code}`));
                        return;
                    }
                    resolve();
                });
            });
            await p;
        }
        let jsonFile = path_1.default.resolve(this.root, global.hasOwnProperty('__TEST__') ? '' : '..', 'package.json');
        let obj = JSON.parse(fs_1.default.readFileSync(jsonFile, 'utf8'));
        obj.dependencies = obj.dependencies || {};
        if (this.url) {
            obj.dependencies[info.name] = this.url;
        }
        else {
            obj.dependencies[info.name] = '>=' + info.version;
        }
        const sortedObj = { dependencies: {} };
        Object.keys(obj.dependencies).sort().forEach(k => {
            sortedObj.dependencies[k] = obj.dependencies[k];
        });
        let stat = await fs_2.statAsync(folder);
        if (stat) {
            if (stat.isDirectory()) {
                rimraf_1.default.sync(folder, { glob: false });
            }
            else {
                fs_1.default.unlinkSync(folder);
            }
        }
        await util_1.promisify(mv_1.default)(tmpFolder, folder, { mkdirp: true, clobber: true });
        fs_1.default.writeFileSync(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: 'utf8' });
        this.log(`Update package.json at ${jsonFile}`);
        this.log(`Installed extension ${this.name}@${info.version} at ${folder}`);
    }
    async getInfo() {
        if (this.url)
            return await this.getInfoFromUri();
        let registry = registryUrl();
        this.log(`Get info from ${registry}`);
        let res = await fetch_1.default(registry + this.name, { timeout: 10000 });
        if (!this.version)
            this.version = res['dist-tags']['latest'];
        let obj = res['versions'][this.version];
        if (!obj)
            throw new Error(`${this.def} doesn't exists in ${registry}.`);
        let requiredVersion = obj['engines'] && obj['engines']['coc'];
        if (!requiredVersion) {
            throw new Error(`${this.def} is not valid coc extension, "engines" field with coc property required.`);
        }
        return {
            'dist.tarball': obj['dist']['tarball'],
            'engines.coc': requiredVersion,
            version: obj['version'],
            name: res.name
        };
    }
    async getInfoFromUri() {
        let { url } = this;
        if (!url.includes('github.com')) {
            throw new Error(`"${url}" is not supported, coc.nvim support github.com only`);
        }
        url = url.replace(/\/$/, '');
        let fileUrl = url.replace('github.com', 'raw.githubusercontent.com') + '/master/package.json';
        this.log(`Get info from ${fileUrl}`);
        let content = await fetch_1.default(fileUrl, { timeout: 10000 });
        let obj = typeof content == 'string' ? JSON.parse(content) : content;
        this.name = obj.name;
        return {
            'dist.tarball': `${url}/archive/master.tar.gz`,
            'engines.coc': obj['engines'] ? obj['engines']['coc'] : null,
            name: obj.name,
            version: obj.version
        };
    }
    log(msg, extra) {
        logger.info(msg, extra ? extra : '');
        if (typeof this.onMessage === 'function') {
            this.onMessage(msg);
        }
    }
}
exports.Installer = Installer;
function createInstallerFactory(npm, root) {
    return (def, onMessage) => new Installer(root, npm, def, onMessage);
}
exports.createInstallerFactory = createInstallerFactory;
//# sourceMappingURL=installer.js.map

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(66);
var ncp = __webpack_require__(337).ncp;
var path = __webpack_require__(82);
var rimraf = __webpack_require__(338);
var mkdirp = __webpack_require__(342);

module.exports = mv;

function mv(source, dest, options, cb){
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }
  var shouldMkdirp = !!options.mkdirp;
  var clobber = options.clobber !== false;
  var limit = options.limit || 16;

  if (shouldMkdirp) {
    mkdirs();
  } else {
    doRename();
  }

  function mkdirs() {
    mkdirp(path.dirname(dest), function(err) {
      if (err) return cb(err);
      doRename();
    });
  }

  function doRename() {
    if (clobber) {
      fs.rename(source, dest, function(err) {
        if (!err) return cb();
        if (err.code !== 'EXDEV') return cb(err);
        moveFileAcrossDevice(source, dest, clobber, limit, cb);
      });
    } else {
      fs.link(source, dest, function(err) {
        if (err) {
          if (err.code === 'EXDEV') {
            moveFileAcrossDevice(source, dest, clobber, limit, cb);
            return;
          }
          if (err.code === 'EISDIR' || err.code === 'EPERM') {
            moveDirAcrossDevice(source, dest, clobber, limit, cb);
            return;
          }
          cb(err);
          return;
        }
        fs.unlink(source, cb);
      });
    }
  }
}

function moveFileAcrossDevice(source, dest, clobber, limit, cb) {
  var outFlags = clobber ? 'w' : 'wx';
  var ins = fs.createReadStream(source);
  var outs = fs.createWriteStream(dest, {flags: outFlags});
  ins.on('error', function(err){
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    if (err.code === 'EISDIR' || err.code === 'EPERM') {
      moveDirAcrossDevice(source, dest, clobber, limit, cb);
    } else {
      cb(err);
    }
  });
  outs.on('error', function(err){
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    cb(err);
  });
  outs.once('close', onClose);
  ins.pipe(outs);
  function onClose(){
    fs.unlink(source, cb);
  }
}

function moveDirAcrossDevice(source, dest, clobber, limit, cb) {
  var options = {
    stopOnErr: true,
    clobber: false,
    limit: limit,
  };
  if (clobber) {
    rimraf(dest, { disableGlob: true }, function(err) {
      if (err) return cb(err);
      startNcp();
    });
  } else {
    startNcp();
  }
  function startNcp() {
    ncp(source, dest, options, function(errList) {
      if (errList) return cb(errList[0]);
      rimraf(source, { disableGlob: true }, cb);
    });
  }
}


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(66),
    path = __webpack_require__(82);

module.exports = ncp;
ncp.ncp = ncp;

function ncp (source, dest, options, callback) {
  var cback = callback;

  if (!callback) {
    cback = options;
    options = {};
  }

  var basePath = process.cwd(),
      currentPath = path.resolve(basePath, source),
      targetPath = path.resolve(basePath, dest),
      filter = options.filter,
      rename = options.rename,
      transform = options.transform,
      clobber = options.clobber !== false,
      modified = options.modified,
      dereference = options.dereference,
      errs = null,
      started = 0,
      finished = 0,
      running = 0,
      limit = options.limit || ncp.limit || 16;

  limit = (limit < 1) ? 1 : (limit > 512) ? 512 : limit;

  startCopy(currentPath);
  
  function startCopy(source) {
    started++;
    if (filter) {
      if (filter instanceof RegExp) {
        if (!filter.test(source)) {
          return cb(true);
        }
      }
      else if (typeof filter === 'function') {
        if (!filter(source)) {
          return cb(true);
        }
      }
    }
    return getStats(source);
  }

  function getStats(source) {
    var stat = dereference ? fs.stat : fs.lstat;
    if (running >= limit) {
      return setImmediate(function () {
        getStats(source);
      });
    }
    running++;
    stat(source, function (err, stats) {
      var item = {};
      if (err) {
        return onError(err);
      }

      // We need to get the mode from the stats object and preserve it.
      item.name = source;
      item.mode = stats.mode;
      item.mtime = stats.mtime; //modified time
      item.atime = stats.atime; //access time

      if (stats.isDirectory()) {
        return onDir(item);
      }
      else if (stats.isFile()) {
        return onFile(item);
      }
      else if (stats.isSymbolicLink()) {
        // Symlinks don't really need to know about the mode.
        return onLink(source);
      }
    });
  }

  function onFile(file) {
    var target = file.name.replace(currentPath, targetPath);
    if(rename) {
      target =  rename(target);
    }
    isWritable(target, function (writable) {
      if (writable) {
        return copyFile(file, target);
      }
      if(clobber) {
        rmFile(target, function () {
          copyFile(file, target);
        });
      }
      if (modified) {
        var stat = dereference ? fs.stat : fs.lstat;
        stat(target, function(err, stats) {
            //if souce modified time greater to target modified time copy file
            if (file.mtime.getTime()>stats.mtime.getTime())
                copyFile(file, target);
            else return cb();
        });
      }
      else {
        return cb();
      }
    });
  }

  function copyFile(file, target) {
    var readStream = fs.createReadStream(file.name),
        writeStream = fs.createWriteStream(target, { mode: file.mode });
    
    readStream.on('error', onError);
    writeStream.on('error', onError);
    
    if(transform) {
      transform(readStream, writeStream, file);
    } else {
      writeStream.on('open', function() {
        readStream.pipe(writeStream);
      });
    }
    writeStream.once('finish', function() {
        if (modified) {
            //target file modified date sync.
            fs.utimesSync(target, file.atime, file.mtime);
            cb();
        }
        else cb();
    });
  }

  function rmFile(file, done) {
    fs.unlink(file, function (err) {
      if (err) {
        return onError(err);
      }
      return done();
    });
  }

  function onDir(dir) {
    var target = dir.name.replace(currentPath, targetPath);
    isWritable(target, function (writable) {
      if (writable) {
        return mkDir(dir, target);
      }
      copyDir(dir.name);
    });
  }

  function mkDir(dir, target) {
    fs.mkdir(target, dir.mode, function (err) {
      if (err) {
        return onError(err);
      }
      copyDir(dir.name);
    });
  }

  function copyDir(dir) {
    fs.readdir(dir, function (err, items) {
      if (err) {
        return onError(err);
      }
      items.forEach(function (item) {
        startCopy(path.join(dir, item));
      });
      return cb();
    });
  }

  function onLink(link) {
    var target = link.replace(currentPath, targetPath);
    fs.readlink(link, function (err, resolvedPath) {
      if (err) {
        return onError(err);
      }
      checkLink(resolvedPath, target);
    });
  }

  function checkLink(resolvedPath, target) {
    if (dereference) {
      resolvedPath = path.resolve(basePath, resolvedPath);
    }
    isWritable(target, function (writable) {
      if (writable) {
        return makeLink(resolvedPath, target);
      }
      fs.readlink(target, function (err, targetDest) {
        if (err) {
          return onError(err);
        }
        if (dereference) {
          targetDest = path.resolve(basePath, targetDest);
        }
        if (targetDest === resolvedPath) {
          return cb();
        }
        return rmFile(target, function () {
          makeLink(resolvedPath, target);
        });
      });
    });
  }

  function makeLink(linkPath, target) {
    fs.symlink(linkPath, target, function (err) {
      if (err) {
        return onError(err);
      }
      return cb();
    });
  }

  function isWritable(path, done) {
    fs.lstat(path, function (err) {
      if (err) {
        if (err.code === 'ENOENT') return done(true);
        return done(false);
      }
      return done(false);
    });
  }

  function onError(err) {
    if (options.stopOnError) {
      return cback(err);
    }
    else if (!errs && options.errs) {
      errs = fs.createWriteStream(options.errs);
    }
    else if (!errs) {
      errs = [];
    }
    if (typeof errs.write === 'undefined') {
      errs.push(err);
    }
    else { 
      errs.write(err.stack + '\n\n');
    }
    return cb();
  }

  function cb(skipped) {
    if (!skipped) running--;
    finished++;
    if ((started === finished) && (running === 0)) {
      if (cback !== undefined ) {
        return errs ? cback(errs) : cback(null);
      }
    }
  }
}




/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = rimraf
rimraf.sync = rimrafSync

var assert = __webpack_require__(108)
var path = __webpack_require__(82)
var fs = __webpack_require__(66)
var glob = __webpack_require__(339)

var globOpts = {
  nosort: true,
  nocomment: true,
  nonegate: true,
  silent: true
}

// for EMFILE handling
var timeout = 0

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  options.disableGlob = options.disableGlob || false
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')

  defaults(options)

  var busyTries = 0
  var errState = null
  var n = 0

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  fs.lstat(p, function (er, stat) {
    if (!er)
      return afterGlob(null, [p])

    glob(p, globOpts, afterGlob)
  })

  function next (er) {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  function afterGlob (er, results) {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(function (p) {
      rimraf_(p, options, function CB (er) {
        if (er) {
          if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            var time = busyTries * 100
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, time)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      })
    })
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT")
      return cb(null)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, 666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, 666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  var results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      fs.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, globOpts)
    }
  }

  if (!results.length)
    return

  for (var i = 0; i < results.length; i++) {
    var p = results[i]

    try {
      var st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er
      rmdirSync(p, options, er)
    }
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })
  options.rmdirSync(p, options)
}


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __webpack_require__(66)
var minimatch = __webpack_require__(271)
var Minimatch = minimatch.Minimatch
var inherits = __webpack_require__(275)
var EE = __webpack_require__(198).EventEmitter
var path = __webpack_require__(82)
var assert = __webpack_require__(108)
var isAbsolute = __webpack_require__(277)
var globSync = __webpack_require__(340)
var common = __webpack_require__(341)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __webpack_require__(280)
var util = __webpack_require__(74)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __webpack_require__(282)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set
  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  var n = this.minimatch.set.length
  this._processing = 0
  this.matches = new Array(n)

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }

  function done () {
    --self._processing
    if (self._processing <= 0)
      self._finish()
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    fs.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (this.matches[index][e])
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = this._makeAbs(e)

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  if (this.mark)
    e = this._mark(e)

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er)
      return cb()

    var isSym = lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      this.cache[this._makeAbs(f)] = 'FILE'
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && !stat.isDirectory())
    return cb(null, false, stat)

  var c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c !== 'DIR')
    return cb()

  return cb(null, c, stat)
}


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __webpack_require__(66)
var minimatch = __webpack_require__(271)
var Minimatch = minimatch.Minimatch
var Glob = __webpack_require__(339).Glob
var util = __webpack_require__(74)
var path = __webpack_require__(82)
var assert = __webpack_require__(108)
var isAbsolute = __webpack_require__(277)
var common = __webpack_require__(341)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = fs.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this.matches[index][e] = true
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  var abs = this._makeAbs(e)
  if (this.mark)
    e = this._mark(e)

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[this._makeAbs(e)]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true
  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    // lstat failed, doesn't exist
    return null
  }

  var isSym = lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      this.cache[this._makeAbs(f)] = 'FILE'
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this.matches[index][prefix] = true
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      return false
    }

    if (lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c !== 'DIR')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __webpack_require__(82)
var minimatch = __webpack_require__(271)
var isAbsolute = __webpack_require__(277)
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = options.cwd
    self.changedCwd = path.resolve(options.cwd) !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        return !(/\/$/.test(e))
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }
  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(82);
var fs = __webpack_require__(66);
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                if (path.dirname(p) === p) return cb(er);
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

var cc   = __webpack_require__(344)
var join = __webpack_require__(82).join
var deepExtend = __webpack_require__(347)
var etc = '/etc'
var win = process.platform === "win32"
var home = win
           ? process.env.USERPROFILE
           : process.env.HOME

module.exports = function (name, defaults, argv, parse) {
  if('string' !== typeof name)
    throw new Error('rc(name): name *must* be string')
  if(!argv)
    argv = __webpack_require__(348)(process.argv.slice(2))
  defaults = (
      'string' === typeof defaults
    ? cc.json(defaults) : defaults
    ) || {}

  parse = parse || cc.parse

  var env = cc.env(name + '_')

  var configs = [defaults]
  var configFiles = []
  function addConfigFile (file) {
    if (configFiles.indexOf(file) >= 0) return
    var fileConfig = cc.file(file)
    if (fileConfig) {
      configs.push(parse(fileConfig))
      configFiles.push(file)
    }
  }

  // which files do we look at?
  if (!win)
   [join(etc, name, 'config'),
    join(etc, name + 'rc')].forEach(addConfigFile)
  if (home)
   [join(home, '.config', name, 'config'),
    join(home, '.config', name),
    join(home, '.' + name, 'config'),
    join(home, '.' + name + 'rc')].forEach(addConfigFile)
  addConfigFile(cc.find('.'+name+'rc'))
  if (env.config) addConfigFile(env.config)
  if (argv.config) addConfigFile(argv.config)

  return deepExtend.apply(null, configs.concat([
    env,
    argv,
    configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : undefined,
  ]))
}


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fs   = __webpack_require__(66)
var ini  = __webpack_require__(345)
var path = __webpack_require__(82)
var stripJsonComments = __webpack_require__(346)

var parse = exports.parse = function (content) {

  //if it ends in .json or starts with { then it must be json.
  //must be done this way, because ini accepts everything.
  //can't just try and parse it and let it throw if it's not ini.
  //everything is ini. even json with a syntax error.

  if(/^\s*{/.test(content))
    return JSON.parse(stripJsonComments(content))
  return ini.parse(content)

}

var file = exports.file = function () {
  var args = [].slice.call(arguments).filter(function (arg) { return arg != null })

  //path.join breaks if it's a not a string, so just skip this.
  for(var i in args)
    if('string' !== typeof args[i])
      return

  var file = path.join.apply(null, args)
  var content
  try {
    return fs.readFileSync(file,'utf-8')
  } catch (err) {
    return
  }
}

var json = exports.json = function () {
  var content = file.apply(null, arguments)
  return content ? parse(content) : null
}

var env = exports.env = function (prefix, env) {
  env = env || process.env
  var obj = {}
  var l = prefix.length
  for(var k in env) {
    if(k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {

      var keypath = k.substring(l).split('__')

      // Trim empty strings from keypath array
      var _emptyStringIndex
      while ((_emptyStringIndex=keypath.indexOf('')) > -1) {
        keypath.splice(_emptyStringIndex, 1)
      }

      var cursor = obj
      keypath.forEach(function _buildSubObj(_subkey,i){

        // (check for _subkey first so we ignore empty strings)
        // (check for cursor to avoid assignment to primitive objects)
        if (!_subkey || typeof cursor !== 'object')
          return

        // If this is the last key, just stuff the value in there
        // Assigns actual value from env variable to final key
        // (unless it's just an empty string- in that case use the last valid key)
        if (i === keypath.length-1)
          cursor[_subkey] = env[k]


        // Build sub-object if nothing already exists at the keypath
        if (cursor[_subkey] === undefined)
          cursor[_subkey] = {}

        // Increment cursor used to track the object at the current depth
        cursor = cursor[_subkey]

      })

    }

  }

  return obj
}

var find = exports.find = function () {
  var rel = path.join.apply(null, [].slice.call(arguments))

  function find(start, rel) {
    var file = path.join(start, rel)
    try {
      fs.statSync(file)
      return file
    } catch (err) {
      if(path.dirname(start) !== start) // root
        return find(path.dirname(start), rel)
    }
  }
  return find(process.cwd(), rel)
}




/***/ }),
/* 345 */
/***/ (function(module, exports) {

exports.parse = exports.decode = decode

exports.stringify = exports.encode = encode

exports.safe = safe
exports.unsafe = unsafe

var eol = typeof process !== 'undefined' &&
  process.platform === 'win32' ? '\r\n' : '\n'

function encode (obj, opt) {
  var children = []
  var out = ''

  if (typeof opt === 'string') {
    opt = {
      section: opt,
      whitespace: false
    }
  } else {
    opt = opt || {}
    opt.whitespace = opt.whitespace === true
  }

  var separator = opt.whitespace ? ' = ' : '='

  Object.keys(obj).forEach(function (k, _, __) {
    var val = obj[k]
    if (val && Array.isArray(val)) {
      val.forEach(function (item) {
        out += safe(k + '[]') + separator + safe(item) + '\n'
      })
    } else if (val && typeof val === 'object') {
      children.push(k)
    } else {
      out += safe(k) + separator + safe(val) + eol
    }
  })

  if (opt.section && out.length) {
    out = '[' + safe(opt.section) + ']' + eol + out
  }

  children.forEach(function (k, _, __) {
    var nk = dotSplit(k).join('\\.')
    var section = (opt.section ? opt.section + '.' : '') + nk
    var child = encode(obj[k], {
      section: section,
      whitespace: opt.whitespace
    })
    if (out.length && child.length) {
      out += eol
    }
    out += child
  })

  return out
}

function dotSplit (str) {
  return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002')
    .replace(/\\\./g, '\u0001')
    .split(/\./).map(function (part) {
      return part.replace(/\1/g, '\\.')
      .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
    })
}

function decode (str) {
  var out = {}
  var p = out
  var section = null
  //          section     |key      = value
  var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i
  var lines = str.split(/[\r\n]+/g)

  lines.forEach(function (line, _, __) {
    if (!line || line.match(/^\s*[;#]/)) return
    var match = line.match(re)
    if (!match) return
    if (match[1] !== undefined) {
      section = unsafe(match[1])
      p = out[section] = out[section] || {}
      return
    }
    var key = unsafe(match[2])
    var value = match[3] ? unsafe(match[4]) : true
    switch (value) {
      case 'true':
      case 'false':
      case 'null': value = JSON.parse(value)
    }

    // Convert keys with '[]' suffix to an array
    if (key.length > 2 && key.slice(-2) === '[]') {
      key = key.substring(0, key.length - 2)
      if (!p[key]) {
        p[key] = []
      } else if (!Array.isArray(p[key])) {
        p[key] = [p[key]]
      }
    }

    // safeguard against resetting a previously defined
    // array by accidentally forgetting the brackets
    if (Array.isArray(p[key])) {
      p[key].push(value)
    } else {
      p[key] = value
    }
  })

  // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
  // use a filter to return the keys that have to be deleted.
  Object.keys(out).filter(function (k, _, __) {
    if (!out[k] ||
      typeof out[k] !== 'object' ||
      Array.isArray(out[k])) {
      return false
    }
    // see if the parent section is also an object.
    // if so, add it to that, and mark this one for deletion
    var parts = dotSplit(k)
    var p = out
    var l = parts.pop()
    var nl = l.replace(/\\\./g, '.')
    parts.forEach(function (part, _, __) {
      if (!p[part] || typeof p[part] !== 'object') p[part] = {}
      p = p[part]
    })
    if (p === out && nl === l) {
      return false
    }
    p[nl] = out[k]
    return true
  }).forEach(function (del, _, __) {
    delete out[del]
  })

  return out
}

function isQuoted (val) {
  return (val.charAt(0) === '"' && val.slice(-1) === '"') ||
    (val.charAt(0) === "'" && val.slice(-1) === "'")
}

function safe (val) {
  return (typeof val !== 'string' ||
    val.match(/[=\r\n]/) ||
    val.match(/^\[/) ||
    (val.length > 1 &&
     isQuoted(val)) ||
    val !== val.trim())
      ? JSON.stringify(val)
      : val.replace(/;/g, '\\;').replace(/#/g, '\\#')
}

function unsafe (val, doUnesc) {
  val = (val || '').trim()
  if (isQuoted(val)) {
    // remove the single quotes before calling JSON.parse
    if (val.charAt(0) === "'") {
      val = val.substr(1, val.length - 2)
    }
    try { val = JSON.parse(val) } catch (_) {}
  } else {
    // walk the val to find the first not-escaped ; character
    var esc = false
    var unesc = ''
    for (var i = 0, l = val.length; i < l; i++) {
      var c = val.charAt(i)
      if (esc) {
        if ('\\;#'.indexOf(c) !== -1) {
          unesc += c
        } else {
          unesc += '\\' + c
        }
        esc = false
      } else if (';#'.indexOf(c) !== -1) {
        break
      } else if (c === '\\') {
        esc = true
      } else {
        unesc += c
      }
    }
    if (esc) {
      unesc += '\\'
    }
    return unesc.trim()
  }
  return val
}


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var singleComment = 1;
var multiComment = 2;

function stripWithoutWhitespace() {
	return '';
}

function stripWithWhitespace(str, start, end) {
	return str.slice(start, end).replace(/\S/g, ' ');
}

module.exports = function (str, opts) {
	opts = opts || {};

	var currentChar;
	var nextChar;
	var insideString = false;
	var insideComment = false;
	var offset = 0;
	var ret = '';
	var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;

	for (var i = 0; i < str.length; i++) {
		currentChar = str[i];
		nextChar = str[i + 1];

		if (!insideComment && currentChar === '"') {
			var escaped = str[i - 1] === '\\' && str[i - 2] !== '\\';
			if (!escaped) {
				insideString = !insideString;
			}
		}

		if (insideString) {
			continue;
		}

		if (!insideComment && currentChar + nextChar === '//') {
			ret += str.slice(offset, i);
			offset = i;
			insideComment = singleComment;
			i++;
		} else if (insideComment === singleComment && currentChar + nextChar === '\r\n') {
			i++;
			insideComment = false;
			ret += strip(str, offset, i);
			offset = i;
			continue;
		} else if (insideComment === singleComment && currentChar === '\n') {
			insideComment = false;
			ret += strip(str, offset, i);
			offset = i;
		} else if (!insideComment && currentChar + nextChar === '/*') {
			ret += str.slice(offset, i);
			offset = i;
			insideComment = multiComment;
			i++;
			continue;
		} else if (insideComment === multiComment && currentChar + nextChar === '*/') {
			i++;
			insideComment = false;
			ret += strip(str, offset, i + 1);
			offset = i + 1;
			continue;
		}
	}

	return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
};


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



function isSpecificValue(val) {
	return (
		val instanceof Buffer
		|| val instanceof Date
		|| val instanceof RegExp
	) ? true : false;
}

function cloneSpecificValue(val) {
	if (val instanceof Buffer) {
		var x = Buffer.alloc
			? Buffer.alloc(val.length)
			: new Buffer(val.length);
		val.copy(x);
		return x;
	} else if (val instanceof Date) {
		return new Date(val.getTime());
	} else if (val instanceof RegExp) {
		return new RegExp(val);
	} else {
		throw new Error('Unexpected situation');
	}
}

/**
 * Recursive cloning array.
 */
function deepCloneArray(arr) {
	var clone = [];
	arr.forEach(function (item, index) {
		if (typeof item === 'object' && item !== null) {
			if (Array.isArray(item)) {
				clone[index] = deepCloneArray(item);
			} else if (isSpecificValue(item)) {
				clone[index] = cloneSpecificValue(item);
			} else {
				clone[index] = deepExtend({}, item);
			}
		} else {
			clone[index] = item;
		}
	});
	return clone;
}

function safeGetProperty(object, property) {
	return property === '__proto__' ? undefined : object[property];
}

/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
		return false;
	}

	if (arguments.length < 2) {
		return arguments[0];
	}

	var target = arguments[0];

	// convert arguments to array and cut off target object
	var args = Array.prototype.slice.call(arguments, 1);

	var val, src, clone;

	args.forEach(function (obj) {
		// skip argument if isn't an object, is null, or is an array
		if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
			return;
		}

		Object.keys(obj).forEach(function (key) {
			src = safeGetProperty(target, key); // source value
			val = safeGetProperty(obj, key); // new value

			// recursion prevention
			if (val === target) {
				return;

			/**
			 * if new value isn't object then just overwrite by new value
			 * instead of extending.
			 */
			} else if (typeof val !== 'object' || val === null) {
				target[key] = val;
				return;

			// just clone arrays (and recursive clone objects inside)
			} else if (Array.isArray(val)) {
				target[key] = deepCloneArray(val);
				return;

			// custom cloning and overwrite for specific objects
			} else if (isSpecificValue(val)) {
				target[key] = cloneSpecificValue(val);
				return;

			// overwrite by new value if source isn't object or array
			} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
				target[key] = deepExtend({}, val);
				return;

			// source value and new value is objects both, extending...
			} else {
				target[key] = deepExtend(src, val);
				return;
			}
		});
	});

	return target;
};


/***/ }),
/* 348 */
/***/ (function(module, exports) {

module.exports = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        for (var i = 0; i < keys.length-1; i++) {
            var key = keys[i];
            if (key === '__proto__') return;
            if (o[key] === undefined) o[key] = {};
            if (o[key] === Object.prototype || o[key] === Number.prototype
                || o[key] === String.prototype) o[key] = {};
            if (o[key] === Array.prototype) o[key] = [];
            o = o[key];
        }

        var key = keys[keys.length - 1];
        if (key === '__proto__') return;
        if (o === Object.prototype || o === Number.prototype
            || o === String.prototype) o = {};
        if (o === Array.prototype) o = [];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg)
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /^(true|false)$/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}



/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const follow_redirects_1 = __webpack_require__(350);
const uuid_1 = __webpack_require__(283);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const mkdirp_1 = tslib_1.__importDefault(__webpack_require__(260));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const tar_1 = tslib_1.__importDefault(__webpack_require__(355));
const unzipper_1 = tslib_1.__importDefault(__webpack_require__(385));
const fetch_1 = __webpack_require__(478);
const content_disposition_1 = tslib_1.__importDefault(__webpack_require__(489));
const logger = __webpack_require__(64)('model-download');
/**
 * Download file from url, with optional untar/unzip support.
 *
 * @param {string} url
 * @param {DownloadOptions} options contains dest folder and optional onProgress callback
 */
function download(url, options, token) {
    let { dest, onProgress, extract } = options;
    if (!dest || !path_1.default.isAbsolute(dest)) {
        throw new Error(`Expect absolute file path for dest option.`);
    }
    let stat;
    try {
        stat = fs_1.default.statSync(dest);
    }
    catch (_e) {
        mkdirp_1.default.sync(dest);
    }
    if (stat && !stat.isDirectory()) {
        throw new Error(`${dest} exists, but not directory!`);
    }
    let mod = url.startsWith('https') ? follow_redirects_1.https : follow_redirects_1.http;
    let opts = fetch_1.resolveRequestOptions(url, options);
    let extname = path_1.default.extname(url);
    return new Promise((resolve, reject) => {
        if (token) {
            let disposable = token.onCancellationRequested(() => {
                disposable.dispose();
                req.destroy(new Error('request aborted'));
            });
        }
        const req = mod.request(opts, (res) => {
            var _a;
            if ((res.statusCode >= 200 && res.statusCode < 300) || res.statusCode === 1223) {
                let headers = res.headers || {};
                let dispositionHeader = headers['content-disposition'];
                if (!extname && dispositionHeader) {
                    let disposition = content_disposition_1.default.parse(dispositionHeader);
                    if ((_a = disposition.parameters) === null || _a === void 0 ? void 0 : _a.filename) {
                        extname = path_1.default.extname(disposition.parameters.filename);
                    }
                }
                if (extract === true) {
                    if (extname === '.zip' || headers['content-type'] == 'application/zip') {
                        extract = 'unzip';
                    }
                    else if (extname == '.tgz') {
                        extract = 'untar';
                    }
                    else {
                        reject(new Error(`Unable to extract for ${url}`));
                        return;
                    }
                }
                let total = Number(headers['content-length']);
                let cur = 0;
                if (!isNaN(total)) {
                    res.on('data', chunk => {
                        cur += chunk.length;
                        let percent = (cur / total * 100).toFixed(1);
                        if (onProgress) {
                            onProgress(percent);
                        }
                        else {
                            logger.info(`Download ${url} progress ${percent}%`);
                        }
                    });
                }
                res.on('error', err => {
                    reject(new Error(`Unable to connect ${url}: ${err.message}`));
                });
                res.on('end', () => {
                    logger.info('Download completed:', url);
                });
                let stream;
                if (extract === 'untar') {
                    stream = res.pipe(tar_1.default.x({ strip: 1, C: dest }));
                }
                else if (extract === 'unzip') {
                    stream = res.pipe(unzipper_1.default.Extract({ path: dest }));
                }
                else {
                    dest = path_1.default.join(dest, `${uuid_1.v1()}${extname}`);
                    stream = res.pipe(fs_1.default.createWriteStream(dest));
                }
                stream.on('finish', () => {
                    logger.info(`Downloaded ${url} => ${dest}`);
                    setTimeout(() => {
                        resolve(dest);
                    }, 100);
                });
                stream.on('error', reject);
            }
            else {
                reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
            }
        });
        req.on('error', reject);
        req.on('timeout', () => {
            req.destroy(new Error(`request timeout after ${options.timeout}ms`));
        });
        if (options.timeout) {
            req.setTimeout(options.timeout);
        }
        req.end();
    });
}
exports.default = download;
//# sourceMappingURL=download.js.map

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var url = __webpack_require__(351);
var URL = url.URL;
var http = __webpack_require__(352);
var https = __webpack_require__(353);
var Writable = __webpack_require__(106).Writable;
var assert = __webpack_require__(108);
var debug = __webpack_require__(354);

// Create handlers that pass events from native requests
var eventHandlers = Object.create(null);
["abort", "aborted", "connect", "error", "socket", "timeout"].forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  ""
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded"
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    self._processResponse(response);
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!(typeof data === "string" || typeof data === "object" && ("length" in data))) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (typeof data === "function") {
    callback = data;
    data = encoding = null;
  }
  else if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  if (callback) {
    this.once("timeout", callback);
  }

  if (this.socket) {
    startTimer(this, msecs);
  }
  else {
    var self = this;
    this._currentRequest.once("socket", function () {
      startTimer(self, msecs);
    });
  }

  this.once("response", clearTimer);
  this.once("error", clearTimer);

  return this;
};

function startTimer(request, msecs) {
  clearTimeout(request._timeout);
  request._timeout = setTimeout(function () {
    request.emit("timeout");
  }, msecs);
}

function clearTimer() {
  clearTimeout(this._timeout);
}

// Proxy all other public ClientRequest methods
[
  "abort", "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    this.emit("error", new TypeError("Unsupported protocol " + protocol));
    return;
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.substr(0, protocol.length - 1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  this._currentUrl = url.format(this._options);

  // Set up event handlers
  request._redirectable = this;
  for (var event in eventHandlers) {
    /* istanbul ignore else */
    if (event) {
      request.on(event, eventHandlers[event]);
    }
  }

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end.
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      /* istanbul ignore else */
      if (request === self._currentRequest) {
        // Report any write errors
        /* istanbul ignore if */
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          /* istanbul ignore else */
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.
  var location = response.headers.location;
  if (location && this._options.followRedirects !== false &&
      statusCode >= 300 && statusCode < 400) {
    // Abort the current request
    this._currentRequest.removeAllListeners();
    this._currentRequest.on("error", noop);
    this._currentRequest.abort();
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();

    // RFC7231§6.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
      this.emit("error", new TooManyRedirectsError());
      return;
    }

    // RFC7231§6.4: Automatic redirection needs to done with
    // care for methods not known to be safe, […]
    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
        // RFC7231§6.4.4: The 303 (See Other) status code indicates that
        // the server is redirecting the user agent to a different resource […]
        // A user agent can perform a retrieval request targeting that URI
        // (a GET or HEAD request if using HTTP) […]
        (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      // Drop a possible entity and headers related to it
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }

    // Drop the Host header, as the redirect might lead to a different host
    var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) ||
      url.parse(this._currentUrl).hostname;

    // Create the redirected request
    var redirectUrl = url.resolve(this._currentUrl, location);
    debug("redirecting to", redirectUrl);
    this._isRedirect = true;
    var redirectUrlParts = url.parse(redirectUrl);
    Object.assign(this._options, redirectUrlParts);

    // Drop the Authorization header if redirecting to another host
    if (redirectUrlParts.hostname !== previousHostName) {
      removeMatchingHeaders(/^authorization$/i, this._options.headers);
    }

    // Evaluate the beforeRedirect callback
    if (typeof this._options.beforeRedirect === "function") {
      var responseDetails = { headers: response.headers };
      try {
        this._options.beforeRedirect.call(null, this._options, responseDetails);
      }
      catch (err) {
        this.emit("error", err);
        return;
      }
      this._sanitizeOptions(this._options);
    }

    // Perform the redirected request
    try {
      this._performRequest();
    }
    catch (cause) {
      var error = new RedirectionError("Redirected request failed: " + cause.message);
      error.cause = cause;
      this.emit("error", error);
    }
  }
  else {
    // The response is not a redirect; return it as-is
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
  }
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    wrappedProtocol.request = function (input, options, callback) {
      // Parse parameters
      if (typeof input === "string") {
        var urlStr = input;
        try {
          input = urlToOptions(new URL(urlStr));
        }
        catch (err) {
          /* istanbul ignore next */
          input = url.parse(urlStr);
        }
      }
      else if (URL && (input instanceof URL)) {
        input = urlToOptions(input);
      }
      else {
        callback = options;
        options = input;
        input = { protocol: protocol };
      }
      if (typeof options === "function") {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    };

    // Executes a GET request, following redirects
    wrappedProtocol.get = function (input, options, callback) {
      var request = wrappedProtocol.request(input, options, callback);
      request.end();
      return request;
    };
  });
  return exports;
}

/* istanbul ignore next */
function noop() { /* empty */ }

// from https://github.com/nodejs/node/blob/master/lib/internal/url.js
function urlToOptions(urlObject) {
  var options = {
    protocol: urlObject.protocol,
    hostname: urlObject.hostname.startsWith("[") ?
      /* istanbul ignore next */
      urlObject.hostname.slice(1, -1) :
      urlObject.hostname,
    hash: urlObject.hash,
    search: urlObject.search,
    pathname: urlObject.pathname,
    path: urlObject.pathname + urlObject.search,
    href: urlObject.href,
  };
  if (urlObject.port !== "") {
    options.port = Number(urlObject.port);
  }
  return options;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return lastValue;
}

function createErrorType(code, defaultMessage) {
  function CustomError(message) {
    Error.captureStackTrace(this, this.constructor);
    this.message = message || defaultMessage;
  }
  CustomError.prototype = new Error();
  CustomError.prototype.constructor = CustomError;
  CustomError.prototype.name = "Error [" + code + "]";
  CustomError.prototype.code = code;
  return CustomError;
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),
/* 351 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 352 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 353 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

var debug;
try {
  /* eslint global-require: off */
  debug = __webpack_require__(68)("follow-redirects");
}
catch (error) {
  debug = function () { /* */ };
}
module.exports = debug;


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// high-level commands
exports.c = exports.create = __webpack_require__(356)
exports.r = exports.replace = __webpack_require__(377)
exports.t = exports.list = __webpack_require__(375)
exports.u = exports.update = __webpack_require__(378)
exports.x = exports.extract = __webpack_require__(379)

// classes
exports.Pack = __webpack_require__(358)
exports.Unpack = __webpack_require__(380)
exports.Parse = __webpack_require__(376)
exports.ReadEntry = __webpack_require__(365)
exports.WriteEntry = __webpack_require__(367)
exports.Header = __webpack_require__(369)
exports.Pax = __webpack_require__(368)
exports.types = __webpack_require__(366)


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// tar -c
const hlo = __webpack_require__(357)

const Pack = __webpack_require__(358)
const fs = __webpack_require__(66)
const fsm = __webpack_require__(374)
const t = __webpack_require__(375)
const path = __webpack_require__(82)

const c = module.exports = (opt_, files, cb) => {
  if (typeof files === 'function')
    cb = files

  if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  return opt.file && opt.sync ? createFileSync(opt, files)
    : opt.file ? createFile(opt, files, cb)
    : opt.sync ? createSync(opt, files)
    : create(opt, files)
}

const createFileSync = (opt, files) => {
  const p = new Pack.Sync(opt)
  const stream = new fsm.WriteStreamSync(opt.file, {
    mode: opt.mode || 0o666
  })
  p.pipe(stream)
  addFilesSync(p, files)
}

const createFile = (opt, files, cb) => {
  const p = new Pack(opt)
  const stream = new fsm.WriteStream(opt.file, {
    mode: opt.mode || 0o666
  })
  p.pipe(stream)

  const promise = new Promise((res, rej) => {
    stream.on('error', rej)
    stream.on('close', res)
    p.on('error', rej)
  })

  addFilesAsync(p, files)

  return cb ? promise.then(cb, cb) : promise
}

const addFilesSync = (p, files) => {
  files.forEach(file => {
    if (file.charAt(0) === '@')
      t({
        file: path.resolve(p.cwd, file.substr(1)),
        sync: true,
        noResume: true,
        onentry: entry => p.add(entry)
      })
    else
      p.add(file)
  })
  p.end()
}

const addFilesAsync = (p, files) => {
  while (files.length) {
    const file = files.shift()
    if (file.charAt(0) === '@')
      return t({
        file: path.resolve(p.cwd, file.substr(1)),
        noResume: true,
        onentry: entry => p.add(entry)
      }).then(_ => addFilesAsync(p, files))
    else
      p.add(file)
  }
  p.end()
}

const createSync = (opt, files) => {
  const p = new Pack.Sync(opt)
  addFilesSync(p, files)
  return p
}

const create = (opt, files) => {
  const p = new Pack(opt)
  addFilesAsync(p, files)
  return p
}


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// turn tar(1) style args like `C` into the more verbose things like `cwd`

const argmap = new Map([
  ['C', 'cwd'],
  ['f', 'file'],
  ['z', 'gzip'],
  ['P', 'preservePaths'],
  ['U', 'unlink'],
  ['strip-components', 'strip'],
  ['stripComponents', 'strip'],
  ['keep-newer', 'newer'],
  ['keepNewer', 'newer'],
  ['keep-newer-files', 'newer'],
  ['keepNewerFiles', 'newer'],
  ['k', 'keep'],
  ['keep-existing', 'keep'],
  ['keepExisting', 'keep'],
  ['m', 'noMtime'],
  ['no-mtime', 'noMtime'],
  ['p', 'preserveOwner'],
  ['L', 'follow'],
  ['h', 'follow']
])

const parse = module.exports = opt => opt ? Object.keys(opt).map(k => [
  argmap.has(k) ? argmap.get(k) : k, opt[k]
]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// A readable tar stream creator
// Technically, this is a transform stream that you write paths into,
// and tar format comes out of.
// The `add()` method is like `write()` but returns this,
// and end() return `this` as well, so you can
// do `new Pack(opt).add('files').add('dir').end().pipe(output)
// You could also do something like:
// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))

class PackJob {
  constructor (path, absolute) {
    this.path = path || './'
    this.absolute = absolute
    this.entry = null
    this.stat = null
    this.readdir = null
    this.pending = false
    this.ignore = false
    this.piped = false
  }
}

const MiniPass = __webpack_require__(359)
const zlib = __webpack_require__(363)
const ReadEntry = __webpack_require__(365)
const WriteEntry = __webpack_require__(367)
const WriteEntrySync = WriteEntry.Sync
const WriteEntryTar = WriteEntry.Tar
const Yallist = __webpack_require__(360)
const EOF = Buffer.alloc(1024)
const ONSTAT = Symbol('onStat')
const ENDED = Symbol('ended')
const QUEUE = Symbol('queue')
const CURRENT = Symbol('current')
const PROCESS = Symbol('process')
const PROCESSING = Symbol('processing')
const PROCESSJOB = Symbol('processJob')
const JOBS = Symbol('jobs')
const JOBDONE = Symbol('jobDone')
const ADDFSENTRY = Symbol('addFSEntry')
const ADDTARENTRY = Symbol('addTarEntry')
const STAT = Symbol('stat')
const READDIR = Symbol('readdir')
const ONREADDIR = Symbol('onreaddir')
const PIPE = Symbol('pipe')
const ENTRY = Symbol('entry')
const ENTRYOPT = Symbol('entryOpt')
const WRITEENTRYCLASS = Symbol('writeEntryClass')
const WRITE = Symbol('write')
const ONDRAIN = Symbol('ondrain')

const fs = __webpack_require__(66)
const path = __webpack_require__(82)
const warner = __webpack_require__(371)

const Pack = warner(class Pack extends MiniPass {
  constructor (opt) {
    super(opt)
    opt = opt || Object.create(null)
    this.opt = opt
    this.file = opt.file || ''
    this.cwd = opt.cwd || process.cwd()
    this.maxReadSize = opt.maxReadSize
    this.preservePaths = !!opt.preservePaths
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.prefix = (opt.prefix || '').replace(/(\\|\/)+$/, '')
    this.linkCache = opt.linkCache || new Map()
    this.statCache = opt.statCache || new Map()
    this.readdirCache = opt.readdirCache || new Map()

    this[WRITEENTRYCLASS] = WriteEntry
    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    this.portable = !!opt.portable
    this.zip = null
    if (opt.gzip) {
      if (typeof opt.gzip !== 'object')
        opt.gzip = {}
      if (this.portable)
        opt.gzip.portable = true
      this.zip = new zlib.Gzip(opt.gzip)
      this.zip.on('data', chunk => super.write(chunk))
      this.zip.on('end', _ => super.end())
      this.zip.on('drain', _ => this[ONDRAIN]())
      this.on('resume', _ => this.zip.resume())
    } else
      this.on('drain', this[ONDRAIN])

    this.noDirRecurse = !!opt.noDirRecurse
    this.follow = !!opt.follow
    this.noMtime = !!opt.noMtime
    this.mtime = opt.mtime || null

    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true

    this[QUEUE] = new Yallist
    this[JOBS] = 0
    this.jobs = +opt.jobs || 4
    this[PROCESSING] = false
    this[ENDED] = false
  }

  [WRITE] (chunk) {
    return super.write(chunk)
  }

  add (path) {
    this.write(path)
    return this
  }

  end (path) {
    if (path)
      this.write(path)
    this[ENDED] = true
    this[PROCESS]()
    return this
  }

  write (path) {
    if (this[ENDED])
      throw new Error('write after end')

    if (path instanceof ReadEntry)
      this[ADDTARENTRY](path)
    else
      this[ADDFSENTRY](path)
    return this.flowing
  }

  [ADDTARENTRY] (p) {
    const absolute = path.resolve(this.cwd, p.path)
    if (this.prefix)
      p.path = this.prefix + '/' + p.path.replace(/^\.(\/+|$)/, '')

    // in this case, we don't have to wait for the stat
    if (!this.filter(p.path, p))
      p.resume()
    else {
      const job = new PackJob(p.path, absolute, false)
      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))
      job.entry.on('end', _ => this[JOBDONE](job))
      this[JOBS] += 1
      this[QUEUE].push(job)
    }

    this[PROCESS]()
  }

  [ADDFSENTRY] (p) {
    const absolute = path.resolve(this.cwd, p)
    if (this.prefix)
      p = this.prefix + '/' + p.replace(/^\.(\/+|$)/, '')

    this[QUEUE].push(new PackJob(p, absolute))
    this[PROCESS]()
  }

  [STAT] (job) {
    job.pending = true
    this[JOBS] += 1
    const stat = this.follow ? 'stat' : 'lstat'
    fs[stat](job.absolute, (er, stat) => {
      job.pending = false
      this[JOBS] -= 1
      if (er)
        this.emit('error', er)
      else
        this[ONSTAT](job, stat)
    })
  }

  [ONSTAT] (job, stat) {
    this.statCache.set(job.absolute, stat)
    job.stat = stat

    // now we have the stat, we can filter it.
    if (!this.filter(job.path, stat))
      job.ignore = true

    this[PROCESS]()
  }

  [READDIR] (job) {
    job.pending = true
    this[JOBS] += 1
    fs.readdir(job.absolute, (er, entries) => {
      job.pending = false
      this[JOBS] -= 1
      if (er)
        return this.emit('error', er)
      this[ONREADDIR](job, entries)
    })
  }

  [ONREADDIR] (job, entries) {
    this.readdirCache.set(job.absolute, entries)
    job.readdir = entries
    this[PROCESS]()
  }

  [PROCESS] () {
    if (this[PROCESSING])
      return

    this[PROCESSING] = true
    for (let w = this[QUEUE].head;
         w !== null && this[JOBS] < this.jobs;
         w = w.next) {
      this[PROCESSJOB](w.value)
      if (w.value.ignore) {
        const p = w.next
        this[QUEUE].removeNode(w)
        w.next = p
      }
    }

    this[PROCESSING] = false

    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
      if (this.zip)
        this.zip.end(EOF)
      else {
        super.write(EOF)
        super.end()
      }
    }
  }

  get [CURRENT] () {
    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value
  }

  [JOBDONE] (job) {
    this[QUEUE].shift()
    this[JOBS] -= 1
    this[PROCESS]()
  }

  [PROCESSJOB] (job) {
    if (job.pending)
      return

    if (job.entry) {
      if (job === this[CURRENT] && !job.piped)
        this[PIPE](job)
      return
    }

    if (!job.stat) {
      if (this.statCache.has(job.absolute))
        this[ONSTAT](job, this.statCache.get(job.absolute))
      else
        this[STAT](job)
    }
    if (!job.stat)
      return

    // filtered out!
    if (job.ignore)
      return

    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
      if (this.readdirCache.has(job.absolute))
        this[ONREADDIR](job, this.readdirCache.get(job.absolute))
      else
        this[READDIR](job)
      if (!job.readdir)
        return
    }

    // we know it doesn't have an entry, because that got checked above
    job.entry = this[ENTRY](job)
    if (!job.entry) {
      job.ignore = true
      return
    }

    if (job === this[CURRENT] && !job.piped)
      this[PIPE](job)
  }

  [ENTRYOPT] (job) {
    return {
      onwarn: (code, msg, data) => this.warn(code, msg, data),
      noPax: this.noPax,
      cwd: this.cwd,
      absolute: job.absolute,
      preservePaths: this.preservePaths,
      maxReadSize: this.maxReadSize,
      strict: this.strict,
      portable: this.portable,
      linkCache: this.linkCache,
      statCache: this.statCache,
      noMtime: this.noMtime,
      mtime: this.mtime
    }
  }

  [ENTRY] (job) {
    this[JOBS] += 1
    try {
      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))
        .on('end', () => this[JOBDONE](job))
        .on('error', er => this.emit('error', er))
    } catch (er) {
      this.emit('error', er)
    }
  }

  [ONDRAIN] () {
    if (this[CURRENT] && this[CURRENT].entry)
      this[CURRENT].entry.resume()
  }

  // like .pipe() but using super, because our write() is special
  [PIPE] (job) {
    job.piped = true

    if (job.readdir)
      job.readdir.forEach(entry => {
        const p = this.prefix ?
          job.path.slice(this.prefix.length + 1) || './'
          : job.path

        const base = p === './' ? '' : p.replace(/\/*$/, '/')
        this[ADDFSENTRY](base + entry)
      })

    const source = job.entry
    const zip = this.zip

    if (zip)
      source.on('data', chunk => {
        if (!zip.write(chunk))
          source.pause()
      })
    else
      source.on('data', chunk => {
        if (!super.write(chunk))
          source.pause()
      })
  }

  pause () {
    if (this.zip)
      this.zip.pause()
    return super.pause()
  }
})

class PackSync extends Pack {
  constructor (opt) {
    super(opt)
    this[WRITEENTRYCLASS] = WriteEntrySync
  }

  // pause/resume are no-ops in sync streams.
  pause () {}
  resume () {}

  [STAT] (job) {
    const stat = this.follow ? 'statSync' : 'lstatSync'
    this[ONSTAT](job, fs[stat](job.absolute))
  }

  [READDIR] (job, stat) {
    this[ONREADDIR](job, fs.readdirSync(job.absolute))
  }

  // gotta get it all in this tick
  [PIPE] (job) {
    const source = job.entry
    const zip = this.zip

    if (job.readdir)
      job.readdir.forEach(entry => {
        const p = this.prefix ?
          job.path.slice(this.prefix.length + 1) || './'
          : job.path

        const base = p === './' ? '' : p.replace(/\/*$/, '/')
        this[ADDFSENTRY](base + entry)
      })

    if (zip)
      source.on('data', chunk => {
        zip.write(chunk)
      })
    else
      source.on('data', chunk => {
        super[WRITE](chunk)
      })
  }
}

Pack.Sync = PackSync

module.exports = Pack


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const EE = __webpack_require__(198)
const Stream = __webpack_require__(106)
const Yallist = __webpack_require__(360)
const SD = __webpack_require__(362).StringDecoder

const EOF = Symbol('EOF')
const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
const EMITTED_END = Symbol('emittedEnd')
const EMITTING_END = Symbol('emittingEnd')
const CLOSED = Symbol('closed')
const READ = Symbol('read')
const FLUSH = Symbol('flush')
const FLUSHCHUNK = Symbol('flushChunk')
const ENCODING = Symbol('encoding')
const DECODER = Symbol('decoder')
const FLOWING = Symbol('flowing')
const PAUSED = Symbol('paused')
const RESUME = Symbol('resume')
const BUFFERLENGTH = Symbol('bufferLength')
const BUFFERPUSH = Symbol('bufferPush')
const BUFFERSHIFT = Symbol('bufferShift')
const OBJECTMODE = Symbol('objectMode')
const DESTROYED = Symbol('destroyed')

// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'
const ASYNCITERATOR = doIter && Symbol.asyncIterator
  || Symbol('asyncIterator not implemented')
const ITERATOR = doIter && Symbol.iterator
  || Symbol('iterator not implemented')

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = ev =>
  ev === 'end' ||
  ev === 'finish' ||
  ev === 'prefinish'

const isArrayBuffer = b => b instanceof ArrayBuffer ||
  typeof b === 'object' &&
  b.constructor &&
  b.constructor.name === 'ArrayBuffer' &&
  b.byteLength >= 0

const isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)

module.exports = class Minipass extends Stream {
  constructor (options) {
    super()
    this[FLOWING] = false
    // whether we're explicitly paused
    this[PAUSED] = false
    this.pipes = new Yallist()
    this.buffer = new Yallist()
    this[OBJECTMODE] = options && options.objectMode || false
    if (this[OBJECTMODE])
      this[ENCODING] = null
    else
      this[ENCODING] = options && options.encoding || null
    if (this[ENCODING] === 'buffer')
      this[ENCODING] = null
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
    this[EOF] = false
    this[EMITTED_END] = false
    this[EMITTING_END] = false
    this[CLOSED] = false
    this.writable = true
    this.readable = true
    this[BUFFERLENGTH] = 0
    this[DESTROYED] = false
  }

  get bufferLength () { return this[BUFFERLENGTH] }

  get encoding () { return this[ENCODING] }
  set encoding (enc) {
    if (this[OBJECTMODE])
      throw new Error('cannot set encoding in objectMode')

    if (this[ENCODING] && enc !== this[ENCODING] &&
        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
      throw new Error('cannot change encoding')

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null
      if (this.buffer.length)
        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))
    }

    this[ENCODING] = enc
  }

  setEncoding (enc) {
    this.encoding = enc
  }

  get objectMode () { return this[OBJECTMODE] }
  set objectMode (ॐ ) { this[OBJECTMODE] = this[OBJECTMODE] || !!ॐ  }

  write (chunk, encoding, cb) {
    if (this[EOF])
      throw new Error('write after end')

    if (this[DESTROYED]) {
      this.emit('error', Object.assign(
        new Error('Cannot call write after a stream was destroyed'),
        { code: 'ERR_STREAM_DESTROYED' }
      ))
      return true
    }

    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (!encoding)
      encoding = 'utf8'

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
      else if (isArrayBuffer(chunk))
        chunk = Buffer.from(chunk)
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true
    }

    // this ensures at this point that the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!this.objectMode && !chunk.length) {
      const ret = this.flowing
      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')
      if (cb)
        cb()
      return ret
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (typeof chunk === 'string' && !this[OBJECTMODE] &&
        // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
      chunk = Buffer.from(chunk, encoding)
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk)

    try {
      return this.flowing
        ? (this.emit('data', chunk), this.flowing)
        : (this[BUFFERPUSH](chunk), false)
    } finally {
      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')
      if (cb)
        cb()
    }
  }

  read (n) {
    if (this[DESTROYED])
      return null

    try {
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
        return null

      if (this[OBJECTMODE])
        n = null

      if (this.buffer.length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this.buffer = new Yallist([
            Array.from(this.buffer).join('')
          ])
        else
          this.buffer = new Yallist([
            Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
          ])
      }

      return this[READ](n || null, this.buffer.head.value)
    } finally {
      this[MAYBE_EMIT_END]()
    }
  }

  [READ] (n, chunk) {
    if (n === chunk.length || n === null)
      this[BUFFERSHIFT]()
    else {
      this.buffer.head.value = chunk.slice(n)
      chunk = chunk.slice(0, n)
      this[BUFFERLENGTH] -= n
    }

    this.emit('data', chunk)

    if (!this.buffer.length && !this[EOF])
      this.emit('drain')

    return chunk
  }

  end (chunk, encoding, cb) {
    if (typeof chunk === 'function')
      cb = chunk, chunk = null
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'
    if (chunk)
      this.write(chunk, encoding)
    if (cb)
      this.once('end', cb)
    this[EOF] = true
    this.writable = false

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED])
      this[MAYBE_EMIT_END]()
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME] () {
    if (this[DESTROYED])
      return

    this[PAUSED] = false
    this[FLOWING] = true
    this.emit('resume')
    if (this.buffer.length)
      this[FLUSH]()
    else if (this[EOF])
      this[MAYBE_EMIT_END]()
    else
      this.emit('drain')
  }

  resume () {
    return this[RESUME]()
  }

  pause () {
    this[FLOWING] = false
    this[PAUSED] = true
  }

  get destroyed () {
    return this[DESTROYED]
  }

  get flowing () {
    return this[FLOWING]
  }

  get paused () {
    return this[PAUSED]
  }

  [BUFFERPUSH] (chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1
    else
      this[BUFFERLENGTH] += chunk.length
    return this.buffer.push(chunk)
  }

  [BUFFERSHIFT] () {
    if (this.buffer.length) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1
      else
        this[BUFFERLENGTH] -= this.buffer.head.value.length
    }
    return this.buffer.shift()
  }

  [FLUSH] () {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))

    if (!this.buffer.length && !this[EOF])
      this.emit('drain')
  }

  [FLUSHCHUNK] (chunk) {
    return chunk ? (this.emit('data', chunk), this.flowing) : false
  }

  pipe (dest, opts) {
    if (this[DESTROYED])
      return

    const ended = this[EMITTED_END]
    opts = opts || {}
    if (dest === process.stdout || dest === process.stderr)
      opts.end = false
    else
      opts.end = opts.end !== false

    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }
    this.pipes.push(p)

    dest.on('drain', p.ondrain)
    this[RESUME]()
    // piping an ended stream ends immediately
    if (ended && p.opts.end)
      p.dest.end()
    return dest
  }

  addListener (ev, fn) {
    return this.on(ev, fn)
  }

  on (ev, fn) {
    try {
      return super.on(ev, fn)
    } finally {
      if (ev === 'data' && !this.pipes.length && !this.flowing)
        this[RESUME]()
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev)
        this.removeAllListeners(ev)
      }
    }
  }

  get emittedEnd () {
    return this[EMITTED_END]
  }

  [MAYBE_EMIT_END] () {
    if (!this[EMITTING_END] &&
        !this[EMITTED_END] &&
        !this[DESTROYED] &&
        this.buffer.length === 0 &&
        this[EOF]) {
      this[EMITTING_END] = true
      this.emit('end')
      this.emit('prefinish')
      this.emit('finish')
      if (this[CLOSED])
        this.emit('close')
      this[EMITTING_END] = false
    }
  }

  emit (ev, data) {
    // error and close are only events allowed after calling destroy()
    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])
      return
    else if (ev === 'data') {
      if (!data)
        return

      if (this.pipes.length)
        this.pipes.forEach(p =>
          p.dest.write(data) === false && this.pause())
    } else if (ev === 'end') {
      // only actual end gets this treatment
      if (this[EMITTED_END] === true)
        return

      this[EMITTED_END] = true
      this.readable = false

      if (this[DECODER]) {
        data = this[DECODER].end()
        if (data) {
          this.pipes.forEach(p => p.dest.write(data))
          super.emit('data', data)
        }
      }

      this.pipes.forEach(p => {
        p.dest.removeListener('drain', p.ondrain)
        if (p.opts.end)
          p.dest.end()
      })
    } else if (ev === 'close') {
      this[CLOSED] = true
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END] && !this[DESTROYED])
        return
    }

    // TODO: replace with a spread operator when Node v4 support drops
    const args = new Array(arguments.length)
    args[0] = ev
    args[1] = data
    if (arguments.length > 2) {
      for (let i = 2; i < arguments.length; i++) {
        args[i] = arguments[i]
      }
    }

    try {
      return super.emit.apply(this, args)
    } finally {
      if (!isEndish(ev))
        this[MAYBE_EMIT_END]()
      else
        this.removeAllListeners(ev)
    }
  }

  // const all = await stream.collect()
  collect () {
    const buf = []
    if (!this[OBJECTMODE])
      buf.dataLength = 0
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise()
    this.on('data', c => {
      buf.push(c)
      if (!this[OBJECTMODE])
        buf.dataLength += c.length
    })
    return p.then(() => buf)
  }

  // const data = await stream.concat()
  concat () {
    return this[OBJECTMODE]
      ? Promise.reject(new Error('cannot concat in objectMode'))
      : this.collect().then(buf =>
          this[OBJECTMODE]
            ? Promise.reject(new Error('cannot concat in objectMode'))
            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))
  }

  // stream.promise().then(() => done, er => emitted error)
  promise () {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error('stream destroyed')))
      this.on('end', () => resolve())
      this.on('error', er => reject(er))
    })
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR] () {
    const next = () => {
      const res = this.read()
      if (res !== null)
        return Promise.resolve({ done: false, value: res })

      if (this[EOF])
        return Promise.resolve({ done: true })

      let resolve = null
      let reject = null
      const onerr = er => {
        this.removeListener('data', ondata)
        this.removeListener('end', onend)
        reject(er)
      }
      const ondata = value => {
        this.removeListener('error', onerr)
        this.removeListener('end', onend)
        this.pause()
        resolve({ value: value, done: !!this[EOF] })
      }
      const onend = () => {
        this.removeListener('error', onerr)
        this.removeListener('data', ondata)
        resolve({ done: true })
      }
      const ondestroy = () => onerr(new Error('stream destroyed'))
      return new Promise((res, rej) => {
        reject = rej
        resolve = res
        this.once(DESTROYED, ondestroy)
        this.once('error', onerr)
        this.once('end', onend)
        this.once('data', ondata)
      })
    }

    return { next }
  }

  // for (let chunk of stream)
  [ITERATOR] () {
    const next = () => {
      const value = this.read()
      const done = value === null
      return { value, done }
    }
    return { next }
  }

  destroy (er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit('error', er)
      else
        this.emit(DESTROYED)
      return this
    }

    this[DESTROYED] = true

    // throw away all buffered data, it's never coming out
    this.buffer = new Yallist()
    this[BUFFERLENGTH] = 0

    if (typeof this.close === 'function' && !this[CLOSED])
      this.close()

    if (er)
      this.emit('error', er)
    else // if no error to emit, still reject pending promises
      this.emit(DESTROYED)

    return this
  }

  static isStream (s) {
    return !!s && (s instanceof Minipass || s instanceof Stream ||
      s instanceof EE && (
        typeof s.pipe === 'function' || // readable
        (typeof s.write === 'function' && typeof s.end === 'function') // writable
      ))
  }
}


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(361)(Yallist)
} catch (er) {}


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),
/* 362 */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const assert = __webpack_require__(108)
const Buffer = __webpack_require__(316).Buffer
const realZlib = __webpack_require__(145)

const constants = exports.constants = __webpack_require__(364)
const Minipass = __webpack_require__(359)

const OriginalBufferConcat = Buffer.concat

const _superWrite = Symbol('_superWrite')
class ZlibError extends Error {
  constructor (err) {
    super('zlib: ' + err.message)
    this.code = err.code
    this.errno = err.errno
    /* istanbul ignore if */
    if (!this.code)
      this.code = 'ZLIB_ERROR'

    this.message = 'zlib: ' + err.message
    Error.captureStackTrace(this, this.constructor)
  }

  get name () {
    return 'ZlibError'
  }
}

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
const _opts = Symbol('opts')
const _flushFlag = Symbol('flushFlag')
const _finishFlushFlag = Symbol('finishFlushFlag')
const _fullFlushFlag = Symbol('fullFlushFlag')
const _handle = Symbol('handle')
const _onError = Symbol('onError')
const _sawError = Symbol('sawError')
const _level = Symbol('level')
const _strategy = Symbol('strategy')
const _ended = Symbol('ended')
const _defaultFullFlush = Symbol('_defaultFullFlush')

class ZlibBase extends Minipass {
  constructor (opts, mode) {
    if (!opts || typeof opts !== 'object')
      throw new TypeError('invalid options for ZlibBase constructor')

    super(opts)
    this[_sawError] = false
    this[_ended] = false
    this[_opts] = opts

    this[_flushFlag] = opts.flush
    this[_finishFlushFlag] = opts.finishFlush
    // this will throw if any options are invalid for the class selected
    try {
      this[_handle] = new realZlib[mode](opts)
    } catch (er) {
      // make sure that all errors get decorated properly
      throw new ZlibError(er)
    }

    this[_onError] = (err) => {
      // no sense raising multiple errors, since we abort on the first one.
      if (this[_sawError])
        return

      this[_sawError] = true

      // there is no way to cleanly recover.
      // continuing only obscures problems.
      this.close()
      this.emit('error', err)
    }

    this[_handle].on('error', er => this[_onError](new ZlibError(er)))
    this.once('end', () => this.close)
  }

  close () {
    if (this[_handle]) {
      this[_handle].close()
      this[_handle] = null
      this.emit('close')
    }
  }

  reset () {
    if (!this[_sawError]) {
      assert(this[_handle], 'zlib binding closed')
      return this[_handle].reset()
    }
  }

  flush (flushFlag) {
    if (this.ended)
      return

    if (typeof flushFlag !== 'number')
      flushFlag = this[_fullFlushFlag]
    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))
  }

  end (chunk, encoding, cb) {
    if (chunk)
      this.write(chunk, encoding)
    this.flush(this[_finishFlushFlag])
    this[_ended] = true
    return super.end(null, null, cb)
  }

  get ended () {
    return this[_ended]
  }

  write (chunk, encoding, cb) {
    // process the chunk using the sync process
    // then super.write() all the outputted chunks
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (typeof chunk === 'string')
      chunk = Buffer.from(chunk, encoding)

    if (this[_sawError])
      return
    assert(this[_handle], 'zlib binding closed')

    // _processChunk tries to .close() the native handle after it's done, so we
    // intercept that by temporarily making it a no-op.
    const nativeHandle = this[_handle]._handle
    const originalNativeClose = nativeHandle.close
    nativeHandle.close = () => {}
    const originalClose = this[_handle].close
    this[_handle].close = () => {}
    // It also calls `Buffer.concat()` at the end, which may be convenient
    // for some, but which we are not interested in as it slows us down.
    Buffer.concat = (args) => args
    let result
    try {
      const flushFlag = typeof chunk[_flushFlag] === 'number'
        ? chunk[_flushFlag] : this[_flushFlag]
      result = this[_handle]._processChunk(chunk, flushFlag)
      // if we don't throw, reset it back how it was
      Buffer.concat = OriginalBufferConcat
    } catch (err) {
      // or if we do, put Buffer.concat() back before we emit error
      // Error events call into user code, which may call Buffer.concat()
      Buffer.concat = OriginalBufferConcat
      this[_onError](new ZlibError(err))
    } finally {
      if (this[_handle]) {
        // Core zlib resets `_handle` to null after attempting to close the
        // native handle. Our no-op handler prevented actual closure, but we
        // need to restore the `._handle` property.
        this[_handle]._handle = nativeHandle
        nativeHandle.close = originalNativeClose
        this[_handle].close = originalClose
        // `_processChunk()` adds an 'error' listener. If we don't remove it
        // after each call, these handlers start piling up.
        this[_handle].removeAllListeners('error')
        // make sure OUR error listener is still attached tho
      }
    }

    if (this[_handle])
      this[_handle].on('error', er => this[_onError](new ZlibError(er)))

    let writeReturn
    if (result) {
      if (Array.isArray(result) && result.length > 0) {
        // The first buffer is always `handle._outBuffer`, which would be
        // re-used for later invocations; so, we always have to copy that one.
        writeReturn = this[_superWrite](Buffer.from(result[0]))
        for (let i = 1; i < result.length; i++) {
          writeReturn = this[_superWrite](result[i])
        }
      } else {
        writeReturn = this[_superWrite](Buffer.from(result))
      }
    }

    if (cb)
      cb()
    return writeReturn
  }

  [_superWrite] (data) {
    return super.write(data)
  }
}

class Zlib extends ZlibBase {
  constructor (opts, mode) {
    opts = opts || {}

    opts.flush = opts.flush || constants.Z_NO_FLUSH
    opts.finishFlush = opts.finishFlush || constants.Z_FINISH
    super(opts, mode)

    this[_fullFlushFlag] = constants.Z_FULL_FLUSH
    this[_level] = opts.level
    this[_strategy] = opts.strategy
  }

  params (level, strategy) {
    if (this[_sawError])
      return

    if (!this[_handle])
      throw new Error('cannot switch params when binding is closed')

    // no way to test this without also not supporting params at all
    /* istanbul ignore if */
    if (!this[_handle].params)
      throw new Error('not supported in this implementation')

    if (this[_level] !== level || this[_strategy] !== strategy) {
      this.flush(constants.Z_SYNC_FLUSH)
      assert(this[_handle], 'zlib binding closed')
      // .params() calls .flush(), but the latter is always async in the
      // core zlib. We override .flush() temporarily to intercept that and
      // flush synchronously.
      const origFlush = this[_handle].flush
      this[_handle].flush = (flushFlag, cb) => {
        this.flush(flushFlag)
        cb()
      }
      try {
        this[_handle].params(level, strategy)
      } finally {
        this[_handle].flush = origFlush
      }
      /* istanbul ignore else */
      if (this[_handle]) {
        this[_level] = level
        this[_strategy] = strategy
      }
    }
  }
}

// minimal 2-byte header
class Deflate extends Zlib {
  constructor (opts) {
    super(opts, 'Deflate')
  }
}

class Inflate extends Zlib {
  constructor (opts) {
    super(opts, 'Inflate')
  }
}

// gzip - bigger header, same deflate compression
const _portable = Symbol('_portable')
class Gzip extends Zlib {
  constructor (opts) {
    super(opts, 'Gzip')
    this[_portable] = opts && !!opts.portable
  }

  [_superWrite] (data) {
    if (!this[_portable])
      return super[_superWrite](data)

    // we'll always get the header emitted in one first chunk
    // overwrite the OS indicator byte with 0xFF
    this[_portable] = false
    data[9] = 255
    return super[_superWrite](data)
  }
}

class Gunzip extends Zlib {
  constructor (opts) {
    super(opts, 'Gunzip')
  }
}

// raw - no header
class DeflateRaw extends Zlib {
  constructor (opts) {
    super(opts, 'DeflateRaw')
  }
}

class InflateRaw extends Zlib {
  constructor (opts) {
    super(opts, 'InflateRaw')
  }
}

// auto-detect header.
class Unzip extends Zlib {
  constructor (opts) {
    super(opts, 'Unzip')
  }
}

class Brotli extends ZlibBase {
  constructor (opts, mode) {
    opts = opts || {}

    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS
    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH

    super(opts, mode)

    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH
  }
}

class BrotliCompress extends Brotli {
  constructor (opts) {
    super(opts, 'BrotliCompress')
  }
}

class BrotliDecompress extends Brotli {
  constructor (opts) {
    super(opts, 'BrotliDecompress')
  }
}

exports.Deflate = Deflate
exports.Inflate = Inflate
exports.Gzip = Gzip
exports.Gunzip = Gunzip
exports.DeflateRaw = DeflateRaw
exports.InflateRaw = InflateRaw
exports.Unzip = Unzip
/* istanbul ignore else */
if (typeof realZlib.BrotliCompress === 'function') {
  exports.BrotliCompress = BrotliCompress
  exports.BrotliDecompress = BrotliDecompress
} else {
  exports.BrotliCompress = exports.BrotliDecompress = class {
    constructor () {
      throw new Error('Brotli is not supported in this version of Node.js')
    }
  }
}


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

// Update with any zlib constants that are added or changed in the future.
// Node v6 didn't export this, so we just hard code the version and rely
// on all the other hard-coded values from zlib v4736.  When node v6
// support drops, we can just export the realZlibConstants object.
const realZlibConstants = __webpack_require__(145).constants ||
  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }

module.exports = Object.freeze(Object.assign(Object.create(null), {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31,
}, realZlibConstants))


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const types = __webpack_require__(366)
const MiniPass = __webpack_require__(359)

const SLURP = Symbol('slurp')
module.exports = class ReadEntry extends MiniPass {
  constructor (header, ex, gex) {
    super()
    // read entries always start life paused.  this is to avoid the
    // situation where Minipass's auto-ending empty streams results
    // in an entry ending before we're ready for it.
    this.pause()
    this.extended = ex
    this.globalExtended = gex
    this.header = header
    this.startBlockSize = 512 * Math.ceil(header.size / 512)
    this.blockRemain = this.startBlockSize
    this.remain = header.size
    this.type = header.type
    this.meta = false
    this.ignore = false
    switch (this.type) {
      case 'File':
      case 'OldFile':
      case 'Link':
      case 'SymbolicLink':
      case 'CharacterDevice':
      case 'BlockDevice':
      case 'Directory':
      case 'FIFO':
      case 'ContiguousFile':
      case 'GNUDumpDir':
        break

      case 'NextFileHasLongLinkpath':
      case 'NextFileHasLongPath':
      case 'OldGnuLongPath':
      case 'GlobalExtendedHeader':
      case 'ExtendedHeader':
      case 'OldExtendedHeader':
        this.meta = true
        break

      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
      // it may be worth doing the same, but with a warning.
      default:
        this.ignore = true
    }

    this.path = header.path
    this.mode = header.mode
    if (this.mode)
      this.mode = this.mode & 0o7777
    this.uid = header.uid
    this.gid = header.gid
    this.uname = header.uname
    this.gname = header.gname
    this.size = header.size
    this.mtime = header.mtime
    this.atime = header.atime
    this.ctime = header.ctime
    this.linkpath = header.linkpath
    this.uname = header.uname
    this.gname = header.gname

    if (ex) this[SLURP](ex)
    if (gex) this[SLURP](gex, true)
  }

  write (data) {
    const writeLen = data.length
    if (writeLen > this.blockRemain)
      throw new Error('writing more to entry than is appropriate')

    const r = this.remain
    const br = this.blockRemain
    this.remain = Math.max(0, r - writeLen)
    this.blockRemain = Math.max(0, br - writeLen)
    if (this.ignore)
      return true

    if (r >= writeLen)
      return super.write(data)

    // r < writeLen
    return super.write(data.slice(0, r))
  }

  [SLURP] (ex, global) {
    for (let k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined &&
          !(global && k === 'path'))
        this[k] = ex[k]
    }
  }
}


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// map types from key to human-friendly name
exports.name = new Map([
  ['0', 'File'],
  // same as File
  ['', 'OldFile'],
  ['1', 'Link'],
  ['2', 'SymbolicLink'],
  // Devices and FIFOs aren't fully supported
  // they are parsed, but skipped when unpacking
  ['3', 'CharacterDevice'],
  ['4', 'BlockDevice'],
  ['5', 'Directory'],
  ['6', 'FIFO'],
  // same as File
  ['7', 'ContiguousFile'],
  // pax headers
  ['g', 'GlobalExtendedHeader'],
  ['x', 'ExtendedHeader'],
  // vendor-specific stuff
  // skip
  ['A', 'SolarisACL'],
  // like 5, but with data, which should be skipped
  ['D', 'GNUDumpDir'],
  // metadata only, skip
  ['I', 'Inode'],
  // data = link path of next file
  ['K', 'NextFileHasLongLinkpath'],
  // data = path of next file
  ['L', 'NextFileHasLongPath'],
  // skip
  ['M', 'ContinuationFile'],
  // like L
  ['N', 'OldGnuLongPath'],
  // skip
  ['S', 'SparseFile'],
  // skip
  ['V', 'TapeVolumeHeader'],
  // like x
  ['X', 'OldExtendedHeader']
])

// map the other direction
exports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const MiniPass = __webpack_require__(359)
const Pax = __webpack_require__(368)
const Header = __webpack_require__(369)
const ReadEntry = __webpack_require__(365)
const fs = __webpack_require__(66)
const path = __webpack_require__(82)

const types = __webpack_require__(366)
const maxReadSize = 16 * 1024 * 1024
const PROCESS = Symbol('process')
const FILE = Symbol('file')
const DIRECTORY = Symbol('directory')
const SYMLINK = Symbol('symlink')
const HARDLINK = Symbol('hardlink')
const HEADER = Symbol('header')
const READ = Symbol('read')
const LSTAT = Symbol('lstat')
const ONLSTAT = Symbol('onlstat')
const ONREAD = Symbol('onread')
const ONREADLINK = Symbol('onreadlink')
const OPENFILE = Symbol('openfile')
const ONOPENFILE = Symbol('onopenfile')
const CLOSE = Symbol('close')
const MODE = Symbol('mode')
const warner = __webpack_require__(371)
const winchars = __webpack_require__(372)

const modeFix = __webpack_require__(373)

const WriteEntry = warner(class WriteEntry extends MiniPass {
  constructor (p, opt) {
    opt = opt || {}
    super(opt)
    if (typeof p !== 'string')
      throw new TypeError('path is required')
    this.path = p
    // suppress atime, ctime, uid, gid, uname, gname
    this.portable = !!opt.portable
    // until node has builtin pwnam functions, this'll have to do
    this.myuid = process.getuid && process.getuid()
    this.myuser = process.env.USER || ''
    this.maxReadSize = opt.maxReadSize || maxReadSize
    this.linkCache = opt.linkCache || new Map()
    this.statCache = opt.statCache || new Map()
    this.preservePaths = !!opt.preservePaths
    this.cwd = opt.cwd || process.cwd()
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.noMtime = !!opt.noMtime
    this.mtime = opt.mtime || null

    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    let pathWarn = false
    if (!this.preservePaths && path.win32.isAbsolute(p)) {
      // absolutes on posix are also absolutes on win32
      // so we only need to test this one to get both
      const parsed = path.win32.parse(p)
      this.path = p.substr(parsed.root.length)
      pathWarn = parsed.root
    }

    this.win32 = !!opt.win32 || process.platform === 'win32'
    if (this.win32) {
      this.path = winchars.decode(this.path.replace(/\\/g, '/'))
      p = p.replace(/\\/g, '/')
    }

    this.absolute = opt.absolute || path.resolve(this.cwd, p)

    if (this.path === '')
      this.path = './'

    if (pathWarn) {
      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path,
      })
    }

    if (this.statCache.has(this.absolute))
      this[ONLSTAT](this.statCache.get(this.absolute))
    else
      this[LSTAT]()
  }

  [LSTAT] () {
    fs.lstat(this.absolute, (er, stat) => {
      if (er)
        return this.emit('error', er)
      this[ONLSTAT](stat)
    })
  }

  [ONLSTAT] (stat) {
    this.statCache.set(this.absolute, stat)
    this.stat = stat
    if (!stat.isFile())
      stat.size = 0
    this.type = getType(stat)
    this.emit('stat', stat)
    this[PROCESS]()
  }

  [PROCESS] () {
    switch (this.type) {
      case 'File': return this[FILE]()
      case 'Directory': return this[DIRECTORY]()
      case 'SymbolicLink': return this[SYMLINK]()
      // unsupported types are ignored.
      default: return this.end()
    }
  }

  [MODE] (mode) {
    return modeFix(mode, this.type === 'Directory', this.portable)
  }

  [HEADER] () {
    if (this.type === 'Directory' && this.portable)
      this.noMtime = true

    this.header = new Header({
      path: this.path,
      linkpath: this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this[MODE](this.stat.mode),
      uid: this.portable ? null : this.stat.uid,
      gid: this.portable ? null : this.stat.gid,
      size: this.stat.size,
      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
      type: this.type,
      uname: this.portable ? null :
        this.stat.uid === this.myuid ? this.myuser : '',
      atime: this.portable ? null : this.stat.atime,
      ctime: this.portable ? null : this.stat.ctime
    })

    if (this.header.encode() && !this.noPax)
      this.write(new Pax({
        atime: this.portable ? null : this.header.atime,
        ctime: this.portable ? null : this.header.ctime,
        gid: this.portable ? null : this.header.gid,
        mtime: this.noMtime ? null : this.mtime || this.header.mtime,
        path: this.path,
        linkpath: this.linkpath,
        size: this.header.size,
        uid: this.portable ? null : this.header.uid,
        uname: this.portable ? null : this.header.uname,
        dev: this.portable ? null : this.stat.dev,
        ino: this.portable ? null : this.stat.ino,
        nlink: this.portable ? null : this.stat.nlink
      }).encode())
    this.write(this.header.block)
  }

  [DIRECTORY] () {
    if (this.path.substr(-1) !== '/')
      this.path += '/'
    this.stat.size = 0
    this[HEADER]()
    this.end()
  }

  [SYMLINK] () {
    fs.readlink(this.absolute, (er, linkpath) => {
      if (er)
        return this.emit('error', er)
      this[ONREADLINK](linkpath)
    })
  }

  [ONREADLINK] (linkpath) {
    this.linkpath = linkpath.replace(/\\/g, '/')
    this[HEADER]()
    this.end()
  }

  [HARDLINK] (linkpath) {
    this.type = 'Link'
    this.linkpath = path.relative(this.cwd, linkpath).replace(/\\/g, '/')
    this.stat.size = 0
    this[HEADER]()
    this.end()
  }

  [FILE] () {
    if (this.stat.nlink > 1) {
      const linkKey = this.stat.dev + ':' + this.stat.ino
      if (this.linkCache.has(linkKey)) {
        const linkpath = this.linkCache.get(linkKey)
        if (linkpath.indexOf(this.cwd) === 0)
          return this[HARDLINK](linkpath)
      }
      this.linkCache.set(linkKey, this.absolute)
    }

    this[HEADER]()
    if (this.stat.size === 0)
      return this.end()

    this[OPENFILE]()
  }

  [OPENFILE] () {
    fs.open(this.absolute, 'r', (er, fd) => {
      if (er)
        return this.emit('error', er)
      this[ONOPENFILE](fd)
    })
  }

  [ONOPENFILE] (fd) {
    const blockLen = 512 * Math.ceil(this.stat.size / 512)
    const bufLen = Math.min(blockLen, this.maxReadSize)
    const buf = Buffer.allocUnsafe(bufLen)
    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)
  }

  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {
    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {
      if (er) {
        // ignoring the error from close(2) is a bad practice, but at
        // this point we already have an error, don't need another one
        return this[CLOSE](fd, () => this.emit('error', er))
      }
      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)
    })
  }

  [CLOSE] (fd, cb) {
    fs.close(fd, cb)
  }

  [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {
    if (bytesRead <= 0 && remain > 0) {
      const er = new Error('encountered unexpected EOF')
      er.path = this.absolute
      er.syscall = 'read'
      er.code = 'EOF'
      return this[CLOSE](fd, () => this.emit('error', er))
    }

    if (bytesRead > remain) {
      const er = new Error('did not encounter expected EOF')
      er.path = this.absolute
      er.syscall = 'read'
      er.code = 'EOF'
      return this[CLOSE](fd, () => this.emit('error', er))
    }

    // null out the rest of the buffer, if we could fit the block padding
    if (bytesRead === remain) {
      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {
        buf[i + offset] = 0
        bytesRead ++
        remain ++
      }
    }

    const writeBuf = offset === 0 && bytesRead === buf.length ?
      buf : buf.slice(offset, offset + bytesRead)
    remain -= bytesRead
    blockRemain -= bytesRead
    pos += bytesRead
    offset += bytesRead

    this.write(writeBuf)

    if (!remain) {
      if (blockRemain)
        this.write(Buffer.alloc(blockRemain))
      return this[CLOSE](fd, er => er ? this.emit('error', er) : this.end())
    }

    if (offset >= length) {
      buf = Buffer.allocUnsafe(length)
      offset = 0
    }
    length = buf.length - offset
    this[READ](fd, buf, offset, length, pos, remain, blockRemain)
  }
})

class WriteEntrySync extends WriteEntry {
  constructor (path, opt) {
    super(path, opt)
  }

  [LSTAT] () {
    this[ONLSTAT](fs.lstatSync(this.absolute))
  }

  [SYMLINK] () {
    this[ONREADLINK](fs.readlinkSync(this.absolute))
  }

  [OPENFILE] () {
    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))
  }

  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {
    let threw = true
    try {
      const bytesRead = fs.readSync(fd, buf, offset, length, pos)
      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)
      threw = false
    } finally {
      // ignoring the error from close(2) is a bad practice, but at
      // this point we already have an error, don't need another one
      if (threw)
        try { this[CLOSE](fd, () => {}) } catch (er) {}
    }
  }

  [CLOSE] (fd, cb) {
    fs.closeSync(fd)
    cb()
  }
}

const WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
  constructor (readEntry, opt) {
    opt = opt || {}
    super(opt)
    this.preservePaths = !!opt.preservePaths
    this.portable = !!opt.portable
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.noMtime = !!opt.noMtime

    this.readEntry = readEntry
    this.type = readEntry.type
    if (this.type === 'Directory' && this.portable)
      this.noMtime = true

    this.path = readEntry.path
    this.mode = this[MODE](readEntry.mode)
    this.uid = this.portable ? null : readEntry.uid
    this.gid = this.portable ? null : readEntry.gid
    this.uname = this.portable ? null : readEntry.uname
    this.gname = this.portable ? null : readEntry.gname
    this.size = readEntry.size
    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime
    this.atime = this.portable ? null : readEntry.atime
    this.ctime = this.portable ? null : readEntry.ctime
    this.linkpath = readEntry.linkpath

    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    let pathWarn = false
    if (path.isAbsolute(this.path) && !this.preservePaths) {
      const parsed = path.parse(this.path)
      pathWarn = parsed.root
      this.path = this.path.substr(parsed.root.length)
    }

    this.remain = readEntry.size
    this.blockRemain = readEntry.startBlockSize

    this.header = new Header({
      path: this.path,
      linkpath: this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this.mode,
      uid: this.portable ? null : this.uid,
      gid: this.portable ? null : this.gid,
      size: this.size,
      mtime: this.noMtime ? null : this.mtime,
      type: this.type,
      uname: this.portable ? null : this.uname,
      atime: this.portable ? null : this.atime,
      ctime: this.portable ? null : this.ctime
    })

    if (pathWarn) {
      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path,
      })
    }

    if (this.header.encode() && !this.noPax)
      super.write(new Pax({
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime,
        gid: this.portable ? null : this.gid,
        mtime: this.noMtime ? null : this.mtime,
        path: this.path,
        linkpath: this.linkpath,
        size: this.size,
        uid: this.portable ? null : this.uid,
        uname: this.portable ? null : this.uname,
        dev: this.portable ? null : this.readEntry.dev,
        ino: this.portable ? null : this.readEntry.ino,
        nlink: this.portable ? null : this.readEntry.nlink
      }).encode())

    super.write(this.header.block)
    readEntry.pipe(this)
  }

  [MODE] (mode) {
    return modeFix(mode, this.type === 'Directory', this.portable)
  }

  write (data) {
    const writeLen = data.length
    if (writeLen > this.blockRemain)
      throw new Error('writing more to entry than is appropriate')
    this.blockRemain -= writeLen
    return super.write(data)
  }

  end () {
    if (this.blockRemain)
      this.write(Buffer.alloc(this.blockRemain))
    return super.end()
  }
})

WriteEntry.Sync = WriteEntrySync
WriteEntry.Tar = WriteEntryTar

const getType = stat =>
  stat.isFile() ? 'File'
  : stat.isDirectory() ? 'Directory'
  : stat.isSymbolicLink() ? 'SymbolicLink'
  : 'Unsupported'

module.exports = WriteEntry


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const Header = __webpack_require__(369)
const path = __webpack_require__(82)

class Pax {
  constructor (obj, global) {
    this.atime = obj.atime || null
    this.charset = obj.charset || null
    this.comment = obj.comment || null
    this.ctime = obj.ctime || null
    this.gid = obj.gid || null
    this.gname = obj.gname || null
    this.linkpath = obj.linkpath || null
    this.mtime = obj.mtime || null
    this.path = obj.path || null
    this.size = obj.size || null
    this.uid = obj.uid || null
    this.uname = obj.uname || null
    this.dev = obj.dev || null
    this.ino = obj.ino || null
    this.nlink = obj.nlink || null
    this.global = global || false
  }

  encode () {
    const body = this.encodeBody()
    if (body === '')
      return null

    const bodyLen = Buffer.byteLength(body)
    // round up to 512 bytes
    // add 512 for header
    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)
    const buf = Buffer.allocUnsafe(bufLen)

    // 0-fill the header section, it might not hit every field
    for (let i = 0; i < 512; i++) {
      buf[i] = 0
    }

    new Header({
      // XXX split the path
      // then the path should be PaxHeader + basename, but less than 99,
      // prepend with the dirname
      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),
      mode: this.mode || 0o644,
      uid: this.uid || null,
      gid: this.gid || null,
      size: bodyLen,
      mtime: this.mtime || null,
      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',
      linkpath: '',
      uname: this.uname || '',
      gname: this.gname || '',
      devmaj: 0,
      devmin: 0,
      atime: this.atime || null,
      ctime: this.ctime || null
    }).encode(buf)

    buf.write(body, 512, bodyLen, 'utf8')

    // null pad after the body
    for (let i = bodyLen + 512; i < buf.length; i++) {
      buf[i] = 0
    }

    return buf
  }

  encodeBody () {
    return (
      this.encodeField('path') +
      this.encodeField('ctime') +
      this.encodeField('atime') +
      this.encodeField('dev') +
      this.encodeField('ino') +
      this.encodeField('nlink') +
      this.encodeField('charset') +
      this.encodeField('comment') +
      this.encodeField('gid') +
      this.encodeField('gname') +
      this.encodeField('linkpath') +
      this.encodeField('mtime') +
      this.encodeField('size') +
      this.encodeField('uid') +
      this.encodeField('uname')
    )
  }

  encodeField (field) {
    if (this[field] === null || this[field] === undefined)
      return ''
    const v = this[field] instanceof Date ? this[field].getTime() / 1000
      : this[field]
    const s = ' ' +
      (field === 'dev' || field === 'ino' || field === 'nlink'
       ? 'SCHILY.' : '') +
      field + '=' + v + '\n'
    const byteLen = Buffer.byteLength(s)
    // the digits includes the length of the digits in ascii base-10
    // so if it's 9 characters, then adding 1 for the 9 makes it 10
    // which makes it 11 chars.
    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1
    if (byteLen + digits >= Math.pow(10, digits))
      digits += 1
    const len = digits + byteLen
    return len + s
  }
}

Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)

const merge = (a, b) =>
  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a

const parseKV = string =>
  string
    .replace(/\n$/, '')
    .split('\n')
    .reduce(parseKVLine, Object.create(null))

const parseKVLine = (set, line) => {
  const n = parseInt(line, 10)

  // XXX Values with \n in them will fail this.
  // Refactor to not be a naive line-by-line parse.
  if (n !== Buffer.byteLength(line) + 1)
    return set

  line = line.substr((n + ' ').length)
  const kv = line.split('=')
  const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, '$1')
  if (!k)
    return set

  const v = kv.join('=')
  set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k)
    ?  new Date(v * 1000)
    : /^[0-9]+$/.test(v) ? +v
    : v
  return set
}

module.exports = Pax


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// parse a 512-byte header block to a data object, or vice-versa
// encode returns `true` if a pax extended header is needed, because
// the data could not be faithfully encoded in a simple header.
// (Also, check header.needPax to see if it needs a pax header.)

const types = __webpack_require__(366)
const pathModule = __webpack_require__(82).posix
const large = __webpack_require__(370)

const SLURP = Symbol('slurp')
const TYPE = Symbol('type')

class Header {
  constructor (data, off, ex, gex) {
    this.cksumValid = false
    this.needPax = false
    this.nullBlock = false

    this.block = null
    this.path = null
    this.mode = null
    this.uid = null
    this.gid = null
    this.size = null
    this.mtime = null
    this.cksum = null
    this[TYPE] = '0'
    this.linkpath = null
    this.uname = null
    this.gname = null
    this.devmaj = 0
    this.devmin = 0
    this.atime = null
    this.ctime = null

    if (Buffer.isBuffer(data))
      this.decode(data, off || 0, ex, gex)
    else if (data)
      this.set(data)
  }

  decode (buf, off, ex, gex) {
    if (!off)
      off = 0

    if (!buf || !(buf.length >= off + 512))
      throw new Error('need 512 bytes for header')

    this.path = decString(buf, off, 100)
    this.mode = decNumber(buf, off + 100, 8)
    this.uid = decNumber(buf, off + 108, 8)
    this.gid = decNumber(buf, off + 116, 8)
    this.size = decNumber(buf, off + 124, 12)
    this.mtime = decDate(buf, off + 136, 12)
    this.cksum = decNumber(buf, off + 148, 12)

    // if we have extended or global extended headers, apply them now
    // See https://github.com/npm/node-tar/pull/187
    this[SLURP](ex)
    this[SLURP](gex, true)

    // old tar versions marked dirs as a file with a trailing /
    this[TYPE] = decString(buf, off + 156, 1)
    if (this[TYPE] === '')
      this[TYPE] = '0'
    if (this[TYPE] === '0' && this.path.substr(-1) === '/')
      this[TYPE] = '5'

    // tar implementations sometimes incorrectly put the stat(dir).size
    // as the size in the tarball, even though Directory entries are
    // not able to have any body at all.  In the very rare chance that
    // it actually DOES have a body, we weren't going to do anything with
    // it anyway, and it'll just be a warning about an invalid header.
    if (this[TYPE] === '5')
      this.size = 0

    this.linkpath = decString(buf, off + 157, 100)
    if (buf.slice(off + 257, off + 265).toString() === 'ustar\u000000') {
      this.uname = decString(buf, off + 265, 32)
      this.gname = decString(buf, off + 297, 32)
      this.devmaj = decNumber(buf, off + 329, 8)
      this.devmin = decNumber(buf, off + 337, 8)
      if (buf[off + 475] !== 0) {
        // definitely a prefix, definitely >130 chars.
        const prefix = decString(buf, off + 345, 155)
        this.path = prefix + '/' + this.path
      } else {
        const prefix = decString(buf, off + 345, 130)
        if (prefix)
          this.path = prefix + '/' + this.path
        this.atime = decDate(buf, off + 476, 12)
        this.ctime = decDate(buf, off + 488, 12)
      }
    }

    let sum = 8 * 0x20
    for (let i = off; i < off + 148; i++) {
      sum += buf[i]
    }
    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i]
    }
    this.cksumValid = sum === this.cksum
    if (this.cksum === null && sum === 8 * 0x20)
      this.nullBlock = true
  }

  [SLURP] (ex, global) {
    for (let k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined &&
          !(global && k === 'path'))
        this[k] = ex[k]
    }
  }

  encode (buf, off) {
    if (!buf) {
      buf = this.block = Buffer.alloc(512)
      off = 0
    }

    if (!off)
      off = 0

    if (!(buf.length >= off + 512))
      throw new Error('need 512 bytes for header')

    const prefixSize = this.ctime || this.atime ? 130 : 155
    const split = splitPrefix(this.path || '', prefixSize)
    const path = split[0]
    const prefix = split[1]
    this.needPax = split[2]

    this.needPax = encString(buf, off, 100, path) || this.needPax
    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax
    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax
    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax
    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax
    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax
    buf[off + 156] = this[TYPE].charCodeAt(0)
    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax
    buf.write('ustar\u000000', off + 257, 8)
    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax
    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax
    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax
    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax
    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax
    if (buf[off + 475] !== 0)
      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax
    else {
      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax
      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax
      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax
    }

    let sum = 8 * 0x20
    for (let i = off; i < off + 148; i++) {
      sum += buf[i]
    }
    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i]
    }
    this.cksum = sum
    encNumber(buf, off + 148, 8, this.cksum)
    this.cksumValid = true

    return this.needPax
  }

  set (data) {
    for (let i in data) {
      if (data[i] !== null && data[i] !== undefined)
        this[i] = data[i]
    }
  }

  get type () {
    return types.name.get(this[TYPE]) || this[TYPE]
  }

  get typeKey () {
    return this[TYPE]
  }

  set type (type) {
    if (types.code.has(type))
      this[TYPE] = types.code.get(type)
    else
      this[TYPE] = type
  }
}

const splitPrefix = (p, prefixSize) => {
  const pathSize = 100
  let pp = p
  let prefix = ''
  let ret
  const root = pathModule.parse(p).root || '.'

  if (Buffer.byteLength(pp) < pathSize)
    ret = [pp, prefix, false]
  else {
    // first set prefix to the dir, and path to the base
    prefix = pathModule.dirname(pp)
    pp = pathModule.basename(pp)

    do {
      // both fit!
      if (Buffer.byteLength(pp) <= pathSize &&
          Buffer.byteLength(prefix) <= prefixSize)
        ret = [pp, prefix, false]

      // prefix fits in prefix, but path doesn't fit in path
      else if (Buffer.byteLength(pp) > pathSize &&
          Buffer.byteLength(prefix) <= prefixSize)
        ret = [pp.substr(0, pathSize - 1), prefix, true]

      else {
        // make path take a bit from prefix
        pp = pathModule.join(pathModule.basename(prefix), pp)
        prefix = pathModule.dirname(prefix)
      }
    } while (prefix !== root && !ret)

    // at this point, found no resolution, just truncate
    if (!ret)
      ret = [p.substr(0, pathSize - 1), '', true]
  }
  return ret
}

const decString = (buf, off, size) =>
  buf.slice(off, off + size).toString('utf8').replace(/\0.*/, '')

const decDate = (buf, off, size) =>
  numToDate(decNumber(buf, off, size))

const numToDate = num => num === null ? null : new Date(num * 1000)

const decNumber = (buf, off, size) =>
  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))
    : decSmallNumber(buf, off, size)

const nanNull = value => isNaN(value) ? null : value

const decSmallNumber = (buf, off, size) =>
  nanNull(parseInt(
    buf.slice(off, off + size)
      .toString('utf8').replace(/\0.*$/, '').trim(), 8))

// the maximum encodable as a null-terminated octal, by field size
const MAXNUM = {
  12: 0o77777777777,
  8 : 0o7777777
}

const encNumber = (buf, off, size, number) =>
  number === null ? false :
  number > MAXNUM[size] || number < 0
    ? (large.encode(number, buf.slice(off, off + size)), true)
    : (encSmallNumber(buf, off, size, number), false)

const encSmallNumber = (buf, off, size, number) =>
  buf.write(octalString(number, size), off, size, 'ascii')

const octalString = (number, size) =>
  padOctal(Math.floor(number).toString(8), size)

const padOctal = (string, size) =>
  (string.length === size - 1 ? string
  : new Array(size - string.length - 1).join('0') + string + ' ') + '\0'

const encDate = (buf, off, size, date) =>
  date === null ? false :
  encNumber(buf, off, size, date.getTime() / 1000)

// enough to fill the longest string we've got
const NULLS = new Array(156).join('\0')
// pad with nulls, return true if it's longer or non-ascii
const encString = (buf, off, size, string) =>
  string === null ? false :
  (buf.write(string + NULLS, off, size, 'utf8'),
   string.length !== Buffer.byteLength(string) || string.length > size)

module.exports = Header


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Tar can encode large and negative numbers using a leading byte of
// 0xff for negative, and 0x80 for positive.

const encode = exports.encode = (num, buf) => {
  if (!Number.isSafeInteger(num))
    // The number is so large that javascript cannot represent it with integer
    // precision.
    throw Error('cannot encode number outside of javascript safe integer range')
  else if (num < 0)
    encodeNegative(num, buf)
  else
    encodePositive(num, buf)
  return buf
}

const encodePositive = (num, buf) => {
  buf[0] = 0x80

  for (var i = buf.length; i > 1; i--) {
    buf[i-1] = num & 0xff
    num = Math.floor(num / 0x100)
  }
}

const encodeNegative = (num, buf) => {
  buf[0] = 0xff
  var flipped = false
  num = num * -1
  for (var i = buf.length; i > 1; i--) {
    var byte = num & 0xff
    num = Math.floor(num / 0x100)
    if (flipped)
      buf[i-1] = onesComp(byte)
    else if (byte === 0)
      buf[i-1] = 0
    else {
      flipped = true
      buf[i-1] = twosComp(byte)
    }
  }
}

const parse = exports.parse = (buf) => {
  var post = buf[buf.length - 1]
  var pre = buf[0]
  var value;
  if (pre === 0x80)
    value = pos(buf.slice(1, buf.length))
  else if (pre === 0xff)
    value = twos(buf)
  else
    throw Error('invalid base256 encoding')

  if (!Number.isSafeInteger(value))
    // The number is so large that javascript cannot represent it with integer
    // precision.
    throw Error('parsed number outside of javascript safe integer range')

  return value
}

const twos = (buf) => {
  var len = buf.length
  var sum = 0
  var flipped = false
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i]
    var f
    if (flipped)
      f = onesComp(byte)
    else if (byte === 0)
      f = byte
    else {
      flipped = true
      f = twosComp(byte)
    }
    if (f !== 0)
      sum -= f * Math.pow(256, len - i - 1)
  }
  return sum
}

const pos = (buf) => {
  var len = buf.length
  var sum = 0
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i]
    if (byte !== 0)
      sum += byte * Math.pow(256, len - i - 1)
  }
  return sum
}

const onesComp = byte => (0xff ^ byte) & 0xff

const twosComp = byte => ((0xff ^ byte) + 1) & 0xff


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Base => class extends Base {
  warn (code, message, data = {}) {
    if (this.file)
      data.file = this.file
    if (this.cwd)
      data.cwd = this.cwd
    data.code = message instanceof Error && message.code || code
    data.tarCode = code
    if (!this.strict && data.recoverable !== false) {
      if (message instanceof Error) {
        data = Object.assign(message, data)
        message = message.message
      }
      this.emit('warn', data.tarCode, message, data)
    } else if (message instanceof Error) {
      this.emit('error', Object.assign(message, data))
    } else
      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))
  }
}


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// When writing files on Windows, translate the characters to their
// 0xf000 higher-encoded versions.

const raw = [
  '|',
  '<',
  '>',
  '?',
  ':'
]

const win = raw.map(char =>
  String.fromCharCode(0xf000 + char.charCodeAt(0)))

const toWin = new Map(raw.map((char, i) => [char, win[i]]))
const toRaw = new Map(win.map((char, i) => [char, raw[i]]))

module.exports = {
  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),
  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)
}


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = (mode, isDir, portable) => {
  mode &= 0o7777

  // in portable mode, use the minimum reasonable umask
  // if this system creates files with 0o664 by default
  // (as some linux distros do), then we'll write the
  // archive with 0o644 instead.  Also, don't ever create
  // a file that is not readable/writable by the owner.
  if (portable) {
    mode = (mode | 0o600) &~0o22
  }

  // if dirs are readable, then they should be listable
  if (isDir) {
    if (mode & 0o400)
      mode |= 0o100
    if (mode & 0o40)
      mode |= 0o10
    if (mode & 0o4)
      mode |= 0o1
  }
  return mode
}


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const MiniPass = __webpack_require__(359)
const EE = __webpack_require__(198).EventEmitter
const fs = __webpack_require__(66)

let writev = fs.writev
/* istanbul ignore next */
if (!writev) {
  // This entire block can be removed if support for earlier than Node.js
  // 12.9.0 is not needed.
  const binding = process.binding('fs')
  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback

  writev = (fd, iovec, pos, cb) => {
    const done = (er, bw) => cb(er, bw, iovec)
    const req = new FSReqWrap()
    req.oncomplete = done
    binding.writeBuffers(fd, iovec, pos, req)
  }
}

const _autoClose = Symbol('_autoClose')
const _close = Symbol('_close')
const _ended = Symbol('_ended')
const _fd = Symbol('_fd')
const _finished = Symbol('_finished')
const _flags = Symbol('_flags')
const _flush = Symbol('_flush')
const _handleChunk = Symbol('_handleChunk')
const _makeBuf = Symbol('_makeBuf')
const _mode = Symbol('_mode')
const _needDrain = Symbol('_needDrain')
const _onerror = Symbol('_onerror')
const _onopen = Symbol('_onopen')
const _onread = Symbol('_onread')
const _onwrite = Symbol('_onwrite')
const _open = Symbol('_open')
const _path = Symbol('_path')
const _pos = Symbol('_pos')
const _queue = Symbol('_queue')
const _read = Symbol('_read')
const _readSize = Symbol('_readSize')
const _reading = Symbol('_reading')
const _remain = Symbol('_remain')
const _size = Symbol('_size')
const _write = Symbol('_write')
const _writing = Symbol('_writing')
const _defaultFlag = Symbol('_defaultFlag')
const _errored = Symbol('_errored')

class ReadStream extends MiniPass {
  constructor (path, opt) {
    opt = opt || {}
    super(opt)

    this.readable = true
    this.writable = false

    if (typeof path !== 'string')
      throw new TypeError('path must be a string')

    this[_errored] = false
    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
    this[_path] = path
    this[_readSize] = opt.readSize || 16*1024*1024
    this[_reading] = false
    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity
    this[_remain] = this[_size]
    this[_autoClose] = typeof opt.autoClose === 'boolean' ?
      opt.autoClose : true

    if (typeof this[_fd] === 'number')
      this[_read]()
    else
      this[_open]()
  }

  get fd () { return this[_fd] }
  get path () { return this[_path] }

  write () {
    throw new TypeError('this is a readable stream')
  }

  end () {
    throw new TypeError('this is a readable stream')
  }

  [_open] () {
    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))
  }

  [_onopen] (er, fd) {
    if (er)
      this[_onerror](er)
    else {
      this[_fd] = fd
      this.emit('open', fd)
      this[_read]()
    }
  }

  [_makeBuf] () {
    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))
  }

  [_read] () {
    if (!this[_reading]) {
      this[_reading] = true
      const buf = this[_makeBuf]()
      /* istanbul ignore if */
      if (buf.length === 0)
        return process.nextTick(() => this[_onread](null, 0, buf))
      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>
        this[_onread](er, br, buf))
    }
  }

  [_onread] (er, br, buf) {
    this[_reading] = false
    if (er)
      this[_onerror](er)
    else if (this[_handleChunk](br, buf))
      this[_read]()
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))
    }
  }

  [_onerror] (er) {
    this[_reading] = true
    this[_close]()
    this.emit('error', er)
  }

  [_handleChunk] (br, buf) {
    let ret = false
    // no effect if infinite
    this[_remain] -= br
    if (br > 0)
      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)

    if (br === 0 || this[_remain] <= 0) {
      ret = false
      this[_close]()
      super.end()
    }

    return ret
  }

  emit (ev, data) {
    switch (ev) {
      case 'prefinish':
      case 'finish':
        break

      case 'drain':
        if (typeof this[_fd] === 'number')
          this[_read]()
        break

      case 'error':
        if (this[_errored])
          return
        this[_errored] = true
        return super.emit(ev, data)

      default:
        return super.emit(ev, data)
    }
  }
}

class ReadStreamSync extends ReadStream {
  [_open] () {
    let threw = true
    try {
      this[_onopen](null, fs.openSync(this[_path], 'r'))
      threw = false
    } finally {
      if (threw)
        this[_close]()
    }
  }

  [_read] () {
    let threw = true
    try {
      if (!this[_reading]) {
        this[_reading] = true
        do {
          const buf = this[_makeBuf]()
          /* istanbul ignore next */
          const br = buf.length === 0 ? 0
            : fs.readSync(this[_fd], buf, 0, buf.length, null)
          if (!this[_handleChunk](br, buf))
            break
        } while (true)
        this[_reading] = false
      }
      threw = false
    } finally {
      if (threw)
        this[_close]()
    }
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.closeSync(fd)
      this.emit('close')
    }
  }
}

class WriteStream extends EE {
  constructor (path, opt) {
    opt = opt || {}
    super(opt)
    this.readable = false
    this.writable = true
    this[_errored] = false
    this[_writing] = false
    this[_ended] = false
    this[_needDrain] = false
    this[_queue] = []
    this[_path] = path
    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode
    this[_pos] = typeof opt.start === 'number' ? opt.start : null
    this[_autoClose] = typeof opt.autoClose === 'boolean' ?
      opt.autoClose : true

    // truncating makes no sense when writing into the middle
    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'
    this[_defaultFlag] = opt.flags === undefined
    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags

    if (this[_fd] === null)
      this[_open]()
  }

  emit (ev, data) {
    if (ev === 'error') {
      if (this[_errored])
        return
      this[_errored] = true
    }
    return super.emit(ev, data)
  }


  get fd () { return this[_fd] }
  get path () { return this[_path] }

  [_onerror] (er) {
    this[_close]()
    this[_writing] = true
    this.emit('error', er)
  }

  [_open] () {
    fs.open(this[_path], this[_flags], this[_mode],
      (er, fd) => this[_onopen](er, fd))
  }

  [_onopen] (er, fd) {
    if (this[_defaultFlag] &&
        this[_flags] === 'r+' &&
        er && er.code === 'ENOENT') {
      this[_flags] = 'w'
      this[_open]()
    } else if (er)
      this[_onerror](er)
    else {
      this[_fd] = fd
      this.emit('open', fd)
      this[_flush]()
    }
  }

  end (buf, enc) {
    if (buf)
      this.write(buf, enc)

    this[_ended] = true

    // synthetic after-write logic, where drain/finish live
    if (!this[_writing] && !this[_queue].length &&
        typeof this[_fd] === 'number')
      this[_onwrite](null, 0)
    return this
  }

  write (buf, enc) {
    if (typeof buf === 'string')
      buf = Buffer.from(buf, enc)

    if (this[_ended]) {
      this.emit('error', new Error('write() after end()'))
      return false
    }

    if (this[_fd] === null || this[_writing] || this[_queue].length) {
      this[_queue].push(buf)
      this[_needDrain] = true
      return false
    }

    this[_writing] = true
    this[_write](buf)
    return true
  }

  [_write] (buf) {
    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>
      this[_onwrite](er, bw))
  }

  [_onwrite] (er, bw) {
    if (er)
      this[_onerror](er)
    else {
      if (this[_pos] !== null)
        this[_pos] += bw
      if (this[_queue].length)
        this[_flush]()
      else {
        this[_writing] = false

        if (this[_ended] && !this[_finished]) {
          this[_finished] = true
          this[_close]()
          this.emit('finish')
        } else if (this[_needDrain]) {
          this[_needDrain] = false
          this.emit('drain')
        }
      }
    }
  }

  [_flush] () {
    if (this[_queue].length === 0) {
      if (this[_ended])
        this[_onwrite](null, 0)
    } else if (this[_queue].length === 1)
      this[_write](this[_queue].pop())
    else {
      const iovec = this[_queue]
      this[_queue] = []
      writev(this[_fd], iovec, this[_pos],
        (er, bw) => this[_onwrite](er, bw))
    }
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))
    }
  }
}

class WriteStreamSync extends WriteStream {
  [_open] () {
    let fd
    // only wrap in a try{} block if we know we'll retry, to avoid
    // the rethrow obscuring the error's source frame in most cases.
    if (this[_defaultFlag] && this[_flags] === 'r+') {
      try {
        fd = fs.openSync(this[_path], this[_flags], this[_mode])
      } catch (er) {
        if (er.code === 'ENOENT') {
          this[_flags] = 'w'
          return this[_open]()
        } else
          throw er
      }
    } else
      fd = fs.openSync(this[_path], this[_flags], this[_mode])

    this[_onopen](null, fd)
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.closeSync(fd)
      this.emit('close')
    }
  }

  [_write] (buf) {
    // throw the original, but try to close if it fails
    let threw = true
    try {
      this[_onwrite](null,
        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))
      threw = false
    } finally {
      if (threw)
        try { this[_close]() } catch (_) {}
    }
  }
}

exports.ReadStream = ReadStream
exports.ReadStreamSync = ReadStreamSync

exports.WriteStream = WriteStream
exports.WriteStreamSync = WriteStreamSync


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// XXX: This shares a lot in common with extract.js
// maybe some DRY opportunity here?

// tar -t
const hlo = __webpack_require__(357)
const Parser = __webpack_require__(376)
const fs = __webpack_require__(66)
const fsm = __webpack_require__(374)
const path = __webpack_require__(82)

const t = module.exports = (opt_, files, cb) => {
  if (typeof opt_ === 'function')
    cb = opt_, files = null, opt_ = {}
  else if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (typeof files === 'function')
    cb = files, files = null

  if (!files)
    files = []
  else
    files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  if (files.length)
    filesFilter(opt, files)

  if (!opt.noResume)
    onentryFunction(opt)

  return opt.file && opt.sync ? listFileSync(opt)
    : opt.file ? listFile(opt, cb)
    : list(opt)
}

const onentryFunction = opt => {
  const onentry = opt.onentry
  opt.onentry = onentry ? e => {
    onentry(e)
    e.resume()
  } : e => e.resume()
}

// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
  const map = new Map(files.map(f => [f.replace(/\/+$/, ''), true]))
  const filter = opt.filter

  const mapHas = (file, r) => {
    const root = r || path.parse(file).root || '.'
    const ret = file === root ? false
      : map.has(file) ? map.get(file)
      : mapHas(path.dirname(file), root)

    map.set(file, ret)
    return ret
  }

  opt.filter = filter
    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, ''))
    : file => mapHas(file.replace(/\/+$/, ''))
}

const listFileSync = opt => {
  const p = list(opt)
  const file = opt.file
  let threw = true
  let fd
  try {
    const stat = fs.statSync(file)
    const readSize = opt.maxReadSize || 16*1024*1024
    if (stat.size < readSize) {
      p.end(fs.readFileSync(file))
    } else {
      let pos = 0
      const buf = Buffer.allocUnsafe(readSize)
      fd = fs.openSync(file, 'r')
      while (pos < stat.size) {
        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)
        pos += bytesRead
        p.write(buf.slice(0, bytesRead))
      }
      p.end()
    }
    threw = false
  } finally {
    if (threw && fd)
      try { fs.closeSync(fd) } catch (er) {}
  }
}

const listFile = (opt, cb) => {
  const parse = new Parser(opt)
  const readSize = opt.maxReadSize || 16*1024*1024

  const file = opt.file
  const p = new Promise((resolve, reject) => {
    parse.on('error', reject)
    parse.on('end', resolve)

    fs.stat(file, (er, stat) => {
      if (er)
        reject(er)
      else {
        const stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size
        })
        stream.on('error', reject)
        stream.pipe(parse)
      }
    })
  })
  return cb ? p.then(cb, cb) : p
}

const list = opt => new Parser(opt)


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// this[BUFFER] is the remainder of a chunk if we're waiting for
// the full 512 bytes of a header to come in.  We will Buffer.concat()
// it to the next write(), which is a mem copy, but a small one.
//
// this[QUEUE] is a Yallist of entries that haven't been emitted
// yet this can only get filled up if the user keeps write()ing after
// a write() returns false, or does a write() with more than one entry
//
// We don't buffer chunks, we always parse them and either create an
// entry, or push it into the active entry.  The ReadEntry class knows
// to throw data away if .ignore=true
//
// Shift entry off the buffer when it emits 'end', and emit 'entry' for
// the next one in the list.
//
// At any time, we're pushing body chunks into the entry at WRITEENTRY,
// and waiting for 'end' on the entry at READENTRY
//
// ignored entries get .resume() called on them straight away

const warner = __webpack_require__(371)
const path = __webpack_require__(82)
const Header = __webpack_require__(369)
const EE = __webpack_require__(198)
const Yallist = __webpack_require__(360)
const maxMetaEntrySize = 1024 * 1024
const Entry = __webpack_require__(365)
const Pax = __webpack_require__(368)
const zlib = __webpack_require__(363)

const gzipHeader = Buffer.from([0x1f, 0x8b])
const STATE = Symbol('state')
const WRITEENTRY = Symbol('writeEntry')
const READENTRY = Symbol('readEntry')
const NEXTENTRY = Symbol('nextEntry')
const PROCESSENTRY = Symbol('processEntry')
const EX = Symbol('extendedHeader')
const GEX = Symbol('globalExtendedHeader')
const META = Symbol('meta')
const EMITMETA = Symbol('emitMeta')
const BUFFER = Symbol('buffer')
const QUEUE = Symbol('queue')
const ENDED = Symbol('ended')
const EMITTEDEND = Symbol('emittedEnd')
const EMIT = Symbol('emit')
const UNZIP = Symbol('unzip')
const CONSUMECHUNK = Symbol('consumeChunk')
const CONSUMECHUNKSUB = Symbol('consumeChunkSub')
const CONSUMEBODY = Symbol('consumeBody')
const CONSUMEMETA = Symbol('consumeMeta')
const CONSUMEHEADER = Symbol('consumeHeader')
const CONSUMING = Symbol('consuming')
const BUFFERCONCAT = Symbol('bufferConcat')
const MAYBEEND = Symbol('maybeEnd')
const WRITING = Symbol('writing')
const ABORTED = Symbol('aborted')
const DONE = Symbol('onDone')
const SAW_VALID_ENTRY = Symbol('sawValidEntry')
const SAW_NULL_BLOCK = Symbol('sawNullBlock')
const SAW_EOF = Symbol('sawEOF')

const noop = _ => true

module.exports = warner(class Parser extends EE {
  constructor (opt) {
    opt = opt || {}
    super(opt)

    this.file = opt.file || ''

    // set to boolean false when an entry starts.  1024 bytes of \0
    // is technically a valid tarball, albeit a boring one.
    this[SAW_VALID_ENTRY] = null

    // these BADARCHIVE errors can't be detected early. listen on DONE.
    this.on(DONE, _ => {
      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {
        // either less than 1 block of data, or all entries were invalid.
        // Either way, probably not even a tarball.
        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')
      }
    })

    if (opt.ondone)
      this.on(DONE, opt.ondone)
    else
      this.on(DONE, _ => {
        this.emit('prefinish')
        this.emit('finish')
        this.emit('end')
        this.emit('close')
      })

    this.strict = !!opt.strict
    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize
    this.filter = typeof opt.filter === 'function' ? opt.filter : noop

    // have to set this so that streams are ok piping into it
    this.writable = true
    this.readable = false

    this[QUEUE] = new Yallist()
    this[BUFFER] = null
    this[READENTRY] = null
    this[WRITEENTRY] = null
    this[STATE] = 'begin'
    this[META] = ''
    this[EX] = null
    this[GEX] = null
    this[ENDED] = false
    this[UNZIP] = null
    this[ABORTED] = false
    this[SAW_NULL_BLOCK] = false
    this[SAW_EOF] = false
    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)
    if (typeof opt.onentry === 'function')
      this.on('entry', opt.onentry)
  }

  [CONSUMEHEADER] (chunk, position) {
    if (this[SAW_VALID_ENTRY] === null)
      this[SAW_VALID_ENTRY] = false
    let header
    try {
      header = new Header(chunk, position, this[EX], this[GEX])
    } catch (er) {
      return this.warn('TAR_ENTRY_INVALID', er)
    }

    if (header.nullBlock) {
      if (this[SAW_NULL_BLOCK]) {
        this[SAW_EOF] = true
        // ending an archive with no entries.  pointless, but legal.
        if (this[STATE] === 'begin')
          this[STATE] = 'header'
        this[EMIT]('eof')
      } else {
        this[SAW_NULL_BLOCK] = true
        this[EMIT]('nullBlock')
      }
    } else {
      this[SAW_NULL_BLOCK] = false
      if (!header.cksumValid)
        this.warn('TAR_ENTRY_INVALID', 'checksum failure', {header})
      else if (!header.path)
        this.warn('TAR_ENTRY_INVALID', 'path is required', {header})
      else {
        const type = header.type
        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {header})
        else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {header})
        else {
          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])

          // we do this for meta & ignored entries as well, because they
          // are still valid tar, or else we wouldn't know to ignore them
          if (!this[SAW_VALID_ENTRY]) {
            if (entry.remain) {
              // this might be the one!
              const onend = () => {
                if (!entry.invalid)
                  this[SAW_VALID_ENTRY] = true
              }
              entry.on('end', onend)
            } else {
              this[SAW_VALID_ENTRY] = true
            }
          }

          if (entry.meta) {
            if (entry.size > this.maxMetaEntrySize) {
              entry.ignore = true
              this[EMIT]('ignoredEntry', entry)
              this[STATE] = 'ignore'
              entry.resume()
            } else if (entry.size > 0) {
              this[META] = ''
              entry.on('data', c => this[META] += c)
              this[STATE] = 'meta'
            }
          } else {
            this[EX] = null
            entry.ignore = entry.ignore || !this.filter(entry.path, entry)

            if (entry.ignore) {
              // probably valid, just not something we care about
              this[EMIT]('ignoredEntry', entry)
              this[STATE] = entry.remain ? 'ignore' : 'header'
              entry.resume()
            } else {
              if (entry.remain)
                this[STATE] = 'body'
              else {
                this[STATE] = 'header'
                entry.end()
              }

              if (!this[READENTRY]) {
                this[QUEUE].push(entry)
                this[NEXTENTRY]()
              } else
                this[QUEUE].push(entry)
            }
          }
        }
      }
    }
  }

  [PROCESSENTRY] (entry) {
    let go = true

    if (!entry) {
      this[READENTRY] = null
      go = false
    } else if (Array.isArray(entry))
      this.emit.apply(this, entry)
    else {
      this[READENTRY] = entry
      this.emit('entry', entry)
      if (!entry.emittedEnd) {
        entry.on('end', _ => this[NEXTENTRY]())
        go = false
      }
    }

    return go
  }

  [NEXTENTRY] () {
    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))

    if (!this[QUEUE].length) {
      // At this point, there's nothing in the queue, but we may have an
      // entry which is being consumed (readEntry).
      // If we don't, then we definitely can handle more data.
      // If we do, and either it's flowing, or it has never had any data
      // written to it, then it needs more.
      // The only other possibility is that it has returned false from a
      // write() call, so we wait for the next drain to continue.
      const re = this[READENTRY]
      const drainNow = !re || re.flowing || re.size === re.remain
      if (drainNow) {
        if (!this[WRITING])
          this.emit('drain')
      } else
        re.once('drain', _ => this.emit('drain'))
     }
  }

  [CONSUMEBODY] (chunk, position) {
    // write up to but no  more than writeEntry.blockRemain
    const entry = this[WRITEENTRY]
    const br = entry.blockRemain
    const c = (br >= chunk.length && position === 0) ? chunk
      : chunk.slice(position, position + br)

    entry.write(c)

    if (!entry.blockRemain) {
      this[STATE] = 'header'
      this[WRITEENTRY] = null
      entry.end()
    }

    return c.length
  }

  [CONSUMEMETA] (chunk, position) {
    const entry = this[WRITEENTRY]
    const ret = this[CONSUMEBODY](chunk, position)

    // if we finished, then the entry is reset
    if (!this[WRITEENTRY])
      this[EMITMETA](entry)

    return ret
  }

  [EMIT] (ev, data, extra) {
    if (!this[QUEUE].length && !this[READENTRY])
      this.emit(ev, data, extra)
    else
      this[QUEUE].push([ev, data, extra])
  }

  [EMITMETA] (entry) {
    this[EMIT]('meta', this[META])
    switch (entry.type) {
      case 'ExtendedHeader':
      case 'OldExtendedHeader':
        this[EX] = Pax.parse(this[META], this[EX], false)
        break

      case 'GlobalExtendedHeader':
        this[GEX] = Pax.parse(this[META], this[GEX], true)
        break

      case 'NextFileHasLongPath':
      case 'OldGnuLongPath':
        this[EX] = this[EX] || Object.create(null)
        this[EX].path = this[META].replace(/\0.*/, '')
        break

      case 'NextFileHasLongLinkpath':
        this[EX] = this[EX] || Object.create(null)
        this[EX].linkpath = this[META].replace(/\0.*/, '')
        break

      /* istanbul ignore next */
      default: throw new Error('unknown meta: ' + entry.type)
    }
  }

  abort (error) {
    this[ABORTED] = true
    this.emit('abort', error)
    // always throws, even in non-strict mode
    this.warn('TAR_ABORT', error, { recoverable: false })
  }

  write (chunk) {
    if (this[ABORTED])
      return

    // first write, might be gzipped
    if (this[UNZIP] === null && chunk) {
      if (this[BUFFER]) {
        chunk = Buffer.concat([this[BUFFER], chunk])
        this[BUFFER] = null
      }
      if (chunk.length < gzipHeader.length) {
        this[BUFFER] = chunk
        return true
      }
      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
        if (chunk[i] !== gzipHeader[i])
          this[UNZIP] = false
      }
      if (this[UNZIP] === null) {
        const ended = this[ENDED]
        this[ENDED] = false
        this[UNZIP] = new zlib.Unzip()
        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))
        this[UNZIP].on('error', er => this.abort(er))
        this[UNZIP].on('end', _ => {
          this[ENDED] = true
          this[CONSUMECHUNK]()
        })
        this[WRITING] = true
        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)
        this[WRITING] = false
        return ret
      }
    }

    this[WRITING] = true
    if (this[UNZIP])
      this[UNZIP].write(chunk)
    else
      this[CONSUMECHUNK](chunk)
    this[WRITING] = false

    // return false if there's a queue, or if the current entry isn't flowing
    const ret =
      this[QUEUE].length ? false :
      this[READENTRY] ? this[READENTRY].flowing :
      true

    // if we have no queue, then that means a clogged READENTRY
    if (!ret && !this[QUEUE].length)
      this[READENTRY].once('drain', _ => this.emit('drain'))

    return ret
  }

  [BUFFERCONCAT] (c) {
    if (c && !this[ABORTED])
      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c
  }

  [MAYBEEND] () {
    if (this[ENDED] &&
        !this[EMITTEDEND] &&
        !this[ABORTED] &&
        !this[CONSUMING]) {
      this[EMITTEDEND] = true
      const entry = this[WRITEENTRY]
      if (entry && entry.blockRemain) {
        // truncated, likely a damaged file
        const have = this[BUFFER] ? this[BUFFER].length : 0
        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${
          entry.blockRemain} more bytes, only ${have} available)`, {entry})
        if (this[BUFFER])
          entry.write(this[BUFFER])
        entry.end()
      }
      this[EMIT](DONE)
    }
  }

  [CONSUMECHUNK] (chunk) {
    if (this[CONSUMING])
      this[BUFFERCONCAT](chunk)
    else if (!chunk && !this[BUFFER])
      this[MAYBEEND]()
    else {
      this[CONSUMING] = true
      if (this[BUFFER]) {
        this[BUFFERCONCAT](chunk)
        const c = this[BUFFER]
        this[BUFFER] = null
        this[CONSUMECHUNKSUB](c)
      } else {
        this[CONSUMECHUNKSUB](chunk)
      }

      while (this[BUFFER] &&
          this[BUFFER].length >= 512 &&
          !this[ABORTED] &&
          !this[SAW_EOF]) {
        const c = this[BUFFER]
        this[BUFFER] = null
        this[CONSUMECHUNKSUB](c)
      }
      this[CONSUMING] = false
    }

    if (!this[BUFFER] || this[ENDED])
      this[MAYBEEND]()
  }

  [CONSUMECHUNKSUB] (chunk) {
    // we know that we are in CONSUMING mode, so anything written goes into
    // the buffer.  Advance the position and put any remainder in the buffer.
    let position = 0
    let length = chunk.length
    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
      switch (this[STATE]) {
        case 'begin':
        case 'header':
          this[CONSUMEHEADER](chunk, position)
          position += 512
          break

        case 'ignore':
        case 'body':
          position += this[CONSUMEBODY](chunk, position)
          break

        case 'meta':
          position += this[CONSUMEMETA](chunk, position)
          break

        /* istanbul ignore next */
        default:
          throw new Error('invalid state: ' + this[STATE])
      }
    }

    if (position < length) {
      if (this[BUFFER])
        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])
      else
        this[BUFFER] = chunk.slice(position)
    }
  }

  end (chunk) {
    if (!this[ABORTED]) {
      if (this[UNZIP])
        this[UNZIP].end(chunk)
      else {
        this[ENDED] = true
        this.write(chunk)
      }
    }
  }
})


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// tar -r
const hlo = __webpack_require__(357)
const Pack = __webpack_require__(358)
const Parse = __webpack_require__(376)
const fs = __webpack_require__(66)
const fsm = __webpack_require__(374)
const t = __webpack_require__(375)
const path = __webpack_require__(82)

// starting at the head of the file, read a Header
// If the checksum is invalid, that's our position to start writing
// If it is, jump forward by the specified size (round up to 512)
// and try again.
// Write the new Pack stream starting there.

const Header = __webpack_require__(369)

const r = module.exports = (opt_, files, cb) => {
  const opt = hlo(opt_)

  if (!opt.file)
    throw new TypeError('file is required')

  if (opt.gzip)
    throw new TypeError('cannot append to compressed archives')

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  return opt.sync ? replaceSync(opt, files)
    : replace(opt, files, cb)
}

const replaceSync = (opt, files) => {
  const p = new Pack.Sync(opt)

  let threw = true
  let fd
  let position

  try {
    try {
      fd = fs.openSync(opt.file, 'r+')
    } catch (er) {
      if (er.code === 'ENOENT')
        fd = fs.openSync(opt.file, 'w+')
      else
        throw er
    }

    const st = fs.fstatSync(fd)
    const headBuf = Buffer.alloc(512)

    POSITION: for (position = 0; position < st.size; position += 512) {
      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
        bytes = fs.readSync(
          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos
        )

        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)
          throw new Error('cannot append to compressed archives')

        if (!bytes)
          break POSITION
      }

      let h = new Header(headBuf)
      if (!h.cksumValid)
        break
      let entryBlockSize = 512 * Math.ceil(h.size / 512)
      if (position + entryBlockSize + 512 > st.size)
        break
      // the 512 for the header we just parsed will be added as well
      // also jump ahead all the blocks for the body
      position += entryBlockSize
      if (opt.mtimeCache)
        opt.mtimeCache.set(h.path, h.mtime)
    }
    threw = false

    streamSync(opt, p, position, fd, files)
  } finally {
    if (threw)
      try { fs.closeSync(fd) } catch (er) {}
  }
}

const streamSync = (opt, p, position, fd, files) => {
  const stream = new fsm.WriteStreamSync(opt.file, {
    fd: fd,
    start: position
  })
  p.pipe(stream)
  addFilesSync(p, files)
}

const replace = (opt, files, cb) => {
  files = Array.from(files)
  const p = new Pack(opt)

  const getPos = (fd, size, cb_) => {
    const cb = (er, pos) => {
      if (er)
        fs.close(fd, _ => cb_(er))
      else
        cb_(null, pos)
    }

    let position = 0
    if (size === 0)
      return cb(null, 0)

    let bufPos = 0
    const headBuf = Buffer.alloc(512)
    const onread = (er, bytes) => {
      if (er)
        return cb(er)
      bufPos += bytes
      if (bufPos < 512 && bytes)
        return fs.read(
          fd, headBuf, bufPos, headBuf.length - bufPos,
          position + bufPos, onread
        )

      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)
        return cb(new Error('cannot append to compressed archives'))

      // truncated header
      if (bufPos < 512)
        return cb(null, position)

      const h = new Header(headBuf)
      if (!h.cksumValid)
        return cb(null, position)

      const entryBlockSize = 512 * Math.ceil(h.size / 512)
      if (position + entryBlockSize + 512 > size)
        return cb(null, position)

      position += entryBlockSize + 512
      if (position >= size)
        return cb(null, position)

      if (opt.mtimeCache)
        opt.mtimeCache.set(h.path, h.mtime)
      bufPos = 0
      fs.read(fd, headBuf, 0, 512, position, onread)
    }
    fs.read(fd, headBuf, 0, 512, position, onread)
  }

  const promise = new Promise((resolve, reject) => {
    p.on('error', reject)
    let flag = 'r+'
    const onopen = (er, fd) => {
      if (er && er.code === 'ENOENT' && flag === 'r+') {
        flag = 'w+'
        return fs.open(opt.file, flag, onopen)
      }

      if (er)
        return reject(er)

      fs.fstat(fd, (er, st) => {
        if (er)
          return reject(er)
        getPos(fd, st.size, (er, position) => {
          if (er)
            return reject(er)
          const stream = new fsm.WriteStream(opt.file, {
            fd: fd,
            start: position
          })
          p.pipe(stream)
          stream.on('error', reject)
          stream.on('close', resolve)
          addFilesAsync(p, files)
        })
      })
    }
    fs.open(opt.file, flag, onopen)
  })

  return cb ? promise.then(cb, cb) : promise
}

const addFilesSync = (p, files) => {
  files.forEach(file => {
    if (file.charAt(0) === '@')
      t({
        file: path.resolve(p.cwd, file.substr(1)),
        sync: true,
        noResume: true,
        onentry: entry => p.add(entry)
      })
    else
      p.add(file)
  })
  p.end()
}

const addFilesAsync = (p, files) => {
  while (files.length) {
    const file = files.shift()
    if (file.charAt(0) === '@')
      return t({
        file: path.resolve(p.cwd, file.substr(1)),
        noResume: true,
        onentry: entry => p.add(entry)
      }).then(_ => addFilesAsync(p, files))
    else
      p.add(file)
  }
  p.end()
}


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// tar -u

const hlo = __webpack_require__(357)
const r = __webpack_require__(377)
// just call tar.r with the filter and mtimeCache

const u = module.exports = (opt_, files, cb) => {
  const opt = hlo(opt_)

  if (!opt.file)
    throw new TypeError('file is required')

  if (opt.gzip)
    throw new TypeError('cannot append to compressed archives')

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  mtimeFilter(opt)
  return r(opt, files, cb)
}

const mtimeFilter = opt => {
  const filter = opt.filter

  if (!opt.mtimeCache)
    opt.mtimeCache = new Map()

  opt.filter = filter ? (path, stat) =>
    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)
    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)
}


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// tar -x
const hlo = __webpack_require__(357)
const Unpack = __webpack_require__(380)
const fs = __webpack_require__(66)
const fsm = __webpack_require__(374)
const path = __webpack_require__(82)

const x = module.exports = (opt_, files, cb) => {
  if (typeof opt_ === 'function')
    cb = opt_, files = null, opt_ = {}
  else if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (typeof files === 'function')
    cb = files, files = null

  if (!files)
    files = []
  else
    files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  if (files.length)
    filesFilter(opt, files)

  return opt.file && opt.sync ? extractFileSync(opt)
    : opt.file ? extractFile(opt, cb)
    : opt.sync ? extractSync(opt)
    : extract(opt)
}

// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
  const map = new Map(files.map(f => [f.replace(/\/+$/, ''), true]))
  const filter = opt.filter

  const mapHas = (file, r) => {
    const root = r || path.parse(file).root || '.'
    const ret = file === root ? false
      : map.has(file) ? map.get(file)
      : mapHas(path.dirname(file), root)

    map.set(file, ret)
    return ret
  }

  opt.filter = filter
    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, ''))
    : file => mapHas(file.replace(/\/+$/, ''))
}

const extractFileSync = opt => {
  const u = new Unpack.Sync(opt)

  const file = opt.file
  let threw = true
  let fd
  const stat = fs.statSync(file)
  // This trades a zero-byte read() syscall for a stat
  // However, it will usually result in less memory allocation
  const readSize = opt.maxReadSize || 16*1024*1024
  const stream = new fsm.ReadStreamSync(file, {
    readSize: readSize,
    size: stat.size
  })
  stream.pipe(u)
}

const extractFile = (opt, cb) => {
  const u = new Unpack(opt)
  const readSize = opt.maxReadSize || 16*1024*1024

  const file = opt.file
  const p = new Promise((resolve, reject) => {
    u.on('error', reject)
    u.on('close', resolve)

    // This trades a zero-byte read() syscall for a stat
    // However, it will usually result in less memory allocation
    fs.stat(file, (er, stat) => {
      if (er)
        reject(er)
      else {
        const stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size
        })
        stream.on('error', reject)
        stream.pipe(u)
      }
    })
  })
  return cb ? p.then(cb, cb) : p
}

const extractSync = opt => {
  return new Unpack.Sync(opt)
}

const extract = opt => {
  return new Unpack(opt)
}


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.
// but the path reservations are required to avoid race conditions where
// parallelized unpack ops may mess with one another, due to dependencies
// (like a Link depending on its target) or destructive operations (like
// clobbering an fs object to create one of a different type.)

const assert = __webpack_require__(108)
const EE = __webpack_require__(198).EventEmitter
const Parser = __webpack_require__(376)
const fs = __webpack_require__(66)
const fsm = __webpack_require__(374)
const path = __webpack_require__(82)
const mkdir = __webpack_require__(381)
const mkdirSync = mkdir.sync
const wc = __webpack_require__(372)
const pathReservations = __webpack_require__(383)

const ONENTRY = Symbol('onEntry')
const CHECKFS = Symbol('checkFs')
const CHECKFS2 = Symbol('checkFs2')
const ISREUSABLE = Symbol('isReusable')
const MAKEFS = Symbol('makeFs')
const FILE = Symbol('file')
const DIRECTORY = Symbol('directory')
const LINK = Symbol('link')
const SYMLINK = Symbol('symlink')
const HARDLINK = Symbol('hardlink')
const UNSUPPORTED = Symbol('unsupported')
const UNKNOWN = Symbol('unknown')
const CHECKPATH = Symbol('checkPath')
const MKDIR = Symbol('mkdir')
const ONERROR = Symbol('onError')
const PENDING = Symbol('pending')
const PEND = Symbol('pend')
const UNPEND = Symbol('unpend')
const ENDED = Symbol('ended')
const MAYBECLOSE = Symbol('maybeClose')
const SKIP = Symbol('skip')
const DOCHOWN = Symbol('doChown')
const UID = Symbol('uid')
const GID = Symbol('gid')
const crypto = __webpack_require__(221)
const getFlag = __webpack_require__(384)

/* istanbul ignore next */
const neverCalled = () => {
  throw new Error('sync function called cb somehow?!?')
}

// Unlinks on Windows are not atomic.
//
// This means that if you have a file entry, followed by another
// file entry with an identical name, and you cannot re-use the file
// (because it's a hardlink, or because unlink:true is set, or it's
// Windows, which does not have useful nlink values), then the unlink
// will be committed to the disk AFTER the new file has been written
// over the old one, deleting the new file.
//
// To work around this, on Windows systems, we rename the file and then
// delete the renamed file.  It's a sloppy kludge, but frankly, I do not
// know of a better way to do this, given windows' non-atomic unlink
// semantics.
//
// See: https://github.com/npm/node-tar/issues/183
/* istanbul ignore next */
const unlinkFile = (path, cb) => {
  if (process.platform !== 'win32')
    return fs.unlink(path, cb)

  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
  fs.rename(path, name, er => {
    if (er)
      return cb(er)
    fs.unlink(name, cb)
  })
}

/* istanbul ignore next */
const unlinkFileSync = path => {
  if (process.platform !== 'win32')
    return fs.unlinkSync(path)

  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
  fs.renameSync(path, name)
  fs.unlinkSync(name)
}

// this.gid, entry.gid, this.processUid
const uint32 = (a, b, c) =>
  a === a >>> 0 ? a
  : b === b >>> 0 ? b
  : c

class Unpack extends Parser {
  constructor (opt) {
    if (!opt)
      opt = {}

    opt.ondone = _ => {
      this[ENDED] = true
      this[MAYBECLOSE]()
    }

    super(opt)

    this.reservations = pathReservations()

    this.transform = typeof opt.transform === 'function' ? opt.transform : null

    this.writable = true
    this.readable = false

    this[PENDING] = 0
    this[ENDED] = false

    this.dirCache = opt.dirCache || new Map()

    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {
      // need both or neither
      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')
        throw new TypeError('cannot set owner without number uid and gid')
      if (opt.preserveOwner)
        throw new TypeError(
          'cannot preserve owner in archive and also set owner explicitly')
      this.uid = opt.uid
      this.gid = opt.gid
      this.setOwner = true
    } else {
      this.uid = null
      this.gid = null
      this.setOwner = false
    }

    // default true for root
    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')
      this.preserveOwner = process.getuid && process.getuid() === 0
    else
      this.preserveOwner = !!opt.preserveOwner

    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?
      process.getuid() : null
    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?
      process.getgid() : null

    // mostly just for testing, but useful in some cases.
    // Forcibly trigger a chown on every entry, no matter what
    this.forceChown = opt.forceChown === true

    // turn ><?| in filenames into 0xf000-higher encoded forms
    this.win32 = !!opt.win32 || process.platform === 'win32'

    // do not unpack over files that are newer than what's in the archive
    this.newer = !!opt.newer

    // do not unpack over ANY files
    this.keep = !!opt.keep

    // do not set mtime/atime of extracted entries
    this.noMtime = !!opt.noMtime

    // allow .., absolute path entries, and unpacking through symlinks
    // without this, warn and skip .., relativize absolutes, and error
    // on symlinks in extraction path
    this.preservePaths = !!opt.preservePaths

    // unlink files and links before writing. This breaks existing hard
    // links, and removes symlink directories rather than erroring
    this.unlink = !!opt.unlink

    this.cwd = path.resolve(opt.cwd || process.cwd())
    this.strip = +opt.strip || 0
    this.processUmask = process.umask()
    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask
    // default mode for dirs created as parents
    this.dmode = opt.dmode || (0o0777 & (~this.umask))
    this.fmode = opt.fmode || (0o0666 & (~this.umask))
    this.on('entry', entry => this[ONENTRY](entry))
  }

  // a bad or damaged archive is a warning for Parser, but an error
  // when extracting.  Mark those errors as unrecoverable, because
  // the Unpack contract cannot be met.
  warn (code, msg, data = {}) {
    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT')
      data.recoverable = false
    return super.warn(code, msg, data)
  }

  [MAYBECLOSE] () {
    if (this[ENDED] && this[PENDING] === 0) {
      this.emit('prefinish')
      this.emit('finish')
      this.emit('end')
      this.emit('close')
    }
  }

  [CHECKPATH] (entry) {
    if (this.strip) {
      const parts = entry.path.split(/\/|\\/)
      if (parts.length < this.strip)
        return false
      entry.path = parts.slice(this.strip).join('/')

      if (entry.type === 'Link') {
        const linkparts = entry.linkpath.split(/\/|\\/)
        if (linkparts.length >= this.strip)
          entry.linkpath = linkparts.slice(this.strip).join('/')
      }
    }

    if (!this.preservePaths) {
      const p = entry.path
      if (p.match(/(^|\/|\\)\.\.(\\|\/|$)/)) {
        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {
          entry,
          path: p,
        })
        return false
      }

      // absolutes on posix are also absolutes on win32
      // so we only need to test this one to get both
      if (path.win32.isAbsolute(p)) {
        const parsed = path.win32.parse(p)
        entry.path = p.substr(parsed.root.length)
        const r = parsed.root
        this.warn('TAR_ENTRY_INFO', `stripping ${r} from absolute path`, {
          entry,
          path: p,
        })
      }
    }

    // only encode : chars that aren't drive letter indicators
    if (this.win32) {
      const parsed = path.win32.parse(entry.path)
      entry.path = parsed.root === '' ? wc.encode(entry.path)
        : parsed.root + wc.encode(entry.path.substr(parsed.root.length))
    }

    if (path.isAbsolute(entry.path))
      entry.absolute = entry.path
    else
      entry.absolute = path.resolve(this.cwd, entry.path)

    return true
  }

  [ONENTRY] (entry) {
    if (!this[CHECKPATH](entry))
      return entry.resume()

    assert.equal(typeof entry.absolute, 'string')

    switch (entry.type) {
      case 'Directory':
      case 'GNUDumpDir':
        if (entry.mode)
          entry.mode = entry.mode | 0o700

      case 'File':
      case 'OldFile':
      case 'ContiguousFile':
      case 'Link':
      case 'SymbolicLink':
        return this[CHECKFS](entry)

      case 'CharacterDevice':
      case 'BlockDevice':
      case 'FIFO':
        return this[UNSUPPORTED](entry)
    }
  }

  [ONERROR] (er, entry) {
    // Cwd has to exist, or else nothing works. That's serious.
    // Other errors are warnings, which raise the error in strict
    // mode, but otherwise continue on.
    if (er.name === 'CwdError')
      this.emit('error', er)
    else {
      this.warn('TAR_ENTRY_ERROR', er, {entry})
      this[UNPEND]()
      entry.resume()
    }
  }

  [MKDIR] (dir, mode, cb) {
    mkdir(dir, {
      uid: this.uid,
      gid: this.gid,
      processUid: this.processUid,
      processGid: this.processGid,
      umask: this.processUmask,
      preserve: this.preservePaths,
      unlink: this.unlink,
      cache: this.dirCache,
      cwd: this.cwd,
      mode: mode
    }, cb)
  }

  [DOCHOWN] (entry) {
    // in preserve owner mode, chown if the entry doesn't match process
    // in set owner mode, chown if setting doesn't match process
    return this.forceChown ||
      this.preserveOwner &&
      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||
        typeof entry.gid === 'number' && entry.gid !== this.processGid )
      ||
      ( typeof this.uid === 'number' && this.uid !== this.processUid ||
        typeof this.gid === 'number' && this.gid !== this.processGid )
  }

  [UID] (entry) {
    return uint32(this.uid, entry.uid, this.processUid)
  }

  [GID] (entry) {
    return uint32(this.gid, entry.gid, this.processGid)
  }

  [FILE] (entry, fullyDone) {
    const mode = entry.mode & 0o7777 || this.fmode
    const stream = new fsm.WriteStream(entry.absolute, {
      flags: getFlag(entry.size),
      mode: mode,
      autoClose: false
    })
    stream.on('error', er => this[ONERROR](er, entry))

    let actions = 1
    const done = er => {
      if (er)
        return this[ONERROR](er, entry)

      if (--actions === 0) {
        fs.close(stream.fd, er => {
          fullyDone()
          er ? this[ONERROR](er, entry) : this[UNPEND]()
        })
      }
    }

    stream.on('finish', _ => {
      // if futimes fails, try utimes
      // if utimes fails, fail with the original error
      // same for fchown/chown
      const abs = entry.absolute
      const fd = stream.fd

      if (entry.mtime && !this.noMtime) {
        actions++
        const atime = entry.atime || new Date()
        const mtime = entry.mtime
        fs.futimes(fd, atime, mtime, er =>
          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))
          : done())
      }

      if (this[DOCHOWN](entry)) {
        actions++
        const uid = this[UID](entry)
        const gid = this[GID](entry)
        fs.fchown(fd, uid, gid, er =>
          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))
          : done())
      }

      done()
    })

    const tx = this.transform ? this.transform(entry) || entry : entry
    if (tx !== entry) {
      tx.on('error', er => this[ONERROR](er, entry))
      entry.pipe(tx)
    }
    tx.pipe(stream)
  }

  [DIRECTORY] (entry, fullyDone) {
    const mode = entry.mode & 0o7777 || this.dmode
    this[MKDIR](entry.absolute, mode, er => {
      if (er) {
        fullyDone()
        return this[ONERROR](er, entry)
      }

      let actions = 1
      const done = _ => {
        if (--actions === 0) {
          fullyDone()
          this[UNPEND]()
          entry.resume()
        }
      }

      if (entry.mtime && !this.noMtime) {
        actions++
        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)
      }

      if (this[DOCHOWN](entry)) {
        actions++
        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)
      }

      done()
    })
  }

  [UNSUPPORTED] (entry) {
    entry.unsupported = true
    this.warn('TAR_ENTRY_UNSUPPORTED',
      `unsupported entry type: ${entry.type}`, {entry})
    entry.resume()
  }

  [SYMLINK] (entry, done) {
    this[LINK](entry, entry.linkpath, 'symlink', done)
  }

  [HARDLINK] (entry, done) {
    this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link', done)
  }

  [PEND] () {
    this[PENDING]++
  }

  [UNPEND] () {
    this[PENDING]--
    this[MAYBECLOSE]()
  }

  [SKIP] (entry) {
    this[UNPEND]()
    entry.resume()
  }

  // Check if we can reuse an existing filesystem entry safely and
  // overwrite it, rather than unlinking and recreating
  // Windows doesn't report a useful nlink, so we just never reuse entries
  [ISREUSABLE] (entry, st) {
    return entry.type === 'File' &&
      !this.unlink &&
      st.isFile() &&
      st.nlink <= 1 &&
      process.platform !== 'win32'
  }

  // check if a thing is there, and if so, try to clobber it
  [CHECKFS] (entry) {
    this[PEND]()
    const paths = [entry.path]
    if (entry.linkpath)
      paths.push(entry.linkpath)
    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))
  }
  [CHECKFS2] (entry, done) {
    this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {
      if (er) {
        done()
        return this[ONERROR](er, entry)
      }
      fs.lstat(entry.absolute, (er, st) => {
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          this[SKIP](entry)
          done()
        } else if (er || this[ISREUSABLE](entry, st)) {
          this[MAKEFS](null, entry, done)
        }
        else if (st.isDirectory()) {
          if (entry.type === 'Directory') {
            if (!entry.mode || (st.mode & 0o7777) === entry.mode)
              this[MAKEFS](null, entry, done)
            else
              fs.chmod(entry.absolute, entry.mode,
                er => this[MAKEFS](er, entry, done))
          } else
            fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry, done))
        } else
          unlinkFile(entry.absolute, er => this[MAKEFS](er, entry, done))
      })
    })
  }

  [MAKEFS] (er, entry, done) {
    if (er)
      return this[ONERROR](er, entry)

    switch (entry.type) {
      case 'File':
      case 'OldFile':
      case 'ContiguousFile':
        return this[FILE](entry, done)

      case 'Link':
        return this[HARDLINK](entry, done)

      case 'SymbolicLink':
        return this[SYMLINK](entry, done)

      case 'Directory':
      case 'GNUDumpDir':
        return this[DIRECTORY](entry, done)
    }
  }

  [LINK] (entry, linkpath, link, done) {
    // XXX: get the type ('file' or 'dir') for windows
    fs[link](linkpath, entry.absolute, er => {
      if (er)
        return this[ONERROR](er, entry)
      done()
      this[UNPEND]()
      entry.resume()
    })
  }
}

class UnpackSync extends Unpack {
  constructor (opt) {
    super(opt)
  }

  [CHECKFS] (entry) {
    const er = this[MKDIR](path.dirname(entry.absolute), this.dmode, neverCalled)
    if (er)
      return this[ONERROR](er, entry)
    try {
      const st = fs.lstatSync(entry.absolute)
      if (this.keep || this.newer && st.mtime > entry.mtime)
        return this[SKIP](entry)
      else if (this[ISREUSABLE](entry, st))
        return this[MAKEFS](null, entry, neverCalled)
      else {
        try {
          if (st.isDirectory()) {
            if (entry.type === 'Directory') {
              if (entry.mode && (st.mode & 0o7777) !== entry.mode)
                fs.chmodSync(entry.absolute, entry.mode)
            } else
              fs.rmdirSync(entry.absolute)
          } else
            unlinkFileSync(entry.absolute)
          return this[MAKEFS](null, entry, neverCalled)
        } catch (er) {
          return this[ONERROR](er, entry)
        }
      }
    } catch (er) {
      return this[MAKEFS](null, entry, neverCalled)
    }
  }

  [FILE] (entry, _) {
    const mode = entry.mode & 0o7777 || this.fmode

    const oner = er => {
      let closeError
      try {
        fs.closeSync(fd)
      } catch (e) {
        closeError = e
      }
      if (er || closeError)
        this[ONERROR](er || closeError, entry)
    }

    let stream
    let fd
    try {
      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)
    } catch (er) {
      return oner(er)
    }
    const tx = this.transform ? this.transform(entry) || entry : entry
    if (tx !== entry) {
      tx.on('error', er => this[ONERROR](er, entry))
      entry.pipe(tx)
    }

    tx.on('data', chunk => {
      try {
        fs.writeSync(fd, chunk, 0, chunk.length)
      } catch (er) {
        oner(er)
      }
    })

    tx.on('end', _ => {
      let er = null
      // try both, falling futimes back to utimes
      // if either fails, handle the first error
      if (entry.mtime && !this.noMtime) {
        const atime = entry.atime || new Date()
        const mtime = entry.mtime
        try {
          fs.futimesSync(fd, atime, mtime)
        } catch (futimeser) {
          try {
            fs.utimesSync(entry.absolute, atime, mtime)
          } catch (utimeser) {
            er = futimeser
          }
        }
      }

      if (this[DOCHOWN](entry)) {
        const uid = this[UID](entry)
        const gid = this[GID](entry)

        try {
          fs.fchownSync(fd, uid, gid)
        } catch (fchowner) {
          try {
            fs.chownSync(entry.absolute, uid, gid)
          } catch (chowner) {
            er = er || fchowner
          }
        }
      }

      oner(er)
    })
  }

  [DIRECTORY] (entry, _) {
    const mode = entry.mode & 0o7777 || this.dmode
    const er = this[MKDIR](entry.absolute, mode)
    if (er)
      return this[ONERROR](er, entry)
    if (entry.mtime && !this.noMtime) {
      try {
        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)
      } catch (er) {}
    }
    if (this[DOCHOWN](entry)) {
      try {
        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))
      } catch (er) {}
    }
    entry.resume()
  }

  [MKDIR] (dir, mode) {
    try {
      return mkdir.sync(dir, {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode
      })
    } catch (er) {
      return er
    }
  }

  [LINK] (entry, linkpath, link, _) {
    try {
      fs[link + 'Sync'](linkpath, entry.absolute)
      entry.resume()
    } catch (er) {
      return this[ONERROR](er, entry)
    }
  }
}

Unpack.Sync = UnpackSync
module.exports = Unpack


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// wrapper around mkdirp for tar's needs.

// TODO: This should probably be a class, not functionally
// passing around state in a gazillion args.

const mkdirp = __webpack_require__(260)
const fs = __webpack_require__(66)
const path = __webpack_require__(82)
const chownr = __webpack_require__(382)

class SymlinkError extends Error {
  constructor (symlink, path) {
    super('Cannot extract through symbolic link')
    this.path = path
    this.symlink = symlink
  }

  get name () {
    return 'SylinkError'
  }
}

class CwdError extends Error {
  constructor (path, code) {
    super(code + ': Cannot cd into \'' + path + '\'')
    this.path = path
    this.code = code
  }

  get name () {
    return 'CwdError'
  }
}

const mkdir = module.exports = (dir, opt, cb) => {
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    ( uid !== opt.processUid || gid !== opt.processGid )

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
  const cwd = opt.cwd

  const done = (er, created) => {
    if (er)
      cb(er)
    else {
      cache.set(dir, true)
      if (created && doChown)
        chownr(created, uid, gid, er => done(er))
      else if (needChmod)
        fs.chmod(dir, mode, cb)
      else
        cb()
    }
  }

  if (cache && cache.get(dir) === true)
    return done()

  if (dir === cwd)
    return fs.stat(dir, (er, st) => {
      if (er || !st.isDirectory())
        er = new CwdError(dir, er && er.code || 'ENOTDIR')
      done(er)
    })

  if (preserve)
    return mkdirp(dir, {mode}).then(made => done(null, made), done)

  const sub = path.relative(cwd, dir)
  const parts = sub.split(/\/|\\/)
  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)
}

const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length)
    return cb(null, created)
  const p = parts.shift()
  const part = base + '/' + p
  if (cache.get(part))
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
}

const onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {
  if (er) {
    if (er.path && path.dirname(er.path) === cwd &&
        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
      return cb(new CwdError(cwd, er.code))

    fs.lstat(part, (statEr, st) => {
      if (statEr)
        cb(statEr)
      else if (st.isDirectory())
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
      else if (unlink)
        fs.unlink(part, er => {
          if (er)
            return cb(er)
          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
        })
      else if (st.isSymbolicLink())
        return cb(new SymlinkError(part, part + '/' + parts.join('/')))
      else
        cb(er)
    })
  } else {
    created = created || part
    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  }
}

const mkdirSync = module.exports.sync = (dir, opt) => {
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    ( uid !== opt.processUid || gid !== opt.processGid )

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
  const cwd = opt.cwd

  const done = (created) => {
    cache.set(dir, true)
    if (created && doChown)
      chownr.sync(created, uid, gid)
    if (needChmod)
      fs.chmodSync(dir, mode)
  }

  if (cache && cache.get(dir) === true)
    return done()

  if (dir === cwd) {
    let ok = false
    let code = 'ENOTDIR'
    try {
      ok = fs.statSync(dir).isDirectory()
    } catch (er) {
      code = er.code
    } finally {
      if (!ok)
        throw new CwdError(dir, code)
    }
    done()
    return
  }

  if (preserve)
    return done(mkdirp.sync(dir, mode))

  const sub = path.relative(cwd, dir)
  const parts = sub.split(/\/|\\/)
  let created = null
  for (let p = parts.shift(), part = cwd;
       p && (part += '/' + p);
       p = parts.shift()) {

    if (cache.get(part))
      continue

    try {
      fs.mkdirSync(part, mode)
      created = created || part
      cache.set(part, true)
    } catch (er) {
      if (er.path && path.dirname(er.path) === cwd &&
          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
        return new CwdError(cwd, er.code)

      const st = fs.lstatSync(part)
      if (st.isDirectory()) {
        cache.set(part, true)
        continue
      } else if (unlink) {
        fs.unlinkSync(part)
        fs.mkdirSync(part, mode)
        created = created || part
        cache.set(part, true)
        continue
      } else if (st.isSymbolicLink())
        return new SymlinkError(part, part + '/' + parts.join('/'))
    }
  }

  return done(created)
}


/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const fs = __webpack_require__(66)
const path = __webpack_require__(82)

/* istanbul ignore next */
const LCHOWN = fs.lchown ? 'lchown' : 'chown'
/* istanbul ignore next */
const LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'

/* istanbul ignore next */
const needEISDIRHandled = fs.lchown &&
  !process.version.match(/v1[1-9]+\./) &&
  !process.version.match(/v10\.[6-9]/)

const lchownSync = (path, uid, gid) => {
  try {
    return fs[LCHOWNSYNC](path, uid, gid)
  } catch (er) {
    if (er.code !== 'ENOENT')
      throw er
  }
}

/* istanbul ignore next */
const chownSync = (path, uid, gid) => {
  try {
    return fs.chownSync(path, uid, gid)
  } catch (er) {
    if (er.code !== 'ENOENT')
      throw er
  }
}

/* istanbul ignore next */
const handleEISDIR =
  needEISDIRHandled ? (path, uid, gid, cb) => er => {
    // Node prior to v10 had a very questionable implementation of
    // fs.lchown, which would always try to call fs.open on a directory
    // Fall back to fs.chown in those cases.
    if (!er || er.code !== 'EISDIR')
      cb(er)
    else
      fs.chown(path, uid, gid, cb)
  }
  : (_, __, ___, cb) => cb

/* istanbul ignore next */
const handleEISDirSync =
  needEISDIRHandled ? (path, uid, gid) => {
    try {
      return lchownSync(path, uid, gid)
    } catch (er) {
      if (er.code !== 'EISDIR')
        throw er
      chownSync(path, uid, gid)
    }
  }
  : (path, uid, gid) => lchownSync(path, uid, gid)

// fs.readdir could only accept an options object as of node v6
const nodeVersion = process.version
let readdir = (path, options, cb) => fs.readdir(path, options, cb)
let readdirSync = (path, options) => fs.readdirSync(path, options)
/* istanbul ignore next */
if (/^v4\./.test(nodeVersion))
  readdir = (path, options, cb) => fs.readdir(path, cb)

const chown = (cpath, uid, gid, cb) => {
  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {
    // Skip ENOENT error
    cb(er && er.code !== 'ENOENT' ? er : null)
  }))
}

const chownrKid = (p, child, uid, gid, cb) => {
  if (typeof child === 'string')
    return fs.lstat(path.resolve(p, child), (er, stats) => {
      // Skip ENOENT error
      if (er)
        return cb(er.code !== 'ENOENT' ? er : null)
      stats.name = child
      chownrKid(p, stats, uid, gid, cb)
    })

  if (child.isDirectory()) {
    chownr(path.resolve(p, child.name), uid, gid, er => {
      if (er)
        return cb(er)
      const cpath = path.resolve(p, child.name)
      chown(cpath, uid, gid, cb)
    })
  } else {
    const cpath = path.resolve(p, child.name)
    chown(cpath, uid, gid, cb)
  }
}


const chownr = (p, uid, gid, cb) => {
  readdir(p, { withFileTypes: true }, (er, children) => {
    // any error other than ENOTDIR or ENOTSUP means it's not readable,
    // or doesn't exist.  give up.
    if (er) {
      if (er.code === 'ENOENT')
        return cb()
      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')
        return cb(er)
    }
    if (er || !children.length)
      return chown(p, uid, gid, cb)

    let len = children.length
    let errState = null
    const then = er => {
      if (errState)
        return
      if (er)
        return cb(errState = er)
      if (-- len === 0)
        return chown(p, uid, gid, cb)
    }

    children.forEach(child => chownrKid(p, child, uid, gid, then))
  })
}

const chownrKidSync = (p, child, uid, gid) => {
  if (typeof child === 'string') {
    try {
      const stats = fs.lstatSync(path.resolve(p, child))
      stats.name = child
      child = stats
    } catch (er) {
      if (er.code === 'ENOENT')
        return
      else
        throw er
    }
  }

  if (child.isDirectory())
    chownrSync(path.resolve(p, child.name), uid, gid)

  handleEISDirSync(path.resolve(p, child.name), uid, gid)
}

const chownrSync = (p, uid, gid) => {
  let children
  try {
    children = readdirSync(p, { withFileTypes: true })
  } catch (er) {
    if (er.code === 'ENOENT')
      return
    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')
      return handleEISDirSync(p, uid, gid)
    else
      throw er
  }

  if (children && children.length)
    children.forEach(child => chownrKidSync(p, child, uid, gid))

  return handleEISDirSync(p, uid, gid)
}

module.exports = chownr
chownr.sync = chownrSync


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

// A path exclusive reservation system
// reserve([list, of, paths], fn)
// When the fn is first in line for all its paths, it
// is called with a cb that clears the reservation.
//
// Used by async unpack to avoid clobbering paths in use,
// while still allowing maximal safe parallelization.

const assert = __webpack_require__(108)

module.exports = () => {
  // path => [function or Set]
  // A Set object means a directory reservation
  // A fn is a direct reservation on that path
  const queues = new Map()

  // fn => {paths:[path,...], dirs:[path, ...]}
  const reservations = new Map()

  // return a set of parent dirs for a given path
  const { join } = __webpack_require__(82)
  const getDirs = path =>
    join(path).split(/[\\\/]/).slice(0, -1).reduce((set, path) =>
      set.length ? set.concat(join(set[set.length-1], path)) : [path], [])

  // functions currently running
  const running = new Set()

  // return the queues for each path the function cares about
  // fn => {paths, dirs}
  const getQueues = fn => {
    const res = reservations.get(fn)
    /* istanbul ignore if - unpossible */
    if (!res)
      throw new Error('function does not have any path reservations')
    return {
      paths: res.paths.map(path => queues.get(path)),
      dirs: [...res.dirs].map(path => queues.get(path)),
    }
  }

  // check if fn is first in line for all its paths, and is
  // included in the first set for all its dir queues
  const check = fn => {
    const {paths, dirs} = getQueues(fn)
    return paths.every(q => q[0] === fn) &&
      dirs.every(q => q[0] instanceof Set && q[0].has(fn))
  }

  // run the function if it's first in line and not already running
  const run = fn => {
    if (running.has(fn) || !check(fn))
      return false
    running.add(fn)
    fn(() => clear(fn))
    return true
  }

  const clear = fn => {
    if (!running.has(fn))
      return false

    const { paths, dirs } = reservations.get(fn)
    const next = new Set()

    paths.forEach(path => {
      const q = queues.get(path)
      assert.equal(q[0], fn)
      if (q.length === 1)
        queues.delete(path)
      else {
        q.shift()
        if (typeof q[0] === 'function')
          next.add(q[0])
        else
          q[0].forEach(fn => next.add(fn))
      }
    })

    dirs.forEach(dir => {
      const q = queues.get(dir)
      assert(q[0] instanceof Set)
      if (q[0].size === 1 && q.length === 1) {
        queues.delete(dir)
      } else if (q[0].size === 1) {
        q.shift()

        // must be a function or else the Set would've been reused
        next.add(q[0])
      } else
        q[0].delete(fn)
    })
    running.delete(fn)

    next.forEach(fn => run(fn))
    return true
  }

  const reserve = (paths, fn) => {
    const dirs = new Set(
      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))
    )
    reservations.set(fn, {dirs, paths})
    paths.forEach(path => {
      const q = queues.get(path)
      if (!q)
        queues.set(path, [fn])
      else
        q.push(fn)
    })
    dirs.forEach(dir => {
      const q = queues.get(dir)
      if (!q)
        queues.set(dir, [new Set([fn])])
      else if (q[q.length-1] instanceof Set)
        q[q.length-1].add(fn)
      else
        q.push(new Set([fn]))
    })

    return run(fn)
  }

  return { check, reserve }
}


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

// Get the appropriate flag to use for creating files
// We use fmap on Windows platforms for files less than
// 512kb.  This is a fairly low limit, but avoids making
// things slower in some cases.  Since most of what this
// library is used for is extracting tarballs of many
// relatively small files in npm packages and the like,
// it can be a big boost on Windows platforms.
// Only supported in Node v12.9.0 and above.
const platform = process.env.__FAKE_PLATFORM__ || process.platform
const isWindows = platform === 'win32'
const fs = global.__FAKE_TESTING_FS__ || __webpack_require__(66)

/* istanbul ignore next */
const { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants

const fMapEnabled = isWindows && !!UV_FS_O_FILEMAP
const fMapLimit = 512 * 1024
const fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY
module.exports = !fMapEnabled ? () => 'w'
  : size => size < fMapLimit ? fMapFlag : 'w'


/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Polyfills for node 0.8
__webpack_require__(386);
__webpack_require__(387);
__webpack_require__(389);


exports.Parse = __webpack_require__(390);
exports.ParseOne = __webpack_require__(452);
exports.Extract = __webpack_require__(454);
exports.Open = __webpack_require__(472);

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var listenerCount = __webpack_require__(198).listenerCount
// listenerCount isn't in node 0.10, so here's a basic polyfill
listenerCount = listenerCount || function (ee, event) {
  var listeners = ee && ee._events && ee._events[event]
  if (Array.isArray(listeners)) {
    return listeners.length
  } else if (typeof listeners === 'function') {
    return 1
  } else {
    return 0
  }
}

module.exports = listenerCount


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var initBuffer = __webpack_require__(388);

if (!Buffer.prototype.indexOf) {
    Buffer.prototype.indexOf = function (value, offset) {
        offset = offset || 0;

        // Always wrap the input as a Buffer so that this method will support any
        // data type such as array octet, string or buffer.
        if (typeof value === "string" || value instanceof String) {
            value = initBuffer(value);
        } else if (typeof value === "number" || value instanceof Number) {
            value = initBuffer([ value ]);
        }

        var len = value.length;

        for (var i = offset; i <= this.length - len; i++) {
            var mismatch = false;
            for (var j = 0; j < len; j++) {
                if (this[i + j] != value[j]) {
                    mismatch = true;
                    break;
                }
            }

            if (!mismatch) {
                return i;
            }
        }

        return -1;
    };
}

function bufferLastIndexOf (value, offset) {

    // Always wrap the input as a Buffer so that this method will support any
    // data type such as array octet, string or buffer.
    if (typeof value === "string" || value instanceof String) {
        value = initBuffer(value);
    } else if (typeof value === "number" || value instanceof Number) {
        value = initBuffer([ value ]);
    }

    var len = value.length;
    offset = offset || this.length - len;

    for (var i = offset; i >= 0; i--) {
        var mismatch = false;
        for (var j = 0; j < len; j++) {
            if (this[i + j] != value[j]) {
                mismatch = true;
                break;
            }
        }

        if (!mismatch) {
            return i;
        }
    }

    return -1;
}


if (Buffer.prototype.lastIndexOf) {
    // check Buffer#lastIndexOf is usable: https://github.com/nodejs/node/issues/4604
    if (initBuffer("ABC").lastIndexOf ("ABC") === -1)
        Buffer.prototype.lastIndexOf = bufferLastIndexOf;
} else {
    Buffer.prototype.lastIndexOf = bufferLastIndexOf;
}


/***/ }),
/* 388 */
/***/ (function(module, exports) {

module.exports = function initBuffer(val) {
  // assume old version
    var nodeVersion = process && process.version ? process.version : "v5.0.0";
    var major = nodeVersion.split(".")[0].replace("v", "");
    return major < 6
      ? new Buffer(val)
      : Buffer.from(val);
};

/***/ }),
/* 389 */
/***/ (function(module, exports) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(74);
var zlib = __webpack_require__(145);
var Stream = __webpack_require__(106);
var binary = __webpack_require__(391);
var Promise = __webpack_require__(396);
var PullStream = __webpack_require__(432);
var NoopStream = __webpack_require__(448);
var BufferStream = __webpack_require__(449);
var parseExtraField = __webpack_require__(450);
var Buffer = __webpack_require__(433);
var parseDateTime = __webpack_require__(451);

// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = __webpack_require__(434);

var endDirectorySignature = Buffer.alloc(4);
endDirectorySignature.writeUInt32LE(0x06054b50, 0);

function Parse(opts) {
  if (!(this instanceof Parse)) {
    return new Parse(opts);
  }
  var self = this;
  self._opts = opts || { verbose: false };

  PullStream.call(self, self._opts);
  self.on('finish',function() {
    self.emit('close');
  });
  self._readRecord().catch(function(e) {
    if (!self.__emittedError || self.__emittedError !== e)
      self.emit('error',e);
  });
}

util.inherits(Parse, PullStream);

Parse.prototype._readRecord = function () {
  var self = this;
  return self.pull(4).then(function(data) {
    if (data.length === 0)
      return;

    var signature = data.readUInt32LE(0);

    if (signature === 0x34327243) {
      return self._readCrxHeader();
    }
    if (signature === 0x04034b50) {
      return self._readFile();
    }
    else if (signature === 0x02014b50) {
      self.__ended = true;
      return self._readCentralDirectoryFileHeader();
    }
    else if (signature === 0x06054b50) {
      return self._readEndOfCentralDirectoryRecord();
    }
    else if (self.__ended) {
      return self.pull(endDirectorySignature).then(function() {
          return self._readEndOfCentralDirectoryRecord();
        });
    }
    else
      self.emit('error', new Error('invalid signature: 0x' + signature.toString(16)));
  });
};

Parse.prototype._readCrxHeader = function() {
  var self = this;
  return self.pull(12).then(function(data) {
    self.crxHeader = binary.parse(data)
      .word32lu('version')
      .word32lu('pubKeyLength')
      .word32lu('signatureLength')
      .vars;
    return self.pull(self.crxHeader.pubKeyLength + self.crxHeader.signatureLength);
  }).then(function(data) {
    self.crxHeader.publicKey = data.slice(0,self.crxHeader.pubKeyLength);
    self.crxHeader.signature = data.slice(self.crxHeader.pubKeyLength);
    self.emit('crx-header',self.crxHeader);
    return self._readRecord();
  });
};

Parse.prototype._readFile = function () {
  var self = this;
  return self.pull(26).then(function(data) {
    var vars = binary.parse(data)
      .word16lu('versionsNeededToExtract')
      .word16lu('flags')
      .word16lu('compressionMethod')
      .word16lu('lastModifiedTime')
      .word16lu('lastModifiedDate')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .word16lu('fileNameLength')
      .word16lu('extraFieldLength')
      .vars;

    vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);

    if (self.crxHeader) vars.crxHeader = self.crxHeader;

    return self.pull(vars.fileNameLength).then(function(fileNameBuffer) {
      var fileName = fileNameBuffer.toString('utf8');
      var entry = Stream.PassThrough();
      var __autodraining = false;

      entry.autodrain = function() {
        __autodraining = true;
        var draining = entry.pipe(NoopStream());
        draining.promise = function() {
          return new Promise(function(resolve, reject) {
            draining.on('finish',resolve);
            draining.on('error',reject);
          });
        };
        return draining;
      };

      entry.buffer = function() {
        return BufferStream(entry);
      };

      entry.path = fileName;
      entry.props = {};
      entry.props.path = fileName;
      entry.props.pathBuffer = fileNameBuffer;
      entry.props.flags = {
        "isUnicode": vars.flags & 0x11
      };
      entry.type = (vars.uncompressedSize === 0 && /[\/\\]$/.test(fileName)) ? 'Directory' : 'File';

      if (self._opts.verbose) {
        if (entry.type === 'Directory') {
          console.log('   creating:', fileName);
        } else if (entry.type === 'File') {
          if (vars.compressionMethod === 0) {
            console.log(' extracting:', fileName);
          } else {
            console.log('  inflating:', fileName);
          }
        }
      }

      return self.pull(vars.extraFieldLength).then(function(extraField) {
        var extra = parseExtraField(extraField, vars);

        entry.vars = vars;
        entry.extra = extra;

        if (self._opts.forceStream) {
          self.push(entry);
        } else {
          self.emit('entry', entry);

          if (self._readableState.pipesCount || (self._readableState.pipes && self._readableState.pipes.length))
            self.push(entry);
        }

        if (self._opts.verbose)
          console.log({
            filename:fileName,
            vars: vars,
            extra: extra
          });

        var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0,
            eof;

        entry.__autodraining = __autodraining;  // expose __autodraining for test purposes
        var inflater = (vars.compressionMethod && !__autodraining) ? zlib.createInflateRaw() : Stream.PassThrough();

        if (fileSizeKnown) {
          entry.size = vars.uncompressedSize;
          eof = vars.compressedSize;
        } else {
          eof = Buffer.alloc(4);
          eof.writeUInt32LE(0x08074b50, 0);
        }

        return new Promise(function(resolve, reject) {
          self.stream(eof)
            .pipe(inflater)
            .on('error',function(err) { self.emit('error',err);})
            .pipe(entry)
            .on('finish', function() {
              return fileSizeKnown ?
                self._readRecord().then(resolve).catch(reject) :
                self._processDataDescriptor(entry).then(resolve).catch(reject);
            });
        });
      });
    });
  });
};

Parse.prototype._processDataDescriptor = function (entry) {
  var self = this;
  return self.pull(16).then(function(data) {
    var vars = binary.parse(data)
      .word32lu('dataDescriptorSignature')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .vars;

    entry.size = vars.uncompressedSize;
    return self._readRecord();
  });
};

Parse.prototype._readCentralDirectoryFileHeader = function () {
  var self = this;
  return self.pull(42).then(function(data) {

    var vars = binary.parse(data)
      .word16lu('versionMadeBy')
      .word16lu('versionsNeededToExtract')
      .word16lu('flags')
      .word16lu('compressionMethod')
      .word16lu('lastModifiedTime')
      .word16lu('lastModifiedDate')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .word16lu('fileNameLength')
      .word16lu('extraFieldLength')
      .word16lu('fileCommentLength')
      .word16lu('diskNumber')
      .word16lu('internalFileAttributes')
      .word32lu('externalFileAttributes')
      .word32lu('offsetToLocalFileHeader')
      .vars;

    return self.pull(vars.fileNameLength).then(function(fileName) {
      vars.fileName = fileName.toString('utf8');
      return self.pull(vars.extraFieldLength);
    })
    .then(function(extraField) {
      return self.pull(vars.fileCommentLength);
    })
    .then(function(fileComment) {
      return self._readRecord();
    });
  });
};

Parse.prototype._readEndOfCentralDirectoryRecord = function() {
  var self = this;
  return self.pull(18).then(function(data) {

    var vars = binary.parse(data)
      .word16lu('diskNumber')
      .word16lu('diskStart')
      .word16lu('numberOfRecordsOnDisk')
      .word16lu('numberOfRecords')
      .word32lu('sizeOfCentralDirectory')
      .word32lu('offsetToStartOfCentralDirectory')
      .word16lu('commentLength')
      .vars;

    return self.pull(vars.commentLength).then(function(comment) {
      comment = comment.toString('utf8');
      self.end();
      self.push(null);
    });

  });
};

Parse.prototype.promise = function() {
  var self = this;
  return new Promise(function(resolve,reject) {
    self.on('finish',resolve);
    self.on('error',reject);
  });
};

module.exports = Parse;


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

var Chainsaw = __webpack_require__(392);
var EventEmitter = __webpack_require__(198).EventEmitter;
var Buffers = __webpack_require__(394);
var Vars = __webpack_require__(395);
var Stream = __webpack_require__(106).Stream;

exports = module.exports = function (bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm)) {
        return exports.parse(bufOrEm);
    }
    
    var s = exports.stream();
    if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
    }
    else if (bufOrEm) {
        bufOrEm.on(eventName || 'data', function (buf) {
            s.write(buf);
        });
        
        bufOrEm.on('end', function () {
            s.end();
        });
    }
    return s;
};

exports.stream = function (input) {
    if (input) return exports.apply(null, arguments);
    
    var pending = null;
    function getBytes (bytes, cb, skip) {
        pending = {
            bytes : bytes,
            skip : skip,
            cb : function (buf) {
                pending = null;
                cb(buf);
            },
        };
        dispatch();
    }
    
    var offset = null;
    function dispatch () {
        if (!pending) {
            if (caughtEnd) done = true;
            return;
        }
        if (typeof pending === 'function') {
            pending();
        }
        else {
            var bytes = offset + pending.bytes;
            
            if (buffers.length >= bytes) {
                var buf;
                if (offset == null) {
                    buf = buffers.splice(0, bytes);
                    if (!pending.skip) {
                        buf = buf.slice();
                    }
                }
                else {
                    if (!pending.skip) {
                        buf = buffers.slice(offset, bytes);
                    }
                    offset = bytes;
                }
                
                if (pending.skip) {
                    pending.cb();
                }
                else {
                    pending.cb(buf);
                }
            }
        }
    }
    
    function builder (saw) {
        function next () { if (!done) saw.next() }
        
        var self = words(function (bytes, cb) {
            return function (name) {
                getBytes(bytes, function (buf) {
                    vars.set(name, cb(buf));
                    next();
                });
            };
        });
        
        self.tap = function (cb) {
            saw.nest(cb, vars.store);
        };
        
        self.into = function (key, cb) {
            if (!vars.get(key)) vars.set(key, {});
            var parent = vars;
            vars = Vars(parent.get(key));
            
            saw.nest(function () {
                cb.apply(this, arguments);
                this.tap(function () {
                    vars = parent;
                });
            }, vars.store);
        };
        
        self.flush = function () {
            vars.store = {};
            next();
        };
        
        self.loop = function (cb) {
            var end = false;
            
            saw.nest(false, function loop () {
                this.vars = vars.store;
                cb.call(this, function () {
                    end = true;
                    next();
                }, vars.store);
                this.tap(function () {
                    if (end) saw.next()
                    else loop.call(this)
                }.bind(this));
            }, vars.store);
        };
        
        self.buffer = function (name, bytes) {
            if (typeof bytes === 'string') {
                bytes = vars.get(bytes);
            }
            
            getBytes(bytes, function (buf) {
                vars.set(name, buf);
                next();
            });
        };
        
        self.skip = function (bytes) {
            if (typeof bytes === 'string') {
                bytes = vars.get(bytes);
            }
            
            getBytes(bytes, function () {
                next();
            });
        };
        
        self.scan = function find (name, search) {
            if (typeof search === 'string') {
                search = new Buffer(search);
            }
            else if (!Buffer.isBuffer(search)) {
                throw new Error('search must be a Buffer or a string');
            }
            
            var taken = 0;
            pending = function () {
                var pos = buffers.indexOf(search, offset + taken);
                var i = pos-offset-taken;
                if (pos !== -1) {
                    pending = null;
                    if (offset != null) {
                        vars.set(
                            name,
                            buffers.slice(offset, offset + taken + i)
                        );
                        offset += taken + i + search.length;
                    }
                    else {
                        vars.set(
                            name,
                            buffers.slice(0, taken + i)
                        );
                        buffers.splice(0, taken + i + search.length);
                    }
                    next();
                    dispatch();
                } else {
                    i = Math.max(buffers.length - search.length - offset - taken, 0);
				}
                taken += i;
            };
            dispatch();
        };
        
        self.peek = function (cb) {
            offset = 0;
            saw.nest(function () {
                cb.call(this, vars.store);
                this.tap(function () {
                    offset = null;
                });
            });
        };
        
        return self;
    };
    
    var stream = Chainsaw.light(builder);
    stream.writable = true;
    
    var buffers = Buffers();
    
    stream.write = function (buf) {
        buffers.push(buf);
        dispatch();
    };
    
    var vars = Vars();
    
    var done = false, caughtEnd = false;
    stream.end = function () {
        caughtEnd = true;
    };
    
    stream.pipe = Stream.prototype.pipe;
    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {
        stream[name] = EventEmitter.prototype[name];
    });
    
    return stream;
};

exports.parse = function parse (buffer) {
    var self = words(function (bytes, cb) {
        return function (name) {
            if (offset + bytes <= buffer.length) {
                var buf = buffer.slice(offset, offset + bytes);
                offset += bytes;
                vars.set(name, cb(buf));
            }
            else {
                vars.set(name, null);
            }
            return self;
        };
    });
    
    var offset = 0;
    var vars = Vars();
    self.vars = vars.store;
    
    self.tap = function (cb) {
        cb.call(self, vars.store);
        return self;
    };
    
    self.into = function (key, cb) {
        if (!vars.get(key)) {
            vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self, vars.store);
        vars = parent;
        return self;
    };
    
    self.loop = function (cb) {
        var end = false;
        var ender = function () { end = true };
        while (end === false) {
            cb.call(self, ender, vars.store);
        }
        return self;
    };
    
    self.buffer = function (name, size) {
        if (typeof size === 'string') {
            size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name, buf);
        
        return self;
    };
    
    self.skip = function (bytes) {
        if (typeof bytes === 'string') {
            bytes = vars.get(bytes);
        }
        offset += bytes;
        
        return self;
    };
    
    self.scan = function (name, search) {
        if (typeof search === 'string') {
            search = new Buffer(search);
        }
        else if (!Buffer.isBuffer(search)) {
            throw new Error('search must be a Buffer or a string');
        }
        vars.set(name, null);
        
        // simple but slow string search
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
            for (
                var j = 0;
                j < search.length && buffer[offset+i+j] === search[j];
                j++
            );
            if (j === search.length) break;
        }
        
        vars.set(name, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self;
    };
    
    self.peek = function (cb) {
        var was = offset;
        cb.call(self, vars.store);
        offset = was;
        return self;
    };
    
    self.flush = function () {
        vars.store = {};
        return self;
    };
    
    self.eof = function () {
        return offset >= buffer.length;
    };
    
    return self;
};

// convert byte strings to unsigned little endian numbers
function decodeLEu (bytes) {
    var acc = 0;
    for (var i = 0; i < bytes.length; i++) {
        acc += Math.pow(256,i) * bytes[i];
    }
    return acc;
}

// convert byte strings to unsigned big endian numbers
function decodeBEu (bytes) {
    var acc = 0;
    for (var i = 0; i < bytes.length; i++) {
        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
    }
    return acc;
}

// convert byte strings to signed big endian numbers
function decodeBEs (bytes) {
    var val = decodeBEu(bytes);
    if ((bytes[0] & 0x80) == 0x80) {
        val -= Math.pow(256, bytes.length);
    }
    return val;
}

// convert byte strings to signed little endian numbers
function decodeLEs (bytes) {
    var val = decodeLEu(bytes);
    if ((bytes[bytes.length - 1] & 0x80) == 0x80) {
        val -= Math.pow(256, bytes.length);
    }
    return val;
}

function words (decode) {
    var self = {};
    
    [ 1, 2, 4, 8 ].forEach(function (bytes) {
        var bits = bytes * 8;
        
        self['word' + bits + 'le']
        = self['word' + bits + 'lu']
        = decode(bytes, decodeLEu);
        
        self['word' + bits + 'ls']
        = decode(bytes, decodeLEs);
        
        self['word' + bits + 'be']
        = self['word' + bits + 'bu']
        = decode(bytes, decodeBEu);
        
        self['word' + bits + 'bs']
        = decode(bytes, decodeBEs);
    });
    
    // word8be(n) == word8le(n) for all n
    self.word8 = self.word8u = self.word8be;
    self.word8s = self.word8bs;
    
    return self;
}


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

var Traverse = __webpack_require__(393);
var EventEmitter = __webpack_require__(198).EventEmitter;

module.exports = Chainsaw;
function Chainsaw (builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    saw.record();
    return saw.chain();
};

Chainsaw.light = function ChainsawLight (builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    return saw.chain();
};

Chainsaw.saw = function (builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];

    saw.chain = function () {
        var ch = Traverse(saw.handlers).map(function (node) {
            if (this.isRoot) return node;
            var ps = this.path;

            if (typeof node === 'function') {
                this.update(function () {
                    saw.actions.push({
                        path : ps,
                        args : [].slice.call(arguments)
                    });
                    return ch;
                });
            }
        });

        process.nextTick(function () {
            saw.emit('begin');
            saw.next();
        });

        return ch;
    };

    saw.pop = function () {
        return saw.actions.shift();
    };

    saw.next = function () {
        var action = saw.pop();

        if (!action) {
            saw.emit('end');
        }
        else if (!action.trap) {
            var node = saw.handlers;
            action.path.forEach(function (key) { node = node[key] });
            node.apply(saw.handlers, action.args);
        }
    };

    saw.nest = function (cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;

        if (typeof cb === 'boolean') {
            var autonext = cb;
            cb = args.shift();
        }

        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);

        if (r !== undefined) s.handlers = r;

        // If we are recording...
        if ("undefined" !== typeof saw.step) {
            // ... our children should, too
            s.record();
        }

        cb.apply(s.chain(), args);
        if (autonext !== false) s.on('end', saw.next);
    };

    saw.record = function () {
        upgradeChainsaw(saw);
    };

    ['trap', 'down', 'jump'].forEach(function (method) {
        saw[method] = function () {
            throw new Error("To use the trap, down and jump features, please "+
                            "call record() first to start recording actions.");
        };
    });

    return saw;
};

function upgradeChainsaw(saw) {
    saw.step = 0;

    // override pop
    saw.pop = function () {
        return saw.actions[saw.step++];
    };

    saw.trap = function (name, cb) {
        var ps = Array.isArray(name) ? name : [name];
        saw.actions.push({
            path : ps,
            step : saw.step,
            cb : cb,
            trap : true
        });
    };

    saw.down = function (name) {
        var ps = (Array.isArray(name) ? name : [name]).join('/');
        var i = saw.actions.slice(saw.step).map(function (x) {
            if (x.trap && x.step <= saw.step) return false;
            return x.path.join('/') == ps;
        }).indexOf(true);

        if (i >= 0) saw.step += i;
        else saw.step = saw.actions.length;

        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
            // It's a trap!
            saw.step = act.step;
            act.cb();
        }
        else saw.next();
    };

    saw.jump = function (step) {
        saw.step = step;
        saw.next();
    };
};


/***/ }),
/* 393 */
/***/ (function(module, exports) {

module.exports = Traverse;
function Traverse (obj) {
    if (!(this instanceof Traverse)) return new Traverse(obj);
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.deepEqual = function (obj) {
    if (arguments.length !== 1) {
        throw new Error(
            'deepEqual requires exactly one object to compare against'
        );
    }
    
    var equal = true;
    var node = obj;
    
    this.forEach(function (y) {
        var notEqual = (function () {
            equal = false;
            //this.stop();
            return undefined;
        }).bind(this);
        
        //if (node === undefined || node === null) return notEqual();
        
        if (!this.isRoot) {
        /*
            if (!Object.hasOwnProperty.call(node, this.key)) {
                return notEqual();
            }
        */
            if (typeof node !== 'object') return notEqual();
            node = node[this.key];
        }
        
        var x = node;
        
        this.post(function () {
            node = x;
        });
        
        var toS = function (o) {
            return Object.prototype.toString.call(o);
        };
        
        if (this.circular) {
            if (Traverse(obj).get(this.circular.path) !== x) notEqual();
        }
        else if (typeof x !== typeof y) {
            notEqual();
        }
        else if (x === null || y === null || x === undefined || y === undefined) {
            if (x !== y) notEqual();
        }
        else if (x.__proto__ !== y.__proto__) {
            notEqual();
        }
        else if (x === y) {
            // nop
        }
        else if (typeof x === 'function') {
            if (x instanceof RegExp) {
                // both regexps on account of the __proto__ check
                if (x.toString() != y.toString()) notEqual();
            }
            else if (x !== y) notEqual();
        }
        else if (typeof x === 'object') {
            if (toS(y) === '[object Arguments]'
            || toS(x) === '[object Arguments]') {
                if (toS(x) !== toS(y)) {
                    notEqual();
                }
            }
            else if (x instanceof Date || y instanceof Date) {
                if (!(x instanceof Date) || !(y instanceof Date)
                || x.getTime() !== y.getTime()) {
                    notEqual();
                }
            }
            else {
                var kx = Object.keys(x);
                var ky = Object.keys(y);
                if (kx.length !== ky.length) return notEqual();
                for (var i = 0; i < kx.length; i++) {
                    var k = kx[i];
                    if (!Object.hasOwnProperty.call(y, k)) {
                        notEqual();
                    }
                }
            }
        }
    });
    
    return equal;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            Object.keys(src).forEach(function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents.slice(-1)[0],
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
            },
            'delete' : function () {
                delete state.parent.node[state.key];
            },
            remove : function () {
                if (Array.isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
            },
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false }
        };
        
        if (!alive) return state;
        
        if (typeof node === 'object' && node !== null) {
            state.isLeaf = Object.keys(node).length == 0;
            
            for (var i = 0; i < parents.length; i++) {
                if (parents[i].node_ === node_) {
                    state.circular = parents[i];
                    break;
                }
            }
        }
        else {
            state.isLeaf = true;
        }
        
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            var keys = Object.keys(state.node);
            keys.forEach(function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && Object.hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

Object.keys(Traverse.prototype).forEach(function (key) {
    Traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
    };
});

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (Array.isArray(src)) {
            dst = [];
        }
        else if (src instanceof Date) {
            dst = new Date(src);
        }
        else if (src instanceof Boolean) {
            dst = new Boolean(src);
        }
        else if (src instanceof Number) {
            dst = new Number(src);
        }
        else if (src instanceof String) {
            dst = new String(src);
        }
        else {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        
        Object.keys(src).forEach(function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}


/***/ }),
/* 394 */
/***/ (function(module, exports) {

module.exports = Buffers;

function Buffers (bufs) {
    if (!(this instanceof Buffers)) return new Buffers(bufs);
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function (size, buf) {
        return size + buf.length
    }, 0);
}

Buffers.prototype.push = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
            throw new TypeError('Tried to push a non-buffer');
        }
    }
    
    for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
    }
    return this.length;
};

Buffers.prototype.unshift = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
            throw new TypeError('Tried to unshift a non-buffer');
        }
    }
    
    for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
    }
    return this.length;
};

Buffers.prototype.copy = function (dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
};

Buffers.prototype.splice = function (i, howMany) {
    var buffers = this.buffers;
    var index = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);
    
    if (howMany === undefined) {
        howMany = this.length - index;
    }
    else if (howMany > this.length - index) {
        howMany = this.length - index;
    }
    
    for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
    }
    
    var removed = new Buffers();
    var bytes = 0;
    
    var startBytes = 0;
    for (
        var ii = 0;
        ii < buffers.length && startBytes + buffers[ii].length < index;
        ii ++
    ) { startBytes += buffers[ii].length }
    
    if (index - startBytes > 0) {
        var start = index - startBytes;
        
        if (start + howMany < buffers[ii].length) {
            removed.push(buffers[ii].slice(start, start + howMany));
            
            var orig = buffers[ii];
            //var buf = new Buffer(orig.length - howMany);
            var buf0 = new Buffer(start);
            for (var i = 0; i < start; i++) {
                buf0[i] = orig[i];
            }
            
            var buf1 = new Buffer(orig.length - start - howMany);
            for (var i = start + howMany; i < orig.length; i++) {
                buf1[ i - howMany - start ] = orig[i]
            }
            
            if (reps.length > 0) {
                var reps_ = reps.slice();
                reps_.unshift(buf0);
                reps_.push(buf1);
                buffers.splice.apply(buffers, [ ii, 1 ].concat(reps_));
                ii += reps_.length;
                reps = [];
            }
            else {
                buffers.splice(ii, 1, buf0, buf1);
                //buffers[ii] = buf;
                ii += 2;
            }
        }
        else {
            removed.push(buffers[ii].slice(start));
            buffers[ii] = buffers[ii].slice(0, start);
            ii ++;
        }
    }
    
    if (reps.length > 0) {
        buffers.splice.apply(buffers, [ ii, 0 ].concat(reps));
        ii += reps.length;
    }
    
    while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        
        if (take === len) {
            removed.push(buf);
            buffers.splice(ii, 1);
        }
        else {
            removed.push(buf.slice(0, take));
            buffers[ii] = buffers[ii].slice(take);
        }
    }
    
    this.length -= removed.length;
    
    return removed;
};
 
Buffers.prototype.slice = function (i, j) {
    var buffers = this.buffers;
    if (j === undefined) j = this.length;
    if (i === undefined) i = 0;
    
    if (j > this.length) j = this.length;
    
    var startBytes = 0;
    for (
        var si = 0;
        si < buffers.length && startBytes + buffers[si].length <= i;
        si ++
    ) { startBytes += buffers[si].length }
    
    var target = new Buffer(j - i);
    
    var ti = 0;
    for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i
            ? Math.min(start + (j - i) - ti, len)
            : len
        ;
        
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
    }
    
    return target;
};

Buffers.prototype.pos = function (i) {
    if (i < 0 || i >= this.length) throw new Error('oob');
    var l = i, bi = 0, bu = null;
    for (;;) {
        bu = this.buffers[bi];
        if (l < bu.length) {
            return {buf: bi, offset: l};
        } else {
            l -= bu.length;
        }
        bi++;
    }
};

Buffers.prototype.get = function get (i) {
    var pos = this.pos(i);

    return this.buffers[pos.buf].get(pos.offset);
};

Buffers.prototype.set = function set (i, b) {
    var pos = this.pos(i);

    return this.buffers[pos.buf].set(pos.offset, b);
};

Buffers.prototype.indexOf = function (needle, offset) {
    if ("string" === typeof needle) {
        needle = new Buffer(needle);
    } else if (needle instanceof Buffer) {
        // already a buffer
    } else {
        throw new Error('Invalid type for a search string');
    }

    if (!needle.length) {
        return 0;
    }

    if (!this.length) {
        return -1;
    }

    var i = 0, j = 0, match = 0, mstart, pos = 0;

    // start search from a particular point in the virtual buffer
    if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
    }

    // for each character in virtual buffer
    for (;;) {
        while (j >= this.buffers[i].length) {
            j = 0;
            i++;

            if (i >= this.buffers.length) {
                // search string not found
                return -1;
            }
        }

        var char = this.buffers[i][j];

        if (char == needle[match]) {
            // keep track where match started
            if (match == 0) {
                mstart = {
                    i: i,
                    j: j,
                    pos: pos
                };
            }
            match++;
            if (match == needle.length) {
                // full match
                return mstart.pos;
            }
        } else if (match != 0) {
            // a partial match ended, go back to match starting position
            // this will continue the search at the next character
            i = mstart.i;
            j = mstart.j;
            pos = mstart.pos;
            match = 0;
        }

        j++;
        pos++;
    }
};

Buffers.prototype.toBuffer = function() {
    return this.slice();
}

Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
}


/***/ }),
/* 395 */
/***/ (function(module, exports) {

module.exports = function (store) {
    function getset (name, value) {
        var node = vars.store;
        var keys = name.split('.');
        keys.slice(0,-1).forEach(function (k) {
            if (node[k] === undefined) node[k] = {};
            node = node[k]
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
            return node[key];
        }
        else {
            return node[key] = value;
        }
    }
    
    var vars = {
        get : function (name) {
            return getset(name);
        },
        set : function (name, value) {
            return getset(name, value);
        },
        store : store || {},
    };
    return vars;
};


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = __webpack_require__(397)();
bluebird.noConflict = noConflict;
module.exports = bluebird;


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var reflectHandler = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
function Proxyable() {}
var UNDEFINED_BINDING = {};
var util = __webpack_require__(398);

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var es5 = __webpack_require__(399);
var Async = __webpack_require__(400);
var async = new Async();
es5.defineProperty(Promise, "_async", {value: async});
var errors = __webpack_require__(403);
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
var CancellationError = Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {};
var tryConvertToPromise = __webpack_require__(404)(Promise, INTERNAL);
var PromiseArray =
    __webpack_require__(405)(Promise, INTERNAL,
                               tryConvertToPromise, apiRejection, Proxyable);
var Context = __webpack_require__(406)(Promise);
 /*jshint unused:false*/
var createContext = Context.create;
var debug = __webpack_require__(407)(Promise, Context);
var CapturedTrace = debug.CapturedTrace;
var PassThroughHandlerContext =
    __webpack_require__(408)(Promise, tryConvertToPromise);
var catchFilter = __webpack_require__(409)(NEXT_FILTER);
var nodebackForPromise = __webpack_require__(410);
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function check(self, executor) {
    if (typeof executor !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(executor));
    }
    if (self.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
}

function Promise(executor) {
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    if (executor !== INTERNAL) {
        check(this, executor);
        this._resolveFromExecutor(executor);
    }
    this._promiseCreated();
    this._fireEvent("promiseCreated", this);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return apiRejection("expecting an object but got " +
                    "A catch statement predicate " + util.classString(item));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
    }
    return this.then(undefined, fn);
};

Promise.prototype.reflect = function () {
    return this._then(reflectHandler,
        reflectHandler, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject) {
    if (debug.warnings() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, undefined, undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject) {
    var promise =
        this._then(didFulfill, didReject, undefined, undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
    }
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.getNewLibraryCopy = module.exports;

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = Promise.fromCallback = function(fn) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
                                         : false;
    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true);
    }
    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    return async.setScheduler(fn);
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    _,    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
    var target = this._target();
    var bitField = target._bitField;

    if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined &&
            ((this._bitField & 2097152) !== 0)) {
            if (!((bitField & 50397184) === 0)) {
                receiver = this._boundValue();
            } else {
                receiver = target === this ? undefined : this._boundTo;
            }
        }
        this._fireEvent("promiseChained", this, promise);
    }

    var domain = getDomain();
    if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if (((bitField & 33554432) !== 0)) {
            value = target._rejectionHandler0;
            handler = didFulfill;
        } else if (((bitField & 16777216) !== 0)) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
        } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
        }

        async.invoke(settler, target, {
            handler: domain === null ? handler
                : (typeof handler === "function" &&
                    util.domainBind(domain, handler)),
            promise: promise,
            receiver: receiver,
            value: value
        });
    } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
    }

    return promise;
};

Promise.prototype._length = function () {
    return this._bitField & 65535;
};

Promise.prototype._isFateSealed = function () {
    return (this._bitField & 117506048) !== 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 67108864) === 67108864;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -65536) |
        (len & 65535);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 33554432;
    this._fireEvent("promiseFulfilled", this);
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 16777216;
    this._fireEvent("promiseRejected", this);
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 67108864;
    this._fireEvent("promiseResolved", this);
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._unsetCancelled = function() {
    this._bitField = this._bitField & (~65536);
};

Promise.prototype._setCancelled = function() {
    this._bitField = this._bitField | 65536;
    this._fireEvent("promiseCancelled", this);
};

Promise.prototype._setWillBeCancelled = function() {
    this._bitField = this._bitField | 8388608;
};

Promise.prototype._setAsyncGuaranteed = function() {
    if (async.hasCustomScheduler()) return;
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0 ? this._receiver0 : this[
            index * 4 - 4 + 3];
    if (ret === UNDEFINED_BINDING) {
        return undefined;
    } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return this[
            index * 4 - 4 + 2];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 1];
};

Promise.prototype._boundValue = function() {};

Promise.prototype._migrateCallback0 = function (follower) {
    var bitField = follower._bitField;
    var fulfill = follower._fulfillmentHandler0;
    var reject = follower._rejectionHandler0;
    var promise = follower._promise0;
    var receiver = follower._receiverAt(0);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._migrateCallbackAt = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._proxy = function (proxyable, arg) {
    this._addCallbacks(undefined, undefined, arg, proxyable, null);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (((this._bitField & 117506048) !== 0)) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    if (shouldBind) this._propagateFrom(maybePromise, 2);

    var promise = maybePromise._target();

    if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
    }

    var bitField = promise._bitField;
    if (((bitField & 50397184) === 0)) {
        var len = this._length();
        if (len > 0) promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (((bitField & 33554432) !== 0)) {
        this._fulfill(promise._value());
    } else if (((bitField & 16777216) !== 0)) {
        this._reject(promise._reason());
    } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, ignoreNonErrorWarnings) {
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " +
            util.classString(reason);
        this._warn(message, true);
    }
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason);
};

Promise.prototype._resolveFromExecutor = function (executor) {
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
    }, function (reason) {
        promise._rejectCallback(reason, synchronous);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined) {
        promise._rejectCallback(r, true);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    var bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError("cannot .spread() a non-array: " +
                                    util.classString(value));
        } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
        }
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    var promiseCreated = promise._popContext();
    bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;

    if (x === NEXT_FILTER) {
        promise._reject(value);
    } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
    } else {
        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
    var isPromise = promise instanceof Promise;
    var bitField = this._bitField;
    var asyncGuaranteed = ((bitField & 134217728) !== 0);
    if (((bitField & 65536) !== 0)) {
        if (isPromise) promise._invokeInternalOnCancel();

        if (receiver instanceof PassThroughHandlerContext &&
            receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
            }
        } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
        } else {
            receiver.cancel();
        }
    } else if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
            if (((bitField & 33554432) !== 0)) {
                receiver._promiseFulfilled(value, promise);
            } else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (asyncGuaranteed) promise._setAsyncGuaranteed();
        if (((bitField & 33554432) !== 0)) {
            promise._fulfill(value);
        } else {
            promise._reject(value);
        }
    }
};

Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
    var handler = ctx.handler;
    var promise = ctx.promise;
    var receiver = ctx.receiver;
    var value = ctx.value;
    if (typeof handler === "function") {
        if (!(promise instanceof Promise)) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (promise instanceof Promise) {
        promise._reject(value);
    }
};

Promise.prototype._settlePromiseCtx = function(ctx) {
    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
};

Promise.prototype._settlePromise0 = function(handler, value, bitField) {
    var promise = this._promise0;
    var receiver = this._receiverAt(0);
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settlePromise(promise, handler, receiver, value);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    var base = index * 4 - 4;
    this[base + 2] =
    this[base + 3] =
    this[base + 0] =
    this[base + 1] = undefined;
};

Promise.prototype._fulfill = function (value) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
    }
    this._setFulfilled();
    this._rejectionHandler0 = value;

    if ((bitField & 65535) > 0) {
        if (((bitField & 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
    }
};

Promise.prototype._reject = function (reason) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    this._setRejected();
    this._fulfillmentHandler0 = reason;

    if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
    }

    if ((bitField & 65535) > 0) {
        async.settlePromises(this);
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._fulfillPromises = function (len, value) {
    for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
    }
};

Promise.prototype._rejectPromises = function (len, reason) {
    for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
    }
};

Promise.prototype._settlePromises = function () {
    var bitField = this._bitField;
    var len = (bitField & 65535);

    if (len > 0) {
        if (((bitField & 16842752) !== 0)) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
        } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
        }
        this._setLength(0);
    }
    this._clearCancellationData();
};

Promise.prototype._settledValue = function() {
    var bitField = this._bitField;
    if (((bitField & 33554432) !== 0)) {
        return this._rejectionHandler0;
    } else if (((bitField & 16777216) !== 0)) {
        return this._fulfillmentHandler0;
    }
};

function deferResolve(v) {this.promise._resolveCallback(v);}
function deferReject(v) {this.promise._rejectCallback(v, false);}

Promise.defer = Promise.pending = function() {
    debug.deprecated("Promise.defer", "new Promise");
    var promise = new Promise(INTERNAL);
    return {
        promise: promise,
        resolve: deferResolve,
        reject: deferReject
    };
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

__webpack_require__(411)(Promise, INTERNAL, tryConvertToPromise, apiRejection,
    debug);
__webpack_require__(412)(Promise, INTERNAL, tryConvertToPromise, debug);
__webpack_require__(413)(Promise, PromiseArray, apiRejection, debug);
__webpack_require__(414)(Promise);
__webpack_require__(415)(Promise);
__webpack_require__(416)(
    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
Promise.Promise = Promise;
Promise.version = "3.4.7";
__webpack_require__(417)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
__webpack_require__(418)(Promise);
__webpack_require__(419)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
__webpack_require__(420)(Promise, INTERNAL, debug);
__webpack_require__(421)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
__webpack_require__(422)(Promise);
__webpack_require__(423)(Promise, INTERNAL);
__webpack_require__(424)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
__webpack_require__(425)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
__webpack_require__(426)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
__webpack_require__(427)(Promise, PromiseArray, debug);
__webpack_require__(428)(Promise, PromiseArray, apiRejection);
__webpack_require__(429)(Promise, INTERNAL);
__webpack_require__(430)(Promise, INTERNAL);
__webpack_require__(431)(Promise);
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    debug.setBounds(Async.firstLineError, util.lastLineError);               
    return Promise;                                                          

};


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var es5 = __webpack_require__(399);
var canEvaluate = typeof navigator == "undefined";

var errorObj = {e: {}};
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    typeof global !== "undefined" ? global :
    this !== undefined ? this : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return typeof value === "function" ||
           typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj !== null &&
           typeof obj === "object" &&
           typeof obj.message === "string" &&
           typeof obj.name === "string";
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function(v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
    } : function(v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function(v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" &&
    typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function(){});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;


/***/ }),
/* 399 */
/***/ (function(module, exports) {

var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = __webpack_require__(401);
var Queue = __webpack_require__(402);
var util = __webpack_require__(398);

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};


Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
            "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(398);
var schedule;
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if (typeof NativePromise === "function" &&
           typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
        nativePromise.then(fn);
    };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
        var div = document.createElement("div");
        var opts = {attributes: true};
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function() {
            if (toggleScheduled) return;
                toggleScheduled = true;
                div2.classList.toggle("foo");
            };

            return function schedule(fn) {
            var o = new MutationObserver(function() {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    })();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var es5 = __webpack_require__(399);
var Objectfreeze = es5.freeze;
var util = __webpack_require__(398);
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, INTERNAL) {
var util = __webpack_require__(398);
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfill,
                    ret._reject,
                    undefined,
                    ret,
                    null
                );
                return ret;
            }
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function doGetThen(obj) {
    return obj.then;
}

function getThen(obj) {
    try {
        return doGetThen(obj);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    try {
        return hasProp.call(obj, "_promise0");
    } catch (e) {
        return false;
    }
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x, resolve, reject);
    synchronous = false;

    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolve(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function reject(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }
    return ret;
}

return tryConvertToPromise;
};


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection, Proxyable) {
var util = __webpack_require__(398);
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    if (values instanceof Promise) {
        promise._propagateFrom(values, 3);
    }
    promise._setOnCancel(this);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
util.inherits(PromiseArray, Proxyable);

PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;

        if (((bitField & 50397184) === 0)) {
            this._promise._setAsyncGuaranteed();
            return values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
        } else if (((bitField & 33554432) !== 0)) {
            values = values._value();
        } else if (((bitField & 16777216) !== 0)) {
            return this._reject(values._reason());
        } else {
            return this._cancel();
        }
    }
    values = util.asArray(values);
    if (values === null) {
        var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    this._iterate(values);
};

PromiseArray.prototype._iterate = function(values) {
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var result = this._promise;
    var isResolved = false;
    var bitField = null;
    for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);

        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
        } else {
            bitField = null;
        }

        if (isResolved) {
            if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
            }
        } else if (bitField !== null) {
            if (((bitField & 50397184) === 0)) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
            } else if (((bitField & 33554432) !== 0)) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if (((bitField & 16777216) !== 0)) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
                isResolved = this._promiseCancelled(i);
            }
        } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
        }
    }
    if (!isResolved) result._setAsyncGuaranteed();
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype._cancel = function() {
    if (this._isResolved() || !this._promise._isCancellable()) return;
    this._values = null;
    this._promise._cancel();
};

PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false);
};

PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

PromiseArray.prototype._promiseCancelled = function() {
    this._cancel();
    return true;
};

PromiseArray.prototype._promiseRejected = function (reason) {
    this._totalResolved++;
    this._reject(reason);
    return true;
};

PromiseArray.prototype._resultCancelled = function() {
    if (this._isResolved()) return;
    var values = this._values;
    this._cancel();
    if (values instanceof Promise) {
        values.cancel();
    } else {
        for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise) {
                values[i].cancel();
            }
        }
    }
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise) {
var longStackTraces = false;
var contextStack = [];

Promise.prototype._promiseCreated = function() {};
Promise.prototype._pushContext = function() {};
Promise.prototype._popContext = function() {return null;};
Promise._peekContext = Promise.prototype._peekContext = function() {};

function Context() {
    this._trace = new Context.CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
    }
    return null;
};

function createContext() {
    if (longStackTraces) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}
Context.CapturedTrace = null;
Context.create = createContext;
Context.deactivateLongStackTraces = function() {};
Context.activateLongStackTraces = function() {
    var Promise_pushContext = Promise.prototype._pushContext;
    var Promise_popContext = Promise.prototype._popContext;
    var Promise_PeekContext = Promise._peekContext;
    var Promise_peekContext = Promise.prototype._peekContext;
    var Promise_promiseCreated = Promise.prototype._promiseCreated;
    Context.deactivateLongStackTraces = function() {
        Promise.prototype._pushContext = Promise_pushContext;
        Promise.prototype._popContext = Promise_popContext;
        Promise._peekContext = Promise_PeekContext;
        Promise.prototype._peekContext = Promise_peekContext;
        Promise.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
    };
    longStackTraces = true;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    Promise._peekContext = Promise.prototype._peekContext = peekContext;
    Promise.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
    };
};
return Context;
};


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, Context) {
var getDomain = Promise._getDomain;
var async = Promise._async;
var Warning = __webpack_require__(403).Warning;
var util = __webpack_require__(398);
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var printWarning;
var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
                        ( false ||
                         util.env("BLUEBIRD_DEBUG") ||
                         util.env("NODE_ENV") === "development"));

var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
    (debugging || util.env("BLUEBIRD_WARNINGS")));

var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

Promise.prototype.suppressUnhandledRejections = function() {
    var target = this._target();
    target._bitField = ((target._bitField & (~1048576)) |
                      524288);
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 524288) !== 0) return;
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._setReturnedNonUndefined = function() {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._returnedNonUndefined = function() {
    return (this._bitField & 268435456) !== 0;
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 262144;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~262144);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 262144) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 1048576;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~1048576);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
    return warn(message, shouldUseOwnTrace, promise || this);
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

var disableLongStackTraces = function() {};
Promise.longStackTraces = function () {
    if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            }
            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
        };
        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return config.longStackTraces && longStackTracesIsSupported();
};

var fireDomEvent = (function() {
    try {
        if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new CustomEvent(name.toLowerCase(), {
                    detail: event,
                    cancelable: true
                });
                return !util.global.dispatchEvent(domEvent);
            };
        } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new Event(name.toLowerCase(), {
                    cancelable: true
                });
                domEvent.detail = event;
                return !util.global.dispatchEvent(domEvent);
            };
        } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = document.createEvent("CustomEvent");
                domEvent.initCustomEvent(name.toLowerCase(), false, true,
                    event);
                return !util.global.dispatchEvent(domEvent);
            };
        }
    } catch (e) {}
    return function() {
        return false;
    };
})();

var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function() {
            return process.emit.apply(process, arguments);
        };
    } else {
        if (!util.global) {
            return function() {
                return false;
            };
        }
        return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method) return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
        };
    }
})();

function generatePromiseLifecycleEventObject(name, promise) {
    return {promise: promise};
}

var eventToObjectGenerator = {
    promiseCreated: generatePromiseLifecycleEventObject,
    promiseFulfilled: generatePromiseLifecycleEventObject,
    promiseRejected: generatePromiseLifecycleEventObject,
    promiseResolved: generatePromiseLifecycleEventObject,
    promiseCancelled: generatePromiseLifecycleEventObject,
    promiseChained: function(name, promise, child) {
        return {promise: promise, child: child};
    },
    warning: function(name, warning) {
        return {warning: warning};
    },
    unhandledRejection: function (name, reason, promise) {
        return {reason: reason, promise: promise};
    },
    rejectionHandled: generatePromiseLifecycleEventObject
};

var activeFireEvent = function (name) {
    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
    } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
    }

    var domEventFired = false;
    try {
        domEventFired = fireDomEvent(name,
                    eventToObjectGenerator[name].apply(null, arguments));
    } catch (e) {
        async.throwLater(e);
        domEventFired = true;
    }

    return domEventFired || globalEventFired;
};

Promise.config = function(opts) {
    opts = Object(opts);
    if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
            Promise.longStackTraces();
        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;

        if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
        }
    }
    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
            throw new Error(
                "cannot enable cancellation after promises are in use");
        }
        Promise.prototype._clearCancellationData =
            cancellationClearCancellationData;
        Promise.prototype._propagateFrom = cancellationPropagateFrom;
        Promise.prototype._onCancel = cancellationOnCancel;
        Promise.prototype._setOnCancel = cancellationSetOnCancel;
        Promise.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        Promise.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
    }
    if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise.prototype._fireEvent = defaultFireEvent;
        }
    }
    return Promise;
};

function defaultFireEvent() { return false; }

Promise.prototype._fireEvent = defaultFireEvent;
Promise.prototype._execute = function(executor, resolve, reject) {
    try {
        executor(resolve, reject);
    } catch (e) {
        return e;
    }
};
Promise.prototype._onCancel = function () {};
Promise.prototype._setOnCancel = function (handler) { ; };
Promise.prototype._attachCancellationCallback = function(onCancel) {
    ;
};
Promise.prototype._captureStackTrace = function () {};
Promise.prototype._attachExtraTrace = function () {};
Promise.prototype._clearCancellationData = function() {};
Promise.prototype._propagateFrom = function (parent, flags) {
    ;
    ;
};

function cancellationExecute(executor, resolve, reject) {
    var promise = this;
    try {
        executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } catch (e) {
        return e;
    }
}

function cancellationAttachCancellationCallback(onCancel) {
    if (!this._isCancellable()) return this;

    var previousOnCancel = this._onCancel();
    if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } else {
            this._setOnCancel([previousOnCancel, onCancel]);
        }
    } else {
        this._setOnCancel(onCancel);
    }
}

function cancellationOnCancel() {
    return this._onCancelField;
}

function cancellationSetOnCancel(onCancel) {
    this._onCancelField = onCancel;
}

function cancellationClearCancellationData() {
    this._cancellationParent = undefined;
    this._onCancelField = undefined;
}

function cancellationPropagateFrom(parent, flags) {
    if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
            branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
    }
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}

function bindingPropagateFrom(parent, flags) {
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}
var propagateFromFunction = bindingPropagateFrom;

function boundValueFunction() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
}

function longStackTracesCaptureStackTrace() {
    this._trace = new CapturedTrace(this._peekContext());
}

function longStackTracesAttachExtraTrace(error, ignoreSelf) {
    if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
}

function checkForgottenReturns(returnValue, promiseCreated, name, promise,
                               parent) {
    if (returnValue === undefined && promiseCreated !== null &&
        wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined()) return;
        if ((promise._bitField & 65535) === 0) return;

        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
                var line = stack[i];
                if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                        handlerLine  = "at " + lineMatches[1] +
                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                }
            }

            if (stack.length > 0) {
                var firstUserLine = stack[0];
                for (var i = 0; i < traceLines.length; ++i) {

                    if (traceLines[i] === firstUserLine) {
                        if (i > 0) {
                            creatorLine = "\n" + traceLines[i - 1];
                        }
                        break;
                    }
                }

            }
        }
        var msg = "a promise was created in a " + name +
            "handler " + handlerLine + "but was not returned from it, " +
            "see http://goo.gl/rRqMUw" +
            creatorLine;
        promise._warn(msg, true, promiseCreated);
    }
}

function deprecated(name, replacement) {
    var message = name +
        " is deprecated and will be removed in a future version.";
    if (replacement) message += " Use " + replacement + " instead.";
    return warn(message);
}

function warn(message, shouldUseOwnTrace, promise) {
    if (!config.warnings) return;
    var warning = new Warning(message);
    var ctx;
    if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }

    if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
    }
}

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line ||
            stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
    }
    return stack;
}

function parseStackAndMessage(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
    };
}

function formatAndLogError(error, title, isSoft) {
    if (typeof console !== "undefined") {
        var message;
        if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof printWarning === "function") {
            printWarning(message, isSoft);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
}

function fireRejectionEvent(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
        }
    } else {
        activeFireEvent(name, promise);
    }
}

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj && typeof obj.toString === "function"
            ? obj.toString() : util.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

function longStackTracesIsSupported() {
    return typeof captureStackTrace === "function";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}

function setBounds(firstLineError, lastLineError) {
    if (!longStackTracesIsSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
}

function CapturedTrace(parent) {
    this._parent = parent;
    this._promisesCreated = 0;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit += 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit -= 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    printWarning = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
            console.warn(color + message + "\u001b[0m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        printWarning = function(message, isSoft) {
            console.warn("%c" + message,
                        isSoft ? "color: darkorange" : "color: red");
        };
    }
}

var config = {
    warnings: warnings,
    longStackTraces: false,
    cancellation: false,
    monitoring: false
};

if (longStackTraces) Promise.longStackTraces();

return {
    longStackTraces: function() {
        return config.longStackTraces;
    },
    warnings: function() {
        return config.warnings;
    },
    cancellation: function() {
        return config.cancellation;
    },
    monitoring: function() {
        return config.monitoring;
    },
    propagateFromFunction: function() {
        return propagateFromFunction;
    },
    boundValueFunction: function() {
        return boundValueFunction;
    },
    checkForgottenReturns: checkForgottenReturns,
    setBounds: setBounds,
    warn: warn,
    deprecated: deprecated,
    CapturedTrace: CapturedTrace,
    fireDomEvent: fireDomEvent,
    fireGlobalEvent: fireGlobalEvent
};
};


/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, tryConvertToPromise) {
var util = __webpack_require__(398);
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;

function PassThroughHandlerContext(promise, type, handler) {
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
}

PassThroughHandlerContext.prototype.isFinallyHandler = function() {
    return this.type === 0;
};

function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret !== undefined) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== "function") return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};

Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

return PassThroughHandlerContext;
};


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(NEXT_FILTER) {
var util = __webpack_require__(398);
var getKeys = __webpack_require__(399).keys;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function catchFilter(instances, cb, promise) {
    return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];

            if (item === Error ||
                (item != null && item.prototype instanceof Error)) {
                if (e instanceof item) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (typeof item === "function") {
                var matchesPredicate = tryCatch(item).call(boundTo, e);
                if (matchesPredicate === errorObj) {
                    return matchesPredicate;
                } else if (matchesPredicate) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                    var key = keys[j];
                    if (item[key] != e[key]) {
                        continue predicateLoop;
                    }
                }
                return tryCatch(cb).call(boundTo, e);
            }
        }
        return NEXT_FILTER;
    };
}

return catchFilter;
};


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(398);
var maybeWrapAsError = util.maybeWrapAsError;
var errors = __webpack_require__(403);
var OperationalError = errors.OperationalError;
var es5 = __webpack_require__(399);

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
var util = __webpack_require__(398);
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    } else {
        value = tryCatch(fn)();
    }
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, "Promise.try", ret);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
    } else {
        this._resolveCallback(value, true);
    }
};
};


/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
var calledBind = false;
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (((this._bitField & 50397184) === 0)) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    if (!calledBind) {
        calledBind = true;
        Promise.prototype._propagateFrom = debug.propagateFromFunction();
        Promise.prototype._boundValue = debug.boundValueFunction();
    }
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~2097152);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 2097152) === 2097152;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};
};


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, PromiseArray, apiRejection, debug) {
var util = __webpack_require__(398);
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype["break"] = Promise.prototype.cancel = function() {
    if (!debug.cancellation()) return this._warn("cancellation is disabled");

    var promise = this;
    var child = promise;
    while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
                child._followee().cancel();
            } else {
                child._cancelBranched();
            }
            break;
        }

        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
                promise._followee().cancel();
            } else {
                promise._cancelBranched();
            }
            break;
        } else {
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
        }
    }
};

Promise.prototype._branchHasCancelled = function() {
    this._branchesRemainingToCancel--;
};

Promise.prototype._enoughBranchesHaveCancelled = function() {
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel <= 0;
};

Promise.prototype._cancelBy = function(canceller) {
    if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
        }
    }
    return false;
};

Promise.prototype._cancelBranched = function() {
    if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
    }
};

Promise.prototype._cancel = function() {
    if (!this._isCancellable()) return;
    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
};

Promise.prototype._cancelPromises = function() {
    if (this._length() > 0) this._settlePromises();
};

Promise.prototype._unsetOnCancel = function() {
    this._onCancelField = undefined;
};

Promise.prototype._isCancellable = function() {
    return this.isPending() && !this._isCancelled();
};

Promise.prototype.isCancellable = function() {
    return this.isPending() && !this.isCancelled();
};

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
    if (util.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
    } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                }
            }
        } else {
            onCancelCallback._resultCancelled(this);
        }
    }
};

Promise.prototype._invokeOnCancel = function() {
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
};

Promise.prototype._invokeInternalOnCancel = function() {
    if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    }
};

Promise.prototype._resultCancelled = function() {
    this.cancel();
};

};


/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise) {
function returner() {
    return this.value;
}
function thrower() {
    throw this.reason;
}

Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value instanceof Promise) value.suppressUnhandledRejections();
    return this._then(
        returner, undefined, undefined, {value: value}, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    return this._then(
        thrower, undefined, undefined, {reason: reason}, undefined);
};

Promise.prototype.catchThrow = function (reason) {
    if (arguments.length <= 1) {
        return this._then(
            undefined, thrower, undefined, {reason: reason}, undefined);
    } else {
        var _reason = arguments[1];
        var handler = function() {throw _reason;};
        return this.caught(reason, handler);
    }
};

Promise.prototype.catchReturn = function (value) {
    if (arguments.length <= 1) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(
            undefined, returner, undefined, {value: value}, undefined);
    } else {
        var _value = arguments[1];
        if (_value instanceof Promise) _value.suppressUnhandledRejections();
        var handler = function() {return _value;};
        return this.caught(value, handler);
    }
};
};


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed()
            ? promise._settledValue() : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValueField = undefined;
    }
}

PromiseInspection.prototype._settledValue = function() {
    return this._settledValueField;
};

var value = PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var reason = PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
    return (this._bitField & 33554432) !== 0;
};

var isRejected = PromiseInspection.prototype.isRejected = function () {
    return (this._bitField & 16777216) !== 0;
};

var isPending = PromiseInspection.prototype.isPending = function () {
    return (this._bitField & 50397184) === 0;
};

var isResolved = PromiseInspection.prototype.isResolved = function () {
    return (this._bitField & 50331648) !== 0;
};

PromiseInspection.prototype.isCancelled = function() {
    return (this._bitField & 8454144) !== 0;
};

Promise.prototype.__isCancelled = function() {
    return (this._bitField & 65536) === 65536;
};

Promise.prototype._isCancelled = function() {
    return this._target().__isCancelled();
};

Promise.prototype.isCancelled = function() {
    return (this._target()._bitField & 8454144) !== 0;
};

Promise.prototype.isPending = function() {
    return isPending.call(this._target());
};

Promise.prototype.isRejected = function() {
    return isRejected.call(this._target());
};

Promise.prototype.isFulfilled = function() {
    return isFulfilled.call(this._target());
};

Promise.prototype.isResolved = function() {
    return isResolved.call(this._target());
};

Promise.prototype.value = function() {
    return value.call(this._target());
};

Promise.prototype.reason = function() {
    var target = this._target();
    target._unsetRejectionIsUnhandled();
    return reason.call(target);
};

Promise.prototype._value = function() {
    return this._settledValue();
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue();
};

Promise.PromiseInspection = PromiseInspection;
};


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
         getDomain) {
var util = __webpack_require__(398);
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var promiseSetter = function(i) {
        return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
    };

    var generateHolderClass = function(total) {
        var props = new Array(total);
        for (var i = 0; i < props.length; ++i) {
            props[i] = "this.p" + (i+1);
        }
        var assignment = props.join(" = ") + " = null;";
        var cancellationCode= "var promise;\n" + props.map(function(prop) {
            return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
        }).join("\n");
        var passedArguments = props.join(", ");
        var name = "Holder$" + total;


        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

        code = code.replace(/\[TheName\]/g, name)
            .replace(/\[TheTotal\]/g, total)
            .replace(/\[ThePassedArguments\]/g, passedArguments)
            .replace(/\[TheProperties\]/g, assignment)
            .replace(/\[CancellationCode\]/g, cancellationCode);

        return new Function("tryCatch", "errorObj", "Promise", "async", code)
                           (tryCatch, errorObj, Promise, async);
    };

    var holderClasses = [];
    var thenCallbacks = [];
    var promiseSetters = [];

    for (var i = 0; i < 8; ++i) {
        holderClasses.push(generateHolderClass(i + 1));
        thenCallbacks.push(thenCallback(i + 1));
        promiseSetters.push(promiseSetter(i + 1));
    }

    reject = function (reason) {
        this._reject(reason);
    };
}}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (true) {
            if (last <= 8 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var HolderClass = holderClasses[last - 1];
                var holder = new HolderClass(fn);
                var callbacks = thenCallbacks;

                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField & 50397184) === 0)) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                            promiseSetters[i](maybePromise, holder);
                            holder.asyncNeeded = false;
                        } else if (((bitField & 33554432) !== 0)) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else if (((bitField & 16777216) !== 0)) {
                            ret._reject(maybePromise._reason());
                        } else {
                            ret._cancel();
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }

                if (!ret._isFateSealed()) {
                    if (holder.asyncNeeded) {
                        var domain = getDomain();
                        if (domain !== null) {
                            holder.fn = util.domainBind(domain, holder.fn);
                        }
                    }
                    ret._setAsyncGuaranteed();
                    ret._setOnCancel(holder);
                }
                return ret;
            }
        }
    }
    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];};
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = __webpack_require__(398);
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    var domain = getDomain();
    this._callback = domain === null ? fn : util.domainBind(domain, fn);
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = [];
    async.invoke(this._asyncInit, this, undefined);
}
util.inherits(MappingPromiseArray, PromiseArray);

MappingPromiseArray.prototype._asyncInit = function() {
    this._init$(undefined, -2);
};

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;

    if (index < 0) {
        index = (index * -1) - 1;
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return true;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var promise = this._promise;
        var callback = this._callback;
        var receiver = promise._boundValue();
        promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(
            ret,
            promiseCreated,
            preservedValues !== null ? "Promise.filter" : "Promise.map",
            promise
        );
        if (ret === errorObj) {
            this._reject(ret.e);
            return true;
        }

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if (((bitField & 50397184) === 0)) {
                if (limit >= 1) this._inFlight++;
                values[index] = maybePromise;
                maybePromise._proxy(this, (index + 1) * -1);
                return false;
            } else if (((bitField & 33554432) !== 0)) {
                ret = maybePromise._value();
            } else if (((bitField & 16777216) !== 0)) {
                this._reject(maybePromise._reason());
                return true;
            } else {
                this._cancel();
                return true;
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }
        return true;
    }
    return false;
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }

    var limit = 0;
    if (options !== undefined) {
        if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
                return Promise.reject(
                    new TypeError("'concurrency' must be a number but it is " +
                                    util.classString(options.concurrency)));
            }
            limit = options.concurrency;
        } else {
            return Promise.reject(new TypeError(
                            "options argument must be an object but it is " +
                             util.classString(options)));
        }
    }
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
}

Promise.prototype.map = function (fn, options) {
    return map(this, fn, options, null);
};

Promise.map = function (promises, fn, options, _filter) {
    return map(promises, fn, options, _filter);
};


};


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function(Promise) {
var util = __webpack_require__(398);
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (true) {
var makeMethodCaller = function (methodName) {
    return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
};

var makeGetter = function (propertyName) {
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
};

var getCompiled = function(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== "function") {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        }
    }
    return ret;
};

getMethodCaller = function(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
};

getGetter = function(name) {
    return getCompiled(name, makeGetter, getterCache);
};
}

function ensureMethod(obj, methodName) {
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj) + " has no method '" +
            util.toString(methodName) + "'";
        throw new Promise.TypeError(message);
    }
    return fn;
}

function caller(obj) {
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};
    if (true) {
        if (canEvaluate) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            }
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext, INTERNAL, debug) {
    var util = __webpack_require__(398);
    var TypeError = __webpack_require__(403).TypeError;
    var inherits = __webpack_require__(398).inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable &&
            typeof thenable._isDisposable === "function" &&
            typeof thenable._getDisposer === "function" &&
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &&
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return NULL;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== NULL
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &&
                typeof d.resource === "function" &&
                typeof d.tryDispose === "function");
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length-1] = null;
    }

    ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection(
                        "you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }

        var resultPromise = Promise.all(reflectedResources)
            .then(function(inspections) {
                for (var i = 0; i < inspections.length; ++i) {
                    var inspection = inspections[i];
                    if (inspection.isRejected()) {
                        errorObj.e = inspection.error();
                        return errorObj;
                    } else if (!inspection.isFulfilled()) {
                        resultPromise.cancel();
                        return;
                    }
                    inspections[i] = inspection.value();
                }
                promise._pushContext();

                fn = tryCatch(fn);
                var ret = spreadArgs
                    ? fn.apply(undefined, inspections) : fn(inspections);
                var promiseCreated = promise._popContext();
                debug.checkForgottenReturns(
                    ret, promiseCreated, "Promise.using", promise);
                return ret;
            });

        var promise = resultPromise.lastly(function() {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 131072) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & (~131072);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};


/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, INTERNAL, debug) {
var util = __webpack_require__(398);
var TimeoutError = Promise.TimeoutError;

function HandleWrapper(handle)  {
    this.handle = handle;
}

HandleWrapper.prototype._resultCancelled = function() {
    clearTimeout(this.handle);
};

var afterValue = function(value) { return delay(+this).thenReturn(value); };
var delay = Promise.delay = function (ms, value) {
    var ret;
    var handle;
    if (value !== undefined) {
        ret = Promise.resolve(value)
                ._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() && value instanceof Promise) {
            ret._setOnCancel(value);
        }
    } else {
        ret = new Promise(INTERNAL);
        handle = setTimeout(function() { ret._fulfill(); }, +ms);
        if (debug.cancellation()) {
            ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
    }
    ret._setAsyncGuaranteed();
    return ret;
};

Promise.prototype.delay = function (ms) {
    return delay(ms, this);
};

var afterTimeout = function (promise, message, parent) {
    var err;
    if (typeof message !== "string") {
        if (message instanceof Error) {
            err = message;
        } else {
            err = new TimeoutError("operation timed out");
        }
    } else {
        err = new TimeoutError(message);
    }
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._reject(err);

    if (parent != null) {
        parent.cancel();
    }
};

function successClear(value) {
    clearTimeout(this.handle);
    return value;
}

function failureClear(reason) {
    clearTimeout(this.handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var ret, parent;

    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
            afterTimeout(ret, message, parent);
        }
    }, ms));

    if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
    } else {
        ret = this._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
    }

    return ret;
};

};


/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise,
                          Proxyable,
                          debug) {
var errors = __webpack_require__(403);
var TypeError = errors.TypeError;
var util = __webpack_require__(398);
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    for (var i = 0; i < yieldHandlers.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
            traceParent._pushContext();
            var ret = Promise.reject(errorObj.e);
            traceParent._popContext();
            return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    if (debug.cancellation()) {
        var internal = new Promise(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
        this._promise = internal.lastly(function() {
            return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
    } else {
        var promise = this._promise = new Promise(INTERNAL);
        promise._captureStackTrace();
    }
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === "function"
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
    this._yieldedPromise = null;
    this._cancellationPhase = false;
}
util.inherits(PromiseSpawn, Proxyable);

PromiseSpawn.prototype._isResolved = function() {
    return this._promise === null;
};

PromiseSpawn.prototype._cleanup = function() {
    this._promise = this._generator = null;
    if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
    }
};

PromiseSpawn.prototype._promiseCancelled = function() {
    if (this._isResolved()) return;
    var implementsReturn = typeof this._generator["return"] !== "undefined";

    var result;
    if (!implementsReturn) {
        var reason = new Promise.CancellationError(
            "generator .return() sentinel");
        Promise.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(this._generator,
                                                         reason);
        this._promise._popContext();
    } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(this._generator,
                                                          undefined);
        this._promise._popContext();
    }
    this._cancellationPhase = true;
    this._yieldedPromise = null;
    this._continue(result);
};

PromiseSpawn.prototype._promiseFulfilled = function(value) {
    this._yieldedPromise = null;
    this._promise._pushContext();
    var result = tryCatch(this._generator.next).call(this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._promiseRejected = function(reason) {
    this._yieldedPromise = null;
    this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch(this._generator["throw"])
        .call(this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._resultCancelled = function() {
    if (this._yieldedPromise instanceof Promise) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
    }
};

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._promiseFulfilled(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    var promise = this._promise;
    if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
            return promise.cancel();
        } else {
            return promise._rejectCallback(result.e, false);
        }
    }

    var value = result.value;
    if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
            return promise.cancel();
        } else {
            return promise._resolveCallback(value);
        }
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._promiseRejected(
                    new TypeError(
                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) +
                        "From coroutine:\u000a" +
                        this._stack.split("\n").slice(1, -7).join("\n")
                    )
                );
                return;
            }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        ;
        if (((bitField & 50397184) === 0)) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
        } else if (((bitField & 33554432) !== 0)) {
            Promise._async.invoke(
                this._promiseFulfilled, this, maybePromise._value()
            );
        } else if (((bitField & 16777216) !== 0)) {
            Promise._async.invoke(
                this._promiseRejected, this, maybePromise._reason()
            );
        } else {
            this._promiseCancelled();
        }
    }
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== "function") {
        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(undefined);
        return ret;
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
    if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise) {
var util = __webpack_require__(398);
var async = Promise._async;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret =
        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundValue();
    var ret = val === undefined
        ? tryCatch(nodeback).call(receiver, null)
        : tryCatch(nodeback).call(receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
                                                                     options) {
    if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = __webpack_require__(398);
var nodebackForPromise = __webpack_require__(410);
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = __webpack_require__(403).TypeError;
var defaultSuffix = "Async";
var defaultPromisified = {__isPromisified__: true};
var noCopyProps = [
    "arity",    "length",
    "name",
    "arguments",
    "caller",
    "callee",
    "prototype",
    "__isPromisified__"
];
var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

var defaultFilter = function(name) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        name !== "constructor";
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, "\\$");
};

var makeNodePromisifiedEval;
if (true) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i >= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, "_arg", "");
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), "_arg", "");
};

var parameterCount = function(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn, _, multiArgs) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(", ");
        var comma = count > 0 ? ", " : "";
        var ret;
        if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
        } else {
            ret = receiver === undefined
                ? "ret = callback({{args}}, nodeback); break;\n"
                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        var ret = "";
        for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis
                                ? "ret = callback.apply(this, args);\n"
                                : "ret = callback.apply(receiver, args);\n"));
        return ret;
    }

    var getFunctionCode = typeof callback === "string"
                                ? ("this != null ? this['"+callback+"'] : fn")
                                : "fn";
    var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
        .replace("[GetFunctionCode]", getFunctionCode);
    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
    return new Function("Promise",
                        "fn",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "tryCatch",
                        "errorObj",
                        "notEnumerableProp",
                        "INTERNAL",
                        body)(
                    Promise,
                    fn,
                    receiver,
                    withAppended,
                    maybeWrapAsError,
                    nodebackForPromise,
                    util.tryCatch,
                    util.errorObj,
                    util.notEnumerableProp,
                    INTERNAL);
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === "string") {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise, multiArgs);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
        return promise;
    }
    util.notEnumerableProp(promisified, "__isPromisified__", true);
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i < len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] =
                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
            var promisified = promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key,
                                           fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj[promisifiedKey] = promisified;
        }
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver, multiArgs) {
    return makeNodePromisified(callback, receiver, undefined,
                                callback, null, multiArgs);
}

Promise.promisify = function (fn, options) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    if (isPromisified(fn)) {
        return fn;
    }
    options = Object(options);
    var receiver = options.context === undefined ? THIS : options.context;
    var multiArgs = !!options.multiArgs;
    var ret = promisify(fn, receiver, multiArgs);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    options = Object(options);
    var multiArgs = !!options.multiArgs;
    var suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier,
                multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
};
};



/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(
    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
var util = __webpack_require__(398);
var isObject = util.isObject;
var es5 = __webpack_require__(399);
var Es6Map;
if (typeof Map === "function") Es6Map = Map;

var mapToEntries = (function() {
    var index = 0;
    var size = 0;

    function extractEntry(value, key) {
        this[index] = value;
        this[index + size] = key;
        index++;
    }

    return function mapToEntries(map) {
        size = map.size;
        index = 0;
        var ret = new Array(map.size * 2);
        map.forEach(extractEntry, ret);
        return ret;
    };
})();

var entriesToMap = function(entries) {
    var ret = new Es6Map();
    var length = entries.length / 2 | 0;
    for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
    }
    return ret;
};

function PropertiesPromiseArray(obj) {
    var isMap = false;
    var entries;
    if (Es6Map !== undefined && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
    } else {
        var keys = es5.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj[key];
            entries[i + len] = key;
        }
    }
    this.constructor$(entries);
    this._isMap = isMap;
    this._init$(undefined, -3);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
            val = entriesToMap(this._values);
        } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
        }
        this._resolve(val);
        return true;
    }
    return false;
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len >> 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises);

    if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 2);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};


/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(
    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var util = __webpack_require__(398);

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else {
        promises = util.asArray(promises);
        if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 3);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];

        if (val === undefined && !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = __webpack_require__(398);
var tryCatch = util.tryCatch;

function ReductionPromiseArray(promises, fn, initialValue, _each) {
    this.constructor$(promises);
    var domain = getDomain();
    this._fn = domain === null ? fn : util.domainBind(domain, fn);
    if (initialValue !== undefined) {
        initialValue = Promise.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
    }
    this._initialValue = initialValue;
    this._currentCancellable = null;
    if(_each === INTERNAL) {
        this._eachValues = Array(this._length);
    } else if (_each === 0) {
        this._eachValues = null;
    } else {
        this._eachValues = undefined;
    }
    this._promise._captureStackTrace();
    this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._gotAccum = function(accum) {
    if (this._eachValues !== undefined && 
        this._eachValues !== null && 
        accum !== INTERNAL) {
        this._eachValues.push(accum);
    }
};

ReductionPromiseArray.prototype._eachComplete = function(value) {
    if (this._eachValues !== null) {
        this._eachValues.push(value);
    }
    return this._eachValues;
};

ReductionPromiseArray.prototype._init = function() {};

ReductionPromiseArray.prototype._resolveEmptyArray = function() {
    this._resolve(this._eachValues !== undefined ? this._eachValues
                                                 : this._initialValue);
};

ReductionPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

ReductionPromiseArray.prototype._resolve = function(value) {
    this._promise._resolveCallback(value);
    this._values = null;
};

ReductionPromiseArray.prototype._resultCancelled = function(sender) {
    if (sender === this._initialValue) return this._cancel();
    if (this._isResolved()) return;
    this._resultCancelled$();
    if (this._currentCancellable instanceof Promise) {
        this._currentCancellable.cancel();
    }
    if (this._initialValue instanceof Promise) {
        this._initialValue.cancel();
    }
};

ReductionPromiseArray.prototype._iterate = function (values) {
    this._values = values;
    var value;
    var i;
    var length = values.length;
    if (this._initialValue !== undefined) {
        value = this._initialValue;
        i = 0;
    } else {
        value = Promise.resolve(values[0]);
        i = 1;
    }

    this._currentCancellable = value;

    if (!value.isRejected()) {
        for (; i < length; ++i) {
            var ctx = {
                accum: null,
                value: values[i],
                index: i,
                length: length,
                array: this
            };
            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
        }
    }

    if (this._eachValues !== undefined) {
        value = value
            ._then(this._eachComplete, undefined, undefined, this, undefined);
    }
    value._then(completed, completed, undefined, value, this);
};

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};

function completed(valueOrReason, array) {
    if (this.isFulfilled()) {
        array._resolve(valueOrReason);
    } else {
        array._reject(valueOrReason);
    }
}

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

function gotAccum(accum) {
    this.accum = accum;
    this.array._gotAccum(accum);
    var value = tryConvertToPromise(this.value, this.array._promise);
    if (value instanceof Promise) {
        this.array._currentCancellable = value;
        return value._then(gotValue, undefined, undefined, this, undefined);
    } else {
        return gotValue.call(this, value);
    }
}

function gotValue(value) {
    var array = this.array;
    var promise = array._promise;
    var fn = tryCatch(array._fn);
    promise._pushContext();
    var ret;
    if (array._eachValues !== undefined) {
        ret = fn.call(promise._boundValue(), value, this.index, this.length);
    } else {
        ret = fn.call(promise._boundValue(),
                              this.accum, value, this.index, this.length);
    }
    if (ret instanceof Promise) {
        array._currentCancellable = ret;
    }
    var promiseCreated = promise._popContext();
    debug.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
        promise
    );
    return ret;
}
};


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports =
    function(Promise, PromiseArray, debug) {
var PromiseInspection = Promise.PromiseInspection;
var util = __webpack_require__(398);

function SettledPromiseArray(values) {
    this.constructor$(values);
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 33554432;
    ret._settledValueField = value;
    return this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 16777216;
    ret._settledValueField = reason;
    return this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    debug.deprecated(".settle()", ".reflect()");
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return Promise.settle(this);
};
};


/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = __webpack_require__(398);
var RangeError = __webpack_require__(403).RangeError;
var AggregateError = __webpack_require__(403).AggregateError;
var isArray = util.isArray;
var CANCELLATION = {};


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &&
        isArrayResolved &&
        this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
        return true;
    }
    return false;

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    return this._checkOutcome();
};

SomePromiseArray.prototype._promiseCancelled = function () {
    if (this._values instanceof Promise || this._values == null) {
        return this._cancel();
    }
    this._addRejected(CANCELLATION);
    return this._checkOutcome();
};

SomePromiseArray.prototype._checkOutcome = function() {
    if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
                e.push(this._values[i]);
            }
        }
        if (e.length > 0) {
            this._reject(e);
        } else {
            this._cancel();
        }
        return true;
    }
    return false;
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = "Input array must contain at least " +
            this._howMany + " items but contains only " + count + " items";
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};


/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;
var PromiseAll = Promise.all;

function promiseAllThis() {
    return PromiseAll(this);
}

function PromiseMapSeries(promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
}

Promise.prototype.each = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, 0)
              ._then(promiseAllThis, undefined, undefined, this, undefined);
};

Promise.prototype.mapSeries = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, 0)
              ._then(promiseAllThis, undefined, undefined, promises, undefined);
};

Promise.mapSeries = PromiseMapSeries;
};



/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(106);
var Promise = __webpack_require__(396);
var util = __webpack_require__(74);
var Buffer = __webpack_require__(433);
var strFunction = 'function';

// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = __webpack_require__(434);

function PullStream() {
  if (!(this instanceof PullStream))
    return new PullStream();

  Stream.Duplex.call(this,{decodeStrings:false, objectMode:true});
  this.buffer = Buffer.from('');
  var self = this;
  self.on('finish',function() {
    self.finished = true;
    self.emit('chunk',false);
  });
}

util.inherits(PullStream,Stream.Duplex);

PullStream.prototype._write = function(chunk,e,cb) {
  this.buffer = Buffer.concat([this.buffer,chunk]);
  this.cb = cb;
  this.emit('chunk');
};


// The `eof` parameter is interpreted as `file_length` if the type is number
// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream
PullStream.prototype.stream = function(eof,includeEof) {
  var p = Stream.PassThrough();
  var done,self= this;

  function cb() {
    if (typeof self.cb === strFunction) {
      var callback = self.cb;
      self.cb = undefined;
      return callback();
    }
  }

  function pull() {
    var packet;
    if (self.buffer && self.buffer.length) {
      if (typeof eof === 'number') {
        packet = self.buffer.slice(0,eof);
        self.buffer = self.buffer.slice(eof);
        eof -= packet.length;
        done = !eof;
      } else {
        var match = self.buffer.indexOf(eof);
        if (match !== -1) {
          // store signature match byte offset to allow us to reference
          // this for zip64 offset
          self.match = match
          if (includeEof) match = match + eof.length;
          packet = self.buffer.slice(0,match);
          self.buffer = self.buffer.slice(match);
          done = true;
        } else {
          var len = self.buffer.length - eof.length;
          if (len <= 0) {
            cb();
          } else {
            packet = self.buffer.slice(0,len);
            self.buffer = self.buffer.slice(len);
          }
        }
      }
      if (packet) p.write(packet,function() {
        if (self.buffer.length === 0 || (eof.length && self.buffer.length <= eof.length)) cb();
      });
    }
    
    if (!done) {
      if (self.finished && !this.__ended) {
        self.removeListener('chunk',pull);
        self.emit('error', new Error('FILE_ENDED'));
        this.__ended = true;
        return;
      }
      
    } else {
      self.removeListener('chunk',pull);
      p.end();
    }
  }

  self.on('chunk',pull);
  pull();
  return p;
};

PullStream.prototype.pull = function(eof,includeEof) {
  if (eof === 0) return Promise.resolve('');

  // If we already have the required data in buffer
  // we can resolve the request immediately
  if (!isNaN(eof) && this.buffer.length > eof) {
    var data = this.buffer.slice(0,eof);
    this.buffer = this.buffer.slice(eof);
    return Promise.resolve(data);
  }

  // Otherwise we stream until we have it
  var buffer = Buffer.from(''),
      self = this;

  var concatStream = Stream.Transform();
  concatStream._transform = function(d,e,cb) {
    buffer = Buffer.concat([buffer,d]);
    cb();
  };
  
  var rejectHandler;
  var pullStreamRejectHandler;
  return new Promise(function(resolve,reject) {
    rejectHandler = reject;
    pullStreamRejectHandler = function(e) {
      self.__emittedError = e;
      reject(e);
    }
    if (self.finished)
      return reject(new Error('FILE_ENDED'));
    self.once('error',pullStreamRejectHandler);  // reject any errors from pullstream itself
    self.stream(eof,includeEof)
      .on('error',reject)
      .pipe(concatStream)
      .on('finish',function() {resolve(buffer);})
      .on('error',reject);
  })
  .finally(function() {
    self.removeListener('error',rejectHandler);
    self.removeListener('error',pullStreamRejectHandler);
  });
};

PullStream.prototype._read = function(){};

module.exports = PullStream;


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(316).Buffer;

// Backwards compatibility for node versions < 8
if (Buffer.from === undefined) {
  Buffer.from = function (a, b, c) {
    return new Buffer(a, b, c)
  };

  Buffer.alloc = Buffer.from;
}

module.exports = Buffer;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(106);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__(435);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__(443);
  exports.Duplex = __webpack_require__(442);
  exports.Transform = __webpack_require__(446);
  exports.PassThrough = __webpack_require__(447);
}


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(436);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(167);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(198).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(437);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(438).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__(439));
util.inherits = __webpack_require__(275);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(74);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(440);
var destroyImpl = __webpack_require__(441);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(442);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(445).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(442);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(445).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}



/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(106);


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(316)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 439 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(438).Buffer;
var util = __webpack_require__(74);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(436);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(436);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__(439));
util.inherits = __webpack_require__(275);
/*</replacement>*/

var Readable = __webpack_require__(435);
var Writable = __webpack_require__(443);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(436);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__(439));
util.inherits = __webpack_require__(275);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(444)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(437);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(438).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(441);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(442);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(442);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __webpack_require__(74).deprecate;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(438).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(442);

/*<replacement>*/
var util = Object.create(__webpack_require__(439));
util.inherits = __webpack_require__(275);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(446);

/*<replacement>*/
var util = Object.create(__webpack_require__(439));
util.inherits = __webpack_require__(275);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(106);
var util = __webpack_require__(74);

// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = __webpack_require__(434);

function NoopStream() {
  if (!(this instanceof NoopStream)) {
    return new NoopStream();
  }
  Stream.Transform.call(this);
}

util.inherits(NoopStream,Stream.Transform);

NoopStream.prototype._transform = function(d,e,cb) { cb() ;};
  
module.exports = NoopStream;

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

var Promise = __webpack_require__(396);
var Stream = __webpack_require__(106);
var Buffer = __webpack_require__(433);

// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = __webpack_require__(434);

module.exports = function(entry) {
  return new Promise(function(resolve,reject) {
    var chunks = [];
    var bufferStream = Stream.Transform()
      .on('finish',function() {
        resolve(Buffer.concat(chunks));
      })
      .on('error',reject);
        
    bufferStream._transform = function(d,e,cb) {
      chunks.push(d);
      cb();
    };
    entry.on('error',reject)
      .pipe(bufferStream);
  });
};


/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

var binary = __webpack_require__(391);

module.exports = function(extraField, vars) {
  var extra;
  // Find the ZIP64 header, if present.
  while(!extra && extraField && extraField.length) {
    var candidateExtra = binary.parse(extraField)
      .word16lu('signature')
      .word16lu('partsize')
      .word64lu('uncompressedSize')
      .word64lu('compressedSize')
      .word64lu('offset')
      .word64lu('disknum')
      .vars;

    if(candidateExtra.signature === 0x0001) {
      extra = candidateExtra;
    } else {
      // Advance the buffer to the next part.
      // The total size of this part is the 4 byte header + partsize.
      extraField = extraField.slice(candidateExtra.partsize + 4);
    }
  }

  extra = extra || {};

  if (vars.compressedSize === 0xffffffff)
    vars.compressedSize = extra.compressedSize;

  if (vars.uncompressedSize  === 0xffffffff)
    vars.uncompressedSize= extra.uncompressedSize;

  if (vars.offsetToLocalFileHeader === 0xffffffff)
    vars.offsetToLocalFileHeader= extra.offset;

  return extra;
};


/***/ }),
/* 451 */
/***/ (function(module, exports) {

// Dates in zip file entries are stored as DosDateTime
// Spec is here: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime

module.exports = function parseDateTime(date, time) {
  const day = date & 0x1F;
  const month = date >> 5 & 0x0F;
  const year = (date >> 9 & 0x7F) + 1980;
  const seconds = time ? (time & 0x1F) * 2 : 0;
  const minutes = time ? (time >> 5) & 0x3F : 0;
  const hours = time ? (time >> 11): 0;

  return new Date(Date.UTC(year, month-1, day, hours, minutes, seconds));
};

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(106);
var Parse = __webpack_require__(390);
var duplexer2 = __webpack_require__(453);
var BufferStream = __webpack_require__(449);

// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = __webpack_require__(434);

function parseOne(match,opts) {
  var inStream = Stream.PassThrough({objectMode:true});
  var outStream = Stream.PassThrough();
  var transform = Stream.Transform({objectMode:true});
  var re = match instanceof RegExp ? match : (match && new RegExp(match));
  var found;

  transform._transform = function(entry,e,cb) {
    if (found || (re && !re.exec(entry.path))) {
      entry.autodrain();
      return cb();
    } else {
      found = true;
      out.emit('entry',entry);
      entry.on('error',function(e) {
        outStream.emit('error',e);
      });
      entry.pipe(outStream)
        .on('error',function(err) {
          cb(err);
        })
        .on('finish',function(d) {
          cb(null,d);
        });
    }
  };

  inStream.pipe(Parse(opts))
    .on('error',function(err) {
      outStream.emit('error',err);
    })
    .pipe(transform)
    .on('error',Object)  // Silence error as its already addressed in transform
    .on('finish',function() {
      if (!found)
        outStream.emit('error',new Error('PATTERN_NOT_FOUND'));
      else
        outStream.end();
    });

  var out = duplexer2(inStream,outStream);
  out.buffer = function() {
    return BufferStream(outStream);
  };

  return out;
}

module.exports = parseOne;


/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stream = __webpack_require__(434);

function DuplexWrapper(options, writable, readable) {
  if (typeof readable === "undefined") {
    readable = writable;
    writable = options;
    options = null;
  }

  stream.Duplex.call(this, options);

  if (typeof readable.read !== "function") {
    readable = (new stream.Readable(options)).wrap(readable);
  }

  this._writable = writable;
  this._readable = readable;
  this._waiting = false;

  var self = this;

  writable.once("finish", function() {
    self.end();
  });

  this.once("finish", function() {
    writable.end();
  });

  readable.on("readable", function() {
    if (self._waiting) {
      self._waiting = false;
      self._read();
    }
  });

  readable.once("end", function() {
    self.push(null);
  });

  if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
    writable.on("error", function(err) {
      self.emit("error", err);
    });

    readable.on("error", function(err) {
      self.emit("error", err);
    });
  }
}

DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});

DuplexWrapper.prototype._write = function _write(input, encoding, done) {
  this._writable.write(input, encoding, done);
};

DuplexWrapper.prototype._read = function _read() {
  var buf;
  var reads = 0;
  while ((buf = this._readable.read()) !== null) {
    this.push(buf);
    reads++;
  }
  if (reads === 0) {
    this._waiting = true;
  }
};

module.exports = function duplex2(options, writable, readable) {
  return new DuplexWrapper(options, writable, readable);
};

module.exports.DuplexWrapper = DuplexWrapper;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Extract;

var Parse = __webpack_require__(390);
var Writer = __webpack_require__(455).Writer;
var path = __webpack_require__(82);
var stream = __webpack_require__(106);
var duplexer2 = __webpack_require__(453);
var Promise = __webpack_require__(396);

function Extract (opts) {
  // make sure path is normalized before using it
  opts.path = path.resolve(path.normalize(opts.path));

  var parser = new Parse(opts);

  var outStream = new stream.Writable({objectMode: true});
  outStream._write = function(entry, encoding, cb) {

    if (entry.type == 'Directory') return cb();

    // to avoid zip slip (writing outside of the destination), we resolve
    // the target path, and make sure it's nested in the intended
    // destination, or not extract it otherwise.
    var extractPath = path.join(opts.path, entry.path);
    if (extractPath.indexOf(opts.path) != 0) {
      return cb();
    }

    const writer = opts.getWriter ? opts.getWriter({path: extractPath}) :  Writer({ path: extractPath });

    entry.pipe(writer)
      .on('error', cb)
      .on('close', cb);
  };

  var extract = duplexer2(parser,outStream);
  parser.once('crx-header', function(crxHeader) {
    extract.crxHeader = crxHeader;
  });

  parser
    .pipe(outStream)
    .on('finish',function() {
      extract.emit('close');
    });
  
  extract.promise = function() {
    return new Promise(function(resolve, reject) {
      extract.on('close', resolve);
      extract.on('error',reject);
    });
  };

  return extract;
}


/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

exports.Abstract = __webpack_require__(456)
exports.Reader = __webpack_require__(457)
exports.Writer = __webpack_require__(464)

exports.File = {
  Reader: __webpack_require__(461),
  Writer: __webpack_require__(470)
}

exports.Dir = {
  Reader: __webpack_require__(460),
  Writer: __webpack_require__(467)
}

exports.Link = {
  Reader: __webpack_require__(459),
  Writer: __webpack_require__(469)
}

exports.Proxy = {
  Reader: __webpack_require__(463),
  Writer: __webpack_require__(471)
}

exports.Reader.Dir = exports.DirReader = exports.Dir.Reader
exports.Reader.File = exports.FileReader = exports.File.Reader
exports.Reader.Link = exports.LinkReader = exports.Link.Reader
exports.Reader.Proxy = exports.ProxyReader = exports.Proxy.Reader

exports.Writer.Dir = exports.DirWriter = exports.Dir.Writer
exports.Writer.File = exports.FileWriter = exports.File.Writer
exports.Writer.Link = exports.LinkWriter = exports.Link.Writer
exports.Writer.Proxy = exports.ProxyWriter = exports.Proxy.Writer

exports.collect = __webpack_require__(468)


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

// the parent class for all fstreams.

module.exports = Abstract

var Stream = __webpack_require__(106).Stream
var inherits = __webpack_require__(275)

function Abstract () {
  Stream.call(this)
}

inherits(Abstract, Stream)

Abstract.prototype.on = function (ev, fn) {
  if (ev === 'ready' && this.ready) {
    process.nextTick(fn.bind(this))
  } else {
    Stream.prototype.on.call(this, ev, fn)
  }
  return this
}

Abstract.prototype.abort = function () {
  this._aborted = true
  this.emit('abort')
}

Abstract.prototype.destroy = function () {}

Abstract.prototype.warn = function (msg, code) {
  var self = this
  var er = decorate(msg, code, self)
  if (!self.listeners('warn')) {
    console.error('%s %s\n' +
    'path = %s\n' +
    'syscall = %s\n' +
    'fstream_type = %s\n' +
    'fstream_path = %s\n' +
    'fstream_unc_path = %s\n' +
    'fstream_class = %s\n' +
    'fstream_stack =\n%s\n',
      code || 'UNKNOWN',
      er.stack,
      er.path,
      er.syscall,
      er.fstream_type,
      er.fstream_path,
      er.fstream_unc_path,
      er.fstream_class,
      er.fstream_stack.join('\n'))
  } else {
    self.emit('warn', er)
  }
}

Abstract.prototype.info = function (msg, code) {
  this.emit('info', msg, code)
}

Abstract.prototype.error = function (msg, code, th) {
  var er = decorate(msg, code, this)
  if (th) throw er
  else this.emit('error', er)
}

function decorate (er, code, self) {
  if (!(er instanceof Error)) er = new Error(er)
  er.code = er.code || code
  er.path = er.path || self.path
  er.fstream_type = er.fstream_type || self.type
  er.fstream_path = er.fstream_path || self.path
  if (self._path !== self.path) {
    er.fstream_unc_path = er.fstream_unc_path || self._path
  }
  if (self.linkpath) {
    er.fstream_linkpath = er.fstream_linkpath || self.linkpath
  }
  er.fstream_class = er.fstream_class || self.constructor.name
  er.fstream_stack = er.fstream_stack ||
    new Error().stack.split(/\n/).slice(3).map(function (s) {
      return s.replace(/^ {4}at /, '')
    })

  return er
}


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Reader

var fs = __webpack_require__(102)
var Stream = __webpack_require__(106).Stream
var inherits = __webpack_require__(275)
var path = __webpack_require__(82)
var getType = __webpack_require__(458)
var hardLinks = Reader.hardLinks = {}
var Abstract = __webpack_require__(456)

// Must do this *before* loading the child classes
inherits(Reader, Abstract)

var LinkReader = __webpack_require__(459)

function Reader (props, currentStat) {
  var self = this
  if (!(self instanceof Reader)) return new Reader(props, currentStat)

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Reader(dir) to get a DirReader object, etc.
  // Note that, unlike in the Writer case, ProxyReader is going
  // to be the *normal* state of affairs, since we rarely know
  // the type of a file prior to reading it.

  var type
  var ClassType

  if (props.type && typeof props.type === 'function') {
    type = props.type
    ClassType = type
  } else {
    type = getType(props)
    ClassType = Reader
  }

  if (currentStat && !type) {
    type = getType(currentStat)
    props[type] = true
    props.type = type
  }

  switch (type) {
    case 'Directory':
      ClassType = __webpack_require__(460)
      break

    case 'Link':
    // XXX hard links are just files.
    // However, it would be good to keep track of files' dev+inode
    // and nlink values, and create a HardLinkReader that emits
    // a linkpath value of the original copy, so that the tar
    // writer can preserve them.
    // ClassType = HardLinkReader
    // break

    case 'File':
      ClassType = __webpack_require__(461)
      break

    case 'SymbolicLink':
      ClassType = LinkReader
      break

    case 'Socket':
      ClassType = __webpack_require__(462)
      break

    case null:
      ClassType = __webpack_require__(463)
      break
  }

  if (!(self instanceof ClassType)) {
    return new ClassType(props)
  }

  Abstract.call(self)

  if (!props.path) {
    self.error('Must provide a path', null, true)
  }

  self.readable = true
  self.writable = false

  self.type = type
  self.props = props
  self.depth = props.depth = props.depth || 0
  self.parent = props.parent || null
  self.root = props.root || (props.parent && props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length >= 260) {
      // how DOES one create files on the moon?
      // if the path has spaces in it, then UNC will fail.
      self._swallowErrors = true
      // if (self._path.indexOf(" ") === -1) {
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    // }
    }
  }
  self.basename = props.basename = path.basename(self.path)
  self.dirname = props.dirname = path.dirname(self.path)

  // these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size
  self.filter = typeof props.filter === 'function' ? props.filter : null
  if (props.sort === 'alpha') props.sort = alphasort

  // start the ball rolling.
  // this will stat the thing, and then call self._read()
  // to start reading whatever it is.
  // console.error("calling stat", props.path, currentStat)
  self._stat(currentStat)
}

function alphasort (a, b) {
  return a === b ? 0
    : a.toLowerCase() > b.toLowerCase() ? 1
      : a.toLowerCase() < b.toLowerCase() ? -1
        : a > b ? 1
          : -1
}

Reader.prototype._stat = function (currentStat) {
  var self = this
  var props = self.props
  var stat = props.follow ? 'stat' : 'lstat'
  // console.error("Reader._stat", self._path, currentStat)
  if (currentStat) process.nextTick(statCb.bind(null, null, currentStat))
  else fs[stat](self._path, statCb)

  function statCb (er, props_) {
    // console.error("Reader._stat, statCb", self._path, props_, props_.nlink)
    if (er) return self.error(er)

    Object.keys(props_).forEach(function (k) {
      props[k] = props_[k]
    })

    // if it's not the expected size, then abort here.
    if (undefined !== self.size && props.size !== self.size) {
      return self.error('incorrect size')
    }
    self.size = props.size

    var type = getType(props)
    var handleHardlinks = props.hardlinks !== false

    // special little thing for handling hardlinks.
    if (handleHardlinks && type !== 'Directory' && props.nlink && props.nlink > 1) {
      var k = props.dev + ':' + props.ino
      // console.error("Reader has nlink", self._path, k)
      if (hardLinks[k] === self._path || !hardLinks[k]) {
        hardLinks[k] = self._path
      } else {
        // switch into hardlink mode.
        type = self.type = self.props.type = 'Link'
        self.Link = self.props.Link = true
        self.linkpath = self.props.linkpath = hardLinks[k]
        // console.error("Hardlink detected, switching mode", self._path, self.linkpath)
        // Setting __proto__ would arguably be the "correct"
        // approach here, but that just seems too wrong.
        self._stat = self._read = LinkReader.prototype._read
      }
    }

    if (self.type && self.type !== type) {
      self.error('Unexpected type: ' + type)
    }

    // if the filter doesn't pass, then just skip over this one.
    // still have to emit end so that dir-walking can move on.
    if (self.filter) {
      var who = self._proxy || self
      // special handling for ProxyReaders
      if (!self.filter.call(who, who, props)) {
        if (!self._disowned) {
          self.abort()
          self.emit('end')
          self.emit('close')
        }
        return
      }
    }

    // last chance to abort or disown before the flow starts!
    var events = ['_stat', 'stat', 'ready']
    var e = 0
    ;(function go () {
      if (self._aborted) {
        self.emit('end')
        self.emit('close')
        return
      }

      if (self._paused && self.type !== 'Directory') {
        self.once('resume', go)
        return
      }

      var ev = events[e++]
      if (!ev) {
        return self._read()
      }
      self.emit(ev, props)
      go()
    })()
  }
}

Reader.prototype.pipe = function (dest) {
  var self = this
  if (typeof dest.add === 'function') {
    // piping to a multi-compatible, and we've got directory entries.
    self.on('entry', function (entry) {
      var ret = dest.add(entry)
      if (ret === false) {
        self.pause()
      }
    })
  }

  // console.error("R Pipe apply Stream Pipe")
  return Stream.prototype.pipe.apply(this, arguments)
}

Reader.prototype.pause = function (who) {
  this._paused = true
  who = who || this
  this.emit('pause', who)
  if (this._stream) this._stream.pause(who)
}

Reader.prototype.resume = function (who) {
  this._paused = false
  who = who || this
  this.emit('resume', who)
  if (this._stream) this._stream.resume(who)
  this._read()
}

Reader.prototype._read = function () {
  this.error('Cannot read unknown type: ' + this.type)
}


/***/ }),
/* 458 */
/***/ (function(module, exports) {

module.exports = getType

function getType (st) {
  var types = [
    'Directory',
    'File',
    'SymbolicLink',
    'Link', // special for hardlinks from tarballs
    'BlockDevice',
    'CharacterDevice',
    'FIFO',
    'Socket'
  ]
  var type

  if (st.type && types.indexOf(st.type) !== -1) {
    st[st.type] = true
    return st.type
  }

  for (var i = 0, l = types.length; i < l; i++) {
    type = types[i]
    var is = st[type] || st['is' + type]
    if (typeof is === 'function') is = is.call(st)
    if (is) {
      st[type] = true
      st.type = type
      return type
    }
  }

  return null
}


/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

// Basically just a wrapper around an fs.readlink
//
// XXX: Enhance this to support the Link type, by keeping
// a lookup table of {<dev+inode>:<path>}, so that hardlinks
// can be preserved in tarballs.

module.exports = LinkReader

var fs = __webpack_require__(102)
var inherits = __webpack_require__(275)
var Reader = __webpack_require__(457)

inherits(LinkReader, Reader)

function LinkReader (props) {
  var self = this
  if (!(self instanceof LinkReader)) {
    throw new Error('LinkReader must be called as constructor.')
  }

  if (!((props.type === 'Link' && props.Link) ||
    (props.type === 'SymbolicLink' && props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  Reader.call(self, props)
}

// When piping a LinkReader into a LinkWriter, we have to
// already have the linkpath property set, so that has to
// happen *before* the "ready" event, which means we need to
// override the _stat method.
LinkReader.prototype._stat = function (currentStat) {
  var self = this
  fs.readlink(self._path, function (er, linkpath) {
    if (er) return self.error(er)
    self.linkpath = self.props.linkpath = linkpath
    self.emit('linkpath', linkpath)
    Reader.prototype._stat.call(self, currentStat)
  })
}

LinkReader.prototype._read = function () {
  var self = this
  if (self._paused) return
  // basically just a no-op, since we got all the info we need
  // from the _stat method
  if (!self._ended) {
    self.emit('end')
    self.emit('close')
    self._ended = true
  }
}


/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

// A thing that emits "entry" events with Reader objects
// Pausing it causes it to stop emitting entry events, and also
// pauses the current entry if there is one.

module.exports = DirReader

var fs = __webpack_require__(102)
var inherits = __webpack_require__(275)
var path = __webpack_require__(82)
var Reader = __webpack_require__(457)
var assert = __webpack_require__(108).ok

inherits(DirReader, Reader)

function DirReader (props) {
  var self = this
  if (!(self instanceof DirReader)) {
    throw new Error('DirReader must be called as constructor.')
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    throw new Error('Non-directory type ' + props.type)
  }

  self.entries = null
  self._index = -1
  self._paused = false
  self._length = -1

  if (props.sort) {
    this.sort = props.sort
  }

  Reader.call(this, props)
}

DirReader.prototype._getEntries = function () {
  var self = this

  // race condition.  might pause() before calling _getEntries,
  // and then resume, and try to get them a second time.
  if (self._gotEntries) return
  self._gotEntries = true

  fs.readdir(self._path, function (er, entries) {
    if (er) return self.error(er)

    self.entries = entries

    self.emit('entries', entries)
    if (self._paused) self.once('resume', processEntries)
    else processEntries()

    function processEntries () {
      self._length = self.entries.length
      if (typeof self.sort === 'function') {
        self.entries = self.entries.sort(self.sort.bind(self))
      }
      self._read()
    }
  })
}

// start walking the dir, and emit an "entry" event for each one.
DirReader.prototype._read = function () {
  var self = this

  if (!self.entries) return self._getEntries()

  if (self._paused || self._currentEntry || self._aborted) {
    // console.error('DR paused=%j, current=%j, aborted=%j', self._paused, !!self._currentEntry, self._aborted)
    return
  }

  self._index++
  if (self._index >= self.entries.length) {
    if (!self._ended) {
      self._ended = true
      self.emit('end')
      self.emit('close')
    }
    return
  }

  // ok, handle this one, then.

  // save creating a proxy, by stat'ing the thing now.
  var p = path.resolve(self._path, self.entries[self._index])
  assert(p !== self._path)
  assert(self.entries[self._index])

  // set this to prevent trying to _read() again in the stat time.
  self._currentEntry = p
  fs[ self.props.follow ? 'stat' : 'lstat' ](p, function (er, stat) {
    if (er) return self.error(er)

    var who = self._proxy || self

    stat.path = p
    stat.basename = path.basename(p)
    stat.dirname = path.dirname(p)
    var childProps = self.getChildProps.call(who, stat)
    childProps.path = p
    childProps.basename = path.basename(p)
    childProps.dirname = path.dirname(p)

    var entry = Reader(childProps, stat)

    // console.error("DR Entry", p, stat.size)

    self._currentEntry = entry

    // "entry" events are for direct entries in a specific dir.
    // "child" events are for any and all children at all levels.
    // This nomenclature is not completely final.

    entry.on('pause', function (who) {
      if (!self._paused && !entry._disowned) {
        self.pause(who)
      }
    })

    entry.on('resume', function (who) {
      if (self._paused && !entry._disowned) {
        self.resume(who)
      }
    })

    entry.on('stat', function (props) {
      self.emit('_entryStat', entry, props)
      if (entry._aborted) return
      if (entry._paused) {
        entry.once('resume', function () {
          self.emit('entryStat', entry, props)
        })
      } else self.emit('entryStat', entry, props)
    })

    entry.on('ready', function EMITCHILD () {
      // console.error("DR emit child", entry._path)
      if (self._paused) {
        // console.error("  DR emit child - try again later")
        // pause the child, and emit the "entry" event once we drain.
        // console.error("DR pausing child entry")
        entry.pause(self)
        return self.once('resume', EMITCHILD)
      }

      // skip over sockets.  they can't be piped around properly,
      // so there's really no sense even acknowledging them.
      // if someone really wants to see them, they can listen to
      // the "socket" events.
      if (entry.type === 'Socket') {
        self.emit('socket', entry)
      } else {
        self.emitEntry(entry)
      }
    })

    var ended = false
    entry.on('close', onend)
    entry.on('disown', onend)
    function onend () {
      if (ended) return
      ended = true
      self.emit('childEnd', entry)
      self.emit('entryEnd', entry)
      self._currentEntry = null
      if (!self._paused) {
        self._read()
      }
    }

    // XXX Remove this.  Works in node as of 0.6.2 or so.
    // Long filenames should not break stuff.
    entry.on('error', function (er) {
      if (entry._swallowErrors) {
        self.warn(er)
        entry.emit('end')
        entry.emit('close')
      } else {
        self.emit('error', er)
      }
    })

    // proxy up some events.
    ;[
      'child',
      'childEnd',
      'warn'
    ].forEach(function (ev) {
      entry.on(ev, self.emit.bind(self, ev))
    })
  })
}

DirReader.prototype.disown = function (entry) {
  entry.emit('beforeDisown')
  entry._disowned = true
  entry.parent = entry.root = null
  if (entry === this._currentEntry) {
    this._currentEntry = null
  }
  entry.emit('disown')
}

DirReader.prototype.getChildProps = function () {
  return {
    depth: this.depth + 1,
    root: this.root || this,
    parent: this,
    follow: this.follow,
    filter: this.filter,
    sort: this.props.sort,
    hardlinks: this.props.hardlinks
  }
}

DirReader.prototype.pause = function (who) {
  var self = this
  if (self._paused) return
  who = who || self
  self._paused = true
  if (self._currentEntry && self._currentEntry.pause) {
    self._currentEntry.pause(who)
  }
  self.emit('pause', who)
}

DirReader.prototype.resume = function (who) {
  var self = this
  if (!self._paused) return
  who = who || self

  self._paused = false
  // console.error('DR Emit Resume', self._path)
  self.emit('resume', who)
  if (self._paused) {
    // console.error('DR Re-paused', self._path)
    return
  }

  if (self._currentEntry) {
    if (self._currentEntry.resume) self._currentEntry.resume(who)
  } else self._read()
}

DirReader.prototype.emitEntry = function (entry) {
  this.emit('entry', entry)
  this.emit('child', entry)
}


/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

// Basically just a wrapper around an fs.ReadStream

module.exports = FileReader

var fs = __webpack_require__(102)
var inherits = __webpack_require__(275)
var Reader = __webpack_require__(457)
var EOF = {EOF: true}
var CLOSE = {CLOSE: true}

inherits(FileReader, Reader)

function FileReader (props) {
  // console.error("    FR create", props.path, props.size, new Error().stack)
  var self = this
  if (!(self instanceof FileReader)) {
    throw new Error('FileReader must be called as constructor.')
  }

  // should already be established as a File type
  // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,
  // with a HardLinkReader class.
  if (!((props.type === 'Link' && props.Link) ||
    (props.type === 'File' && props.File))) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesEmitted = 0
  Reader.call(self, props)
}

FileReader.prototype._getStream = function () {
  var self = this
  var stream = self._stream = fs.createReadStream(self._path, self.props)

  if (self.props.blksize) {
    stream.bufferSize = self.props.blksize
  }

  stream.on('open', self.emit.bind(self, 'open'))

  stream.on('data', function (c) {
    // console.error('\t\t%d %s', c.length, self.basename)
    self._bytesEmitted += c.length
    // no point saving empty chunks
    if (!c.length) {
      return
    } else if (self._paused || self._buffer.length) {
      self._buffer.push(c)
      self._read()
    } else self.emit('data', c)
  })

  stream.on('end', function () {
    if (self._paused || self._buffer.length) {
      // console.error('FR Buffering End', self._path)
      self._buffer.push(EOF)
      self._read()
    } else {
      self.emit('end')
    }

    if (self._bytesEmitted !== self.props.size) {
      self.error("Didn't get expected byte count\n" +
        'expect: ' + self.props.size + '\n' +
        'actual: ' + self._bytesEmitted)
    }
  })

  stream.on('close', function () {
    if (self._paused || self._buffer.length) {
      // console.error('FR Buffering Close', self._path)
      self._buffer.push(CLOSE)
      self._read()
    } else {
      // console.error('FR close 1', self._path)
      self.emit('close')
    }
  })

  stream.on('error', function (e) {
    self.emit('error', e)
  })

  self._read()
}

FileReader.prototype._read = function () {
  var self = this
  // console.error('FR _read', self._path)
  if (self._paused) {
    // console.error('FR _read paused', self._path)
    return
  }

  if (!self._stream) {
    // console.error('FR _getStream calling', self._path)
    return self._getStream()
  }

  // clear out the buffer, if there is one.
  if (self._buffer.length) {
    // console.error('FR _read has buffer', self._buffer.length, self._path)
    var buf = self._buffer
    for (var i = 0, l = buf.length; i < l; i++) {
      var c = buf[i]
      if (c === EOF) {
        // console.error('FR Read emitting buffered end', self._path)
        self.emit('end')
      } else if (c === CLOSE) {
        // console.error('FR Read emitting buffered close', self._path)
        self.emit('close')
      } else {
        // console.error('FR Read emitting buffered data', self._path)
        self.emit('data', c)
      }

      if (self._paused) {
        // console.error('FR Read Re-pausing at '+i, self._path)
        self._buffer = buf.slice(i)
        return
      }
    }
    self._buffer.length = 0
  }
// console.error("FR _read done")
// that's about all there is to it.
}

FileReader.prototype.pause = function (who) {
  var self = this
  // console.error('FR Pause', self._path)
  if (self._paused) return
  who = who || self
  self._paused = true
  if (self._stream) self._stream.pause()
  self.emit('pause', who)
}

FileReader.prototype.resume = function (who) {
  var self = this
  // console.error('FR Resume', self._path)
  if (!self._paused) return
  who = who || self
  self.emit('resume', who)
  self._paused = false
  if (self._stream) self._stream.resume()
  self._read()
}


/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

// Just get the stats, and then don't do anything.
// You can't really "read" from a socket.  You "connect" to it.
// Mostly, this is here so that reading a dir with a socket in it
// doesn't blow up.

module.exports = SocketReader

var inherits = __webpack_require__(275)
var Reader = __webpack_require__(457)

inherits(SocketReader, Reader)

function SocketReader (props) {
  var self = this
  if (!(self instanceof SocketReader)) {
    throw new Error('SocketReader must be called as constructor.')
  }

  if (!(props.type === 'Socket' && props.Socket)) {
    throw new Error('Non-socket type ' + props.type)
  }

  Reader.call(self, props)
}

SocketReader.prototype._read = function () {
  var self = this
  if (self._paused) return
  // basically just a no-op, since we got all the info we have
  // from the _stat method
  if (!self._ended) {
    self.emit('end')
    self.emit('close')
    self._ended = true
  }
}


/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

// A reader for when we don't yet know what kind of thing
// the thing is.

module.exports = ProxyReader

var Reader = __webpack_require__(457)
var getType = __webpack_require__(458)
var inherits = __webpack_require__(275)
var fs = __webpack_require__(102)

inherits(ProxyReader, Reader)

function ProxyReader (props) {
  var self = this
  if (!(self instanceof ProxyReader)) {
    throw new Error('ProxyReader must be called as constructor.')
  }

  self.props = props
  self._buffer = []
  self.ready = false

  Reader.call(self, props)
}

ProxyReader.prototype._stat = function () {
  var self = this
  var props = self.props
  // stat the thing to see what the proxy should be.
  var stat = props.follow ? 'stat' : 'lstat'

  fs[stat](props.path, function (er, current) {
    var type
    if (er || !current) {
      type = 'File'
    } else {
      type = getType(current)
    }

    props[type] = true
    props.type = self.type = type

    self._old = current
    self._addProxy(Reader(props, current))
  })
}

ProxyReader.prototype._addProxy = function (proxy) {
  var self = this
  if (self._proxyTarget) {
    return self.error('proxy already set')
  }

  self._proxyTarget = proxy
  proxy._proxy = self

  ;[
    'error',
    'data',
    'end',
    'close',
    'linkpath',
    'entry',
    'entryEnd',
    'child',
    'childEnd',
    'warn',
    'stat'
  ].forEach(function (ev) {
    // console.error('~~ proxy event', ev, self.path)
    proxy.on(ev, self.emit.bind(self, ev))
  })

  self.emit('proxy', proxy)

  proxy.on('ready', function () {
    // console.error("~~ proxy is ready!", self.path)
    self.ready = true
    self.emit('ready')
  })

  var calls = self._buffer
  self._buffer.length = 0
  calls.forEach(function (c) {
    proxy[c[0]].apply(proxy, c[1])
  })
}

ProxyReader.prototype.pause = function () {
  return this._proxyTarget ? this._proxyTarget.pause() : false
}

ProxyReader.prototype.resume = function () {
  return this._proxyTarget ? this._proxyTarget.resume() : false
}


/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Writer

var fs = __webpack_require__(102)
var inherits = __webpack_require__(275)
var rimraf = __webpack_require__(465)
var mkdir = __webpack_require__(466)
var path = __webpack_require__(82)
var umask = process.platform === 'win32' ? 0 : process.umask()
var getType = __webpack_require__(458)
var Abstract = __webpack_require__(456)

// Must do this *before* loading the child classes
inherits(Writer, Abstract)

Writer.dirmode = parseInt('0777', 8) & (~umask)
Writer.filemode = parseInt('0666', 8) & (~umask)

var DirWriter = __webpack_require__(467)
var LinkWriter = __webpack_require__(469)
var FileWriter = __webpack_require__(470)
var ProxyWriter = __webpack_require__(471)

// props is the desired state.  current is optionally the current stat,
// provided here so that subclasses can avoid statting the target
// more than necessary.
function Writer (props, current) {
  var self = this

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Writer(dir) to get a DirWriter object, etc.
  var type = getType(props)
  var ClassType = Writer

  switch (type) {
    case 'Directory':
      ClassType = DirWriter
      break
    case 'File':
      ClassType = FileWriter
      break
    case 'Link':
    case 'SymbolicLink':
      ClassType = LinkWriter
      break
    case null:
    default:
      // Don't know yet what type to create, so we wrap in a proxy.
      ClassType = ProxyWriter
      break
  }

  if (!(self instanceof ClassType)) return new ClassType(props)

  // now get down to business.

  Abstract.call(self)

  if (!props.path) self.error('Must provide a path', null, true)

  // props is what we want to set.
  // set some convenience properties as well.
  self.type = props.type
  self.props = props
  self.depth = props.depth || 0
  self.clobber = props.clobber === false ? props.clobber : true
  self.parent = props.parent || null
  self.root = props.root || (props.parent && props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length >= 260) {
      self._swallowErrors = true
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    }
  }
  self.basename = path.basename(props.path)
  self.dirname = path.dirname(props.path)
  self.linkpath = props.linkpath || null

  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size

  if (typeof props.mode === 'string') {
    props.mode = parseInt(props.mode, 8)
  }

  self.readable = false
  self.writable = true

  // buffer until ready, or while handling another entry
  self._buffer = []
  self.ready = false

  self.filter = typeof props.filter === 'function' ? props.filter : null

  // start the ball rolling.
  // this checks what's there already, and then calls
  // self._create() to call the impl-specific creation stuff.
  self._stat(current)
}

// Calling this means that it's something we can't create.
// Just assert that it's already there, otherwise raise a warning.
Writer.prototype._create = function () {
  var self = this
  fs[self.props.follow ? 'stat' : 'lstat'](self._path, function (er) {
    if (er) {
      return self.warn('Cannot create ' + self._path + '\n' +
        'Unsupported type: ' + self.type, 'ENOTSUP')
    }
    self._finish()
  })
}

Writer.prototype._stat = function (current) {
  var self = this
  var props = self.props
  var stat = props.follow ? 'stat' : 'lstat'
  var who = self._proxy || self

  if (current) statCb(null, current)
  else fs[stat](self._path, statCb)

  function statCb (er, current) {
    if (self.filter && !self.filter.call(who, who, current)) {
      self._aborted = true
      self.emit('end')
      self.emit('close')
      return
    }

    // if it's not there, great.  We'll just create it.
    // if it is there, then we'll need to change whatever differs
    if (er || !current) {
      return create(self)
    }

    self._old = current
    var currentType = getType(current)

    // if it's a type change, then we need to clobber or error.
    // if it's not a type change, then let the impl take care of it.
    if (currentType !== self.type || self.type === 'File' && current.nlink > 1) {
      return rimraf(self._path, function (er) {
        if (er) return self.error(er)
        self._old = null
        create(self)
      })
    }

    // otherwise, just handle in the app-specific way
    // this creates a fs.WriteStream, or mkdir's, or whatever
    create(self)
  }
}

function create (self) {
  // console.error("W create", self._path, Writer.dirmode)

  // XXX Need to clobber non-dirs that are in the way,
  // unless { clobber: false } in the props.
  mkdir(path.dirname(self._path), Writer.dirmode, function (er, made) {
    // console.error("W created", path.dirname(self._path), er)
    if (er) return self.error(er)

    // later on, we have to set the mode and owner for these
    self._madeDir = made
    return self._create()
  })
}

function endChmod (self, want, current, path, cb) {
  var wantMode = want.mode
  var chmod = want.follow || self.type !== 'SymbolicLink'
    ? 'chmod' : 'lchmod'

  if (!fs[chmod]) return cb()
  if (typeof wantMode !== 'number') return cb()

  var curMode = current.mode & parseInt('0777', 8)
  wantMode = wantMode & parseInt('0777', 8)
  if (wantMode === curMode) return cb()

  fs[chmod](path, wantMode, cb)
}

function endChown (self, want, current, path, cb) {
  // Don't even try it unless root.  Too easy to EPERM.
  if (process.platform === 'win32') return cb()
  if (!process.getuid || process.getuid() !== 0) return cb()
  if (typeof want.uid !== 'number' &&
    typeof want.gid !== 'number') return cb()

  if (current.uid === want.uid &&
    current.gid === want.gid) return cb()

  var chown = (self.props.follow || self.type !== 'SymbolicLink')
    ? 'chown' : 'lchown'
  if (!fs[chown]) return cb()

  if (typeof want.uid !== 'number') want.uid = current.uid
  if (typeof want.gid !== 'number') want.gid = current.gid

  fs[chown](path, want.uid, want.gid, cb)
}

function endUtimes (self, want, current, path, cb) {
  if (!fs.utimes || process.platform === 'win32') return cb()

  var utimes = (want.follow || self.type !== 'SymbolicLink')
    ? 'utimes' : 'lutimes'

  if (utimes === 'lutimes' && !fs[utimes]) {
    utimes = 'utimes'
  }

  if (!fs[utimes]) return cb()

  var curA = current.atime
  var curM = current.mtime
  var meA = want.atime
  var meM = want.mtime

  if (meA === undefined) meA = curA
  if (meM === undefined) meM = curM

  if (!isDate(meA)) meA = new Date(meA)
  if (!isDate(meM)) meA = new Date(meM)

  if (meA.getTime() === curA.getTime() &&
    meM.getTime() === curM.getTime()) return cb()

  fs[utimes](path, meA, meM, cb)
}

// XXX This function is beastly.  Break it up!
Writer.prototype._finish = function () {
  var self = this

  if (self._finishing) return
  self._finishing = true

  // console.error(" W Finish", self._path, self.size)

  // set up all the things.
  // At this point, we're already done writing whatever we've gotta write,
  // adding files to the dir, etc.
  var todo = 0
  var errState = null
  var done = false

  if (self._old) {
    // the times will almost *certainly* have changed.
    // adds the utimes syscall, but remove another stat.
    self._old.atime = new Date(0)
    self._old.mtime = new Date(0)
    // console.error(" W Finish Stale Stat", self._path, self.size)
    setProps(self._old)
  } else {
    var stat = self.props.follow ? 'stat' : 'lstat'
    // console.error(" W Finish Stating", self._path, self.size)
    fs[stat](self._path, function (er, current) {
      // console.error(" W Finish Stated", self._path, self.size, current)
      if (er) {
        // if we're in the process of writing out a
        // directory, it's very possible that the thing we're linking to
        // doesn't exist yet (especially if it was intended as a symlink),
        // so swallow ENOENT errors here and just soldier on.
        if (er.code === 'ENOENT' &&
          (self.type === 'Link' || self.type === 'SymbolicLink') &&
          process.platform === 'win32') {
          self.ready = true
          self.emit('ready')
          self.emit('end')
          self.emit('close')
          self.end = self._finish = function () {}
          return
        } else return self.error(er)
      }
      setProps(self._old = current)
    })
  }

  return

  function setProps (current) {
    todo += 3
    endChmod(self, self.props, current, self._path, next('chmod'))
    endChown(self, self.props, current, self._path, next('chown'))
    endUtimes(self, self.props, current, self._path, next('utimes'))
  }

  function next (what) {
    return function (er) {
      // console.error("   W Finish", what, todo)
      if (errState) return
      if (er) {
        er.fstream_finish_call = what
        return self.error(errState = er)
      }
      if (--todo > 0) return
      if (done) return
      done = true

      // we may still need to set the mode/etc. on some parent dirs
      // that were created previously.  delay end/close until then.
      if (!self._madeDir) return end()
      else endMadeDir(self, self._path, end)

      function end (er) {
        if (er) {
          er.fstream_finish_call = 'setupMadeDir'
          return self.error(er)
        }
        // all the props have been set, so we're completely done.
        self.emit('end')
        self.emit('close')
      }
    }
  }
}

function endMadeDir (self, p, cb) {
  var made = self._madeDir
  // everything *between* made and path.dirname(self._path)
  // needs to be set up.  Note that this may just be one dir.
  var d = path.dirname(p)

  endMadeDir_(self, d, function (er) {
    if (er) return cb(er)
    if (d === made) {
      return cb()
    }
    endMadeDir(self, d, cb)
  })
}

function endMadeDir_ (self, p, cb) {
  var dirProps = {}
  Object.keys(self.props).forEach(function (k) {
    dirProps[k] = self.props[k]

    // only make non-readable dirs if explicitly requested.
    if (k === 'mode' && self.type !== 'Directory') {
      dirProps[k] = dirProps[k] | parseInt('0111', 8)
    }
  })

  var todo = 3
  var errState = null
  fs.stat(p, function (er, current) {
    if (er) return cb(errState = er)
    endChmod(self, dirProps, current, p, next)
    endChown(self, dirProps, current, p, next)
    endUtimes(self, dirProps, current, p, next)
  })

  function next (er) {
    if (errState) return
    if (er) return cb(errState = er)
    if (--todo === 0) return cb()
  }
}

Writer.prototype.pipe = function () {
  this.error("Can't pipe from writable stream")
}

Writer.prototype.add = function () {
  this.error("Can't add to non-Directory type")
}

Writer.prototype.write = function () {
  return true
}

function objectToString (d) {
  return Object.prototype.toString.call(d)
}

function isDate (d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]'
}


/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = rimraf
rimraf.sync = rimrafSync

var assert = __webpack_require__(108)
var path = __webpack_require__(82)
var fs = __webpack_require__(66)
var glob = undefined
try {
  glob = __webpack_require__(268)
} catch (_err) {
  // treat glob as optional.
}
var _0666 = parseInt('666', 8)

var defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
var timeout = 0

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  if (options.disableGlob !== true && glob === undefined) {
    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  var busyTries = 0
  var errState = null
  var n = 0

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, function (er, stat) {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

  function next (er) {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  function afterGlob (er, results) {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(function (p) {
      rimraf_(p, options, function CB (er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            var time = busyTries * 100
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, time)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      })
    })
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, _0666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, _0666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  var results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (var i = 0; i < results.length; i++) {
    var p = results[i]

    try {
      var st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  var retries = isWindows ? 100 : 1
  var i = 0
  do {
    var threw = true
    try {
      var ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}


/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(82);
var fs = __webpack_require__(66);
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                if (path.dirname(p) === p) return cb(er);
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

// It is expected that, when .add() returns false, the consumer
// of the DirWriter will pause until a "drain" event occurs. Note
// that this is *almost always going to be the case*, unless the
// thing being written is some sort of unsupported type, and thus
// skipped over.

module.exports = DirWriter

var Writer = __webpack_require__(464)
var inherits = __webpack_require__(275)
var mkdir = __webpack_require__(466)
var path = __webpack_require__(82)
var collect = __webpack_require__(468)

inherits(DirWriter, Writer)

function DirWriter (props) {
  var self = this
  if (!(self instanceof DirWriter)) {
    self.error('DirWriter must be called as constructor.', null, true)
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    self.error('Non-directory type ' + props.type + ' ' +
      JSON.stringify(props), null, true)
  }

  Writer.call(this, props)
}

DirWriter.prototype._create = function () {
  var self = this
  mkdir(self._path, Writer.dirmode, function (er) {
    if (er) return self.error(er)
    // ready to start getting entries!
    self.ready = true
    self.emit('ready')
    self._process()
  })
}

// a DirWriter has an add(entry) method, but its .write() doesn't
// do anything.  Why a no-op rather than a throw?  Because this
// leaves open the door for writing directory metadata for
// gnu/solaris style dumpdirs.
DirWriter.prototype.write = function () {
  return true
}

DirWriter.prototype.end = function () {
  this._ended = true
  this._process()
}

DirWriter.prototype.add = function (entry) {
  var self = this

  // console.error('\tadd', entry._path, '->', self._path)
  collect(entry)
  if (!self.ready || self._currentEntry) {
    self._buffer.push(entry)
    return false
  }

  // create a new writer, and pipe the incoming entry into it.
  if (self._ended) {
    return self.error('add after end')
  }

  self._buffer.push(entry)
  self._process()

  return this._buffer.length === 0
}

DirWriter.prototype._process = function () {
  var self = this

  // console.error('DW Process p=%j', self._processing, self.basename)

  if (self._processing) return

  var entry = self._buffer.shift()
  if (!entry) {
    // console.error("DW Drain")
    self.emit('drain')
    if (self._ended) self._finish()
    return
  }

  self._processing = true
  // console.error("DW Entry", entry._path)

  self.emit('entry', entry)

  // ok, add this entry
  //
  // don't allow recursive copying
  var p = entry
  var pp
  do {
    pp = p._path || p.path
    if (pp === self.root._path || pp === self._path ||
      (pp && pp.indexOf(self._path) === 0)) {
      // console.error('DW Exit (recursive)', entry.basename, self._path)
      self._processing = false
      if (entry._collected) entry.pipe()
      return self._process()
    }
    p = p.parent
  } while (p)

  // console.error("DW not recursive")

  // chop off the entry's root dir, replace with ours
  var props = {
    parent: self,
    root: self.root || self,
    type: entry.type,
    depth: self.depth + 1
  }

  pp = entry._path || entry.path || entry.props.path
  if (entry.parent) {
    pp = pp.substr(entry.parent._path.length + 1)
  }
  // get rid of any ../../ shenanigans
  props.path = path.join(self.path, path.join('/', pp))

  // if i have a filter, the child should inherit it.
  props.filter = self.filter

  // all the rest of the stuff, copy over from the source.
  Object.keys(entry.props).forEach(function (k) {
    if (!props.hasOwnProperty(k)) {
      props[k] = entry.props[k]
    }
  })

  // not sure at this point what kind of writer this is.
  var child = self._currentChild = new Writer(props)
  child.on('ready', function () {
    // console.error("DW Child Ready", child.type, child._path)
    // console.error("  resuming", entry._path)
    entry.pipe(child)
    entry.resume()
  })

  // XXX Make this work in node.
  // Long filenames should not break stuff.
  child.on('error', function (er) {
    if (child._swallowErrors) {
      self.warn(er)
      child.emit('end')
      child.emit('close')
    } else {
      self.emit('error', er)
    }
  })

  // we fire _end internally *after* end, so that we don't move on
  // until any "end" listeners have had their chance to do stuff.
  child.on('close', onend)
  var ended = false
  function onend () {
    if (ended) return
    ended = true
    // console.error("* DW Child end", child.basename)
    self._currentChild = null
    self._processing = false
    self._process()
  }
}


/***/ }),
/* 468 */
/***/ (function(module, exports) {

module.exports = collect

function collect (stream) {
  if (stream._collected) return

  if (stream._paused) return stream.on('resume', collect.bind(null, stream))

  stream._collected = true
  stream.pause()

  stream.on('data', save)
  stream.on('end', save)
  var buf = []
  function save (b) {
    if (typeof b === 'string') b = new Buffer(b)
    if (Buffer.isBuffer(b) && !b.length) return
    buf.push(b)
  }

  stream.on('entry', saveEntry)
  var entryBuffer = []
  function saveEntry (e) {
    collect(e)
    entryBuffer.push(e)
  }

  stream.on('proxy', proxyPause)
  function proxyPause (p) {
    p.pause()
  }

  // replace the pipe method with a new version that will
  // unlock the buffered stuff.  if you just call .pipe()
  // without a destination, then it'll re-play the events.
  stream.pipe = (function (orig) {
    return function (dest) {
      // console.error(' === open the pipes', dest && dest.path)

      // let the entries flow through one at a time.
      // Once they're all done, then we can resume completely.
      var e = 0
      ;(function unblockEntry () {
        var entry = entryBuffer[e++]
        // console.error(" ==== unblock entry", entry && entry.path)
        if (!entry) return resume()
        entry.on('end', unblockEntry)
        if (dest) dest.add(entry)
        else stream.emit('entry', entry)
      })()

      function resume () {
        stream.removeListener('entry', saveEntry)
        stream.removeListener('data', save)
        stream.removeListener('end', save)

        stream.pipe = orig
        if (dest) stream.pipe(dest)

        buf.forEach(function (b) {
          if (b) stream.emit('data', b)
          else stream.emit('end')
        })

        stream.resume()
      }

      return dest
    }
  })(stream.pipe)
}


/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = LinkWriter

var fs = __webpack_require__(102)
var Writer = __webpack_require__(464)
var inherits = __webpack_require__(275)
var path = __webpack_require__(82)
var rimraf = __webpack_require__(465)

inherits(LinkWriter, Writer)

function LinkWriter (props) {
  var self = this
  if (!(self instanceof LinkWriter)) {
    throw new Error('LinkWriter must be called as constructor.')
  }

  // should already be established as a Link type
  if (!((props.type === 'Link' && props.Link) ||
    (props.type === 'SymbolicLink' && props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  if (props.linkpath === '') props.linkpath = '.'
  if (!props.linkpath) {
    self.error('Need linkpath property to create ' + props.type)
  }

  Writer.call(this, props)
}

LinkWriter.prototype._create = function () {
  // console.error(" LW _create")
  var self = this
  var hard = self.type === 'Link' || process.platform === 'win32'
  var link = hard ? 'link' : 'symlink'
  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath

  // can only change the link path by clobbering
  // For hard links, let's just assume that's always the case, since
  // there's no good way to read them if we don't already know.
  if (hard) return clobber(self, lp, link)

  fs.readlink(self._path, function (er, p) {
    // only skip creation if it's exactly the same link
    if (p && p === lp) return finish(self)
    clobber(self, lp, link)
  })
}

function clobber (self, lp, link) {
  rimraf(self._path, function (er) {
    if (er) return self.error(er)
    create(self, lp, link)
  })
}

function create (self, lp, link) {
  fs[link](lp, self._path, function (er) {
    // if this is a hard link, and we're in the process of writing out a
    // directory, it's very possible that the thing we're linking to
    // doesn't exist yet (especially if it was intended as a symlink),
    // so swallow ENOENT errors here and just soldier in.
    // Additionally, an EPERM or EACCES can happen on win32 if it's trying
    // to make a link to a directory.  Again, just skip it.
    // A better solution would be to have fs.symlink be supported on
    // windows in some nice fashion.
    if (er) {
      if ((er.code === 'ENOENT' ||
        er.code === 'EACCES' ||
        er.code === 'EPERM') && process.platform === 'win32') {
        self.ready = true
        self.emit('ready')
        self.emit('end')
        self.emit('close')
        self.end = self._finish = function () {}
      } else return self.error(er)
    }
    finish(self)
  })
}

function finish (self) {
  self.ready = true
  self.emit('ready')
  if (self._ended && !self._finished) self._finish()
}

LinkWriter.prototype.end = function () {
  // console.error("LW finish in end")
  this._ended = true
  if (this.ready) {
    this._finished = true
    this._finish()
  }
}


/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = FileWriter

var fs = __webpack_require__(102)
var Writer = __webpack_require__(464)
var inherits = __webpack_require__(275)
var EOF = {}

inherits(FileWriter, Writer)

function FileWriter (props) {
  var self = this
  if (!(self instanceof FileWriter)) {
    throw new Error('FileWriter must be called as constructor.')
  }

  // should already be established as a File type
  if (props.type !== 'File' || !props.File) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesWritten = 0

  Writer.call(this, props)
}

FileWriter.prototype._create = function () {
  var self = this
  if (self._stream) return

  var so = {}
  if (self.props.flags) so.flags = self.props.flags
  so.mode = Writer.filemode
  if (self._old && self._old.blksize) so.bufferSize = self._old.blksize

  self._stream = fs.createWriteStream(self._path, so)

  self._stream.on('open', function () {
    // console.error("FW open", self._buffer, self._path)
    self.ready = true
    self._buffer.forEach(function (c) {
      if (c === EOF) self._stream.end()
      else self._stream.write(c)
    })
    self.emit('ready')
    // give this a kick just in case it needs it.
    self.emit('drain')
  })

  self._stream.on('error', function (er) { self.emit('error', er) })

  self._stream.on('drain', function () { self.emit('drain') })

  self._stream.on('close', function () {
    // console.error('\n\nFW Stream Close', self._path, self.size)
    self._finish()
  })
}

FileWriter.prototype.write = function (c) {
  var self = this

  self._bytesWritten += c.length

  if (!self.ready) {
    if (!Buffer.isBuffer(c) && typeof c !== 'string') {
      throw new Error('invalid write data')
    }
    self._buffer.push(c)
    return false
  }

  var ret = self._stream.write(c)
  // console.error('\t-- fw wrote, _stream says', ret, self._stream._queue.length)

  // allow 2 buffered writes, because otherwise there's just too
  // much stop and go bs.
  if (ret === false && self._stream._queue) {
    return self._stream._queue.length <= 2
  } else {
    return ret
  }
}

FileWriter.prototype.end = function (c) {
  var self = this

  if (c) self.write(c)

  if (!self.ready) {
    self._buffer.push(EOF)
    return false
  }

  return self._stream.end()
}

FileWriter.prototype._finish = function () {
  var self = this
  if (typeof self.size === 'number' && self._bytesWritten !== self.size) {
    self.error(
      'Did not get expected byte count.\n' +
      'expect: ' + self.size + '\n' +
      'actual: ' + self._bytesWritten)
  }
  Writer.prototype._finish.call(self)
}


/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

// A writer for when we don't know what kind of thing
// the thing is.  That is, it's not explicitly set,
// so we're going to make it whatever the thing already
// is, or "File"
//
// Until then, collect all events.

module.exports = ProxyWriter

var Writer = __webpack_require__(464)
var getType = __webpack_require__(458)
var inherits = __webpack_require__(275)
var collect = __webpack_require__(468)
var fs = __webpack_require__(66)

inherits(ProxyWriter, Writer)

function ProxyWriter (props) {
  var self = this
  if (!(self instanceof ProxyWriter)) {
    throw new Error('ProxyWriter must be called as constructor.')
  }

  self.props = props
  self._needDrain = false

  Writer.call(self, props)
}

ProxyWriter.prototype._stat = function () {
  var self = this
  var props = self.props
  // stat the thing to see what the proxy should be.
  var stat = props.follow ? 'stat' : 'lstat'

  fs[stat](props.path, function (er, current) {
    var type
    if (er || !current) {
      type = 'File'
    } else {
      type = getType(current)
    }

    props[type] = true
    props.type = self.type = type

    self._old = current
    self._addProxy(Writer(props, current))
  })
}

ProxyWriter.prototype._addProxy = function (proxy) {
  // console.error("~~ set proxy", this.path)
  var self = this
  if (self._proxy) {
    return self.error('proxy already set')
  }

  self._proxy = proxy
  ;[
    'ready',
    'error',
    'close',
    'pipe',
    'drain',
    'warn'
  ].forEach(function (ev) {
    proxy.on(ev, self.emit.bind(self, ev))
  })

  self.emit('proxy', proxy)

  var calls = self._buffer
  calls.forEach(function (c) {
    // console.error("~~ ~~ proxy buffered call", c[0], c[1])
    proxy[c[0]].apply(proxy, c[1])
  })
  self._buffer.length = 0
  if (self._needsDrain) self.emit('drain')
}

ProxyWriter.prototype.add = function (entry) {
  // console.error("~~ proxy add")
  collect(entry)

  if (!this._proxy) {
    this._buffer.push(['add', [entry]])
    this._needDrain = true
    return false
  }
  return this._proxy.add(entry)
}

ProxyWriter.prototype.write = function (c) {
  // console.error('~~ proxy write')
  if (!this._proxy) {
    this._buffer.push(['write', [c]])
    this._needDrain = true
    return false
  }
  return this._proxy.write(c)
}

ProxyWriter.prototype.end = function (c) {
  // console.error('~~ proxy end')
  if (!this._proxy) {
    this._buffer.push(['end', [c]])
    return false
  }
  return this._proxy.end(c)
}


/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(102);
var Promise = __webpack_require__(396);
var directory = __webpack_require__(473);
var Stream = __webpack_require__(106);

// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = __webpack_require__(434);

module.exports = {
  buffer: function(buffer, options) {
    var source = {
      stream: function(offset, length) {
        var stream = Stream.PassThrough();
        stream.end(buffer.slice(offset, length));
        return stream;
      },
      size: function() {
        return Promise.resolve(buffer.length);
      }
    };
    return directory(source, options);
  },
  file: function(filename, options) {
    var source = {
      stream: function(offset,length) {
        return fs.createReadStream(filename,{start: offset, end: length && offset+length});
      },
      size: function() {
        return new Promise(function(resolve,reject) {
          fs.stat(filename,function(err,d) {
            if (err)
              reject(err);
            else
              resolve(d.size);
          });
        });
      }
    };
    return directory(source, options);
  },

  url: function(request, params, options) {
    if (typeof params === 'string')
      params = {url: params};
    if (!params.url)
      throw 'URL missing';
    params.headers = params.headers || {};

    var source = {
      stream : function(offset,length) {
        var options = Object.create(params);
        options.headers = Object.create(params.headers);
        options.headers.range = 'bytes='+offset+'-' + (length ? length : '');
        return request(options);
      },
      size: function() {
        return new Promise(function(resolve,reject) {
          var req = request(params);
          req.on('response',function(d) {
            req.abort();
            if (!d.headers['content-length'])
              reject(new Error('Missing content length header'));
            else
              resolve(d.headers['content-length']);
          }).on('error',reject);
        });
      }
    };

    return directory(source, options);
  },

  s3 : function(client,params, options) {
    var source = {
      size: function() {
        return new Promise(function(resolve,reject) {
          client.headObject(params, function(err,d) {
            if (err)
              reject(err);
            else
              resolve(d.ContentLength);
          });
        });
      },
      stream: function(offset,length) {
        var d = {};
        for (var key in params)
          d[key] = params[key];
        d.Range = 'bytes='+offset+'-' + (length ? length : '');
        return client.getObject(d).createReadStream();
      }
    };

    return directory(source, options);
  }
};


/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

var binary = __webpack_require__(391);
var PullStream = __webpack_require__(432);
var unzip = __webpack_require__(474);
var Promise = __webpack_require__(396);
var BufferStream = __webpack_require__(449);
var parseExtraField = __webpack_require__(450);
var Buffer = __webpack_require__(433);
var path = __webpack_require__(82);
var Writer = __webpack_require__(455).Writer;
var parseDateTime = __webpack_require__(451);

var signature = Buffer.alloc(4);
signature.writeUInt32LE(0x06054b50,0);

function getCrxHeader(source) {
  var sourceStream = source.stream(0).pipe(PullStream());

  return sourceStream.pull(4).then(function(data) {
    var signature = data.readUInt32LE(0);
    if (signature === 0x34327243) {
      var crxHeader;
      return sourceStream.pull(12).then(function(data) {
        crxHeader = binary.parse(data)
          .word32lu('version')
          .word32lu('pubKeyLength')
          .word32lu('signatureLength')
          .vars;
      }).then(function() {
        return sourceStream.pull(crxHeader.pubKeyLength +crxHeader.signatureLength);
      }).then(function(data) {
        crxHeader.publicKey = data.slice(0,crxHeader.pubKeyLength);
        crxHeader.signature = data.slice(crxHeader.pubKeyLength);
        crxHeader.size = 16 + crxHeader.pubKeyLength +crxHeader.signatureLength;
        return crxHeader;
      });
    }
  });
}

// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
function getZip64CentralDirectory(source, zip64CDL) {
  var d64loc = binary.parse(zip64CDL)
    .word32lu('signature')
    .word32lu('diskNumber')
    .word64lu('offsetToStartOfCentralDirectory')
    .word32lu('numberOfDisks')
    .vars;

  if (d64loc.signature != 0x07064b50) {
    throw new Error('invalid zip64 end of central dir locator signature (0x07064b50): 0x' + d64loc.signature.toString(16));
  }

  var dir64 = PullStream();
  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);

  return dir64.pull(56)
}

// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
function parseZip64DirRecord (dir64record) {
  var vars = binary.parse(dir64record)
    .word32lu('signature')
    .word64lu('sizeOfCentralDirectory')
    .word16lu('version')
    .word16lu('versionsNeededToExtract')
    .word32lu('diskNumber')
    .word32lu('diskStart')
    .word64lu('numberOfRecordsOnDisk')
    .word64lu('numberOfRecords')
    .word64lu('sizeOfCentralDirectory')
    .word64lu('offsetToStartOfCentralDirectory')
    .vars;

  if (vars.signature != 0x06064b50) {
    throw new Error('invalid zip64 end of central dir locator signature (0x06064b50): 0x0' + vars.signature.toString(16));
  }

  return vars
}

module.exports = function centralDirectory(source, options) {
  var endDir = PullStream(),
      records = PullStream(),
      tailSize = (options && options.tailSize) || 80,
      sourceSize,
      crxHeader,
      startOffset,
      vars;

  if (options && options.crx)
    crxHeader = getCrxHeader(source);

  return source.size()
    .then(function(size) {
      sourceSize = size;

      source.stream(Math.max(0,size-tailSize))
        .on('error', function (error) { endDir.emit('error', error) })
        .pipe(endDir);

      return endDir.pull(signature);
    })
    .then(function() {
      return Promise.props({directory: endDir.pull(22), crxHeader: crxHeader});
    })
    .then(function(d) {
      var data = d.directory;
      startOffset = d.crxHeader && d.crxHeader.size || 0;

      vars = binary.parse(data)
        .word32lu('signature')
        .word16lu('diskNumber')
        .word16lu('diskStart')
        .word16lu('numberOfRecordsOnDisk')
        .word16lu('numberOfRecords')
        .word32lu('sizeOfCentralDirectory')
        .word32lu('offsetToStartOfCentralDirectory')
        .word16lu('commentLength')
        .vars;

      // Is this zip file using zip64 format? Use same check as Go:
      // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503
      // For zip64 files, need to find zip64 central directory locator header to extract
      // relative offset for zip64 central directory record.
      if (vars.numberOfRecords == 0xffff|| vars.numberOfRecords == 0xffff ||
        vars.offsetToStartOfCentralDirectory == 0xffffffff) {

        // Offset to zip64 CDL is 20 bytes before normal CDR
        const zip64CDLSize = 20
        const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize)
        const zip64CDLStream = PullStream();

        source.stream(zip64CDLOffset).pipe(zip64CDLStream);

        return zip64CDLStream.pull(zip64CDLSize)
          .then(function (d) { return getZip64CentralDirectory(source, d) })
          .then(function (dir64record) {
            vars = parseZip64DirRecord(dir64record)
          })
      } else {
        vars.offsetToStartOfCentralDirectory += startOffset;
      }
    })
    .then(function() {
      source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);

      vars.extract = function(opts) {
        if (!opts || !opts.path) throw new Error('PATH_MISSING');
        return vars.files.then(function(files) {
          return Promise.map(files, function(entry) {
            if (entry.type == 'Directory') return;

            // to avoid zip slip (writing outside of the destination), we resolve
            // the target path, and make sure it's nested in the intended
            // destination, or not extract it otherwise.
            var extractPath = path.join(opts.path, entry.path);
            if (extractPath.indexOf(opts.path) != 0) {
              return;
            }
            var writer = opts.getWriter ? opts.getWriter({path: extractPath}) :  Writer({ path: extractPath });

            return new Promise(function(resolve, reject) {
              entry.stream(opts.password)
                .on('error',reject)
                .pipe(writer)
                .on('close',resolve)
                .on('error',reject);
            });
          }, opts.concurrency > 1 ? {concurrency: opts.concurrency || undefined} : undefined);
        });
      };

      vars.files = Promise.mapSeries(Array(vars.numberOfRecords),function() {
        return records.pull(46).then(function(data) {    
          var vars = binary.parse(data)
            .word32lu('signature')
            .word16lu('versionMadeBy')
            .word16lu('versionsNeededToExtract')
            .word16lu('flags')
            .word16lu('compressionMethod')
            .word16lu('lastModifiedTime')
            .word16lu('lastModifiedDate')
            .word32lu('crc32')
            .word32lu('compressedSize')
            .word32lu('uncompressedSize')
            .word16lu('fileNameLength')
            .word16lu('extraFieldLength')
            .word16lu('fileCommentLength')
            .word16lu('diskNumber')
            .word16lu('internalFileAttributes')
            .word32lu('externalFileAttributes')
            .word32lu('offsetToLocalFileHeader')
            .vars;

        vars.offsetToLocalFileHeader += startOffset;
        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);

        return records.pull(vars.fileNameLength).then(function(fileNameBuffer) {
          vars.pathBuffer = fileNameBuffer;
          vars.path = fileNameBuffer.toString('utf8');
          vars.isUnicode = vars.flags & 0x11;
          return records.pull(vars.extraFieldLength);
        })
        .then(function(extraField) {
          vars.extra = parseExtraField(extraField, vars);
          return records.pull(vars.fileCommentLength);
        })
        .then(function(comment) {
          vars.comment = comment;
          vars.type = (vars.uncompressedSize === 0 && /[\/\\]$/.test(vars.path)) ? 'Directory' : 'File';
          vars.stream = function(_password) {
            return unzip(source, vars.offsetToLocalFileHeader,_password, vars);
          };
          vars.buffer = function(_password) {
            return BufferStream(vars.stream(_password));
          };
          return vars;
        });
      });
    });

    return Promise.props(vars);
  });
};


/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

var Promise = __webpack_require__(396);
var Decrypt = __webpack_require__(475);
var PullStream = __webpack_require__(432);
var Stream = __webpack_require__(106);
var binary = __webpack_require__(391);
var zlib = __webpack_require__(145);
var parseExtraField = __webpack_require__(450);
var Buffer = __webpack_require__(433);
var parseDateTime = __webpack_require__(451);

// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = __webpack_require__(434);

module.exports = function unzip(source,offset,_password, directoryVars) {
  var file = PullStream(),
      entry = Stream.PassThrough();

  var req = source.stream(offset);
  req.pipe(file).on('error', function(e) {
    entry.emit('error', e);
  });

  entry.vars = file.pull(30)
    .then(function(data) {
      var vars = binary.parse(data)
        .word32lu('signature')
        .word16lu('versionsNeededToExtract')
        .word16lu('flags')
        .word16lu('compressionMethod')
        .word16lu('lastModifiedTime')
        .word16lu('lastModifiedDate')
        .word32lu('crc32')
        .word32lu('compressedSize')
        .word32lu('uncompressedSize')
        .word16lu('fileNameLength')
        .word16lu('extraFieldLength')
        .vars;

      vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);

      return file.pull(vars.fileNameLength)
        .then(function(fileName) {
          vars.fileName = fileName.toString('utf8');
          return file.pull(vars.extraFieldLength);
        })
        .then(function(extraField) {
          var checkEncryption;
          vars.extra = parseExtraField(extraField, vars);
          // Ignore logal file header vars if the directory vars are available
          if (directoryVars && directoryVars.compressedSize) vars = directoryVars;

          if (vars.flags & 0x01) checkEncryption = file.pull(12)
            .then(function(header) {
              if (!_password)
                throw new Error('MISSING_PASSWORD');

              var decrypt = Decrypt();

              String(_password).split('').forEach(function(d) {
                decrypt.update(d);
              });

              for (var i=0; i < header.length; i++)
                header[i] = decrypt.decryptByte(header[i]);

              vars.decrypt = decrypt;
              vars.compressedSize -= 12;

              var check = (vars.flags & 0x8) ? (vars.lastModifiedTime >> 8) & 0xff : (vars.crc32 >> 24) & 0xff;
              if (header[11] !== check)
                throw new Error('BAD_PASSWORD');

              return vars;
            });

          return Promise.resolve(checkEncryption)
            .then(function() {
              entry.emit('vars',vars);
              return vars;
            });
        });
    });

    entry.vars.then(function(vars) {
      var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0,
          eof;

      var inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();

      if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
        eof = vars.compressedSize;
      } else {
        eof = Buffer.alloc(4);
        eof.writeUInt32LE(0x08074b50, 0);
      }

      var stream = file.stream(eof);

      if (vars.decrypt)
        stream = stream.pipe(vars.decrypt.stream());

      stream
        .pipe(inflater)
        .on('error',function(err) { entry.emit('error',err);})
        .pipe(entry)
        .on('finish', function() {
          if (req.abort)
            req.abort();
          else if (req.close)
            req.close();
          else if (req.push)
            req.push();
          else
            console.log('warning - unable to close stream');
        });
    })
    .catch(function(e) {
      entry.emit('error',e);
    });

  return entry;
};


/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

var bigInt = __webpack_require__(476);
var Stream = __webpack_require__(106);

// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = __webpack_require__(434);

var table;

function generateTable() {
  var poly = 0xEDB88320,c,n,k;
  table = [];
  for (n = 0; n < 256; n++) {
    c = n;
    for (k = 0; k < 8; k++)
      c = (c & 1) ? poly ^ (c >>> 1) :  c = c >>> 1;
    table[n] = c >>> 0;
  }
}

function crc(ch,crc) {
  if (!table)
    generateTable();

  if (ch.charCodeAt)
    ch = ch.charCodeAt(0);        

  return (bigInt(crc).shiftRight(8).and(0xffffff)).xor(table[bigInt(crc).xor(ch).and(0xff)]).value;
}

function Decrypt() {
  if (!(this instanceof Decrypt))
    return new Decrypt();

  this.key0 = 305419896;
  this.key1 = 591751049;
  this.key2 = 878082192;
}

Decrypt.prototype.update = function(h) {            
  this.key0 = crc(h,this.key0);
  this.key1 = bigInt(this.key0).and(255).and(4294967295).add(this.key1)
  this.key1 = bigInt(this.key1).multiply(134775813).add(1).and(4294967295).value;
  this.key2 = crc(bigInt(this.key1).shiftRight(24).and(255), this.key2);
}


Decrypt.prototype.decryptByte = function(c) {
  var k = bigInt(this.key2).or(2);
  c = c ^ bigInt(k).multiply(bigInt(k^1)).shiftRight(8).and(255);
  this.update(c);
  return c;
};

 Decrypt.prototype.stream = function() {
  var stream = Stream.Transform(),
      self = this;

  stream._transform = function(d,e,cb) {
    for (var i = 0; i<d.length;i++) {
      d[i] = self.decryptByte(d[i]);
    }
    this.push(d);
    cb();
  };
  return stream;
};




module.exports = Decrypt;

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = (function (undefined) {
    "use strict";

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";

    var supportsNativeBigInt = typeof BigInt === "function";

    function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function NativeBigInt(value) {
        this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    NativeBigInt.prototype.add = function (v) {
        return new NativeBigInt(this.value + parseValue(v).value);
    }
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    NativeBigInt.prototype.subtract = function (v) {
        return new NativeBigInt(this.value - parseValue(v).value);
    }
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };
    NativeBigInt.prototype.negate = function () {
        return new NativeBigInt(-this.value);
    }

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function () {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    }


    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
        if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    NativeBigInt.prototype.multiply = function (v) {
        return new NativeBigInt(this.value * parseValue(v).value);
    }
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;

    function square(a) {
        //console.assert(2 * BASE * BASE < MAX_INT);
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            carry = 0 - a_i * a_i;
            for (var j = i; j < l; j++) {
                a_j = a[j];
                product = 2 * (a_i * a_j) + r[i + j] + carry;
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
            }
            r[i + l] = carry;
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    NativeBigInt.prototype.square = function (v) {
        return new NativeBigInt(this.value * this.value);
    }

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
        }
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;


    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
        return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
        return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    NativeBigInt.prototype.pow = function (v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
            if ((b & _1) === _1) {
                y = y.times(x);
                --b;
            }
            if (b === _0) break;
            b /= _2;
            x = x.square();
        }
        return y;
    }

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
        }
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };
    NativeBigInt.prototype.compareAbs = function (v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
    }

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    NativeBigInt.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
    }
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function () {
        return (this.value & BigInt(1)) === BigInt(0);
    }

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function () {
        return (this.value & BigInt(1)) === BigInt(1);
    }

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function () {
        return this.abs().value === BigInt(1);
    }

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function () {
        return this.value === BigInt(0);
    }

    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    function millerRabinTest(n, a) {
        var nPrev = n.prev(),
            b = nPrev,
            r = 0,
            d, t, i, x;
        while (b.isEven()) b = b.divide(2), r++;
        next: for (i = 0; i < a.length; i++) {
            if (n.lesser(a[i])) continue;
            x = bigInt(a[i]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for (d = r - 1; d != 0; d--) {
                x = x.square().mod(n);
                if (x.isUnit()) return false;
                if (x.equals(nPrev)) continue next;
            }
            return false;
        }
        return true;
    }

    // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
    BigInteger.prototype.isPrime = function (strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt(i + 2));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var t = iterations === undefined ? 5 : iterations;
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt.randBetween(2, n.minus(2), rng));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function () {
        return new NativeBigInt(this.value + BigInt(1));
    }

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function () {
        return new NativeBigInt(this.value - BigInt(1));
    }

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
    }

    BigInteger.prototype.shiftLeft = function (v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value,
            x = typeof v === "number" ? v | LOBMASK_I :
                typeof v === "bigint" ? v | BigInt(LOBMASK_I) :
                    v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
    }

    BigInteger.prototype.bitLength = function () {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
            n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
            return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    }
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for (var i = 0; i < digits.length; i++) {
            var top = restricted ? digits[i] : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < top) restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
    }

    var parseBase = function (text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i = 0; i < alphabet.length; i++) {
            alphabetValues[alphabet[i]] = i;
        }
        for (i = 0; i < length; i++) {
            var c = text[i];
            if (c === "-") continue;
            if (c in alphabetValues) {
                if (alphabetValues[c] >= absBase) {
                    if (c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
                }
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
            return alphabet[digit];
        }
        return "<" + digit + ">";
    }

    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return { value: [0], isNegative: false };
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return { value: [0], isNegative: false };
            if (n.isNegative())
                return {
                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))
                        .map(Array.prototype.valueOf, [1, 0])
                    ),
                    isNegative: false
                };

            var arr = Array.apply(null, Array(n.toJSNumber() - 1))
                .map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
                value: [].concat.apply([], arr),
                isNegative: false
            };
        }

        var neg = false;
        if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
        }
        if (base.isUnit()) {
            if (n.isZero()) return { value: [0], isNegative: false };

            return {
                value: Array.apply(null, Array(n.toJSNumber()))
                    .map(Number.prototype.valueOf, 1),
                isNegative: neg
            };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
    }

    function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
            return stringify(x, alphabet);
        }).join('');
    }

    BigInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    SmallInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    NativeBigInt.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    BigInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined) radix = 10;
        if (radix !== 10) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined) radix = 10;
        if (radix != 10) return toBaseString(this, radix, alphabet);
        return String(this.value);
    };

    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;

    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }

    BigInteger.prototype.valueOf = function () {
        return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
        return parseInt(this.toString(), 10);
    }

    function parseStringValue(v) {
        if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate(x))
                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+") exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
                exp -= text.length - decimalPlace - 1;
                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            text += (new Array(exp + 1)).join("0");
            v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max = v.length, l = LOG_BASE, min = max - l;
        while (max > 0) {
            r.push(+v.slice(min, max));
            min -= l;
            if (min < 0) min = 0;
            max -= l;
        }
        trim(r);
        return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        if (typeof v === "bigint") {
            return new NativeBigInt(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if ( true && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}

//amd check
if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return bigInt;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(477)(module)))

/***/ }),
/* 477 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const follow_redirects_1 = __webpack_require__(350);
const url_1 = __webpack_require__(351);
const zlib_1 = tslib_1.__importDefault(__webpack_require__(145));
const is_1 = __webpack_require__(250);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const querystring_1 = __webpack_require__(479);
const http_proxy_agent_1 = tslib_1.__importDefault(__webpack_require__(480));
const https_proxy_agent_1 = tslib_1.__importDefault(__webpack_require__(486));
const logger = __webpack_require__(64)('model-fetch');
function getSystemProxyURI(endpoint) {
    let env;
    if (endpoint.protocol === 'http:') {
        env = process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    else if (endpoint.protocol === 'https:') {
        env = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    let noProxy = process.env.NO_PROXY || process.env.no_proxy;
    if (noProxy === '*') {
        env = null;
    }
    else if (noProxy) {
        // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
        const hostname = endpoint.hostname.replace(/^\.*/, '.').toLowerCase();
        const port = endpoint.port || endpoint.protocol.startsWith('https') ? '443' : '80';
        const noProxyList = noProxy.split(',');
        for (let i = 0, len = noProxyList.length; i < len; i++) {
            let noProxyItem = noProxyList[i].trim().toLowerCase();
            // no_proxy can be granular at the port level, which complicates things a bit.
            if (noProxyItem.includes(':')) {
                let noProxyItemParts = noProxyItem.split(':', 2);
                let noProxyHost = noProxyItemParts[0].replace(/^\.*/, '.');
                let noProxyPort = noProxyItemParts[1];
                if (port === noProxyPort && hostname.endsWith(noProxyHost)) {
                    env = null;
                    break;
                }
            }
            else {
                noProxyItem = noProxyItem.replace(/^\.*/, '.');
                if (hostname.endsWith(noProxyItem)) {
                    env = null;
                    break;
                }
            }
        }
    }
    return env;
}
function getAgent(endpoint, options) {
    let proxy = options.proxyUrl || getSystemProxyURI(endpoint);
    if (proxy) {
        const proxyEndpoint = url_1.parse(proxy);
        if (!/^https?:$/.test(proxyEndpoint.protocol)) {
            return null;
        }
        let opts = {
            host: proxyEndpoint.hostname,
            port: proxyEndpoint.port ? Number(proxyEndpoint.port) : (proxyEndpoint.protocol === 'https' ? '443' : '80'),
            auth: proxyEndpoint.auth,
            rejectUnauthorized: typeof options.strictSSL === 'boolean' ? options.strictSSL : true
        };
        logger.info(`Using proxy ${proxy} from ${options.proxyUrl ? 'configuration' : 'system environment'} for ${endpoint.hostname}:`);
        return endpoint.protocol === 'http:' ? http_proxy_agent_1.default(opts) : https_proxy_agent_1.default(opts);
    }
    return null;
}
exports.getAgent = getAgent;
function resolveRequestOptions(url, options = {}) {
    let config = workspace_1.default.getConfiguration('http');
    let { data } = options;
    let dataType = getDataType(data);
    let proxyOptions = {
        proxyUrl: config.get('proxy', ''),
        strictSSL: config.get('proxyStrictSSL', true),
        proxyAuthorization: config.get('proxyAuthorization', null)
    };
    if (options.query && !url.includes('?')) {
        url = `${url}?${querystring_1.stringify(options.query)}`;
    }
    let headers = Object.assign(options.headers || {}, { 'Proxy-Authorization': proxyOptions.proxyAuthorization });
    let endpoint = url_1.parse(url);
    let agent = getAgent(endpoint, proxyOptions);
    let opts = {
        method: options.method || 'GET',
        hostname: endpoint.hostname,
        port: endpoint.port ? parseInt(endpoint.port, 10) : (endpoint.protocol === 'https:' ? 443 : 80),
        path: endpoint.path,
        agent,
        rejectUnauthorized: proxyOptions.strictSSL,
        maxRedirects: 3,
        headers: Object.assign({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64)',
            'Accept-Encoding': 'gzip, deflate'
        }, headers)
    };
    if (dataType == 'object') {
        opts.headers['Content-Type'] = 'application/json';
    }
    else if (dataType == 'string') {
        opts.headers['Content-Type'] = 'text/plain';
    }
    if (options.user && options.password) {
        opts.auth = options.user + ':' + options.password;
    }
    if (options.timeout) {
        opts.timeout = options.timeout;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return opts;
}
exports.resolveRequestOptions = resolveRequestOptions;
function request(url, data, opts, token) {
    let mod = url.startsWith('https:') ? follow_redirects_1.https : follow_redirects_1.http;
    return new Promise((resolve, reject) => {
        if (token) {
            let disposable = token.onCancellationRequested(() => {
                disposable.dispose();
                req.destroy(new Error('request aborted'));
            });
        }
        const req = mod.request(opts, res => {
            let readable = res;
            if ((res.statusCode >= 200 && res.statusCode < 300) || res.statusCode === 1223) {
                let headers = res.headers || {};
                let chunks = [];
                let contentType = headers['content-type'] || '';
                let contentEncoding = headers['content-encoding'] || '';
                if (contentEncoding === 'gzip') {
                    const unzip = zlib_1.default.createGunzip();
                    readable = res.pipe(unzip);
                }
                else if (contentEncoding === 'deflate') {
                    let inflate = zlib_1.default.createInflate();
                    res.pipe(inflate);
                    readable = inflate;
                }
                readable.on('data', chunk => {
                    chunks.push(chunk);
                });
                readable.on('end', () => {
                    let buf = Buffer.concat(chunks);
                    if (contentType.startsWith('application/json')
                        || contentType.startsWith('text/')) {
                        let ms = contentType.match(/charset=(\S+)/);
                        let encoding = ms ? ms[1] : 'utf8';
                        let rawData = buf.toString(encoding);
                        if (!contentType.includes('application/json')) {
                            resolve(rawData);
                        }
                        else {
                            try {
                                const parsedData = JSON.parse(rawData);
                                resolve(parsedData);
                            }
                            catch (e) {
                                reject(new Error(`Parse response error: ${e}`));
                            }
                        }
                    }
                    else {
                        resolve(buf);
                    }
                });
                readable.on('error', err => {
                    reject(new Error(`Unable to connect ${url}: ${err.message}`));
                });
            }
            else {
                reject(new Error(`Bad response from ${url}: ${res.statusCode}`));
            }
        });
        req.on('error', reject);
        req.on('timeout', () => {
            req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));
        });
        if (data) {
            if (typeof data === 'string' || Buffer.isBuffer(data)) {
                req.write(data);
            }
            else {
                req.write(JSON.stringify(data));
            }
        }
        if (opts.timeout) {
            req.setTimeout(opts.timeout);
        }
        req.end();
    });
}
function getDataType(data) {
    if (data === null)
        return 'null';
    if (data === undefined)
        return 'undefined';
    if (typeof data == 'string')
        return 'string';
    if (Buffer.isBuffer(data))
        return 'buffer';
    if (Array.isArray(data) || is_1.objectLiteral(data))
        return 'object';
    return 'unknown';
}
/**
 * Send request to server for response, supports:
 *
 * - Send json data and parse json response.
 * - Throw error for failed response statusCode.
 * - Timeout support (no timeout by default).
 * - Send buffer (as data) and receive data (as response).
 * - Proxy support from user configuration & environment.
 * - Redirect support, limited to 3.
 * - Support of gzip & deflate response content.
 */
function fetch(url, options = {}, token) {
    let opts = resolveRequestOptions(url, options);
    return request(url, options.data, opts, token).catch(err => {
        logger.error(`Fetch error for ${url}:`, opts, err);
        if (opts.agent && opts.agent.proxy) {
            let { proxy } = opts.agent;
            throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);
        }
        else {
            throw err;
        }
    });
}
exports.default = fetch;
//# sourceMappingURL=fetch.js.map

/***/ }),
/* 479 */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const agent_1 = __importDefault(__webpack_require__(481));
function createHttpProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function (createHttpProxyAgent) {
    createHttpProxyAgent.HttpProxyAgent = agent_1.default;
    createHttpProxyAgent.prototype = agent_1.default.prototype;
})(createHttpProxyAgent || (createHttpProxyAgent = {}));
module.exports = createHttpProxyAgent;
//# sourceMappingURL=index.js.map

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(__webpack_require__(157));
const tls_1 = __importDefault(__webpack_require__(482));
const url_1 = __importDefault(__webpack_require__(351));
const debug_1 = __importDefault(__webpack_require__(68));
const once_1 = __importDefault(__webpack_require__(483));
const agent_base_1 = __webpack_require__(484);
const debug = debug_1.default('http-proxy-agent');
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
/**
 * The `HttpProxyAgent` implements an HTTP Agent subclass that connects
 * to the specified "HTTP proxy server" in order to proxy HTTP requests.
 *
 * @api public
 */
class HttpProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        }
        else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('Creating new HttpProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            const parsed = url_1.default.parse(req.path);
            if (!parsed.protocol) {
                parsed.protocol = 'http:';
            }
            if (!parsed.hostname) {
                parsed.hostname = opts.hostname || opts.host || null;
            }
            if (parsed.port == null && typeof opts.port) {
                parsed.port = String(opts.port);
            }
            if (parsed.port === '80') {
                // if port is 80, then we can remove the port so that the
                // ":80" portion is not on the produced URL
                delete parsed.port;
            }
            // Change the `http.ClientRequest` instance's "path" field
            // to the absolute path of the URL that will be requested.
            req.path = url_1.default.format(parsed);
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                req.setHeader('Proxy-Authorization', `Basic ${Buffer.from(proxy.auth).toString('base64')}`);
            }
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            }
            else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            // At this point, the http ClientRequest's internal `_header` field
            // might have already been set. If this is the case then we'll need
            // to re-generate the string since we just changed the `req.path`.
            if (req._header) {
                let first;
                let endOfHeaders;
                debug('Regenerating stored HTTP header string for request');
                req._header = null;
                req._implicitHeader();
                if (req.output && req.output.length > 0) {
                    // Node < 12
                    debug('Patching connection write() output buffer with updated header');
                    first = req.output[0];
                    endOfHeaders = first.indexOf('\r\n\r\n') + 4;
                    req.output[0] = req._header + first.substring(endOfHeaders);
                    debug('Output buffer: %o', req.output);
                }
                else if (req.outputData && req.outputData.length > 0) {
                    // Node >= 12
                    debug('Patching connection write() output buffer with updated header');
                    first = req.outputData[0].data;
                    endOfHeaders = first.indexOf('\r\n\r\n') + 4;
                    req.outputData[0].data =
                        req._header + first.substring(endOfHeaders);
                    debug('Output buffer: %o', req.outputData[0].data);
                }
            }
            // Wait for the socket's `connect` event, so that this `callback()`
            // function throws instead of the `http` request machinery. This is
            // important for i.e. `PacProxyAgent` which determines a failed proxy
            // connection via the `callback()` function throwing.
            yield once_1.default(socket, 'connect');
            return socket;
        });
    }
}
exports.default = HttpProxyAgent;
//# sourceMappingURL=agent.js.map

/***/ }),
/* 482 */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function noop() { }
function once(emitter, name) {
    const o = once.spread(emitter, name);
    const r = o.then((args) => args[0]);
    r.cancel = o.cancel;
    return r;
}
(function (once) {
    function spread(emitter, name) {
        let c = null;
        const p = new Promise((resolve, reject) => {
            function cancel() {
                emitter.removeListener(name, onEvent);
                emitter.removeListener('error', onError);
                p.cancel = noop;
            }
            function onEvent(...args) {
                cancel();
                resolve(args);
            }
            function onError(err) {
                cancel();
                reject(err);
            }
            c = cancel;
            emitter.on(name, onEvent);
            emitter.on('error', onError);
        });
        if (!c) {
            throw new TypeError('Could not get `cancel()` function');
        }
        p.cancel = c;
        return p;
    }
    once.spread = spread;
})(once || (once = {}));
module.exports = once;
//# sourceMappingURL=index.js.map

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const events_1 = __webpack_require__(198);
const debug_1 = __importDefault(__webpack_require__(68));
const promisify_1 = __importDefault(__webpack_require__(485));
const debug = debug_1.default('agent-base');
function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === 'function';
}
function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== 'string')
        return false;
    return stack.split('\n').some(l => l.indexOf('(https.js:') !== -1);
}
function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
}
(function (createAgent) {
    /**
     * Base `http.Agent` implementation.
     * No pooling/keep-alive is implemented by default.
     *
     * @param {Function} callback
     * @api public
     */
    class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
            super();
            let opts = _opts;
            if (typeof callback === 'function') {
                this.callback = callback;
            }
            else if (callback) {
                opts = callback;
            }
            // Timeout for the socket to be returned from the callback
            this.timeout = null;
            if (opts && typeof opts.timeout === 'number') {
                this.timeout = opts.timeout;
            }
            // These aren't actually used by `agent-base`, but are required
            // for the TypeScript definition files in `@types/node` :/
            this.maxFreeSockets = 1;
            this.maxSockets = 1;
            this.sockets = {};
            this.requests = {};
        }
        get defaultPort() {
            if (typeof this.explicitDefaultPort === 'number') {
                return this.explicitDefaultPort;
            }
            return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
            this.explicitDefaultPort = v;
        }
        get protocol() {
            if (typeof this.explicitProtocol === 'string') {
                return this.explicitProtocol;
            }
            return isSecureEndpoint() ? 'https:' : 'http:';
        }
        set protocol(v) {
            this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
            const opts = Object.assign({}, _opts);
            if (typeof opts.secureEndpoint !== 'boolean') {
                opts.secureEndpoint = isSecureEndpoint();
            }
            if (opts.host == null) {
                opts.host = 'localhost';
            }
            if (opts.port == null) {
                opts.port = opts.secureEndpoint ? 443 : 80;
            }
            if (opts.protocol == null) {
                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';
            }
            if (opts.host && opts.path) {
                // If both a `host` and `path` are specified then it's most
                // likely the result of a `url.parse()` call... we need to
                // remove the `path` portion so that `net.connect()` doesn't
                // attempt to open that as a unix socket file.
                delete opts.path;
            }
            delete opts.agent;
            delete opts.hostname;
            delete opts._defaultAgent;
            delete opts.defaultPort;
            delete opts.createConnection;
            // Hint to use "Connection: close"
            // XXX: non-documented `http` module API :(
            req._last = true;
            req.shouldKeepAlive = false;
            let timedOut = false;
            let timeoutId = null;
            const timeoutMs = opts.timeout || this.timeout;
            const onerror = (err) => {
                if (req._hadError)
                    return;
                req.emit('error', err);
                // For Safety. Some additional errors might fire later on
                // and we need to make sure we don't double-fire the error event.
                req._hadError = true;
            };
            const ontimeout = () => {
                timeoutId = null;
                timedOut = true;
                const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
                err.code = 'ETIMEOUT';
                onerror(err);
            };
            const callbackError = (err) => {
                if (timedOut)
                    return;
                if (timeoutId !== null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                onerror(err);
            };
            const onsocket = (socket) => {
                if (timedOut)
                    return;
                if (timeoutId != null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                if (isAgent(socket)) {
                    // `socket` is actually an `http.Agent` instance, so
                    // relinquish responsibility for this `req` to the Agent
                    // from here on
                    debug('Callback returned another Agent instance %o', socket.constructor.name);
                    socket.addRequest(req, opts);
                    return;
                }
                if (socket) {
                    socket.once('free', () => {
                        this.freeSocket(socket, opts);
                    });
                    req.onSocket(socket);
                    return;
                }
                const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
                onerror(err);
            };
            if (typeof this.callback !== 'function') {
                onerror(new Error('`callback` is not defined'));
                return;
            }
            if (!this.promisifiedCallback) {
                if (this.callback.length >= 3) {
                    debug('Converting legacy callback function to promise');
                    this.promisifiedCallback = promisify_1.default(this.callback);
                }
                else {
                    this.promisifiedCallback = this.callback;
                }
            }
            if (typeof timeoutMs === 'number' && timeoutMs > 0) {
                timeoutId = setTimeout(ontimeout, timeoutMs);
            }
            if ('port' in opts && typeof opts.port !== 'number') {
                opts.port = Number(opts.port);
            }
            try {
                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);
                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
            }
            catch (err) {
                Promise.reject(err).catch(callbackError);
            }
        }
        freeSocket(socket, opts) {
            debug('Freeing socket %o %o', socket.constructor.name, opts);
            socket.destroy();
        }
        destroy() {
            debug('Destroying agent %o', this.constructor.name);
        }
    }
    createAgent.Agent = Agent;
    // So that `instanceof` works correctly
    createAgent.prototype = createAgent.Agent.prototype;
})(createAgent || (createAgent = {}));
module.exports = createAgent;
//# sourceMappingURL=index.js.map

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function promisify(fn) {
    return function (req, opts) {
        return new Promise((resolve, reject) => {
            fn.call(this, req, opts, (err, rtn) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rtn);
                }
            });
        });
    };
}
exports.default = promisify;
//# sourceMappingURL=promisify.js.map

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const agent_1 = __importDefault(__webpack_require__(487));
function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function (createHttpsProxyAgent) {
    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent.prototype = agent_1.default.prototype;
})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
module.exports = createHttpsProxyAgent;
//# sourceMappingURL=index.js.map

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(__webpack_require__(157));
const tls_1 = __importDefault(__webpack_require__(482));
const url_1 = __importDefault(__webpack_require__(351));
const assert_1 = __importDefault(__webpack_require__(108));
const debug_1 = __importDefault(__webpack_require__(68));
const agent_base_1 = __webpack_require__(484);
const parse_proxy_response_1 = __importDefault(__webpack_require__(488));
const debug = debug_1.default('https-proxy-agent:agent');
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 *
 * @api public
 */
class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        }
        else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('creating new HttpsProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        // ALPN is supported by Node.js >= v5.
        // attempt to negotiate http/1.1 for proxy servers that support http/2
        if (this.secureProxy && !('ALPNProtocols' in proxy)) {
            proxy.ALPNProtocols = ['http 1.1'];
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            }
            else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            const headers = Object.assign({}, proxy.headers);
            const hostname = `${opts.host}:${opts.port}`;
            let payload = `CONNECT ${hostname} HTTP/1.1\r\n`;
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;
            }
            // The `Host` header should only include the port
            // number when it is not the default port.
            let { host, port, secureEndpoint } = opts;
            if (!isDefaultPort(port, secureEndpoint)) {
                host += `:${port}`;
            }
            headers.Host = host;
            headers.Connection = 'close';
            for (const name of Object.keys(headers)) {
                payload += `${name}: ${headers[name]}\r\n`;
            }
            const proxyResponsePromise = parse_proxy_response_1.default(socket);
            socket.write(`${payload}\r\n`);
            const { statusCode, buffered } = yield proxyResponsePromise;
            if (statusCode === 200) {
                req.once('socket', resume);
                if (opts.secureEndpoint) {
                    const servername = opts.servername || opts.host;
                    if (!servername) {
                        throw new Error('Could not determine "servername"');
                    }
                    // The proxy is connecting to a TLS server, so upgrade
                    // this socket connection to a TLS connection.
                    debug('Upgrading socket connection to TLS');
                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,
                        servername }));
                }
                return socket;
            }
            // Some other status code that's not 200... need to re-play the HTTP
            // header "data" events onto the socket once the HTTP machinery is
            // attached so that the node core `http` can parse and handle the
            // error status code.
            // Close the original socket, and a new "fake" socket is returned
            // instead, so that the proxy doesn't get the HTTP request
            // written to it (which may contain `Authorization` headers or other
            // sensitive data).
            //
            // See: https://hackerone.com/reports/541502
            socket.destroy();
            const fakeSocket = new net_1.default.Socket();
            fakeSocket.readable = true;
            // Need to wait for the "socket" event to re-play the "data" events.
            req.once('socket', (s) => {
                debug('replaying proxy buffer for failed request');
                assert_1.default(s.listenerCount('data') > 0);
                // Replay the "buffered" Buffer onto the fake `socket`, since at
                // this point the HTTP module machinery has been hooked up for
                // the user.
                s.push(buffered);
                s.push(null);
            });
            return fakeSocket;
        });
    }
}
exports.default = HttpsProxyAgent;
function resume(socket) {
    socket.resume();
}
function isDefaultPort(port, secure) {
    return Boolean((!secure && port === 80) || (secure && port === 443));
}
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
        if (!keys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
}
//# sourceMappingURL=agent.js.map

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(__webpack_require__(68));
const debug = debug_1.default('https-proxy-agent:parse-proxy-response');
function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
        // we need to buffer any HTTP traffic that happens with the proxy before we get
        // the CONNECT response, so that if the response is anything other than an "200"
        // response code, then we can re-play the "data" events on the socket once the
        // HTTP parser is hooked up...
        let buffersLength = 0;
        const buffers = [];
        function read() {
            const b = socket.read();
            if (b)
                ondata(b);
            else
                socket.once('readable', read);
        }
        function cleanup() {
            socket.removeListener('end', onend);
            socket.removeListener('error', onerror);
            socket.removeListener('close', onclose);
            socket.removeListener('readable', read);
        }
        function onclose(err) {
            debug('onclose had error %o', err);
        }
        function onend() {
            debug('onend');
        }
        function onerror(err) {
            cleanup();
            debug('onerror %o', err);
            reject(err);
        }
        function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf('\r\n\r\n');
            if (endOfHeaders === -1) {
                // keep buffering
                debug('have not received end of HTTP headers yet...');
                read();
                return;
            }
            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\r\n'));
            const statusCode = +firstLine.split(' ')[1];
            debug('got proxy server response: %o', firstLine);
            resolve({
                statusCode,
                buffered
            });
        }
        socket.on('error', onerror);
        socket.on('close', onclose);
        socket.on('end', onend);
        read();
    });
}
exports.default = parseProxyResponse;
//# sourceMappingURL=parse-proxy-response.js.map

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = contentDisposition
module.exports.parse = parse

/**
 * Module dependencies.
 * @private
 */

var basename = __webpack_require__(82).basename
var Buffer = __webpack_require__(438).Buffer

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 * @private
 */

var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex

/**
 * RegExp to match percent encoding escape.
 * @private
 */

var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g

/**
 * RegExp to match non-latin1 characters.
 * @private
 */

var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 * @private
 */

var QESC_REGEXP = /\\([\u0000-\u007f])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 * @private
 */

var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 * @private
 */

var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 * @private
 */

var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 * @private
 */

var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex

/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @public
 */

function contentDisposition (filename, options) {
  var opts = options || {}

  // get type
  var type = opts.type || 'attachment'

  // get parameters
  var params = createparams(filename, opts.fallback)

  // format into string
  return format(new ContentDisposition(type, params))
}

/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @private
 */

function createparams (filename, fallback) {
  if (filename === undefined) {
    return
  }

  var params = {}

  if (typeof filename !== 'string') {
    throw new TypeError('filename must be a string')
  }

  // fallback defaults to true
  if (fallback === undefined) {
    fallback = true
  }

  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
    throw new TypeError('fallback must be a string or boolean')
  }

  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError('fallback must be ISO-8859-1 string')
  }

  // restrict to file base name
  var name = basename(filename)

  // determine if name is suitable for quoted string
  var isQuotedString = TEXT_REGEXP.test(name)

  // generate fallback name
  var fallbackName = typeof fallback !== 'string'
    ? fallback && getlatin1(name)
    : basename(fallback)
  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name

  // set extended filename parameter
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params['filename*'] = name
  }

  // set filename parameter
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback
      ? fallbackName
      : name
  }

  return params
}

/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @private
 */

function format (obj) {
  var parameters = obj.parameters
  var type = obj.type

  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  // start with normalized type
  var string = String(type).toLowerCase()

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      var val = param.substr(-1) === '*'
        ? ustring(parameters[param])
        : qstring(parameters[param])

      string += '; ' + param + '=' + val
    }
  }

  return string
}

/**
 * Decode a RFC 6987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function decodefield (str) {
  var match = EXT_VALUE_REGEXP.exec(str)

  if (!match) {
    throw new TypeError('invalid extended field value')
  }

  var charset = match[1].toLowerCase()
  var encoded = match[2]
  var value

  // to binary string
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)

  switch (charset) {
    case 'iso-8859-1':
      value = getlatin1(binary)
      break
    case 'utf-8':
      value = Buffer.from(binary, 'binary').toString('utf8')
      break
    default:
      throw new TypeError('unsupported charset in extended field')
  }

  return value
}

/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function getlatin1 (val) {
  // simple Unicode -> ISO-8859-1 transformation
  return String(val).replace(NON_LATIN1_REGEXP, '?')
}

/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function parse (string) {
  if (!string || typeof string !== 'string') {
    throw new TypeError('argument string is required')
  }

  var match = DISPOSITION_TYPE_REGEXP.exec(string)

  if (!match) {
    throw new TypeError('invalid type format')
  }

  // normalize type
  var index = match[0].length
  var type = match[1].toLowerCase()

  var key
  var names = []
  var params = {}
  var value

  // calculate index to start at
  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'
    ? index - 1
    : index

  // match parameters
  while ((match = PARAM_REGEXP.exec(string))) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (names.indexOf(key) !== -1) {
      throw new TypeError('invalid duplicate parameter')
    }

    names.push(key)

    if (key.indexOf('*') + 1 === key.length) {
      // decode extended value
      key = key.slice(0, -1)
      value = decodefield(value)

      // overwrite existing value
      params[key] = value
      continue
    }

    if (typeof params[key] === 'string') {
      continue
    }

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(QESC_REGEXP, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  return new ContentDisposition(type, params)
}

/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @private
 */

function pdecode (str, hex) {
  return String.fromCharCode(parseInt(hex, 16))
}

/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @private
 */

function pencode (char) {
  return '%' + String(char)
    .charCodeAt(0)
    .toString(16)
    .toUpperCase()
}

/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function ustring (val) {
  var str = String(val)

  // percent encode as UTF-8
  var encoded = encodeURIComponent(str)
    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)

  return 'UTF-8\'\'' + encoded
}

/**
 * Class for parsed Content-Disposition header for v8 optimization
 *
 * @public
 * @param {string} type
 * @param {object} parameters
 * @constructor
 */

function ContentDisposition (type, parameters) {
  this.type = type
  this.parameters = parameters
}


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const object_1 = __webpack_require__(249);
const logger = __webpack_require__(64)('model-memos');
class Memos {
    constructor(filepath) {
        this.filepath = filepath;
        if (!fs_1.default.existsSync(filepath)) {
            fs_1.default.writeFileSync(filepath, '{}', 'utf8');
        }
    }
    fetchContent(id, key) {
        try {
            let content = fs_1.default.readFileSync(this.filepath, 'utf8');
            let res = JSON.parse(content);
            let obj = res[id];
            if (!obj)
                return undefined;
            return obj[key];
        }
        catch (e) {
            return undefined;
        }
    }
    async update(id, key, value) {
        let { filepath } = this;
        try {
            let content = fs_1.default.readFileSync(filepath, 'utf8');
            let current = content ? JSON.parse(content) : {};
            current[id] = current[id] || {};
            if (value !== undefined) {
                current[id][key] = object_1.deepClone(value);
            }
            else {
                delete current[id][key];
            }
            content = JSON.stringify(current, null, 2);
            fs_1.default.writeFileSync(filepath, content, 'utf8');
        }
        catch (e) {
            logger.error(`Error on update memos:`, e);
        }
    }
    createMemento(id) {
        return {
            get: (key, defaultValue) => {
                let res = this.fetchContent(id, key);
                return res === undefined ? defaultValue : res;
            },
            update: async (key, value) => {
                await this.update(id, key, value);
            }
        };
    }
}
exports.default = Memos;
//# sourceMappingURL=memos.js.map

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

const logger = __webpack_require__(64)('extensions');
/**
 * Explicitly tells that promise should be run asynchonously.
 */
Promise.prototype.logError = function () {
    this.catch(e => {
        logger.error(e);
    });
};
//# sourceMappingURL=extensions.js.map

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
/* eslint-disable @typescript-eslint/no-unsafe-return */
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const path = tslib_1.__importStar(__webpack_require__(82));
const vm = tslib_1.__importStar(__webpack_require__(493));
const lodash_1 = __webpack_require__(494);
const createLogger = __webpack_require__(64);
const logger = createLogger('util-factoroy');
const requireFunc =  true ? require : undefined;
const Module = __webpack_require__(495);
const REMOVED_GLOBALS = [
    'reallyExit',
    'abort',
    'umask',
    'setuid',
    'setgid',
    'setgroups',
    '_fatalException',
    'exit',
    'kill',
];
function removedGlobalStub(name) {
    return () => {
        throw new Error(`process.${name}() is not allowed in extension sandbox`);
    };
}
// @see node/lib/internal/module.js
function makeRequireFunction() {
    const req = (p) => {
        if (p === 'coc.nvim') {
            return __webpack_require__(496);
        }
        return this.require(p);
    };
    req.resolve = (request) => Module._resolveFilename(request, this);
    req.main = process.mainModule;
    // Enable support to add extra extension types
    req.extensions = Module._extensions;
    req.cache = Module._cache;
    return req;
}
// @see node/lib/module.js
function compileInSandbox(sandbox) {
    // eslint-disable-next-line
    return function (content, filename) {
        const require = makeRequireFunction.call(this);
        const dirname = path.dirname(filename);
        // remove shebang
        // eslint-disable-next-line
        const newContent = content.replace(/^\#\!.*/, '');
        const wrapper = Module.wrap(newContent);
        const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });
        const args = [this.exports, require, this, filename, dirname];
        return compiledWrapper.apply(this.exports, args);
    };
}
function createSandbox(filename, logger) {
    const module = new Module(filename);
    module.paths = Module._nodeModulePaths(filename);
    const sandbox = vm.createContext({
        module,
        Buffer,
        console: {
            debug: (...args) => {
                logger.debug.apply(logger, args);
            },
            log: (...args) => {
                logger.debug.apply(logger, args);
            },
            error: (...args) => {
                logger.error.apply(logger, args);
            },
            info: (...args) => {
                logger.info.apply(logger, args);
            },
            warn: (...args) => {
                logger.warn.apply(logger, args);
            }
        }
    });
    lodash_1.defaults(sandbox, global);
    sandbox.Reflect = Reflect;
    sandbox.require = function sandboxRequire(p) {
        const oldCompile = Module.prototype._compile;
        Module.prototype._compile = compileInSandbox(sandbox);
        const moduleExports = sandbox.module.require(p);
        Module.prototype._compile = oldCompile;
        return moduleExports;
    };
    // patch `require` in sandbox to run loaded module in sandbox context
    // if you need any of these, it might be worth discussing spawning separate processes
    sandbox.process = new process.constructor();
    for (let key of Object.keys(process)) {
        sandbox.process[key] = process[key];
    }
    REMOVED_GLOBALS.forEach(name => {
        sandbox.process[name] = removedGlobalStub(name);
    });
    sandbox.process['chdir'] = () => { };
    // read-only umask
    sandbox.process.umask = (mask) => {
        if (typeof mask !== 'undefined') {
            throw new Error('Cannot use process.umask() to change mask (read-only)');
        }
        return process.umask();
    };
    return sandbox;
}
// inspiration drawn from Module
function createExtension(id, filename, isEmpty = false) {
    if (isEmpty || !fs_1.default.existsSync(filename))
        return {
            activate: () => { },
            deactivate: null
        };
    const sandbox = createSandbox(filename, createLogger(`extension:${id}`));
    delete Module._cache[requireFunc.resolve(filename)];
    // attempt to import plugin
    // Require plugin to export activate & deactivate
    const defaultImport = sandbox.require(filename);
    const activate = (defaultImport && defaultImport.activate) || defaultImport;
    if (typeof activate !== 'function') {
        return { activate: () => { }, deactivate: null };
    }
    return {
        activate,
        deactivate: typeof defaultImport.deactivate === 'function' ? defaultImport.deactivate : null
    };
}
exports.createExtension = createExtension;
//# sourceMappingURL=factory.js.map

/***/ }),
/* 493 */
/***/ (function(module, exports) {

module.exports = require("vm");

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** Used for built-in method references. */
const objectProto = Object.prototype;
/** Used to check objects for own properties. */
const hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @since 0.1.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see defaultsDeep
 * @example
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 })
 * // => { 'a': 1, 'b': 2 }
 */
function defaults(obj, ...sources) {
    obj = Object(obj);
    sources.forEach(source => {
        if (source != null) {
            source = Object(source);
            for (const key in source) {
                const value = obj[key];
                if (value === undefined ||
                    (value === objectProto[key] && !hasOwnProperty.call(obj, key))) {
                    obj[key] = source[key];
                }
            }
        }
    });
    return obj;
}
exports.defaults = defaults;
function omit(obj, properties) {
    let o = {};
    for (let key of Object.keys(obj)) {
        if (!properties.includes(key)) {
            o[key] = obj[key];
        }
    }
    return o;
}
exports.omit = omit;
//# sourceMappingURL=lodash.js.map

/***/ }),
/* 495 */
/***/ (function(module, exports) {

module.exports = require("module");

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
exports.commands = commands_1.default;
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
exports.events = events_1.default;
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
exports.languages = languages_1.default;
const document_1 = tslib_1.__importDefault(__webpack_require__(307));
exports.Document = document_1.default;
const mru_1 = tslib_1.__importDefault(__webpack_require__(314));
exports.Mru = mru_1.default;
const floatBuffer_1 = tslib_1.__importDefault(__webpack_require__(520));
exports.FloatBuffer = floatBuffer_1.default;
const floatFactory_1 = tslib_1.__importDefault(__webpack_require__(254));
exports.FloatFactory = floatFactory_1.default;
const fetch_1 = tslib_1.__importDefault(__webpack_require__(478));
exports.fetch = fetch_1.default;
const download_1 = tslib_1.__importDefault(__webpack_require__(349));
exports.download = download_1.default;
const highligher_1 = tslib_1.__importDefault(__webpack_require__(523));
exports.Highligher = highligher_1.default;
const fileSystemWatcher_1 = tslib_1.__importDefault(__webpack_require__(313));
exports.FileSystemWatcher = fileSystemWatcher_1.default;
const services_1 = tslib_1.__importDefault(__webpack_require__(525));
exports.services = services_1.default;
const sources_1 = tslib_1.__importDefault(__webpack_require__(332));
exports.sources = sources_1.default;
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
exports.workspace = workspace_1.default;
const extensions_1 = tslib_1.__importDefault(__webpack_require__(333));
exports.extensions = extensions_1.default;
const manager_1 = tslib_1.__importDefault(__webpack_require__(541));
exports.listManager = manager_1.default;
const manager_2 = tslib_1.__importDefault(__webpack_require__(256));
exports.snippetManager = manager_2.default;
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
exports.BasicList = basic_1.default;
const manager_3 = tslib_1.__importDefault(__webpack_require__(253));
exports.diagnosticManager = manager_3.default;
const ansiparse_1 = __webpack_require__(524);
exports.ansiparse = ansiparse_1.ansiparse;
const watchman_1 = tslib_1.__importDefault(__webpack_require__(324));
exports.Watchman = watchman_1.default;
const vscode_uri_1 = __webpack_require__(243);
exports.Uri = vscode_uri_1.URI;
const neovim_1 = __webpack_require__(155);
exports.Neovim = neovim_1.Neovim;
exports.Buffer = neovim_1.Buffer;
exports.Window = neovim_1.Window;
const vscode_languageserver_protocol_1 = __webpack_require__(211);
exports.Disposable = vscode_languageserver_protocol_1.Disposable;
exports.Event = vscode_languageserver_protocol_1.Event;
exports.Emitter = vscode_languageserver_protocol_1.Emitter;
tslib_1.__exportStar(__webpack_require__(295), exports);
tslib_1.__exportStar(__webpack_require__(526), exports);
var util_1 = __webpack_require__(238);
exports.disposeAll = util_1.disposeAll;
exports.concurrent = util_1.concurrent;
exports.wait = util_1.wait;
exports.runCommand = util_1.runCommand;
exports.isRunning = util_1.isRunning;
exports.executable = util_1.executable;
//# sourceMappingURL=index.js.map

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const manager_1 = tslib_1.__importDefault(__webpack_require__(253));
const codeActionmanager_1 = tslib_1.__importDefault(__webpack_require__(498));
const codeLensManager_1 = tslib_1.__importDefault(__webpack_require__(500));
const declarationManager_1 = tslib_1.__importDefault(__webpack_require__(501));
const definitionManager_1 = tslib_1.__importDefault(__webpack_require__(502));
const documentColorManager_1 = tslib_1.__importDefault(__webpack_require__(503));
const documentHighlightManager_1 = tslib_1.__importDefault(__webpack_require__(504));
const documentLinkManager_1 = tslib_1.__importDefault(__webpack_require__(505));
const documentSymbolManager_1 = tslib_1.__importDefault(__webpack_require__(506));
const foldingRangeManager_1 = tslib_1.__importDefault(__webpack_require__(507));
const formatManager_1 = tslib_1.__importDefault(__webpack_require__(508));
const formatRangeManager_1 = tslib_1.__importDefault(__webpack_require__(509));
const hoverManager_1 = tslib_1.__importDefault(__webpack_require__(510));
const implementationManager_1 = tslib_1.__importDefault(__webpack_require__(511));
const onTypeFormatManager_1 = tslib_1.__importDefault(__webpack_require__(512));
const rangeManager_1 = tslib_1.__importDefault(__webpack_require__(513));
const referenceManager_1 = tslib_1.__importDefault(__webpack_require__(514));
const renameManager_1 = tslib_1.__importDefault(__webpack_require__(515));
const signatureManager_1 = tslib_1.__importDefault(__webpack_require__(516));
const typeDefinitionManager_1 = tslib_1.__importDefault(__webpack_require__(517));
const workspaceSymbolsManager_1 = tslib_1.__importDefault(__webpack_require__(518));
const manager_2 = tslib_1.__importDefault(__webpack_require__(256));
const sources_1 = tslib_1.__importDefault(__webpack_require__(332));
const types_1 = __webpack_require__(295);
const complete = tslib_1.__importStar(__webpack_require__(519));
const position_1 = __webpack_require__(311);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('languages');
function fixDocumentation(str) {
    return str.replace(/&nbsp;/g, ' ');
}
function check(_target, key, descriptor) {
    let fn = descriptor.value;
    if (typeof fn !== 'function') {
        return;
    }
    descriptor.value = function (...args) {
        let { cancelTokenSource } = this;
        this.cancelTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        return new Promise((resolve, reject) => {
            let resolved = false;
            let timer = setTimeout(() => {
                cancelTokenSource.cancel();
                logger.error(`${key} timeout after 5s`);
                if (!resolved)
                    reject(new Error(`${key} timeout after 5s`));
            }, 5000);
            Promise.resolve(fn.apply(this, args)).then(res => {
                clearTimeout(timer);
                resolve(res);
            }, e => {
                clearTimeout(timer);
                reject(e);
            });
        });
    };
}
exports.check = check;
class Languages {
    constructor() {
        this.onTypeFormatManager = new onTypeFormatManager_1.default();
        this.documentLinkManager = new documentLinkManager_1.default();
        this.documentColorManager = new documentColorManager_1.default();
        this.foldingRangeManager = new foldingRangeManager_1.default();
        this.renameManager = new renameManager_1.default();
        this.formatManager = new formatManager_1.default();
        this.codeActionManager = new codeActionmanager_1.default();
        this.workspaceSymbolsManager = new workspaceSymbolsManager_1.default();
        this.formatRangeManager = new formatRangeManager_1.default();
        this.hoverManager = new hoverManager_1.default();
        this.signatureManager = new signatureManager_1.default();
        this.documentSymbolManager = new documentSymbolManager_1.default();
        this.documentHighlightManager = new documentHighlightManager_1.default();
        this.definitionManager = new definitionManager_1.default();
        this.declarationManager = new declarationManager_1.default();
        this.typeDefinitionManager = new typeDefinitionManager_1.default();
        this.referenceManager = new referenceManager_1.default();
        this.implementationManager = new implementationManager_1.default();
        this.codeLensManager = new codeLensManager_1.default();
        this.selectionRangeManager = new rangeManager_1.default();
        this.cancelTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        workspace_1.default.onWillSaveUntil(event => {
            let { languageId } = event.document;
            let config = workspace_1.default.getConfiguration('coc.preferences', event.document.uri);
            let filetypes = config.get('formatOnSaveFiletypes', []);
            if (filetypes.includes(languageId) || filetypes.some(item => item === '*')) {
                let willSaveWaitUntil = async () => {
                    let options = await workspace_1.default.getFormatOptions(event.document.uri);
                    let textEdits = await this.provideDocumentFormattingEdits(event.document, options);
                    return textEdits;
                };
                event.waitUntil(willSaveWaitUntil());
            }
        }, null, 'languageserver');
        this.loadCompleteConfig();
        workspace_1.default.onDidChangeConfiguration(this.loadCompleteConfig, this);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    loadCompleteConfig() {
        let config = workspace_1.default.getConfiguration('coc.preferences');
        let suggest = workspace_1.default.getConfiguration('suggest');
        let labels = suggest.get('completionItemKindLabels', {});
        this.completionItemKindMap = new Map([
            [vscode_languageserver_protocol_1.CompletionItemKind.Text, labels['text'] || 'v'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Method, labels['method'] || 'f'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Function, labels['function'] || 'f'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Constructor, typeof labels['constructor'] == 'function' ? 'f' : labels['con' + 'structor']],
            [vscode_languageserver_protocol_1.CompletionItemKind.Field, labels['field'] || 'm'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Variable, labels['variable'] || 'v'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Class, labels['class'] || 'C'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Interface, labels['interface'] || 'I'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Module, labels['module'] || 'M'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Property, labels['property'] || 'm'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Unit, labels['unit'] || 'U'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Value, labels['value'] || 'v'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Enum, labels['enum'] || 'E'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Keyword, labels['keyword'] || 'k'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Snippet, labels['snippet'] || 'S'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Color, labels['color'] || 'v'],
            [vscode_languageserver_protocol_1.CompletionItemKind.File, labels['file'] || 'F'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Reference, labels['reference'] || 'r'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Folder, labels['folder'] || 'F'],
            [vscode_languageserver_protocol_1.CompletionItemKind.EnumMember, labels['enumMember'] || 'm'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Constant, labels['constant'] || 'v'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Struct, labels['struct'] || 'S'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Event, labels['event'] || 'E'],
            [vscode_languageserver_protocol_1.CompletionItemKind.Operator, labels['operator'] || 'O'],
            [vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter, labels['typeParameter'] || 'T'],
        ]);
        this.completeConfig = {
            defaultKindText: labels['default'] || '',
            priority: suggest.get('languageSourcePriority', 99),
            echodocSupport: suggest.get('echodocSupport', false),
            detailField: suggest.get('detailField', 'menu'),
            detailMaxLength: suggest.get('detailMaxLength', 100),
            invalidInsertCharacters: suggest.get('invalidInsertCharacters', [' ', '(', '<', '{', '[', '\r', '\n']),
        };
    }
    registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {
        return this.onTypeFormatManager.register(selector, provider, triggerCharacters);
    }
    registerCompletionItemProvider(name, shortcut, languageIds, provider, triggerCharacters = [], priority, allCommitCharacters) {
        languageIds = typeof languageIds == 'string' ? [languageIds] : languageIds;
        let source = this.createCompleteSource(name, shortcut, provider, languageIds, triggerCharacters, allCommitCharacters || [], priority);
        sources_1.default.addSource(source);
        logger.debug('created service source', name);
        return {
            dispose: () => {
                sources_1.default.removeSource(source);
            }
        };
    }
    registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {
        return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);
    }
    registerHoverProvider(selector, provider) {
        return this.hoverManager.register(selector, provider);
    }
    registerSelectionRangeProvider(selector, provider) {
        return this.selectionRangeManager.register(selector, provider);
    }
    registerSignatureHelpProvider(selector, provider, triggerCharacters) {
        return this.signatureManager.register(selector, provider, triggerCharacters);
    }
    registerDocumentSymbolProvider(selector, provider) {
        return this.documentSymbolManager.register(selector, provider);
    }
    registerFoldingRangeProvider(selector, provider) {
        return this.foldingRangeManager.register(selector, provider);
    }
    registerDocumentHighlightProvider(selector, provider) {
        return this.documentHighlightManager.register(selector, provider);
    }
    registerCodeLensProvider(selector, provider) {
        return this.codeLensManager.register(selector, provider);
    }
    registerDocumentLinkProvider(selector, provider) {
        return this.documentLinkManager.register(selector, provider);
    }
    registerDocumentColorProvider(selector, provider) {
        return this.documentColorManager.register(selector, provider);
    }
    registerDefinitionProvider(selector, provider) {
        return this.definitionManager.register(selector, provider);
    }
    registerDeclarationProvider(selector, provider) {
        return this.declarationManager.register(selector, provider);
    }
    registerTypeDefinitionProvider(selector, provider) {
        return this.typeDefinitionManager.register(selector, provider);
    }
    registerImplementationProvider(selector, provider) {
        return this.implementationManager.register(selector, provider);
    }
    registerReferencesProvider(selector, provider) {
        return this.referenceManager.register(selector, provider);
    }
    registerRenameProvider(selector, provider) {
        return this.renameManager.register(selector, provider);
    }
    registerWorkspaceSymbolProvider(provider) {
        if (arguments.length > 1 && typeof arguments[1].provideWorkspaceSymbols === 'function') {
            provider = arguments[1];
        }
        return this.workspaceSymbolsManager.register(provider);
    }
    registerDocumentFormatProvider(selector, provider, priority = 0) {
        return this.formatManager.register(selector, provider, priority);
    }
    registerDocumentRangeFormatProvider(selector, provider, priority = 0) {
        return this.formatRangeManager.register(selector, provider, priority);
    }
    shouldTriggerSignatureHelp(document, triggerCharacter) {
        return this.signatureManager.shouldTrigger(document, triggerCharacter);
    }
    async getHover(document, position, token) {
        return await this.hoverManager.provideHover(document, position, token);
    }
    async getSignatureHelp(document, position, token) {
        return await this.signatureManager.provideSignatureHelp(document, position, token);
    }
    async getDefinition(document, position, token) {
        if (!this.definitionManager.hasProvider(document))
            return null;
        return await this.definitionManager.provideDefinition(document, position, token);
    }
    async getDeclaration(document, position, token) {
        if (!this.declarationManager.hasProvider(document))
            return null;
        return await this.declarationManager.provideDeclaration(document, position, token);
    }
    async getTypeDefinition(document, position, token) {
        if (!this.typeDefinitionManager.hasProvider(document))
            return null;
        return await this.typeDefinitionManager.provideTypeDefinition(document, position, token);
    }
    async getImplementation(document, position, token) {
        if (!this.implementationManager.hasProvider(document))
            return null;
        return await this.implementationManager.provideReferences(document, position, token);
    }
    async getReferences(document, context, position, token) {
        if (!this.referenceManager.hasProvider(document))
            return null;
        return await this.referenceManager.provideReferences(document, position, context, token);
    }
    async getDocumentSymbol(document) {
        return await this.documentSymbolManager.provideDocumentSymbols(document, this.token);
    }
    async getSelectionRanges(document, positions) {
        return await this.selectionRangeManager.provideSelectionRanges(document, positions, this.token);
    }
    async getWorkspaceSymbols(document, query) {
        query = query || '';
        return await this.workspaceSymbolsManager.provideWorkspaceSymbols(document, query, this.token);
    }
    async resolveWorkspaceSymbol(symbol) {
        return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, this.token);
    }
    async provideRenameEdits(document, position, newName) {
        return await this.renameManager.provideRenameEdits(document, position, newName, this.token);
    }
    async prepareRename(document, position) {
        return await this.renameManager.prepareRename(document, position, this.token);
    }
    async provideDocumentFormattingEdits(document, options) {
        if (!this.formatManager.hasProvider(document)) {
            let hasRangeFormater = this.formatRangeManager.hasProvider(document);
            if (!hasRangeFormater) {
                logger.error('Format provider not found for current document', 'error');
                return null;
            }
            let end = document.positionAt(document.getText().length);
            let range = vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(0, 0), end);
            return await this.provideDocumentRangeFormattingEdits(document, range, options);
        }
        return await this.formatManager.provideDocumentFormattingEdits(document, options, this.token);
    }
    async provideDocumentRangeFormattingEdits(document, range, options) {
        if (!this.formatRangeManager.hasProvider(document))
            return null;
        return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document, range, options, this.token);
    }
    /**
     * Get CodeAction list for document
     *
     * @public
     * @param {TextDocument} document
     * @param {Range} range
     * @param {CodeActionContext} context
     * @returns {Promise<CodeAction[]>}
     */
    async getCodeActions(document, range, context, silent = false) {
        if (!silent && !this.codeActionManager.hasProvider(document)) {
            return null;
        }
        return await this.codeActionManager.provideCodeActions(document, range, context, this.token);
    }
    async getDocumentHighLight(document, position, token) {
        return await this.documentHighlightManager.provideDocumentHighlights(document, position, token);
    }
    async getDocumentLinks(document) {
        if (!this.documentLinkManager.hasProvider(document)) {
            return null;
        }
        return (await this.documentLinkManager.provideDocumentLinks(document, this.token)) || [];
    }
    async resolveDocumentLink(link) {
        return await this.documentLinkManager.resolveDocumentLink(link, this.token);
    }
    async provideDocumentColors(document, token) {
        return await this.documentColorManager.provideDocumentColors(document, token);
    }
    async provideFoldingRanges(document, context) {
        if (!this.foldingRangeManager.hasProvider(document)) {
            return null;
        }
        return await this.foldingRangeManager.provideFoldingRanges(document, context, this.token);
    }
    async provideColorPresentations(color, document) {
        return await this.documentColorManager.provideColorPresentations(color, document, this.token);
    }
    async getCodeLens(document) {
        return await this.codeLensManager.provideCodeLenses(document, this.token);
    }
    async resolveCodeLens(codeLens) {
        return await this.codeLensManager.resolveCodeLens(codeLens, this.token);
    }
    async provideDocumentOnTypeEdits(character, document, position, token) {
        return this.onTypeFormatManager.onCharacterType(character, document, position, token);
    }
    hasOnTypeProvider(character, document) {
        return this.onTypeFormatManager.getProvider(document, character) != null;
    }
    hasProvider(id, document) {
        switch (id) {
            case 'rename':
                return this.renameManager.hasProvider(document);
            case 'onTypeEdit':
                return this.onTypeFormatManager.hasProvider(document);
            case 'documentLink':
                return this.documentLinkManager.hasProvider(document);
            case 'documentColor':
                return this.documentColorManager.hasProvider(document);
            case 'foldingRange':
                return this.foldingRangeManager.hasProvider(document);
            case 'format':
                return this.formatManager.hasProvider(document);
            case 'codeAction':
                return this.codeActionManager.hasProvider(document);
            case 'workspaceSymbols':
                return this.workspaceSymbolsManager.hasProvider();
            case 'formatRange':
                return this.formatRangeManager.hasProvider(document);
            case 'hover':
                return this.hoverManager.hasProvider(document);
            case 'signature':
                return this.signatureManager.hasProvider(document);
            case 'documentSymbol':
                return this.documentSymbolManager.hasProvider(document);
            case 'documentHighlight':
                return this.documentHighlightManager.hasProvider(document);
            case 'definition':
                return this.definitionManager.hasProvider(document);
            case 'declaration':
                return this.declarationManager.hasProvider(document);
            case 'typeDefinition':
                return this.typeDefinitionManager.hasProvider(document);
            case 'reference':
                return this.referenceManager.hasProvider(document);
            case 'implementation':
                return this.implementationManager.hasProvider(document);
            case 'codeLens':
                return this.codeLensManager.hasProvider(document);
            case 'selectionRange':
                return this.selectionRangeManager.hasProvider(document);
            default:
                throw new Error(`${id} not supported.`);
        }
    }
    dispose() {
        // noop
    }
    createDiagnosticCollection(owner) {
        return manager_1.default.create(owner);
    }
    createCompleteSource(name, shortcut, provider, languageIds, triggerCharacters, allCommitCharacters, priority) {
        // track them for resolve
        let completeItems = [];
        // line used for TextEdit
        let hasResolve = typeof provider.resolveCompletionItem === 'function';
        priority = priority == null ? this.completeConfig.priority : priority;
        // index set of resolved items
        let resolvedIndexes = new Set();
        let source = {
            name,
            priority,
            shortcut,
            enable: true,
            sourceType: types_1.SourceType.Service,
            filetypes: languageIds,
            triggerCharacters: triggerCharacters || [],
            toggle: () => {
                source.enable = !source.enable;
            },
            doComplete: async (opt, token) => {
                let { triggerCharacter, bufnr } = opt;
                resolvedIndexes = new Set();
                let isTrigger = triggerCharacters && triggerCharacters.includes(triggerCharacter);
                let triggerKind = vscode_languageserver_protocol_1.CompletionTriggerKind.Invoked;
                if (opt.triggerForInComplete) {
                    triggerKind = vscode_languageserver_protocol_1.CompletionTriggerKind.TriggerForIncompleteCompletions;
                }
                else if (isTrigger) {
                    triggerKind = vscode_languageserver_protocol_1.CompletionTriggerKind.TriggerCharacter;
                }
                if (token.isCancellationRequested)
                    return null;
                let position = complete.getPosition(opt);
                let context = { triggerKind, option: opt };
                if (isTrigger)
                    context.triggerCharacter = triggerCharacter;
                let result;
                try {
                    let doc = workspace_1.default.getDocument(bufnr);
                    result = await Promise.resolve(provider.provideCompletionItems(doc.textDocument, position, token, context));
                }
                catch (e) {
                    // don't disturb user
                    logger.error(`Complete "${name}" error:`, e);
                    return null;
                }
                if (!result || token.isCancellationRequested)
                    return null;
                completeItems = Array.isArray(result) ? result : result.items;
                if (!completeItems || completeItems.length == 0)
                    return null;
                let startcol = this.getStartColumn(opt.line, completeItems);
                let option = Object.assign({}, opt);
                let prefix;
                if (startcol != null) {
                    if (startcol < option.col) {
                        prefix = string_1.byteSlice(opt.line, startcol, option.col);
                    }
                    option.col = startcol;
                }
                let items = completeItems.map((o, index) => {
                    let item = this.convertVimCompleteItem(o, shortcut, option, prefix);
                    item.index = index;
                    return item;
                });
                return {
                    startcol,
                    isIncomplete: !!result.isIncomplete,
                    items
                };
            },
            onCompleteResolve: async (item, token) => {
                let resolving = completeItems[item.index];
                if (!resolving)
                    return;
                if (hasResolve && !resolvedIndexes.has(item.index)) {
                    let resolved = await Promise.resolve(provider.resolveCompletionItem(resolving, token));
                    if (token.isCancellationRequested)
                        return;
                    resolvedIndexes.add(item.index);
                    if (resolved)
                        Object.assign(resolving, resolved);
                }
                if (item.documentation == null) {
                    let { documentation, detail } = resolving;
                    if (!documentation && !detail)
                        return;
                    let docs = [];
                    if (detail && !item.detailShown && detail != item.word) {
                        detail = detail.replace(/\n\s*/g, ' ');
                        if (detail.length) {
                            let isText = /^[\w-\s.,\t]+$/.test(detail);
                            let filetype = isText ? 'txt' : await workspace_1.default.nvim.eval('&filetype');
                            docs.push({ filetype: isText ? 'txt' : filetype, content: detail });
                        }
                    }
                    if (documentation) {
                        if (typeof documentation == 'string') {
                            docs.push({
                                filetype: 'markdown',
                                content: fixDocumentation(documentation)
                            });
                        }
                        else if (documentation.value) {
                            docs.push({
                                filetype: documentation.kind == 'markdown' ? 'markdown' : 'txt',
                                content: fixDocumentation(documentation.value)
                            });
                        }
                    }
                    item.documentation = docs;
                }
            },
            onCompleteDone: async (vimItem, opt) => {
                let item = completeItems[vimItem.index];
                if (!item)
                    return;
                let line = opt.linenr - 1;
                if (item.insertText != null && !item.textEdit) {
                    item.textEdit = {
                        range: vscode_languageserver_protocol_1.Range.create(line, opt.col, line, opt.colnr - 1),
                        newText: item.insertText
                    };
                }
                if (vimItem.line)
                    Object.assign(opt, { line: vimItem.line });
                try {
                    let isSnippet = await this.applyTextEdit(item, opt);
                    let { additionalTextEdits } = item;
                    if (additionalTextEdits && item.textEdit) {
                        let r = item.textEdit.range;
                        additionalTextEdits = additionalTextEdits.filter(edit => {
                            if (position_1.rangeOverlap(r, edit.range)) {
                                logger.error('Filtered overlap additionalTextEdit:', edit);
                                return false;
                            }
                            return true;
                        });
                    }
                    await this.applyAdditionalEdits(additionalTextEdits, opt.bufnr, isSnippet);
                    if (isSnippet)
                        await manager_2.default.selectCurrentPlaceholder();
                    if (item.command)
                        commands_1.default.execute(item.command);
                }
                catch (e) {
                    logger.error('Error on CompleteDone:', e);
                }
            },
            shouldCommit: (item, character) => {
                let completeItem = completeItems[item.index];
                if (!completeItem)
                    return false;
                let commitCharacters = completeItem.commitCharacters || allCommitCharacters;
                return commitCharacters.includes(character);
            }
        };
        return source;
    }
    get token() {
        this.cancelTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        return this.cancelTokenSource.token;
    }
    async applyTextEdit(item, option) {
        let { nvim } = this;
        let { textEdit } = item;
        if (!textEdit)
            return false;
        let { line, bufnr, linenr } = option;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return false;
        let { range, newText } = textEdit;
        // handle possible indent change for textEdit
        let oi = line.match(/^\s*/)[0];
        let ci = doc.getline(linenr - 1).match(/^\s*/)[0];
        if (oi != ci) {
            let c = ci.length - oi.length;
            if (range.start.line == linenr - 1) {
                range.start.character = range.start.character + c;
            }
            if (range.end.line == linenr - 1) {
                range.end.character = range.end.character + c;
            }
        }
        let isSnippet = item.insertTextFormat === vscode_languageserver_protocol_1.InsertTextFormat.Snippet;
        // replace inserted word
        let start = line.substr(0, range.start.character);
        let end = line.substr(range.end.character);
        if (isSnippet) {
            let currline = doc.getline(linenr - 1);
            let endCharacter = currline.length - end.length;
            let r = vscode_languageserver_protocol_1.Range.create(linenr - 1, range.start.character, linenr - 1, endCharacter);
            // can't select, since additionalTextEdits would break selection
            return await manager_2.default.insertSnippet(newText, false, r);
        }
        let newLines = `${start}${newText}${end}`.split('\n');
        if (newLines.length == 1) {
            await nvim.call('coc#util#setline', [linenr, newLines[0]]);
            await workspace_1.default.moveTo(vscode_languageserver_protocol_1.Position.create(linenr - 1, (start + newText).length));
        }
        else {
            let buffer = nvim.createBuffer(bufnr);
            await buffer.setLines(newLines, {
                start: linenr - 1,
                end: linenr,
                strictIndexing: false
            });
            let line = linenr - 1 + newLines.length - 1;
            let character = newLines[newLines.length - 1].length - end.length;
            await workspace_1.default.moveTo({ line, character });
        }
        return false;
    }
    async applyAdditionalEdits(textEdits, bufnr, snippet) {
        if (!textEdits || textEdits.length == 0)
            return;
        let document = workspace_1.default.getDocument(bufnr);
        if (!document)
            return;
        await document.patchChange(true);
        // move cursor after edit
        let changed = null;
        let pos = await workspace_1.default.getCursorPosition();
        if (!snippet)
            changed = position_1.getChangedFromEdits(pos, textEdits);
        await document.applyEdits(textEdits);
        if (changed)
            await workspace_1.default.moveTo(vscode_languageserver_protocol_1.Position.create(pos.line + changed.line, pos.character + changed.character));
    }
    getStartColumn(line, items) {
        let first = items[0];
        if (!first.textEdit)
            return null;
        let { character } = first.textEdit.range.start;
        for (let i = 0; i < 10; i++) {
            let o = items[i];
            if (!o)
                break;
            if (!o.textEdit)
                return null;
            if (o.textEdit.range.start.character !== character)
                return null;
        }
        return string_1.byteIndex(line, character);
    }
    convertVimCompleteItem(item, shortcut, opt, prefix) {
        let { echodocSupport, detailField, detailMaxLength, invalidInsertCharacters } = this.completeConfig;
        let hasAdditionalEdit = item.additionalTextEdits && item.additionalTextEdits.length > 0;
        let isSnippet = item.insertTextFormat === vscode_languageserver_protocol_1.InsertTextFormat.Snippet || hasAdditionalEdit;
        let label = item.label.trim();
        let obj = {
            word: complete.getWord(item, opt, invalidInsertCharacters),
            abbr: label,
            menu: `[${shortcut}]`,
            kind: complete.completionKindString(item.kind, this.completionItemKindMap, this.completeConfig.defaultKindText),
            sortText: item.sortText || null,
            sourceScore: item['score'] || null,
            filterText: item.filterText || label,
            isSnippet,
            dup: item.data && item.data.dup == 0 ? 0 : 1
        };
        if (prefix) {
            if (!obj.filterText.startsWith(prefix)) {
                if (item.textEdit && item.textEdit.newText.startsWith(prefix)) {
                    obj.filterText = item.textEdit.newText.split(/\n/)[0];
                }
                else {
                    obj.filterText = `${prefix}${obj.filterText}`;
                }
            }
            if (!item.textEdit && !obj.word.startsWith(prefix)) {
                // fix remains completeItem that should not change startcol
                obj.word = `${prefix}${obj.word}`;
            }
        }
        if (item && item.detail && detailField != 'preview') {
            let detail = item.detail.replace(/\n\s*/g, ' ');
            if (string_1.byteLength(detail) < detailMaxLength) {
                if (detailField == 'menu') {
                    obj.menu = `${detail} ${obj.menu}`;
                }
                else if (detailField == 'abbr') {
                    obj.abbr = `${obj.abbr} - ${detail}`;
                }
                obj.detailShown = 1;
            }
        }
        if (item.documentation) {
            obj.info = typeof item.documentation == 'string' ? item.documentation : item.documentation.value;
        }
        else {
            obj.info = '';
        }
        if (obj.word == '')
            obj.empty = 1;
        if (item.textEdit)
            obj.line = opt.line;
        if (item.kind == vscode_languageserver_protocol_1.CompletionItemKind.Folder && !obj.abbr.endsWith('/')) {
            obj.abbr = obj.abbr + '/';
        }
        if (echodocSupport && item.kind >= 2 && item.kind <= 4) {
            let fields = [item.detail || '', obj.abbr, obj.word];
            for (let s of fields) {
                if (s.includes('(')) {
                    obj.signature = s;
                    break;
                }
            }
        }
        if (item.preselect)
            obj.preselect = true;
        item.data = item.data || {};
        if (item.data.optional)
            obj.abbr = obj.abbr + '?';
        return obj;
    }
}
tslib_1.__decorate([
    check
], Languages.prototype, "getDocumentSymbol", null);
tslib_1.__decorate([
    check
], Languages.prototype, "getSelectionRanges", null);
tslib_1.__decorate([
    check
], Languages.prototype, "getWorkspaceSymbols", null);
tslib_1.__decorate([
    check
], Languages.prototype, "resolveWorkspaceSymbol", null);
tslib_1.__decorate([
    check
], Languages.prototype, "provideRenameEdits", null);
tslib_1.__decorate([
    check
], Languages.prototype, "prepareRename", null);
tslib_1.__decorate([
    check
], Languages.prototype, "provideDocumentFormattingEdits", null);
tslib_1.__decorate([
    check
], Languages.prototype, "provideDocumentRangeFormattingEdits", null);
tslib_1.__decorate([
    check
], Languages.prototype, "getCodeActions", null);
tslib_1.__decorate([
    check
], Languages.prototype, "getDocumentLinks", null);
tslib_1.__decorate([
    check
], Languages.prototype, "resolveDocumentLink", null);
tslib_1.__decorate([
    check
], Languages.prototype, "provideFoldingRanges", null);
tslib_1.__decorate([
    check
], Languages.prototype, "provideColorPresentations", null);
tslib_1.__decorate([
    check
], Languages.prototype, "getCodeLens", null);
tslib_1.__decorate([
    check
], Languages.prototype, "resolveCodeLens", null);
exports.default = new Languages();
//# sourceMappingURL=languages.js.map

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
const array_1 = __webpack_require__(308);
const logger = __webpack_require__(64)('codeActionManager');
class CodeActionManager extends manager_1.default {
    register(selector, provider, clientId, codeActionKinds) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider,
            kinds: codeActionKinds,
            clientId
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideCodeActions(document, range, context, token) {
        let providers = this.getProviders(document);
        if (!providers.length)
            return null;
        if (context.only) {
            let { only } = context;
            providers = providers.filter(p => {
                if (p.kinds && !p.kinds.some(kind => only.includes(kind))) {
                    return false;
                }
                return true;
            });
        }
        let res = new Map();
        await Promise.all(providers.map(item => {
            let { provider, clientId } = item;
            clientId = clientId || uuid_1.v4();
            return Promise.resolve(provider.provideCodeActions(document, range, context, token)).then(actions => {
                if (!actions || actions.length == 0)
                    return;
                let codeActions = res.get(clientId) || [];
                for (let action of actions) {
                    if (vscode_languageserver_protocol_1.Command.is(action)) {
                        codeActions.push(vscode_languageserver_protocol_1.CodeAction.create(action.title, action));
                    }
                    else {
                        if (context.only) {
                            if (!action.kind)
                                continue;
                            let { only } = context;
                            if (array_1.intersect(only, [vscode_languageserver_protocol_1.CodeActionKind.Source, vscode_languageserver_protocol_1.CodeActionKind.Refactor])) {
                                if (!only.includes(action.kind.split('.', 2)[0])) {
                                    continue;
                                }
                            }
                            else if (!context.only.includes(action.kind)) {
                                continue;
                            }
                        }
                        let idx = codeActions.findIndex(o => o.title == action.title);
                        if (idx == -1)
                            codeActions.push(action);
                    }
                }
                res.set(clientId, codeActions);
            });
        }));
        return res;
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = CodeActionManager;
//# sourceMappingURL=codeActionmanager.js.map

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('provider-manager');
class Manager {
    constructor() {
        this.providers = new Set();
    }
    hasProvider(document) {
        return this.getProvider(document) != null;
    }
    getProvider(document) {
        let currScore = 0;
        let providerItem;
        for (let item of this.providers) {
            let { selector, priority } = item;
            let score = workspace_1.default.match(selector, document);
            if (score == 0)
                continue;
            if (typeof priority == 'number') {
                score = priority;
            }
            if (score < currScore)
                continue;
            currScore = score;
            providerItem = item;
        }
        return providerItem;
    }
    poviderById(id) {
        let item = Array.from(this.providers).find(o => o.id == id);
        return item ? item.provider : null;
    }
    getProviders(document) {
        let items = Array.from(this.providers);
        items = items.filter(item => workspace_1.default.match(item.selector, document) > 0);
        return items.sort((a, b) => workspace_1.default.match(b.selector, document) - workspace_1.default.match(a.selector, document));
    }
    mergeDefinitions(arr) {
        let res = [];
        for (let def of arr) {
            if (!def)
                continue;
            if (vscode_languageserver_protocol_1.Location.is(def)) {
                let { uri, range } = def;
                let idx = res.findIndex(l => l.uri == uri && l.range.start.line == range.start.line);
                if (idx == -1) {
                    res.push(def);
                }
            }
            else if (Array.isArray(def)) {
                for (let d of def) {
                    let { uri, range } = d;
                    let idx = res.findIndex(l => l.uri == uri && l.range.start.line == range.start.line);
                    if (idx == -1) {
                        res.push(d);
                    }
                }
            }
            else {
                workspace_1.default.showMessage(`Bad definition ${JSON.stringify(def)}`, 'error');
            }
        }
        return res;
    }
}
exports.default = Manager;
//# sourceMappingURL=manager.js.map

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
const lodash_1 = __webpack_require__(494);
// const logger = require('../util/logger')('codeActionManager')
class CodeLensManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideCodeLenses(document, token) {
        let providers = this.getProviders(document);
        if (!providers.length)
            return null;
        let arr = await Promise.all(providers.map(item => {
            let { provider, id } = item;
            return Promise.resolve(provider.provideCodeLenses(document, token)).then(res => {
                if (Array.isArray(res)) {
                    for (let item of res) {
                        item.source = id;
                    }
                }
                return res || [];
            });
        }));
        return [].concat(...arr);
    }
    async resolveCodeLens(codeLens, token) {
        // no need to resolve
        if (codeLens.command)
            return codeLens;
        let { source } = codeLens;
        let provider = this.poviderById(source);
        if (!provider || typeof provider.resolveCodeLens != 'function') {
            console.error(`CodeLens Resolve not supported`);
            return codeLens;
        }
        let res = await Promise.resolve(provider.resolveCodeLens(lodash_1.omit(codeLens, ['source']), token));
        Object.assign(codeLens, res);
        return codeLens;
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = CodeLensManager;
//# sourceMappingURL=codeLensManager.js.map

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
const logger = __webpack_require__(64)('definitionManager');
class DeclarationManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideDeclaration(document, position, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDeclaration(document, position, token));
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = DeclarationManager;
//# sourceMappingURL=declarationManager.js.map

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
const logger = __webpack_require__(64)('definitionManager');
class DefinitionManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideDefinition(document, position, token) {
        let providers = this.getProviders(document);
        if (!providers.length)
            return null;
        let arr = await Promise.all(providers.map(item => {
            let { provider } = item;
            return Promise.resolve(provider.provideDefinition(document, position, token));
        }));
        return this.mergeDefinitions(arr);
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = DefinitionManager;
//# sourceMappingURL=definitionManager.js.map

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class DocumentColorManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideDocumentColors(document, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        let res = await Promise.resolve(provider.provideDocumentColors(document, token));
        return res;
    }
    async provideColorPresentations(colorInformation, document, token) {
        let { range, color } = colorInformation;
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        let res = await Promise.resolve(provider.provideColorPresentations(color, { document, range }, token));
        return res;
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = DocumentColorManager;
//# sourceMappingURL=documentColorManager.js.map

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class DocumentHighlightManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideDocumentHighlights(document, position, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentHighlights(document, position, token));
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = DocumentHighlightManager;
//# sourceMappingURL=documentHighlightManager.js.map

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class DocumentLinkManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async _provideDocumentLinks(item, document, token) {
        let { provider, id } = item;
        let items = await Promise.resolve(provider.provideDocumentLinks(document, token));
        if (!items || !items.length)
            return [];
        items.forEach(item => {
            item.data = item.data || {};
            item.data.source = id;
        });
        return items;
    }
    async provideDocumentLinks(document, token) {
        let items = this.getProviders(document);
        if (items.length == 0)
            return [];
        const arr = await Promise.all(items.map(item => this._provideDocumentLinks(item, document, token)));
        return [].concat(...arr);
    }
    async resolveDocumentLink(link, token) {
        let { data } = link;
        if (!data || !data.source)
            return null;
        for (let item of this.providers) {
            if (item.id == data.source) {
                let { provider } = item;
                link = await Promise.resolve(provider.resolveDocumentLink(link, token));
                return link;
            }
        }
        return null;
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = DocumentLinkManager;
//# sourceMappingURL=documentLinkManager.js.map

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class DocumentSymbolManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideDocumentSymbols(document, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        return (await Promise.resolve(provider.provideDocumentSymbols(document, token))) || [];
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = DocumentSymbolManager;
//# sourceMappingURL=documentSymbolManager.js.map

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class FoldingRangeManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideFoldingRanges(document, context, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        return (await Promise.resolve(provider.provideFoldingRanges(document, context, token)) || []);
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = FoldingRangeManager;
//# sourceMappingURL=foldingRangeManager.js.map

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class FormatManager extends manager_1.default {
    register(selector, provider, priority = 0) {
        let item = {
            id: uuid_1.v4(),
            selector,
            priority,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideDocumentFormattingEdits(document, options, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentFormattingEdits(document, options, token));
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = FormatManager;
//# sourceMappingURL=formatManager.js.map

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class FormatRangeManager extends manager_1.default {
    register(selector, provider, priority = 0) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider,
            priority
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideDocumentRangeFormattingEdits(document, range, options, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentRangeFormattingEdits(document, range, options, token));
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = FormatRangeManager;
//# sourceMappingURL=formatRangeManager.js.map

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class HoverManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideHover(document, position, token) {
        let items = this.getProviders(document);
        if (items.length === 0)
            return null;
        let res = [];
        for (let i = 0, len = items.length; i < len; i += 1) {
            const item = items[i];
            let hover = await Promise.resolve(item.provider.provideHover(document, position, token));
            if (hover && hover.contents != '')
                res.push(hover);
        }
        return res;
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = HoverManager;
//# sourceMappingURL=hoverManager.js.map

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class ImplementationManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideReferences(document, position, token) {
        let providers = this.getProviders(document);
        if (!providers.length)
            return null;
        let arr = await Promise.all(providers.map(item => {
            let { provider } = item;
            return Promise.resolve(provider.provideImplementation(document, position, token));
        }));
        return this.mergeDefinitions(arr);
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = ImplementationManager;
//# sourceMappingURL=implementationManager.js.map

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('onTypeFormatManager');
class OnTypeFormatManager {
    constructor() {
        this.providers = new Set();
    }
    register(selector, provider, triggerCharacters) {
        let item = {
            triggerCharacters,
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    hasProvider(document) {
        for (let o of this.providers) {
            let { selector } = o;
            if (workspace_1.default.match(selector, document) > 0) {
                return true;
            }
        }
        return false;
    }
    getProvider(document, triggerCharacter) {
        for (let o of this.providers) {
            let { triggerCharacters, selector } = o;
            if (workspace_1.default.match(selector, document) > 0 && triggerCharacters.includes(triggerCharacter)) {
                return o.provider;
            }
        }
        return null;
    }
    async onCharacterType(character, document, position, token) {
        if (string_1.isWord(character))
            return;
        let provider = this.getProvider(document, character);
        if (!provider)
            return;
        let formatOpts = await workspace_1.default.getFormatOptions(document.uri);
        return await Promise.resolve(provider.provideOnTypeFormattingEdits(document, position, character, formatOpts, token));
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = OnTypeFormatManager;
//# sourceMappingURL=onTypeFormatManager.js.map

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class SelectionRangeManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideSelectionRanges(document, positions, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        return (await Promise.resolve(provider.provideSelectionRanges(document, positions, token)) || []);
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = SelectionRangeManager;
//# sourceMappingURL=rangeManager.js.map

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class ReferenceManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideReferences(document, position, context, token) {
        let providers = this.getProviders(document);
        if (!providers.length)
            return null;
        let arr = await Promise.all(providers.map(item => {
            let { provider } = item;
            return Promise.resolve(provider.provideReferences(document, position, context, token));
        }));
        return this.mergeDefinitions(arr);
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = ReferenceManager;
//# sourceMappingURL=referenceManager.js.map

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class RenameManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideRenameEdits(document, position, newName, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideRenameEdits(document, position, newName, token));
    }
    async prepareRename(document, position, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let { provider } = item;
        if (provider.prepareRename == null)
            return null;
        let res = await Promise.resolve(provider.prepareRename(document, position, token));
        // can not rename
        if (res == null)
            return false;
        return res;
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = RenameManager;
//# sourceMappingURL=renameManager.js.map

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class SignatureManager extends manager_1.default {
    register(selector, provider, triggerCharacters) {
        let characters = triggerCharacters.reduce((p, c) => p.concat(c.split(/\s*/g)), []);
        let item = {
            id: uuid_1.v4(),
            selector,
            provider,
            triggerCharacters: characters
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    shouldTrigger(document, triggerCharacter) {
        let item = this.getProvider(document);
        if (!item)
            return false;
        let { triggerCharacters } = item;
        return triggerCharacters && triggerCharacters.indexOf(triggerCharacter) != -1;
    }
    async provideSignatureHelp(document, position, token) {
        let item = this.getProvider(document);
        if (!item)
            return null;
        let res = await Promise.resolve(item.provider.provideSignatureHelp(document, position, token));
        if (res && res.signatures && res.signatures.length)
            return res;
        return null;
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = SignatureManager;
//# sourceMappingURL=signatureManager.js.map

/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const manager_1 = tslib_1.__importDefault(__webpack_require__(499));
const uuid_1 = __webpack_require__(283);
class TypeDefinitionManager extends manager_1.default {
    register(selector, provider) {
        let item = {
            id: uuid_1.v4(),
            selector,
            provider
        };
        this.providers.add(item);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(item);
        });
    }
    async provideTypeDefinition(document, position, token) {
        let providers = this.getProviders(document);
        if (!providers.length)
            return null;
        let arr = await Promise.all(providers.map(item => {
            let { provider } = item;
            return Promise.resolve(provider.provideTypeDefinition(document, position, token));
        }));
        return this.mergeDefinitions(arr);
    }
    dispose() {
        this.providers = new Set();
    }
}
exports.default = TypeDefinitionManager;
//# sourceMappingURL=typeDefinitionManager.js.map

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = __webpack_require__(283);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
class WorkspaceSymbolManager {
    constructor() {
        this.providers = new Map();
    }
    register(provider) {
        let id = uuid_1.v4();
        this.providers.set(id, provider);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(id);
        });
    }
    async provideWorkspaceSymbols(_document, query, token) {
        let entries = Array.from(this.providers.entries());
        if (!entries.length)
            return [];
        let res = [];
        await Promise.all(entries.map(o => {
            let [id, p] = o;
            return Promise.resolve(p.provideWorkspaceSymbols(query, token)).then(item => {
                if (item) {
                    item.source = id;
                    res.push(...item);
                }
            });
        }));
        return res;
    }
    async resolveWorkspaceSymbol(symbolInfo, token) {
        let provider = this.providers.get(symbolInfo.source);
        if (!provider)
            return;
        if (typeof provider.resolveWorkspaceSymbol != 'function') {
            return Promise.resolve(symbolInfo);
        }
        return await Promise.resolve(provider.resolveWorkspaceSymbol(symbolInfo, token));
    }
    hasProvider() {
        return this.providers.size > 0;
    }
    dispose() {
        this.providers = new Map();
    }
}
exports.default = WorkspaceSymbolManager;
//# sourceMappingURL=workspaceSymbolsManager.js.map

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = __webpack_require__(223);
const parser_1 = __webpack_require__(329);
const string_1 = __webpack_require__(310);
const logger = __webpack_require__(64)('util-complete');
function getPosition(opt) {
    let { line, linenr, colnr } = opt;
    let part = string_1.byteSlice(line, 0, colnr - 1);
    return {
        line: linenr - 1,
        character: part.length
    };
}
exports.getPosition = getPosition;
function getWord(item, opt, invalidInsertCharacters) {
    let { label, data, insertTextFormat, insertText, textEdit } = item;
    let word;
    let newText;
    if (data && typeof data.word === 'string')
        return data.word;
    if (textEdit) {
        let { range } = textEdit;
        newText = textEdit.newText;
        if (range && range.start.line == range.end.line) {
            let { line, col, colnr } = opt;
            let character = string_1.characterIndex(line, col);
            if (range.start.character > character) {
                let before = line.slice(character - range.start.character);
                newText = before + newText;
            }
            else {
                let start = line.slice(range.start.character, character);
                if (start.length && newText.startsWith(start)) {
                    newText = newText.slice(start.length);
                }
            }
            character = string_1.characterIndex(line, colnr - 1);
            if (range.end.character > character) {
                let end = line.slice(character, range.end.character);
                if (newText.endsWith(end)) {
                    newText = newText.slice(0, -end.length);
                }
            }
        }
    }
    else {
        newText = insertText;
    }
    if (insertTextFormat == vscode_languageserver_types_1.InsertTextFormat.Snippet
        && newText
        && newText.includes('$')) {
        let parser = new parser_1.SnippetParser();
        let text = parser.text(newText);
        word = text ? getValidWord(text, invalidInsertCharacters) : label;
    }
    else {
        word = getValidWord(newText, invalidInsertCharacters) || label;
    }
    return word || '';
}
exports.getWord = getWord;
function getDocumentation(item) {
    let { documentation } = item;
    if (!documentation)
        return '';
    if (typeof documentation === 'string')
        return documentation;
    return documentation.value;
}
exports.getDocumentation = getDocumentation;
function completionKindString(kind, map, defaultValue = '') {
    return map.get(kind) || defaultValue;
}
exports.completionKindString = completionKindString;
function getSnippetDocumentation(languageId, body) {
    languageId = languageId.replace(/react$/, '');
    let str = body.replace(/\$\d+/g, '').replace(/\$\{\d+(?::([^{]+))?\}/, '$1');
    str = '``` ' + languageId + '\n' + str + '\n' + '```';
    return str;
}
exports.getSnippetDocumentation = getSnippetDocumentation;
function getValidWord(text, invalidChars) {
    if (!text)
        return '';
    for (let i = 0; i < text.length; i++) {
        let c = text[i];
        if (invalidChars.includes(c)) {
            return text.slice(0, i);
        }
    }
    return text;
}
exports.getValidWord = getValidWord;
//# sourceMappingURL=complete.js.map

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const array_1 = __webpack_require__(308);
const highlight_1 = __webpack_require__(521);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('model-floatBuffer');
class FloatBuffer {
    constructor(nvim) {
        this.nvim = nvim;
        this.lines = [];
        this.positions = [];
        this.enableHighlight = true;
        this.highlightTimeout = 500;
        let config = workspace_1.default.getConfiguration('coc.preferences');
        this.enableHighlight = config.get('enableFloatHighlight', true);
        this.highlightTimeout = config.get('highlightTimeout', 500);
    }
    async setDocuments(docs, width) {
        let fragments = this.calculateFragments(docs, width);
        let { filetype } = docs[0];
        if (!highlight_1.diagnosticFiletypes.includes(filetype)) {
            this.filetype = filetype;
        }
        if (workspace_1.default.isNvim) {
            fragments = fragments.reduce((p, c) => {
                p.push(...this.splitFragment(c, 'sh'));
                return p;
            }, []);
        }
        if (this.enableHighlight) {
            let arr = await Promise.all(fragments.map(f => highlight_1.getHiglights(f.lines, f.filetype, this.highlightTimeout).then(highlights => highlights.map(highlight => Object.assign({}, highlight, { line: highlight.line + f.start })))));
            this.highlights = arr.reduce((p, c) => p.concat(c), []);
        }
        else {
            this.highlights = [];
        }
    }
    splitFragment(fragment, defaultFileType) {
        let res = [];
        let filetype = fragment.filetype;
        let lines = [];
        let curr = fragment.start;
        let inBlock = false;
        for (let line of fragment.lines) {
            let ms = line.match(/^\s*```\s*(\w+)?/);
            if (ms != null) {
                if (lines.length) {
                    res.push({ lines, filetype: fixFiletype(filetype), start: curr - lines.length });
                    lines = [];
                }
                inBlock = !inBlock;
                filetype = inBlock ? ms[1] || defaultFileType : fragment.filetype;
            }
            else {
                lines.push(line);
                curr = curr + 1;
            }
        }
        if (lines.length) {
            res.push({ lines, filetype: fixFiletype(filetype), start: curr - lines.length });
            lines = [];
        }
        return res;
    }
    setLines(bufnr, winid) {
        let { lines, nvim, highlights } = this;
        let buffer = nvim.createBuffer(bufnr);
        nvim.call('clearmatches', winid ? [winid] : [], true);
        // vim will clear text properties
        if (workspace_1.default.isNvim)
            buffer.clearNamespace(-1, 0, -1);
        if (workspace_1.default.isNvim) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false }, true);
        }
        else {
            nvim.call('coc#util#set_buf_lines', [bufnr, lines], true);
        }
        if (highlights && highlights.length) {
            let positions = [];
            for (let highlight of highlights) {
                if (highlight.hlGroup == 'htmlBold') {
                    highlight.hlGroup = 'CocBold';
                }
                buffer.addHighlight(Object.assign({ srcId: workspace_1.default.createNameSpace('coc-float') }, highlight)).logError();
                if (highlight.isMarkdown) {
                    let line = lines[highlight.line];
                    if (line) {
                        let si = string_1.characterIndex(line, highlight.colStart);
                        let ei = string_1.characterIndex(line, highlight.colEnd) - 1;
                        let before = line[si];
                        let after = line[ei];
                        if (before == after && ['_', '`', '*'].includes(before)) {
                            if (before == '_' && line[si + 1] == '_' && line[ei - 1] == '_' && si + 1 < ei - 1) {
                                positions.push([highlight.line + 1, highlight.colStart + 1, 2]);
                                positions.push([highlight.line + 1, highlight.colEnd - 1, 2]);
                            }
                            else {
                                positions.push([highlight.line + 1, highlight.colStart + 1]);
                                positions.push([highlight.line + 1, highlight.colEnd]);
                            }
                        }
                        if (highlight.colEnd - highlight.colStart == 2 && before == '\\') {
                            positions.push([highlight.line + 1, highlight.colStart + 1]);
                        }
                    }
                }
            }
            for (let arr of array_1.group(positions, 8)) {
                if (winid) {
                    nvim.call('win_execute', [winid, `call matchaddpos('Conceal', ${JSON.stringify(arr)},11)`], true);
                }
                else {
                    nvim.call('matchaddpos', ['Conceal', arr, 11], true);
                }
            }
        }
        for (let arr of array_1.group(this.positions || [], 8)) {
            arr = arr.filter(o => o[2] != 0);
            if (arr.length) {
                if (winid) {
                    nvim.call('win_execute', [winid, `call matchaddpos('CocUnderline', ${JSON.stringify(arr)},12)`], true);
                }
                else {
                    nvim.call('matchaddpos', ['CocUnderline', arr, 12], true);
                }
            }
        }
        if (winid && this.enableHighlight && this.filetype) {
            nvim.call('win_execute', [winid, `runtime! syntax/${this.filetype}.vim`], true);
        }
    }
    calculateFragments(docs, width) {
        let fragments = [];
        let idx = 0;
        let currLine = 0;
        let newLines = [];
        let positions = this.positions = [];
        for (let doc of docs) {
            let lines = [];
            let arr = doc.content.split(/\r?\n/);
            for (let str of arr) {
                if (doc.filetype == 'markdown') {
                    // replace `\` surrounded by `__` because bug of markdown highlight in vim.
                    str = str.replace(/__(.+?)__/g, (_, p1) => {
                        return `__${p1.replace(/\\_/g, '_').replace(/\\\\/g, '\\')}__`;
                    });
                }
                lines.push(str);
                if (doc.active) {
                    let part = str.slice(doc.active[0], doc.active[1]);
                    positions.push([currLine + 1, doc.active[0] + 1, string_1.byteLength(part)]);
                }
            }
            fragments.push({
                start: currLine,
                lines,
                filetype: doc.filetype
            });
            let filtered = workspace_1.default.isNvim && doc.filetype === 'markdown' ? lines.filter(s => !/^\s*```/.test(s)) : lines;
            newLines.push(...filtered);
            if (idx != docs.length - 1) {
                newLines.push('—'.repeat(width - 2));
                currLine = newLines.length;
            }
            idx = idx + 1;
        }
        this.lines = newLines;
        return fragments;
    }
    static getDimension(docs, maxWidth, maxHeight) {
        // width contains padding
        if (maxWidth <= 2 || maxHeight == 0)
            return { width: 0, height: 0 };
        let arr = [];
        for (let doc of docs) {
            let lines = doc.content.split(/\r?\n/);
            for (let line of lines) {
                if (workspace_1.default.isNvim && doc.filetype == 'markdown' && /^\s*```/.test(line)) {
                    continue;
                }
                arr.push(string_1.byteLength(line.replace(/\t/g, '  ')) + 2);
            }
        }
        let width = Math.min(Math.max(...arr), maxWidth);
        if (width <= 2)
            return { width: 0, height: 0 };
        let height = docs.length - 1;
        for (let w of arr) {
            height = height + Math.max(Math.ceil((w - 2) / (width - 2)), 1);
        }
        return { width, height: Math.min(height, maxHeight) };
    }
}
exports.default = FloatBuffer;
function fixFiletype(filetype) {
    if (filetype == 'ts')
        return 'typescript';
    if (filetype == 'js')
        return 'javascript';
    if (filetype == 'bash')
        return 'sh';
    return filetype;
}
//# sourceMappingURL=floatBuffer.js.map

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const neovim_1 = __webpack_require__(155);
const cp = tslib_1.__importStar(__webpack_require__(239));
const crypto_1 = __webpack_require__(221);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const os_1 = tslib_1.__importDefault(__webpack_require__(76));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const uuid_1 = __webpack_require__(283);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const lodash_1 = __webpack_require__(494);
const processes_1 = __webpack_require__(522);
const string_1 = __webpack_require__(310);
const logger = __webpack_require__(64)('util-highlights');
exports.diagnosticFiletypes = ['Error', 'Warning', 'Info', 'Hint'];
const cache = {};
let env = null;
// get highlights by send text to another neovim instance.
function getHiglights(lines, filetype, timeout = 500) {
    const hlMap = new Map();
    const content = lines.join('\n');
    if (exports.diagnosticFiletypes.includes(filetype)) {
        let highlights = lines.map((line, i) => ({
            line: i,
            colStart: 0,
            colEnd: string_1.byteLength(line),
            hlGroup: `Coc${filetype}Float`
        }));
        return Promise.resolve(highlights);
    }
    if (filetype == 'javascriptreact') {
        filetype = 'javascript';
    }
    if (filetype == 'typescriptreact') {
        filetype = 'typescript';
    }
    let maxBytes = lines.reduce((p, c) => Math.max(p, string_1.byteLength(c)), 0);
    const id = crypto_1.createHash('md5').update(content).digest('hex');
    if (cache[id])
        return Promise.resolve(cache[id]);
    if (workspace_1.default.env.isVim)
        return Promise.resolve([]);
    const res = [];
    let nvim;
    return new Promise(async (resolve) => {
        if (!env) {
            env = await workspace_1.default.nvim.call('coc#util#highlight_options');
            if (!env)
                resolve([]);
            let paths = env.runtimepath.split(',');
            let dirs = paths.filter(p => {
                if (env.colorscheme) {
                    let schemeFile = path_1.default.join(p, `colors/${env.colorscheme}.vim`);
                    if (fs_1.default.existsSync(schemeFile))
                        return true;
                }
                if (fs_1.default.existsSync(path_1.default.join(p, 'syntax')))
                    return true;
                if (fs_1.default.existsSync(path_1.default.join(p, 'after/syntax')))
                    return true;
                return false;
            });
            env.runtimepath = dirs.join(',');
        }
        let prog = workspace_1.default.env.progpath || 'nvim';
        let proc = cp.spawn(prog, ['-u', 'NORC', '-i', 'NONE', '--embed', '--noplugin', uuid_1.v4()], {
            shell: false,
            cwd: os_1.default.tmpdir(),
            env: lodash_1.omit(process.env, ['NVIM_LISTEN_ADDRESS', 'VIM_NODE_RPC'])
        });
        proc.on('error', error => {
            logger.info('highlight error:', error);
            resolve([]);
        });
        let timer;
        let exited = false;
        const exit = () => {
            if (exited)
                return;
            exited = true;
            if (timer)
                clearTimeout(timer);
            if (nvim) {
                nvim.command('qa!').catch(() => {
                    let killed = processes_1.terminate(proc);
                    if (!killed) {
                        setTimeout(() => {
                            processes_1.terminate(proc);
                        }, 50);
                    }
                });
            }
        };
        try {
            proc.once('exit', () => {
                if (exited)
                    return;
                logger.info('highlight nvim exited.');
                resolve([]);
            });
            timer = setTimeout(() => {
                exit();
                resolve([]);
            }, timeout);
            nvim = neovim_1.attach({ proc }, null, false);
            const callback = (method, args) => {
                if (method == 'redraw') {
                    for (let arr of args) {
                        let [name, ...list] = arr;
                        if (name == 'hl_attr_define') {
                            for (let item of list) {
                                let id = item[0];
                                let { hi_name } = item[item.length - 1][0];
                                hlMap.set(id, hi_name);
                            }
                        }
                        if (name == 'grid_line') {
                            // logger.debug('list:', JSON.stringify(list, null, 2))
                            for (let def of list) {
                                let [, line, col, cells] = def;
                                if (line >= lines.length)
                                    continue;
                                let colStart = 0;
                                let hlGroup = '';
                                let currId = 0;
                                for (let i = 0; i < cells.length; i++) {
                                    let cell = cells[i];
                                    let [ch, hlId, repeat] = cell;
                                    repeat = repeat || 1;
                                    let len = string_1.byteLength(ch.repeat(repeat));
                                    // append result
                                    if (hlId == 0 || (hlId > 0 && hlId != currId)) {
                                        if (hlGroup) {
                                            res.push({
                                                line,
                                                hlGroup,
                                                colStart,
                                                colEnd: col,
                                                isMarkdown: filetype == 'markdown'
                                            });
                                        }
                                        colStart = col;
                                        hlGroup = hlId == 0 ? '' : hlMap.get(hlId);
                                    }
                                    if (hlId != null)
                                        currId = hlId;
                                    col = col + len;
                                }
                                if (hlGroup) {
                                    res.push({
                                        hlGroup,
                                        line,
                                        colStart,
                                        colEnd: col,
                                        isMarkdown: filetype == 'markdown'
                                    });
                                }
                            }
                            cache[id] = res;
                            exit();
                            resolve(res);
                        }
                    }
                }
            };
            nvim.on('notification', callback);
            await nvim.callAtomic([
                ['nvim_set_option', ['runtimepath', env.runtimepath]],
                ['nvim_command', [`highlight! link Normal CocFloating`]],
                ['nvim_command', ['syntax enable']],
                ['nvim_command', [`colorscheme ${env.colorscheme || 'default'}`]],
                ['nvim_command', [`set background=${env.background}`]],
                ['nvim_command', ['set nowrap']],
                ['nvim_command', ['set noswapfile']],
                ['nvim_command', ['set nobackup']],
                ['nvim_command', ['set noshowmode']],
                ['nvim_command', ['set noruler']],
                ['nvim_command', ['set undolevels=-1']],
                ['nvim_command', ['set laststatus=0']],
                ...lines.map((line, idx) => ['nvim_call_function', ['setline', [idx + 1, line]]]),
                ['nvim_command', [`runtime! syntax/${filetype}.vim`]]
            ]);
            await nvim.uiAttach(maxBytes + 10, lines.length + 1, {
                ext_hlstate: true,
                ext_linegrid: true
            });
        }
        catch (e) {
            logger.error(e);
            exit();
            resolve([]);
        }
    });
}
exports.getHiglights = getHiglights;
//# sourceMappingURL=highlight.js.map

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const cp = tslib_1.__importStar(__webpack_require__(239));
const path_1 = __webpack_require__(82);
const isWebpack = typeof __webpack_require__ === "function";
const isWindows = process.platform === 'win32';
const isMacintosh = process.platform === 'darwin';
const isLinux = process.platform === 'linux';
const pluginRoot = isWebpack ? path_1.dirname(__dirname) : path_1.resolve(__dirname, '../..');
function terminate(process, cwd) {
    if (isWindows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd) {
                options.cwd = cwd;
            }
            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (isLinux || isMacintosh) {
        try {
            let cmd = path_1.join(pluginRoot, 'bin/terminateProcess.sh');
            let result = cp.spawnSync(cmd, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;
//# sourceMappingURL=processes.js.map

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ansiparse_1 = __webpack_require__(524);
const string_1 = __webpack_require__(310);
/**
 * Build highlights, with lines and highlights
 */
class Highlighter {
    constructor(srcId = -1) {
        this.srcId = srcId;
        this.lines = [];
        this.highlights = [];
    }
    addLine(line, hlGroup) {
        if (line.includes('\n')) {
            for (let content of line.split(/\r?\n/)) {
                this.addLine(content, hlGroup);
            }
            return;
        }
        if (hlGroup) {
            this.highlights.push({
                line: this.lines.length,
                colStart: line.match(/^\s*/)[0].length,
                colEnd: string_1.byteLength(line),
                hlGroup
            });
        } // '\x1b'
        if (line.includes('\x1b')) {
            let res = ansiparse_1.parseAnsiHighlights(line);
            for (let hl of res.highlights) {
                let { span, hlGroup } = hl;
                if (span[0] != span[1]) {
                    this.highlights.push({
                        line: this.lines.length,
                        colStart: span[0],
                        colEnd: span[1],
                        hlGroup
                    });
                }
            }
            this.lines.push(res.line);
        }
        else {
            this.lines.push(line);
        }
    }
    addLines(lines) {
        this.lines.push(...lines);
    }
    addText(text, hlGroup) {
        let { lines } = this;
        let pre = lines[lines.length - 1] || '';
        if (hlGroup) {
            let colStart = string_1.byteLength(pre);
            this.highlights.push({
                line: lines.length ? lines.length - 1 : 0,
                colStart,
                colEnd: colStart + string_1.byteLength(text),
                hlGroup
            });
        }
        if (lines.length) {
            lines[lines.length - 1] = `${pre}${text}`;
        }
        else {
            lines.push(text);
        }
    }
    get length() {
        return this.lines.length;
    }
    getline(line) {
        return this.lines[line] || '';
    }
    // default to replace
    render(buffer, start = 0, end = -1) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        buffer.setLines(this.lines, { start, end, strictIndexing: false }, true);
        for (let item of this.highlights) {
            buffer.addHighlight({
                hlGroup: item.hlGroup,
                colStart: item.colStart,
                colEnd: item.colEnd == null ? -1 : item.colEnd,
                line: start + item.line,
                srcId: this.srcId
            }).logError();
        }
    }
}
exports.default = Highlighter;
//# sourceMappingURL=highligher.js.map

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const string_1 = __webpack_require__(310);
const foregroundColors = {
    30: 'black',
    31: 'red',
    32: 'green',
    33: 'yellow',
    34: 'blue',
    35: 'magenta',
    36: 'cyan',
    37: 'white',
    90: 'grey'
};
const backgroundColors = {
    40: 'black',
    41: 'red',
    42: 'green',
    43: 'yellow',
    44: 'blue',
    45: 'magenta',
    46: 'cyan',
    47: 'white'
};
const styles = {
    1: 'bold',
    3: 'italic',
    4: 'underline'
};
function parseAnsiHighlights(line) {
    let items = ansiparse(line);
    let highlights = [];
    let newLabel = '';
    for (let item of items) {
        if (!item.text)
            continue;
        let { foreground, background } = item;
        let len = string_1.byteLength(newLabel);
        if (foreground || background) {
            let span = [len, len + string_1.byteLength(item.text)];
            let hlGroup = '';
            if (foreground && background) {
                hlGroup = `CocList${string_1.upperFirst(foreground)}${string_1.upperFirst(background)}`;
            }
            else if (foreground) {
                hlGroup = `CocListFg${string_1.upperFirst(foreground)}`;
            }
            else if (background) {
                hlGroup = `CocListBg${string_1.upperFirst(background)}`;
            }
            highlights.push({ span, hlGroup });
        }
        newLabel = newLabel + item.text;
    }
    return { line: newLabel, highlights };
}
exports.parseAnsiHighlights = parseAnsiHighlights;
function ansiparse(str) {
    //
    // I'm terrible at writing parsers.
    //
    let matchingControl = null;
    let matchingData = null;
    let matchingText = '';
    let ansiState = [];
    let result = [];
    let state = {};
    let eraseChar;
    //
    // General workflow for this thing is:
    // \033\[33mText
    // |     |  |
    // |     |  matchingText
    // |     matchingData
    // matchingControl
    //
    // \033\[K or \033\[m
    //
    // In further steps we hope it's all going to be fine. It usually is.
    //
    //
    // Erases a char from the output
    //
    eraseChar = () => {
        let index;
        let text;
        if (matchingText.length) {
            matchingText = matchingText.substr(0, matchingText.length - 1);
        }
        else if (result.length) {
            index = result.length - 1;
            text = result[index].text;
            if (text.length === 1) {
                //
                // A result bit was fully deleted, pop it out to simplify the final output
                //
                result.pop();
            }
            else {
                result[index].text = text.substr(0, text.length - 1);
            }
        }
    };
    for (let i = 0; i < str.length; i++) {
        if (matchingControl != null) {
            if (matchingControl == '\x1b' && str[i] == '[') {
                //
                // We've matched full control code. Lets start matching formating data.
                //
                //
                // "emit" matched text with correct state
                //
                if (matchingText) {
                    state.text = matchingText;
                    result.push(state);
                    state = {};
                    matchingText = '';
                }
                if (matchingText == '' && (str[i + 1] == 'm' || str[i + 1] == 'K')) {
                    if (state.foreground || state.background) {
                        state.text = '';
                        result.push(state);
                    }
                    state = {};
                }
                matchingControl = null;
                matchingData = '';
            }
            else {
                //
                // We failed to match anything - most likely a bad control code. We
                // go back to matching regular strings.
                //
                matchingText += matchingControl + str[i];
                matchingControl = null;
            }
            continue;
        }
        else if (matchingData != null) {
            if (str[i] == ';') {
                //
                // `;` separates many formatting codes, for example: `\033[33;43m`
                // means that both `33` and `43` should be applied.
                //
                // TODO: this can be simplified by modifying state here.
                //
                ansiState.push(matchingData);
                matchingData = '';
            }
            else if (str[i] == 'm' || str[i] == 'K') {
                //
                // `m` finished whole formatting code. We can proceed to matching
                // formatted text.
                //
                ansiState.push(matchingData);
                matchingData = null;
                matchingText = '';
                //
                // Convert matched formatting data into user-friendly state object.
                //
                // TODO: DRY.
                //
                ansiState.forEach(ansiCode => {
                    if (foregroundColors[ansiCode]) {
                        state.foreground = foregroundColors[ansiCode];
                    }
                    else if (backgroundColors[ansiCode]) {
                        state.background = backgroundColors[ansiCode];
                    }
                    else if (ansiCode == 39) {
                        delete state.foreground;
                    }
                    else if (ansiCode == 49) {
                        delete state.background;
                    }
                    else if (styles[ansiCode]) {
                        state[styles[ansiCode]] = true;
                    }
                    else if (ansiCode == 22) {
                        state.bold = false;
                    }
                    else if (ansiCode == 23) {
                        state.italic = false;
                    }
                    else if (ansiCode == 24) {
                        state.underline = false;
                    }
                });
                ansiState = [];
            }
            else {
                matchingData += str[i];
            }
            continue;
        }
        if (str[i] == '\x1b') {
            matchingControl = str[i];
        }
        else if (str[i] == '\u0008') {
            eraseChar();
        }
        else {
            matchingText += str[i];
        }
    }
    if (matchingText) {
        state.text = matchingText + (matchingControl ? matchingControl : '');
        result.push(state);
    }
    return result;
}
exports.ansiparse = ansiparse;
//# sourceMappingURL=ansiparse.js.map

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const events_1 = __webpack_require__(198);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const net_1 = tslib_1.__importDefault(__webpack_require__(157));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const language_client_1 = __webpack_require__(526);
const types_1 = __webpack_require__(295);
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('services');
function getStateName(state) {
    switch (state) {
        case types_1.ServiceStat.Initial:
            return 'init';
        case types_1.ServiceStat.Running:
            return 'running';
        case types_1.ServiceStat.Starting:
            return 'starting';
        case types_1.ServiceStat.StartFailed:
            return 'startFailed';
        case types_1.ServiceStat.Stopping:
            return 'stopping';
        case types_1.ServiceStat.Stopped:
            return 'stopped';
        default:
            return 'unknown';
    }
}
exports.getStateName = getStateName;
class ServiceManager extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.registered = new Map();
        this.disposables = [];
    }
    init() {
        workspace_1.default.onDidOpenTextDocument(document => {
            this.start(document);
        }, null, this.disposables);
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('languageserver')) {
                this.createCustomServices();
            }
        }, null, this.disposables);
        this.createCustomServices();
    }
    dispose() {
        this.removeAllListeners();
        util_1.disposeAll(this.disposables);
        for (let service of this.registered.values()) {
            service.dispose();
        }
    }
    regist(service) {
        let { id } = service;
        if (!id)
            logger.error('invalid service configuration. ', service.name);
        if (this.registered.get(id))
            return;
        this.registered.set(id, service);
        logger.info(`registered service "${id}"`);
        if (this.shouldStart(service)) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            service.start();
        }
        if (service.state == types_1.ServiceStat.Running) {
            this.emit('ready', id);
        }
        service.onServiceReady(() => {
            logger.info(`service ${id} started`);
            this.emit('ready', id);
        }, null, this.disposables);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            service.stop();
            service.dispose();
            this.registered.delete(id);
        });
    }
    getService(id) {
        let service = this.registered.get(id);
        if (!service)
            service = this.registered.get(`languageserver.${id}`);
        return service;
    }
    shouldStart(service) {
        if (service.state != types_1.ServiceStat.Initial) {
            return false;
        }
        let selector = service.selector;
        for (let doc of workspace_1.default.documents) {
            if (workspace_1.default.match(selector, doc.textDocument)) {
                return true;
            }
        }
        return false;
    }
    start(document) {
        let services = this.getServices(document);
        for (let service of services) {
            if (service.state == types_1.ServiceStat.Initial) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                service.start();
            }
        }
    }
    getServices(document) {
        let res = [];
        for (let service of this.registered.values()) {
            if (workspace_1.default.match(service.selector, document) > 0) {
                res.push(service);
            }
        }
        return res;
    }
    stop(id) {
        let service = this.registered.get(id);
        if (!service) {
            workspace_1.default.showMessage(`Service ${id} not found`, 'error');
            return;
        }
        return Promise.resolve(service.stop());
    }
    stopAll() {
        for (let service of this.registered.values()) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            service.stop();
        }
    }
    async toggle(id) {
        let service = this.registered.get(id);
        if (!service) {
            workspace_1.default.showMessage(`Service ${id} not found`, 'error');
            return;
        }
        let { state } = service;
        try {
            if (state == types_1.ServiceStat.Running) {
                await Promise.resolve(service.stop());
            }
            else if (state == types_1.ServiceStat.Initial) {
                await service.start();
            }
            else if (state == types_1.ServiceStat.Stopped) {
                await service.restart();
            }
        }
        catch (e) {
            workspace_1.default.showMessage(`Service error: ${e.message}`, 'error');
        }
    }
    getServiceStats() {
        let res = [];
        for (let [id, service] of this.registered) {
            res.push({
                id,
                languageIds: documentSelectorToLanguageIds(service.selector),
                state: getStateName(service.state)
            });
        }
        return res;
    }
    createCustomServices() {
        let lspConfig = workspace_1.default.getConfiguration().get('languageserver', {});
        for (let key of Object.keys(lspConfig)) {
            let config = lspConfig[key];
            this.registLanguageClient(key, config);
        }
    }
    waitClient(id) {
        let service = this.getService(id);
        if (service && service.state == types_1.ServiceStat.Running)
            return Promise.resolve();
        if (service)
            return new Promise(resolve => {
                service.onServiceReady(() => {
                    resolve();
                });
            });
        return new Promise(resolve => {
            let listener = clientId => {
                if (clientId == id || clientId == `languageserver.${id}`) {
                    this.off('ready', listener);
                    resolve();
                }
            };
            this.on('ready', listener);
        });
    }
    async registNotification(id, method) {
        await this.waitClient(id);
        let service = this.getService(id);
        if (!service.client) {
            workspace_1.default.showMessage(`Not a language client: ${id}`, 'error');
            return;
        }
        let client = service.client;
        client.onNotification(method, async (result) => {
            await workspace_1.default.nvim.call('coc#do_notify', [id, method, result]);
        });
    }
    async sendNotification(id, method, params) {
        if (!method)
            throw new Error(`method required for ontification`);
        let service = this.getService(id);
        // wait for extension activate
        if (!service || !service.client)
            throw new Error(`Language server ${id} not found`);
        if (service.state == types_1.ServiceStat.Starting) {
            await service.client.onReady();
        }
        if (service.state != types_1.ServiceStat.Running) {
            throw new Error(`Language server ${id} not running`);
        }
        await Promise.resolve(service.client.sendNotification(method, params));
    }
    async sendRequest(id, method, params) {
        if (!method)
            throw new Error(`method required for sendRequest`);
        let service = this.getService(id);
        // wait for extension activate
        if (!service)
            await util_1.wait(100);
        service = this.getService(id);
        if (!service || !service.client) {
            throw new Error(`Language server ${id} not found`);
        }
        if (service.state == types_1.ServiceStat.Starting) {
            await service.client.onReady();
        }
        if (service.state != types_1.ServiceStat.Running) {
            throw new Error(`Language server ${id} not running`);
        }
        return await Promise.resolve(service.client.sendRequest(method, params));
    }
    registLanguageClient(name, config) {
        let id = typeof name === 'string' ? `languageserver.${name}` : name.id;
        let disposables = [];
        let onDidServiceReady = new vscode_languageserver_protocol_1.Emitter();
        let client = typeof name === 'string' ? null : name;
        if (this.registered.has(id))
            return;
        let created = false;
        let service = {
            id,
            client,
            name: typeof name === 'string' ? name : name.name,
            selector: typeof name === 'string' ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name.clientOptions.documentSelector,
            state: types_1.ServiceStat.Initial,
            onServiceReady: onDidServiceReady.event,
            start: () => {
                if (service.state == types_1.ServiceStat.Starting || service.state == types_1.ServiceStat.Running) {
                    return;
                }
                if (client && !client.needsStart()) {
                    return;
                }
                if (created && client) {
                    client.restart();
                    return Promise.resolve();
                }
                if (!created) {
                    if (typeof name == 'string' && !client) {
                        let config = workspace_1.default.getConfiguration().get('languageserver', {})[name];
                        if (!config || config.enable === false)
                            return;
                        let opts = getLanguageServerOptions(id, name, config);
                        if (!opts)
                            return;
                        client = new language_client_1.LanguageClient(id, name, opts[1], opts[0]);
                        service.selector = opts[0].documentSelector;
                        service.client = client;
                    }
                    client.onDidChangeState(changeEvent => {
                        let { oldState, newState } = changeEvent;
                        if (newState == language_client_1.State.Starting) {
                            service.state = types_1.ServiceStat.Starting;
                        }
                        else if (newState == language_client_1.State.Running) {
                            service.state = types_1.ServiceStat.Running;
                        }
                        else if (newState == language_client_1.State.Stopped) {
                            service.state = types_1.ServiceStat.Stopped;
                        }
                        let oldStr = stateString(oldState);
                        let newStr = stateString(newState);
                        logger.info(`${client.name} state change: ${oldStr} => ${newStr}`);
                    }, null, disposables);
                    created = true;
                }
                service.state = types_1.ServiceStat.Starting;
                logger.debug(`starting service: ${id}`);
                let disposable = client.start();
                disposables.push(disposable);
                return new Promise(resolve => {
                    client.onReady().then(() => {
                        onDidServiceReady.fire(void 0);
                        resolve();
                    }, e => {
                        workspace_1.default.showMessage(`Server ${id} failed to start: ${e}`, 'error');
                        logger.error(`Server ${id} failed to start:`, e);
                        service.state = types_1.ServiceStat.StartFailed;
                        resolve();
                    });
                });
            },
            dispose: async () => {
                onDidServiceReady.dispose();
                util_1.disposeAll(disposables);
            },
            stop: async () => {
                if (!client || !client.needsStop())
                    return;
                await Promise.resolve(client.stop());
            },
            restart: async () => {
                if (client) {
                    service.state = types_1.ServiceStat.Starting;
                    client.restart();
                }
                else {
                    await service.start();
                }
            },
        };
        return this.regist(service);
    }
}
exports.ServiceManager = ServiceManager;
function documentSelectorToLanguageIds(documentSelector) {
    let res = documentSelector.map(filter => {
        if (typeof filter == 'string') {
            return filter;
        }
        return filter.language;
    });
    res = res.filter(s => typeof s == 'string');
    return Array.from(new Set(res));
}
exports.documentSelectorToLanguageIds = documentSelectorToLanguageIds;
// convert config to options
function getLanguageServerOptions(id, name, config) {
    let { command, module, port, args, filetypes } = config;
    args = args || [];
    if (!filetypes) {
        workspace_1.default.showMessage(`Wrong configuration of LS "${name}", filetypes not found`, 'error');
        return null;
    }
    if (!command && !module && !port) {
        workspace_1.default.showMessage(`Wrong configuration of LS "${name}", no command or module specified.`, 'error');
        return null;
    }
    let serverOptions;
    if (module) {
        module = workspace_1.default.expand(module);
        if (!fs_1.default.existsSync(module)) {
            workspace_1.default.showMessage(`Module file "${module}" not found for LS "${name}"`, 'error');
            return null;
        }
        serverOptions = {
            module,
            runtime: config.runtime || process.execPath,
            args,
            transport: getTransportKind(config),
            options: getForkOptions(config)
        };
    }
    else if (command) {
        serverOptions = {
            command,
            args,
            options: getSpawnOptions(config)
        };
    }
    else if (port) {
        serverOptions = () => new Promise((resolve, reject) => {
            let client = new net_1.default.Socket();
            let host = config.host || '127.0.0.1';
            logger.info(`languageserver "${id}" connecting to ${host}:${port}`);
            client.connect(port, host, () => {
                resolve({
                    reader: client,
                    writer: client
                });
            });
            client.on('error', e => {
                reject(new Error(`Connection error for ${id}: ${e.message}`));
            });
        });
    }
    let disableWorkspaceFolders = !!config.disableWorkspaceFolders;
    let disableSnippetCompletion = !!config.disableSnippetCompletion;
    let ignoredRootPaths = config.ignoredRootPaths || [];
    let clientOptions = {
        ignoredRootPaths: ignoredRootPaths.map(s => workspace_1.default.expand(s)),
        disableWorkspaceFolders,
        disableSnippetCompletion,
        disableDynamicRegister: !!config.disableDynamicRegister,
        disableCompletion: !!config.disableCompletion,
        disableDiagnostics: !!config.disableDiagnostics,
        formatterPriority: config.formatterPriority || 0,
        documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),
        revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),
        synchronize: {
            configurationSection: `${id}.settings`
        },
        diagnosticCollectionName: name,
        outputChannelName: id,
        stdioEncoding: config.stdioEncoding || 'utf8',
        progressOnInitialization: config.progressOnInitialization !== false,
        initializationOptions: config.initializationOptions || {}
    };
    return [clientOptions, serverOptions];
}
exports.getLanguageServerOptions = getLanguageServerOptions;
function getRevealOutputChannelOn(revealOn) {
    switch (revealOn) {
        case 'info':
            return language_client_1.RevealOutputChannelOn.Info;
        case 'warn':
            return language_client_1.RevealOutputChannelOn.Warn;
        case 'error':
            return language_client_1.RevealOutputChannelOn.Error;
        case 'never':
            return language_client_1.RevealOutputChannelOn.Never;
        default:
            return language_client_1.RevealOutputChannelOn.Never;
    }
}
exports.getRevealOutputChannelOn = getRevealOutputChannelOn;
function getDocumentSelector(filetypes, additionalSchemes) {
    let documentSelector = [];
    let schemes = ['file', 'untitled'].concat(additionalSchemes || []);
    if (!filetypes)
        return schemes.map(s => ({ scheme: s }));
    filetypes.forEach(filetype => {
        documentSelector.push(...schemes.map(scheme => ({ language: filetype, scheme })));
    });
    return documentSelector;
}
exports.getDocumentSelector = getDocumentSelector;
function getTransportKind(config) {
    let { transport, transportPort } = config;
    if (!transport || transport == 'ipc')
        return language_client_1.TransportKind.ipc;
    if (transport == 'stdio')
        return language_client_1.TransportKind.stdio;
    if (transport == 'pipe')
        return language_client_1.TransportKind.pipe;
    return { kind: language_client_1.TransportKind.socket, port: transportPort };
}
exports.getTransportKind = getTransportKind;
function getForkOptions(config) {
    return {
        cwd: config.cwd,
        execArgv: config.execArgv || [],
        env: config.env || undefined
    };
}
function getSpawnOptions(config) {
    return {
        cwd: config.cwd,
        detached: !!config.detached,
        shell: !!config.shell,
        env: config.env || undefined
    };
}
function stateString(state) {
    switch (state) {
        case language_client_1.State.Running:
            return 'running';
        case language_client_1.State.Starting:
            return 'starting';
        case language_client_1.State.Stopped:
            return 'stopped';
        default:
            return 'unknown';
    }
}
exports.default = new ServiceManager();
//# sourceMappingURL=services.js.map

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
/* eslint-disable no-redeclare */
const child_process_1 = tslib_1.__importDefault(__webpack_require__(239));
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const types_1 = __webpack_require__(295);
const util_1 = __webpack_require__(238);
const Is = tslib_1.__importStar(__webpack_require__(250));
const processes_1 = __webpack_require__(522);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const client_1 = __webpack_require__(527);
const colorProvider_1 = __webpack_require__(532);
const configuration_1 = __webpack_require__(533);
const declaration_1 = __webpack_require__(534);
const foldingRange_1 = __webpack_require__(535);
const implementation_1 = __webpack_require__(536);
const progress_1 = __webpack_require__(537);
const typeDefinition_1 = __webpack_require__(538);
const workspaceFolders_1 = __webpack_require__(539);
const selectionRange_1 = __webpack_require__(540);
const logger = __webpack_require__(64)('language-client-index');
tslib_1.__exportStar(__webpack_require__(527), exports);
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        let candidate = value;
        return (candidate &&
            candidate.kind === TransportKind.socket &&
            Is.number(candidate.port));
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return (candidate && candidate.writer !== void 0 && candidate.reader !== void 0);
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return (candidate &&
            candidate.process !== void 0 &&
            typeof candidate.detached === 'boolean');
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends client_1.BaseLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            // first signature
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === void 0) {
            forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this.registerProposedFeatures();
    }
    stop() {
        return super.stop().then(() => {
            if (this._serverProcess) {
                let toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === void 0 || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        });
    }
    get serviceState() {
        let state = this._state;
        switch (state) {
            case client_1.ClientState.Initial:
                return types_1.ServiceStat.Initial;
            case client_1.ClientState.Running:
                return types_1.ServiceStat.Running;
            case client_1.ClientState.StartFailed:
                return types_1.ServiceStat.StartFailed;
            case client_1.ClientState.Starting:
                return types_1.ServiceStat.Starting;
            case client_1.ClientState.Stopped:
                return types_1.ServiceStat.Stopped;
            case client_1.ClientState.Stopping:
                return types_1.ServiceStat.Stopping;
            default:
                logger.error(`Unknown state: ${state}`);
                return types_1.ServiceStat.Stopped;
        }
    }
    static stateName(state) {
        switch (state) {
            case client_1.ClientState.Initial:
                return 'Initial';
            case client_1.ClientState.Running:
                return 'Running';
            case client_1.ClientState.StartFailed:
                return 'StartFailed';
            case client_1.ClientState.Starting:
                return 'Starting';
            case client_1.ClientState.Stopped:
                return 'Stopped';
            case client_1.ClientState.Stopping:
                return 'Stopping';
            default:
                return 'Unknonw';
        }
    }
    checkProcessDied(childProcess) {
        if (!childProcess || global.hasOwnProperty('__TEST__'))
            return;
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
                // All is fine.
            }
        }, 1000);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        super.handleConnectionClosed();
    }
    createMessageTransports(encoding) {
        function getEnvironment(env) {
            if (!env)
                return process.env;
            return Object.assign({}, process.env, env);
        }
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some(arg => /^--debug=?/.test(arg) ||
                    /^--debug-brk=?/.test(arg) ||
                    /^--inspect=?/.test(arg) ||
                    /^--inspect-brk=?/.test(arg));
            }
            return false;
        }
        let server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then(result => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return {
                        reader: new vscode_languageserver_protocol_1.StreamMessageReader(result.reader),
                        writer: new vscode_languageserver_protocol_1.StreamMessageWriter(result.writer)
                    };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', data => this.appendOutput(data, encoding));
                    return {
                        reader: new vscode_languageserver_protocol_1.StreamMessageReader(cp.stdout),
                        writer: new vscode_languageserver_protocol_1.StreamMessageWriter(cp.stdin)
                    };
                }
            });
        }
        let json = server;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            // We are under debugging. So use debug as well.
            if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                let args = [];
                let options = node.options || Object.create(null);
                let runtime = node.runtime || process.execPath;
                if (options.execArgv)
                    options.execArgv.forEach(element => args.push(element));
                if (transport != TransportKind.ipc)
                    args.push(node.module);
                if (node.args)
                    node.args.forEach(element => args.push(element));
                let execOptions = Object.create(null);
                execOptions.cwd = serverWorkingDir;
                execOptions.env = getEnvironment(options.env);
                let pipeName;
                if (transport === TransportKind.ipc) {
                    execOptions.stdio = [null, null, null];
                    args.push('--node-ipc');
                }
                else if (transport === TransportKind.stdio) {
                    args.push('--stdio');
                }
                else if (transport === TransportKind.pipe) {
                    pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();
                    args.push(`--pipe=${pipeName}`);
                }
                else if (Transport.isSocket(transport)) {
                    args.push(`--socket=${transport.port}`);
                }
                args.push(`--clientProcessId=${process.pid.toString()}`);
                if (transport === TransportKind.ipc) {
                    let forkOptions = {
                        cwd: serverWorkingDir,
                        env: getEnvironment(options.env),
                        stdio: [null, null, null, 'ipc'],
                        execPath: runtime,
                        execArgv: options.execArgv || [],
                    };
                    let serverProcess = child_process_1.default.fork(node.module, args, forkOptions);
                    if (!serverProcess || !serverProcess.pid) {
                        return Promise.reject(`Launching server module "${node.module}" failed.`);
                    }
                    serverProcess.on('error', e => {
                        logger.error(e);
                    });
                    logger.info(`${this.id} started with ${serverProcess.pid}`);
                    this._serverProcess = serverProcess;
                    serverProcess.stdout.on('data', data => this.appendOutput(data, encoding));
                    serverProcess.stderr.on('data', data => this.appendOutput(data, encoding));
                    return {
                        reader: new vscode_languageserver_protocol_1.IPCMessageReader(serverProcess),
                        writer: new vscode_languageserver_protocol_1.IPCMessageWriter(serverProcess)
                    };
                }
                else if (transport === TransportKind.stdio) {
                    let serverProcess = child_process_1.default.spawn(runtime, args, execOptions);
                    if (!serverProcess || !serverProcess.pid) {
                        return Promise.reject(`Launching server module "${node.module}" failed.`);
                    }
                    logger.info(`${this.id} started with ${serverProcess.pid}`);
                    this._serverProcess = serverProcess;
                    serverProcess.stderr.on('data', data => this.appendOutput(data, encoding));
                    return {
                        reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout),
                        writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin)
                    };
                }
                else if (transport == TransportKind.pipe) {
                    return Promise.resolve(vscode_languageserver_protocol_1.createClientPipeTransport(pipeName)).then(transport => {
                        let process = child_process_1.default.spawn(runtime, args, execOptions);
                        if (!process || !process.pid) {
                            return Promise.reject(`Launching server module "${node.module}" failed.`);
                        }
                        logger.info(`Language server ${this.id} started with ${process.pid}`);
                        this._serverProcess = process;
                        process.stderr.on('data', data => this.appendOutput(data, encoding));
                        process.stdout.on('data', data => this.appendOutput(data, encoding));
                        return Promise.resolve(transport.onConnected()).then(protocol => ({ reader: protocol[0], writer: protocol[1] }));
                    });
                }
                else if (Transport.isSocket(node.transport)) {
                    return Promise.resolve(vscode_languageserver_protocol_1.createClientSocketTransport(node.transport.port)).then(transport => {
                        let process = child_process_1.default.spawn(runtime, args, execOptions);
                        if (!process || !process.pid) {
                            return Promise.reject(`Launching server ${node.module} failed.`);
                        }
                        process.on('exit', code => {
                            if (code != 0)
                                this.error(`command "${runtime} ${args.join(' ')}" exited with code: ${code}`);
                        });
                        logger.info(`Language server ${this.id} started with ${process.pid}`);
                        this._serverProcess = process;
                        process.stderr.on('data', data => this.appendOutput(data, encoding));
                        process.stdout.on('data', data => this.appendOutput(data, encoding));
                        return Promise.resolve(transport.onConnected()).then(protocol => ({ reader: protocol[0], writer: protocol[1] }));
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                let command = json;
                let args = command.args || [];
                let options = Object.assign({}, command.options);
                options.env = options.env ? Object.assign({}, process.env, options.env) : process.env;
                options.cwd = serverWorkingDir;
                let cmd = workspace_1.default.expand(json.command);
                let serverProcess = child_process_1.default.spawn(cmd, args, options);
                serverProcess.on('error', e => {
                    logger.error(e);
                });
                if (!serverProcess || !serverProcess.pid) {
                    return Promise.reject(`Launching server "${this.id}" using command ${command.command} failed.`);
                }
                logger.info(`Language server "${this.id}" started with ${serverProcess.pid}`);
                serverProcess.on('exit', code => {
                    if (code != 0)
                        this.error(`${command.command} exited with code: ${code}`);
                });
                serverProcess.stderr.on('data', data => this.appendOutput(data, encoding));
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                return {
                    reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout),
                    writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin)
                };
            }
            return Promise.reject(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`);
        });
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        if (!this.clientOptions.disableWorkspaceFolders) {
            this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
        }
    }
    _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (cwd && !path_1.default.isAbsolute(cwd))
            cwd = path_1.default.join(workspace_1.default.cwd, cwd);
        if (!cwd)
            cwd = workspace_1.default.cwd;
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(s => {
                fs_1.default.lstat(cwd, (err, stats) => {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    }
    appendOutput(data, encoding) {
        let msg = Is.string(data) ? data : data.toString(encoding);
        if (global.hasOwnProperty('__TEST__')) {
            console.log(msg);
            return;
        }
        this.outputChannel.append(msg.endsWith('\n') ? msg : msg + '\n');
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration(this._setting)) {
                this.onDidChangeConfiguration();
            }
        }, null, this._listeners);
        this.onDidChangeConfiguration();
        return {
            dispose: () => {
                util_1.disposeAll(this._listeners);
                if (this._client.needsStop()) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this._client.stop();
                }
            }
        };
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest
            ? workspace_1.default.getConfiguration(primary).get(rest, true)
            : workspace_1.default.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this._client.stop();
        }
    }
}
exports.SettingMonitor = SettingMonitor;
// Exporting proposed protocol.
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(_client) {
        let result = [
        // TODO
        // new CallHierarchyFeature(client),
        // new SemanticTokensFeature(client)
        ];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=index.js.map

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/* eslint-disable */
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const fs_1 = __webpack_require__(304);
const Is = tslib_1.__importStar(__webpack_require__(250));
const lodash_1 = __webpack_require__(494);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const progressPart_1 = tslib_1.__importDefault(__webpack_require__(528));
const async_1 = __webpack_require__(529);
const cv = tslib_1.__importStar(__webpack_require__(530));
const UUID = tslib_1.__importStar(__webpack_require__(531));
const logger = __webpack_require__(64)('language-client-client');
class ConsoleLogger {
    error(message) {
        logger.error(message);
    }
    warn(message) {
        logger.warn(message);
    }
    info(message) {
        logger.info(message);
    }
    log(message) {
        logger.log(message);
    }
}
class NullLogger {
    error(_message) {
    }
    warn(_message) {
    }
    info(_message) {
    }
    log(_message) {
    }
}
exports.NullLogger = NullLogger;
function createConnection(input, output, errorHandler, closeHandler) {
    let logger = new ConsoleLogger();
    let connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger);
    connection.onError(data => {
        errorHandler(data[0], data[1], data[2]);
    });
    connection.onClose(closeHandler);
    let result = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),
        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),
        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
                sendNotification: false,
                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === void 0) {
                connection.trace(value, tracer, defaultTraceOptions);
            }
            else if (Is.boolean(sendNotificationOrTraceOptions)) {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
            else {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
        },
        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined),
        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
        dispose: () => connection.dispose()
    };
    return result;
}
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
class DefaultErrorHandler {
    constructor(name) {
        this.name = name;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return ErrorAction.Continue;
        }
        return ErrorAction.Shutdown;
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < 5) {
            return CloseAction.Restart;
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                workspace_1.default.showMessage(`The "${this.name}" server crashed 5 times in the last 3 minutes. The server will not be restarted.`, 'error');
                return CloseAction.DoNotRestart;
            }
            else {
                this.restarts.shift();
                return CloseAction.Restart;
            }
        }
    }
}
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var State;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Running"] = 2] = "Running";
    State[State["Starting"] = 3] = "Starting";
})(State = exports.State || (exports.State = {}));
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState = exports.ClientState || (exports.ClientState = {}));
const SupportedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
const SupportedSymbolTags = [
    vscode_languageserver_protocol_1.SymbolTag.Deprecated
];
function ensure(target, key) {
    if (target[key] == null) {
        target[key] = {};
    }
    return target[key];
}
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        let candidate = value;
        return (candidate &&
            Is.func(candidate.register) &&
            Is.func(candidate.unregister) &&
            Is.func(candidate.dispose) &&
            candidate.messages !== void 0);
    }
    DynamicFeature.is = is;
})(DynamicFeature || (DynamicFeature = {}));
class DocumentNotifiactions {
    constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
    }
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (workspace_1.default.match(selector, textDocument) > 0) {
                return true;
            }
        }
        return false;
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(data) {
        if (!this._selectorFilter ||
            this._selectorFilter(this._selectors.values(), data)) {
            if (this._middleware) {
                this._middleware(data, data => this._client.sendNotification(this._type, this._createParams(data)));
            }
            else {
                this._client.sendNotification(this._type, this._createParams(data));
            }
            this.notificationSent(data);
        }
    }
    notificationSent(_data) { }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const selector of this._selectors.values()) {
            if (workspace_1.default.match(selector, document)) {
                return {
                    send: (data) => {
                        this.callback(data);
                    }
                };
            }
        }
        throw new Error(`No provider available for the given text document`);
    }
}
class DidOpenTextDocumentFeature extends DocumentNotifiactions {
    constructor(client, _syncedDocuments) {
        super(client, workspace_1.default.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => {
            return { textDocument: cv.convertToTextDocumentItem(textDocument) };
        }, DocumentNotifiactions.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.openClose) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(message, data) {
        super.register(message, data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        workspace_1.default.textDocuments.forEach(textDocument => {
            let uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
                return;
            }
            if (workspace_1.default.match(documentSelector, textDocument) > 0) {
                let middleware = this._client.clientOptions.middleware;
                let didOpen = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                if (middleware.didOpen) {
                    middleware.didOpen(textDocument, didOpen);
                }
                else {
                    didOpen(textDocument);
                }
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    }
}
class DidCloseTextDocumentFeature extends DocumentNotifiactions {
    constructor(client, _syncedDocuments) {
        super(client, workspace_1.default.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => cv.asCloseTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.openClose) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.delete(textDocument.uri.toString());
    }
    unregister(id) {
        let selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach(textDocument => {
            if (workspace_1.default.match(selector, textDocument) > 0 &&
                !this._selectorFilter(selectors, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didClose = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                if (middleware.didClose) {
                    middleware.didClose(textDocument, didClose);
                }
                else {
                    didClose(textDocument);
                }
            }
        });
    }
}
class DidChangeTextDocumentFeature {
    constructor(_client) {
        this._client = _client;
        this._changeData = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.change !== void 0 &&
            textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = workspace_1.default.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            documentSelector: data.registerOptions.documentSelector,
            syncKind: data.registerOptions.syncKind
        });
    }
    callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / undirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        let doc = workspace_1.default.getDocument(event.textDocument.uri);
        if (!doc)
            return;
        let { textDocument } = doc;
        for (const changeData of this._changeData.values()) {
            if (workspace_1.default.match(changeData.documentSelector, textDocument) > 0) {
                let middleware = this._client.clientOptions.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    if (middleware.didChange) {
                        middleware.didChange(event, () => this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, lodash_1.omit(event, ['bufnr', 'original'])));
                    }
                    else {
                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, lodash_1.omit(event, ['bufnr', 'original']));
                    }
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    let didChange = event => {
                        let { textDocument } = workspace_1.default.getDocument(event.textDocument.uri);
                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, cv.asChangeTextDocumentParams(textDocument));
                    };
                    if (middleware.didChange) {
                        middleware.didChange(event, didChange);
                    }
                    else {
                        didChange(event);
                    }
                }
            }
        }
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const changeData of this._changeData.values()) {
            if (workspace_1.default.match(changeData.documentSelector, document)) {
                return {
                    send: (event) => {
                        this.callback(event);
                    }
                };
            }
        }
        throw new Error(`No provider available for the given text document`);
    }
}
class WillSaveFeature extends DocumentNotifiactions {
    constructor(client) {
        super(client, workspace_1.default.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, willSaveEvent => cv.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get messages() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.willSave) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
}
class WillSaveWaitUntilFeature {
    constructor(_client) {
        this._client = _client;
        this._selectors = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.willSaveWaitUntil) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = workspace_1.default.onWillSaveUntil(this.callback, this, this._client.id);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(event) {
        if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {
            let middleware = this._client.clientOptions.middleware;
            let willSaveWaitUntil = (event) => {
                return this._client
                    .sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, cv.asWillSaveTextDocumentParams(event))
                    .then(edits => {
                    return edits ? edits : [];
                }, e => {
                    workspace_1.default.showMessage(`Error on willSaveWaitUntil: ${e}`, 'error');
                    logger.error(e);
                    return [];
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
class DidSaveTextDocumentFeature extends DocumentNotifiactions {
    constructor(client) {
        super(client, workspace_1.default.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, textDocument => cv.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifiactions.textDocumentFilter);
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.save) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { includeText: !!textDocumentSyncOptions.save.includeText })
            });
        }
    }
    register(method, data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(method, data);
    }
}
class FileSystemWatcherFeature {
    constructor(_client, _notifyFileEvent) {
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
    }
    initialize(_capabilities, _documentSelector) { }
    register(_method, data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
            if (!Is.string(watcher.globPattern)) {
                continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind != null) {
                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) != 0;
                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) != 0;
            }
            let fileSystemWatcher = workspace_1.default.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
            disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
    }
    registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
            disposables.push(fileSystemWatcher);
            this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
            fileSystemWatcher.onDidCreate(resource => this._notifyFileEvent({
                uri: cv.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange(resource => this._notifyFileEvent({
                uri: cv.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete(resource => this._notifyFileEvent({
                uri: cv.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        }
    }
    dispose() {
        this._watchers.forEach(disposables => {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
class TextDocumentFeature {
    constructor(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._registrations = new Map();
    }
    get messages() {
        return this._message;
    }
    register(message, data) {
        if (message.method !== this.messages.method) {
            throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);
        }
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach(value => {
            value.disposable.dispose();
        });
        this._registrations.clear();
    }
    getRegistration(documentSelector, capability) {
        if (!capability) {
            return [undefined, undefined];
        }
        else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector || documentSelector;
            if (selector) {
                return [id, Object.assign({}, capability, { documentSelector: selector })];
            }
        }
        else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
                return [undefined, undefined];
            }
            let options = (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
            return [UUID.generateUuid(), options];
        }
        return [undefined, undefined];
    }
    getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
            return undefined;
        }
        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
    }
    getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && workspace_1.default.match(selector, textDocument)) {
                return registration.provider;
            }
        }
        throw new Error(`The feature has no registration for the provided text document ${textDocument.uri.toString()}`);
    }
}
exports.TextDocumentFeature = TextDocumentFeature;
class WorkspaceFeature {
    constructor(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._registrations = new Map();
    }
    get messages() {
        return this._message;
    }
    register(message, data) {
        if (message.method !== this.messages.method) {
            throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);
        }
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, registration);
    }
    unregister(id) {
        const registration = this._registrations.get(id);
        if (registration)
            registration.dispose();
    }
    dispose() {
        this._registrations.forEach(value => {
            value.dispose();
        });
        this._registrations.clear();
    }
}
class CompletionItemFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;
        let completion = ensure(ensure(capabilites, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
    }
    initialize(capabilities, documentSelector) {
        this.index = 0;
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        let triggerCharacters = options.triggerCharacters || [];
        let allCommitCharacters = options.allCommitCharacters || [];
        let priority = options.priority;
        this.index = this.index + 1;
        const provider = {
            provideCompletionItems: (document, position, token, context) => {
                const client = this._client;
                const middleware = this._client.clientOptions.middleware;
                const provideCompletionItems = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, cv.asCompletionParams(document, position, context), token).then(result => result, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.clientOptions.middleware;
                    const resolveCompletionItem = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, item, token).then(res => res, error => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, error);
                            return Promise.resolve(item);
                        });
                    };
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                }
                : undefined
        };
        const languageIds = cv.asLanguageIds(options.documentSelector);
        const disposable = languages_1.default.registerCompletionItemProvider(this._client.id + '-' + this.index, 'LS', languageIds, provider, triggerCharacters, priority, allCommitCharacters);
        return [disposable, provider];
    }
}
class HoverFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const hoverCapability = ensure(ensure(capabilites, 'textDocument'), 'hover');
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideHover: (document, position, token) => {
                const client = this._client;
                const provideHover = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        };
        return [languages_1.default.registerHoverProvider(options.documentSelector, provider), provider];
    }
}
class SignatureHelpFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let config = ensure(ensure(capabilites, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        // config.contextSupport = true // TODO context and meta support
        config.signatureInformation = {
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            parameterInformation: {
                labelOffsetSupport: true
            }
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSignatureHelp: (document, position, token) => {
                const client = this._client;
                const providerSignatureHelp = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideSignatureHelp
                    ? middleware.provideSignatureHelp(document, position, token, providerSignatureHelp)
                    : providerSignatureHelp(document, position, token);
            }
        };
        const triggerCharacters = options.triggerCharacters || [];
        const disposable = languages_1.default.registerSignatureHelpProvider(options.documentSelector, provider, triggerCharacters);
        return [disposable, provider];
    }
}
class DefinitionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let definitionSupport = ensure(ensure(capabilites, 'textDocument'), 'definition');
        definitionSupport.dynamicRegistration = true;
        // definitionSupport.linkSupport = true
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDefinition: (document, position, token) => {
                const client = this._client;
                const provideDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        };
        return [languages_1.default.registerDefinitionProvider(options.documentSelector, provider), provider];
    }
}
class ReferencesFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'references').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideReferences: (document, position, options, token) => {
                const client = this._client;
                const _providerReferences = (document, position, options, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, cv.asReferenceParams(document, position, options), token).then(res => res, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, _providerReferences)
                    : _providerReferences(document, position, options, token);
            }
        };
        return [languages_1.default.registerReferencesProvider(options.documentSelector, provider), provider];
    }
}
class DocumentHighlightFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentHighlights: (document, position, token) => {
                const client = this._client;
                const _provideDocumentHighlights = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights)
                    : _provideDocumentHighlights(document, position, token);
            }
        };
        return [languages_1.default.registerDocumentHighlightProvider(options.documentSelector, provider), provider];
    }
}
class DocumentSymbolFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let symbolCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
            valueSet: SupportedSymbolTags
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentSymbols: (document, token) => {
                const client = this._client;
                const _provideDocumentSymbols = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, cv.asDocumentSymbolParams(document), token).then((data) => {
                        if (data === null) {
                            return undefined;
                        }
                        if (data.length === 0) {
                            return [];
                        }
                        else {
                            let element = data[0];
                            // TODO
                            if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {
                                return data;
                            }
                            else {
                                return data;
                            }
                        }
                    }, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols)
                    : _provideDocumentSymbols(document, token);
            }
        };
        return [languages_1.default.registerDocumentSymbolProvider(options.documentSelector, provider), provider];
    }
}
class WorkspaceSymbolFeature extends WorkspaceFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let symbolCapabilities = ensure(ensure(capabilites, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
            valueSet: SupportedSymbolTags
        };
    }
    initialize(capabilities, documentSelector) {
        this.documentSelector = documentSelector;
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
    }
    registerLanguageProvider(_options) {
        const provider = {
            provideWorkspaceSymbols: (query, token) => {
                const client = this._client;
                const provideWorkspaceSymbols = (query, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then(res => res, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            }
        };
        return languages_1.default.registerWorkspaceSymbolProvider(provider);
    }
}
class CodeActionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const cap = ensure(ensure(capabilites, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    vscode_languageserver_protocol_1.CodeActionKind.Empty,
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideCodeActions: (document, range, context, token) => {
                const client = this._client;
                const _provideCodeActions = (document, range, context, token) => {
                    const params = {
                        textDocument: {
                            uri: document.uri
                        },
                        range,
                        context,
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {
                        if (values === null) {
                            return undefined;
                        }
                        return values;
                    }, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)
                    : _provideCodeActions(document, range, context, token);
            }
        };
        return [languages_1.default.registerCodeActionProvider(options.documentSelector, provider, this._client.id, options.codeActionKinds), provider];
    }
}
class CodeLensFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'codeLens').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideCodeLenses: (document, token) => {
                const client = this._client;
                const provideCodeLenses = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, cv.asCodeLensParams(document), token).then(res => res, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    const client = this._client;
                    const resolveCodeLens = (codeLens, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, codeLens, token).then(res => res, error => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, error);
                            return codeLens;
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        };
        return [languages_1.default.registerCodeLensProvider(options.documentSelector, provider), provider];
    }
}
class DocumentFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'formatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentFormattingEdits: (document, options, token) => {
                const client = this._client;
                const provideDocumentFormattingEdits = (document, options, token) => {
                    const params = {
                        textDocument: { uri: document.uri },
                        options
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(res => res, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        };
        return [
            languages_1.default.registerDocumentFormatProvider(options.documentSelector, provider, this._client.clientOptions.formatterPriority),
            provider
        ];
    }
}
class DocumentRangeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentRangeFormattingEdits: (document, range, options, token) => {
                const client = this._client;
                const provideDocumentRangeFormattingEdits = (document, range, options, token) => {
                    const params = {
                        textDocument: { uri: document.uri },
                        range,
                        options,
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(res => res, error => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        };
        return [languages_1.default.registerDocumentRangeFormatProvider(options.documentSelector, provider), provider];
    }
}
class DocumentOnTypeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {
                const client = this._client;
                const provideOnTypeFormattingEdits = (document, position, ch, options, token) => {
                    const params = {
                        textDocument: cv.asVersionedTextDocumentIdentifier(document),
                        position,
                        ch,
                        options
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(res => res, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideOnTypeFormattingEdits
                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                    : provideOnTypeFormattingEdits(document, position, ch, options, token);
            }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        const characters = [options.firstTriggerCharacter, ...moreTriggerCharacter];
        return [languages_1.default.registerOnTypeFormattingEditProvider(options.documentSelector, provider, characters), provider];
    }
}
class RenameFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let rename = ensure(ensure(capabilites, 'textDocument'), 'rename');
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
            return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideRenameEdits: (document, position, newName, token) => {
                const client = this._client;
                const provideRenameEdits = (document, position, newName, token) => {
                    const params = {
                        textDocument: { uri: document.uri },
                        position,
                        newName: newName
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then(res => res, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, error);
                        return Promise.reject(new Error(error.message));
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            },
            prepareRename: options.prepareProvider
                ? (document, position, token) => {
                    const client = this._client;
                    const prepareRename = (document, position, token) => {
                        const params = {
                            textDocument: cv.asTextDocumentIdentifier(document),
                            position
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {
                            if (vscode_languageserver_protocol_1.Range.is(result)) {
                                return result;
                            }
                            else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                                return {
                                    range: result.range,
                                    placeholder: result.placeholder
                                };
                            }
                            // To cancel the rename vscode API expects a rejected promise.
                            return Promise.reject(new Error(`The element can't be renamed.`));
                        }, (error) => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, error);
                            return Promise.reject(new Error(error.message));
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.prepareRename
                        ? middleware.prepareRename(document, position, token, prepareRename)
                        : prepareRename(document, position, token);
                }
                : undefined
        };
        return [languages_1.default.registerRenameProvider(options.documentSelector, provider), provider];
    }
}
class DocumentLinkFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const documentLinkCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentLink');
        documentLinkCapabilities.dynamicRegistration = true;
        // TODO support tooltip
        documentLinkCapabilities.tooltipSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentLinks: (document, token) => {
                const client = this._client;
                const provideDocumentLinks = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, {
                        textDocument: { uri: document.uri }
                    }, token).then(res => res, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? (link, token) => {
                    const client = this._client;
                    let resolveDocumentLink = (link, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, link, token).then(res => res, (error) => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, error);
                            return Promise.resolve(link);
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        };
        return [languages_1.default.registerDocumentLinkProvider(options.documentSelector, provider), provider];
    }
}
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        let section = this._client.clientOptions.synchronize.configurationSection;
        if (section !== void 0) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    }
    register(_message, data) {
        let { section } = data.registerOptions;
        let disposable = workspace_1.default.onDidChangeConfiguration((event) => {
            if (section != null) {
                this.onDidChangeConfiguration(data.registerOptions.section, event);
            }
        });
        this._listeners.set(data.id, disposable);
        if (Is.string(section) && section.endsWith('.settings')) {
            let settings = this.getConfiguredSettings(section);
            if (!settings || Is.emptyObject(settings))
                return;
        }
        if (section != null) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== void 0 && event !== void 0) {
            const affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
                return;
            }
        }
        let isConfigured = sections.length == 1 && /^languageserver\..+\.settings$/.test(sections[0]);
        let didChangeConfiguration = (sections) => {
            if (sections == null) {
                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, {
                    settings: null
                });
                return;
            }
            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, {
                settings: isConfigured ? this.getConfiguredSettings(sections[0]) : this.extractSettingsInformation(sections)
            });
        };
        let middleware = this.getMiddleware();
        middleware
            ? middleware(sections, didChangeConfiguration)
            : didChangeConfiguration(sections);
    }
    getConfiguredSettings(key) {
        let len = '.settings'.length;
        let config = workspace_1.default.getConfiguration(key.slice(0, -len));
        return config.get('settings', {});
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = workspace_1.default.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
            }
            else {
                config = workspace_1.default.getConfiguration(key);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = config;
            }
        }
        return result;
    }
    getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
            return middleware.workspace.didChangeConfiguration;
        }
        else {
            return undefined;
        }
    }
}
class ExecuteCommandFeature {
    constructor(_client) {
        this._client = _client;
        this._commands = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(_message, data) {
        const client = this._client;
        const middleware = client.clientOptions.middleware;
        const executeCommand = (command, args) => {
            const params = {
                command,
                arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, error);
            });
        };
        if (data.registerOptions.commands) {
            let disposables = [];
            for (const command of data.registerOptions.commands) {
                disposables.push(commands_1.default.registerCommand(command, (...args) => {
                    return middleware.executeCommand
                        ? middleware.executeCommand(command, args, executeCommand)
                        : executeCommand(command, args);
                }, null, true));
            }
            this._commands.set(data.id, disposables);
        }
    }
    unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
            disposables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach(value => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return (candidate &&
            vscode_languageserver_protocol_1.MessageReader.is(value.reader) &&
            vscode_languageserver_protocol_1.MessageWriter.is(value.writer));
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class OnReady {
    constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
    }
    get isUsed() {
        return this._used;
    }
    resolve() {
        this._used = true;
        this._resolve();
    }
    reject(error) {
        this._used = true;
        this._reject(error);
    }
}
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        this._features = [];
        this._method2Message = new Map();
        this._dynamicFeatures = new Map();
        this._id = id;
        this._name = name;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
        }
        else {
            this._outputChannel = undefined;
        }
        this._clientOptions = {
            disableWorkspaceFolders: clientOptions.disableWorkspaceFolders,
            disableSnippetCompletion: clientOptions.disableSnippetCompletion,
            disableDynamicRegister: clientOptions.disableDynamicRegister,
            disableDiagnostics: clientOptions.disableDiagnostics,
            disableCompletion: clientOptions.disableCompletion,
            formatterPriority: clientOptions.formatterPriority,
            ignoredRootPaths: clientOptions.ignoredRootPaths,
            documentSelector: clientOptions.documentSelector || [],
            synchronize: clientOptions.synchronize || {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName || this._id,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Never,
            stdioEncoding: clientOptions.stdioEncoding || 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._id),
            middleware: clientOptions.middleware || {},
            workspaceFolder: clientOptions.workspaceFolder
        };
        this.state = ClientState.Initial;
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        this._initializeResult = undefined;
        this._listeners = undefined;
        this._providers = undefined;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise((resolve, reject) => {
            this._onReadyCallbacks = new OnReady(resolve, reject);
        });
        this._onStop = undefined;
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            }
        };
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    get state() {
        return this._state;
    }
    get id() {
        return this._id;
    }
    get name() {
        return this._name;
    }
    set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        if (this.state === ClientState.Running) {
            return State.Running;
        }
        else if (this.state === ClientState.Starting) {
            return State.Starting;
        }
        else {
            return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    async sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            return this._resolvedConnection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onRequest(type, handler);
        }
        catch (error) {
            this.error(`Registering request handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    sendNotification(type, params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onNotification(type, handler);
        }
        catch (error) {
            this.error(`Registering notification handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onProgress(type, token, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            return this._resolvedConnection.onProgress(type, token, handler);
        }
        catch (error) {
            this.error(`Registering progress handler for token ${token} failed.`, error);
            throw error;
        }
    }
    sendProgress(type, token, value) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.sendProgress(type, token, value);
        }
        catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
        }
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            let { outputChannelName } = this._clientOptions;
            this._outputChannel = workspace_1.default.createOutputChannel(outputChannelName ? outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    createDefaultErrorHandler() {
        return new DefaultErrorHandler(this._id);
    }
    set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
            this.resolveConnection().then(connection => {
                connection.trace(this._trace, this._tracer, {
                    sendNotification: false,
                    traceFormat: this._traceFormat
                });
            });
        }, () => { });
    }
    logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
            this.outputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);
        }
        else {
            this.outputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);
        }
        if (data) {
            this.outputChannel.appendLine(`${JSON.stringify(data)}`);
        }
    }
    data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    }
    _appendOutput(type, message, data) {
        let level = RevealOutputChannelOn.Error;
        switch (type) {
            case 'Info':
                level = RevealOutputChannelOn.Info;
                break;
            case 'Warn':
                level = RevealOutputChannelOn.Warn;
                break;
        }
        this.outputChannel.appendLine(`[${type}  - ${(new Date().toLocaleTimeString())}] ${message}`);
        let dataString;
        if (data) {
            dataString = this.data2String(data);
            this.outputChannel.appendLine(dataString);
        }
        if (this._clientOptions.revealOutputChannelOn <= level) {
            this.outputChannel.show(true);
        }
    }
    info(message, data) {
        this._appendOutput('Info', message, data);
    }
    warn(message, data) {
        this._appendOutput('Warn', message, data);
    }
    error(message, data) {
        this._appendOutput('Error', message, data);
    }
    logTrace(message, data) {
        this.outputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
    }
    needsStart() {
        return (this.state === ClientState.Initial ||
            this.state === ClientState.Stopping ||
            this.state === ClientState.Stopped);
    }
    needsStop() {
        return (this.state === ClientState.Starting || this.state === ClientState.Running);
    }
    onReady() {
        return this._onReady;
    }
    get started() {
        return this.state != ClientState.Initial;
    }
    isConnectionActive() {
        return this.state === ClientState.Running && !!this._resolvedConnection;
    }
    start() {
        if (this._onReadyCallbacks.isUsed) {
            this._onReady = new Promise((resolve, reject) => {
                this._onReadyCallbacks = new OnReady(resolve, reject);
            });
        }
        this._listeners = [];
        this._providers = [];
        // If we restart then the diagnostics collection is reused.
        if (!this._diagnostics) {
            let opts = this._clientOptions;
            let name = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;
            this._diagnostics = languages_1.default.createDiagnosticCollection(name);
        }
        this.state = ClientState.Starting;
        this.resolveConnection()
            .then(connection => {
            connection.onLogMessage(message => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        this.error(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        this.warn(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        this.info(message.message);
                        break;
                    default:
                        this.outputChannel.appendLine(message.message);
                }
            });
            connection.onShowMessage(message => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        workspace_1.default.showMessage(message.message, 'error');
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        workspace_1.default.showMessage(message.message, 'warning');
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        workspace_1.default.showMessage(message.message);
                        break;
                    default:
                        workspace_1.default.showMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params => {
                if (!params.actions || params.actions.length == 0) {
                    let msgType = params.type == vscode_languageserver_protocol_1.MessageType.Error
                        ? 'error' : params.type == vscode_languageserver_protocol_1.MessageType.Warning ? 'warning' : 'more';
                    workspace_1.default.showMessage(params.message, msgType);
                    return Promise.resolve(null);
                }
                let items = params.actions.map(o => typeof o === 'string' ? o : o.title);
                return workspace_1.default.showQuickpick(items, params.message).then(idx => {
                    return params.actions[idx];
                });
            });
            connection.onTelemetry(_data => {
                // ignored
            });
            connection.listen();
            // Error is handled in the intialize call.
            return this.initialize(connection);
        }).then(undefined, error => {
            this.state = ClientState.StartFailed;
            this._onReadyCallbacks.reject(error);
            this.error('Starting client failed ', error);
        });
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            if (this.needsStop()) {
                this.stop();
            }
        });
    }
    resolveConnection() {
        if (!this._connectionPromise) {
            this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
    }
    resolveRootPath() {
        if (this._clientOptions.workspaceFolder) {
            return vscode_uri_1.URI.parse(this._clientOptions.workspaceFolder.uri).fsPath;
        }
        let { ignoredRootPaths } = this._clientOptions;
        let config = workspace_1.default.getConfiguration(this.id);
        let rootPatterns = config.get('rootPatterns', []);
        let required = config.get('requireRootPattern', false);
        let resolved;
        if (rootPatterns && rootPatterns.length) {
            let doc = workspace_1.default.getDocument(workspace_1.default.bufnr);
            if (doc && doc.schema == 'file') {
                let dir = path_1.default.dirname(vscode_uri_1.URI.parse(doc.uri).fsPath);
                resolved = fs_1.resolveRoot(dir, rootPatterns, workspace_1.default.cwd);
            }
        }
        if (required && !resolved)
            return null;
        let rootPath = resolved || workspace_1.default.rootPath || workspace_1.default.cwd;
        if (ignoredRootPaths && ignoredRootPaths.indexOf(rootPath) !== -1) {
            workspace_1.default.showMessage(`Ignored rootPath ${rootPath} of client "${this._id}"`, 'warning');
            return null;
        }
        return rootPath;
    }
    initialize(connection) {
        this.refreshTrace(connection, false);
        let { initializationOptions, progressOnInitialization } = this._clientOptions;
        let rootPath = this.resolveRootPath();
        if (!rootPath)
            return;
        let initParams = {
            processId: process.pid,
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? cv.asUri(vscode_uri_1.URI.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initializationOptions) ? initializationOptions() : initializationOptions,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: null,
            clientInfo: {
                name: 'coc.nvim',
                version: workspace_1.default.version
            }
        };
        this.fillInitializeParams(initParams);
        if (progressOnInitialization) {
            const token = UUID.generateUuid();
            // same as VSCode
            initParams.workDoneToken = token;
            const part = progressPart_1.default.create(connection, token);
            part.begin({ kind: 'begin', title: `Starting LS ${this.id}` });
            return this.doInitialize(connection, initParams).then((result) => {
                part.done('finished');
                return result;
            }, (error) => {
                part.cancel();
                throw error;
            });
        }
        else {
            return this.doInitialize(connection, initParams);
        }
    }
    doInitialize(connection, initParams) {
        return connection.initialize(initParams).then(result => {
            this._resolvedConnection = connection;
            this._initializeResult = result;
            this.state = ClientState.Running;
            let textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync != null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, {
                resolvedTextDocumentSync: textDocumentSyncOptions
            });
            if (!this._clientOptions.disableDiagnostics) {
                connection.onDiagnostics(params => this.handleDiagnostics(params));
            }
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            this._onReadyCallbacks.resolve();
            return result;
        }).then(undefined, error => {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    this.initialize(connection);
                }
                else {
                    this.stop();
                    this._onReadyCallbacks.reject(error);
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError &&
                error.data &&
                error.data.retry) {
                workspace_1.default.showPrompt(error.message + ' Retry?').then(confirmed => {
                    if (confirmed) {
                        this.initialize(connection);
                    }
                    else {
                        this.stop();
                        this._onReadyCallbacks.reject(error);
                    }
                });
            }
            else {
                if (error && error.message) {
                    workspace_1.default.showMessage(error.message, 'error');
                }
                this.error('Server initialization failed.', error);
                this.stop();
                this._onReadyCallbacks.reject(error);
            }
            throw error;
        });
    }
    stop() {
        this._initializeResult = undefined;
        if (!this._connectionPromise) {
            this.state = ClientState.Stopped;
            return Promise.resolve();
        }
        if (this.state === ClientState.Stopping && this._onStop) {
            return this._onStop;
        }
        this.state = ClientState.Stopping;
        this.cleanUp();
        // unkook listeners
        return (this._onStop = this.resolveConnection().then(connection => {
            return connection.shutdown().then(() => {
                connection.exit();
                connection.dispose();
                this.state = ClientState.Stopped;
                this.cleanUpChannel();
                this._onStop = undefined;
                this._connectionPromise = undefined;
                this._resolvedConnection = undefined;
            });
        }));
    }
    cleanUp(channel = true, diagnostics = true) {
        if (this._listeners) {
            this._listeners.forEach(listener => listener.dispose());
            this._listeners = undefined;
        }
        if (this._providers) {
            this._providers.forEach(provider => provider.dispose());
            this._providers = undefined;
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        for (let handler of this._dynamicFeatures.values()) {
            handler.dispose();
        }
        if (channel) {
            this.cleanUpChannel();
        }
        if (this._diagnostics) {
            if (diagnostics) {
                this._diagnostics.dispose();
                this._diagnostics = undefined;
            }
            else {
                this._diagnostics.clear();
            }
        }
    }
    cleanUpChannel() {
        if (this._outputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
    }
    notifyFileEvent(event) {
        var _a, _b;
        const client = this;
        function didChangeWatchedFile(event) {
            client._fileEvents.push(event);
            client._fileEventDelayer.trigger(() => {
                client.onReady().then(() => {
                    client.resolveConnection().then(connection => {
                        if (client.isConnectionActive()) {
                            connection.didChangeWatchedFiles({ changes: client._fileEvents });
                        }
                        client._fileEvents = [];
                    });
                }, (error) => {
                    client.error(`Notify file events failed.`, error);
                });
            });
        }
        const workSpaceMiddleware = (_a = this.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        ((_b = workSpaceMiddleware) === null || _b === void 0 ? void 0 : _b.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        let { uri, diagnostics } = params;
        let middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
            middleware(uri, diagnostics, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
        }
        else {
            this.setDiagnostics(uri, diagnostics);
        }
    }
    setDiagnostics(uri, diagnostics) {
        var _a;
        if (!this._diagnostics) {
            return;
        }
        const separate = workspace_1.default.getConfiguration('diagnostic').get('separateRelatedInformationAsDiagnostics');
        if (separate && diagnostics.length > 0) {
            const entries = new Map();
            entries.set(uri, diagnostics);
            for (const diagnostic of diagnostics) {
                if ((_a = diagnostic.relatedInformation) === null || _a === void 0 ? void 0 : _a.length) {
                    let message = `${diagnostic.message}\n\nRelated diagnostics:\n`;
                    for (const info of diagnostic.relatedInformation) {
                        const basename = path_1.default.basename(vscode_uri_1.URI.parse(info.location.uri).fsPath);
                        const ln = info.location.range.start.line;
                        message = `${message}\n${basename}(line ${ln + 1}): ${info.message}`;
                        const diags = entries.get(info.location.uri) || [];
                        diags.push(vscode_languageserver_protocol_1.Diagnostic.create(info.location.range, info.message, vscode_languageserver_protocol_1.DiagnosticSeverity.Hint, diagnostic.code, diagnostic.source));
                        entries.set(info.location.uri, diags);
                    }
                    diagnostic.message = message;
                }
                this._diagnostics.set(Array.from(entries));
            }
        }
        else {
            this._diagnostics.set(uri, diagnostics);
        }
    }
    createConnection() {
        let errorHandler = (error, message, count) => {
            logger.error('connection error:', error, message);
            this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
            this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8').then(transports => {
            return createConnection(transports.reader, transports.writer, errorHandler, closeHandler);
        });
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.state === ClientState.Stopping ||
            this.state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._resolvedConnection) {
                this._resolvedConnection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let action = CloseAction.DoNotRestart;
        try {
            action = this._clientOptions.errorHandler.closed();
        }
        catch (error) {
            // Ignore errors coming from the error handler.
        }
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        if (action === CloseAction.DoNotRestart) {
            this.error('Connection to server got closed. Server will not be restarted.');
            this.state = ClientState.Stopped;
            this.cleanUp(false, true);
        }
        else if (action === CloseAction.Restart) {
            this.info('Connection to server got closed. Server will restart.');
            this.cleanUp(false, true);
            this.state = ClientState.Initial;
            this.start();
        }
    }
    restart() {
        this.cleanUp(true, false);
        this.start();
    }
    handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction.Shutdown) {
            this.error('Connection to server is erroring. Shutting down server.');
            this.stop();
        }
    }
    hookConfigurationChanged(connection) {
        workspace_1.default.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
        });
    }
    refreshTrace(connection, sendNotification = false) {
        let config = workspace_1.default.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        });
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents)
            return;
        let watchers;
        if (Array.isArray(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature);
        }
    }
    registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
            let messages = feature.messages;
            if (Array.isArray(messages)) {
                for (let message of messages) {
                    this._method2Message.set(message.method, message);
                    this._dynamicFeatures.set(message.method, feature);
                }
            }
            else {
                this._method2Message.set(messages.method, messages);
                this._dynamicFeatures.set(messages.method, feature);
            }
        }
    }
    getFeature(request) {
        return this._dynamicFeatures.get(request);
    }
    registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, event => this.notifyFileEvent(event)));
        if (!this._clientOptions.disableCompletion) {
            this.registerFeature(new CompletionItemFeature(this));
        }
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        let result = {};
        ensure(result, 'workspace').applyEdit = true;
        let workspaceEdit = ensure(ensure(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        const diagnostics = ensure(ensure(result, 'textDocument'), 'publishDiagnostics');
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    handleRegistrationRequest(params) {
        if (this.clientOptions.disableDynamicRegister)
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            for (let registration of params.registrations) {
                const feature = this._dynamicFeatures.get(registration.method);
                if (!feature) {
                    reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
                    return;
                }
                const options = registration.registerOptions || {};
                options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
                const data = {
                    id: registration.id,
                    registerOptions: options
                };
                feature.register(this._method2Message.get(registration.method), data);
            }
            resolve();
        });
    }
    handleUnregistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (let unregistration of params.unregisterations) {
                const feature = this._dynamicFeatures.get(unregistration.method);
                if (!feature) {
                    reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
                    return;
                }
                feature.unregister(unregistration.id);
            }
            resolve();
        });
    }
    handleApplyWorkspaceEdit(params) {
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        workspace_1.default.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    let textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return workspace_1.default.applyEdit(params.edit).then(value => {
            return { applied: value };
        });
    }
    logFailedRequest(type, error) {
        // If we get a request cancel don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError &&
            error.code === vscode_languageserver_protocol_1.ErrorCodes.RequestCancelled) {
            return;
        }
        this.error(`Request ${type.method} failed.`, error);
    }
}
exports.BaseLanguageClient = BaseLanguageClient;
//# sourceMappingURL=client.js.map

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const util_1 = __webpack_require__(238);
const progressParts = new Map();
class ProgressPart {
    constructor(_client, _token) {
        this._client = _client;
        this._token = _token;
        this._disposables = [];
        this._cancelled = false;
        this._statusBarItem = workspace_1.default.createStatusBarItem(99, { progress: true });
        this._disposables.push(this._statusBarItem);
        this._disposables.push(_client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, value => {
            switch (value.kind) {
                case 'begin':
                    this.begin(value);
                    break;
                case 'report':
                    this.report(value);
                    break;
                case 'end':
                    this.done(value.message);
                    break;
            }
        }));
    }
    begin(params) {
        // TODO: support progress window with cancel button & WorkDoneProgressCancelNotification
        this.title = params.title;
        this.report(params);
    }
    report(params) {
        let statusBarItem = this._statusBarItem;
        let parts = [];
        if (this.title)
            parts.push(this.title);
        if (params.percentage)
            parts.push(params.percentage.toFixed(0) + '%');
        if (params.message)
            parts.push(params.message);
        statusBarItem.text = parts.join(' ');
        statusBarItem.show();
    }
    cancel() {
        if (this._cancelled)
            return;
        this._cancelled = true;
        util_1.disposeAll(this._disposables);
        if (progressParts.has(this._token)) {
            progressParts.delete(this._token);
        }
    }
    done(message) {
        let statusBarItem = this._statusBarItem;
        if (!message) {
            this.cancel();
        }
        else {
            statusBarItem.text = `${this.title} ${message}`;
            setTimeout(() => {
                this.cancel();
            }, 500);
        }
    }
}
class ProgressManager {
    create(client, token) {
        let part = this.getProgress(token);
        if (part)
            return part;
        part = new ProgressPart(client, token);
        progressParts.set(token, part);
        return part;
    }
    getProgress(token) {
        return progressParts.get(token) || null;
    }
    cancel(token) {
        let progress = this.getProgress(token);
        if (progress)
            progress.cancel();
    }
}
exports.default = new ProgressManager();
//# sourceMappingURL=progressPart.js.map

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A helper to delay execution of a task that is being requested often.
 *
 * Following the throttler, now imagine the mail man wants to optimize the number of
 * trips proactively. The trip itself can be long, so he decides not to make the trip
 * as soon as a letter is submitted. Instead he waits a while, in case more
 * letters are submitted. After said waiting period, if no letters were submitted, he
 * decides to make the trip. Imagine that N more letters were submitted after the first
 * one, all within a short period of time between each other. Even though N+1
 * submissions occurred, only 1 delivery was made.
 *
 * The delayer offers this behavior via the trigger() method, into which both the task
 * to be executed and the waiting period (delay) must be passed in as arguments. Following
 * the example:
 *
 * 		const delayer = new Delayer(WAITING_PERIOD)
 * 		const letters = []
 *
 * 		function letterReceived(l) {
 * 			letters.push(l)
 * 			delayer.trigger(() => { return makeTheTrip(); })
 * 		}
 */
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = null;
        this.completionPromise = null;
        this.doResolve = null;
        this.task = null;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        this.cancelTimeout();
        if (!this.completionPromise) {
            this.completionPromise = new Promise((c, e) => {
                this.doResolve = c;
                this.doReject = e;
            }).then(() => {
                this.completionPromise = null;
                this.doResolve = null;
                const task = this.task;
                this.task = null;
                return task();
            });
        }
        this.timeout = setTimeout(() => {
            this.timeout = null;
            this.doResolve(null);
        }, delay);
        return this.completionPromise;
    }
    isTriggered() {
        return this.timeout !== null;
    }
    cancel() {
        this.cancelTimeout();
        if (this.completionPromise) {
            this.doReject(new Error('Canceled'));
            this.completionPromise = null;
        }
    }
    cancelTimeout() {
        if (this.timeout !== null) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    }
    dispose() {
        this.cancelTimeout();
    }
}
exports.Delayer = Delayer;
//# sourceMappingURL=async.js.map

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __webpack_require__(494);
function asLanguageIds(documentSelector) {
    let res = documentSelector.map(filter => {
        if (typeof filter == 'string') {
            return filter;
        }
        return filter.language;
    });
    res = res.filter(s => s != null);
    return res.length == 0 ? null : res;
}
exports.asLanguageIds = asLanguageIds;
function convertToTextDocumentItem(document) {
    return {
        uri: document.uri,
        languageId: document.languageId,
        version: document.version,
        text: document.getText()
    };
}
exports.convertToTextDocumentItem = convertToTextDocumentItem;
function asCloseTextDocumentParams(document) {
    return {
        textDocument: {
            uri: document.uri
        }
    };
}
exports.asCloseTextDocumentParams = asCloseTextDocumentParams;
function asChangeTextDocumentParams(document) {
    let result = {
        textDocument: {
            uri: document.uri,
            version: document.version
        },
        contentChanges: [{ text: document.getText() }]
    };
    return result;
}
exports.asChangeTextDocumentParams = asChangeTextDocumentParams;
function asWillSaveTextDocumentParams(event) {
    return {
        textDocument: asVersionedTextDocumentIdentifier(event.document),
        reason: event.reason
    };
}
exports.asWillSaveTextDocumentParams = asWillSaveTextDocumentParams;
function asVersionedTextDocumentIdentifier(textDocument) {
    return {
        uri: textDocument.uri,
        version: textDocument.version
    };
}
exports.asVersionedTextDocumentIdentifier = asVersionedTextDocumentIdentifier;
function asSaveTextDocumentParams(document, includeText) {
    let result = {
        textDocument: asVersionedTextDocumentIdentifier(document)
    };
    if (includeText) {
        result.text = document.getText();
    }
    return result;
}
exports.asSaveTextDocumentParams = asSaveTextDocumentParams;
function asUri(resource) {
    return resource.toString();
}
exports.asUri = asUri;
function asCompletionParams(textDocument, position, context) {
    return {
        textDocument: {
            uri: textDocument.uri,
        },
        position,
        context: lodash_1.omit(context, ['option']),
    };
}
exports.asCompletionParams = asCompletionParams;
function asTextDocumentPositionParams(textDocument, position) {
    return {
        textDocument: {
            uri: textDocument.uri,
        },
        position
    };
}
exports.asTextDocumentPositionParams = asTextDocumentPositionParams;
function asTextDocumentIdentifier(textDocument) {
    return {
        uri: textDocument.uri
    };
}
exports.asTextDocumentIdentifier = asTextDocumentIdentifier;
function asReferenceParams(textDocument, position, options) {
    return {
        textDocument: {
            uri: textDocument.uri,
        },
        position,
        context: { includeDeclaration: options.includeDeclaration }
    };
}
exports.asReferenceParams = asReferenceParams;
function asDocumentSymbolParams(textDocument) {
    return {
        textDocument: {
            uri: textDocument.uri
        }
    };
}
exports.asDocumentSymbolParams = asDocumentSymbolParams;
function asCodeLensParams(textDocument) {
    return {
        textDocument: {
            uri: textDocument.uri
        }
    };
}
exports.asCodeLensParams = asCodeLensParams;
//# sourceMappingURL=converter.js.map

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = __webpack_require__(283);
function generateUuid() {
    return uuid_1.v4();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const client_1 = __webpack_require__(527);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ColorProviderFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'colorProvider').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideColorPresentations: (color, context, token) => {
                const client = this._client;
                const provideColorPresentations = (color, context, token) => {
                    const requestParams = {
                        color,
                        textDocument: { uri: context.document.uri },
                        range: context.range
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then(res => res, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideColorPresentations
                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)
                    : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document, token) => {
                const client = this._client;
                const provideDocumentColors = (document, token) => {
                    const requestParams = {
                        textDocument: { uri: document.uri }
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then(res => res, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentColors
                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)
                    : provideDocumentColors(document, token);
            }
        };
        return [languages_1.default.registerDocumentColorProvider(options.documentSelector, provider), provider];
    }
}
exports.ColorProviderFeature = ColorProviderFeature;
//# sourceMappingURL=colorProvider.js.map

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('languageclient-configuration');
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = params => {
                let result = [];
                for (let item of params.items) {
                    result.push(this.getConfiguration(item.scopeUri, item.section));
                }
                return result;
            };
            let middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        let { id } = this._client;
        if (section) {
            if (id.startsWith('languageserver')) {
                let config = workspace_1.default.getConfiguration(id, resource).get('settings');
                if (config && config[section] != null)
                    return config[section];
            }
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = workspace_1.default.getConfiguration(undefined, resource).get(section, {});
            }
            else {
                let config = workspace_1.default.getConfiguration(section.substr(0, index), resource);
                if (config) {
                    result = config.get(section.substr(index + 1));
                }
            }
        }
        else {
            let config = workspace_1.default.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = config.get(key);
                }
            }
        }
        return result;
    }
}
exports.ConfigurationFeature = ConfigurationFeature;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const client_1 = __webpack_require__(527);
const converter_1 = __webpack_require__(530);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class DeclarationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let declarationSupport = ensure(ensure(capabilites, 'textDocument'), 'declaration');
        declarationSupport.dynamicRegistration = true;
        // declarationSupport.linkSupport = true
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDeclaration: (document, position, token) => {
                const client = this._client;
                const provideDeclaration = (document, position, token) => client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, converter_1.asTextDocumentPositionParams(document, position), token).then(res => res, error => {
                    client.logFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, error);
                    return Promise.resolve(null);
                });
                const middleware = client.clientOptions.middleware;
                return middleware.provideDeclaration
                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)
                    : provideDeclaration(document, position, token);
            }
        };
        return [languages_1.default.registerDeclarationProvider(options.documentSelector, provider), provider];
    }
}
exports.DeclarationFeature = DeclarationFeature;
//# sourceMappingURL=declaration.js.map

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const client_1 = __webpack_require__(527);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class FoldingRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let capability = ensure(ensure(capabilites, 'textDocument'), 'foldingRange');
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5000;
        capability.lineFoldingOnly = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideFoldingRanges: (document, context, token) => {
                const client = this._client;
                const provideFoldingRanges = (document, _, token) => {
                    const requestParams = {
                        textDocument: { uri: document.uri }
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then(res => res, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideFoldingRanges
                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)
                    : provideFoldingRanges(document, context, token);
            }
        };
        return [languages_1.default.registerFoldingRangeProvider(options.documentSelector, provider), provider];
    }
}
exports.FoldingRangeFeature = FoldingRangeFeature;
//# sourceMappingURL=foldingRange.js.map

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const client_1 = __webpack_require__(527);
const cv = tslib_1.__importStar(__webpack_require__(530));
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ImplementationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const implementationSupport = ensure(ensure(capabilites, 'textDocument'), 'implementation');
        implementationSupport.dynamicRegistration = true;
        // implementationSupport.linkSupport = true
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideImplementation: (document, position, token) => {
                const client = this._client;
                const provideImplementation = (document, position, token) => client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {
                    client.logFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, error);
                    return Promise.resolve(null);
                });
                const middleware = client.clientOptions.middleware;
                return middleware.provideImplementation
                    ? middleware.provideImplementation(document, position, token, provideImplementation)
                    : provideImplementation(document, position, token);
            }
        };
        return [languages_1.default.registerImplementationProvider(options.documentSelector, provider), provider];
    }
}
exports.ImplementationFeature = ImplementationFeature;
//# sourceMappingURL=implementation.js.map

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const progressPart_1 = tslib_1.__importDefault(__webpack_require__(528));
// const logger = require('../util/logger')('language-client-progress')
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class ProgressFeature {
    constructor(_client) {
        this._client = _client;
    }
    fillClientCapabilities(capabilities) {
        ensure(capabilities, 'window').workDoneProgress = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, (params) => {
            progressPart_1.default.create(this._client, params.token);
        });
    }
}
exports.ProgressFeature = ProgressFeature;
//# sourceMappingURL=progress.js.map

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const client_1 = __webpack_require__(527);
const cv = tslib_1.__importStar(__webpack_require__(530));
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class TypeDefinitionFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const typeDefinitionSupport = ensure(ensure(capabilites, 'textDocument'), 'typeDefinition');
        typeDefinitionSupport.dynamicRegistration = true;
        // typeDefinitionSupport.linkSupport = true
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideTypeDefinition: (document, position, token) => {
                const client = this._client;
                const provideTypeDefinition = (document, position, token) => client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {
                    client.logFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, error);
                    return Promise.resolve(null);
                });
                const middleware = client.clientOptions.middleware;
                return middleware.provideTypeDefinition
                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)
                    : provideTypeDefinition(document, position, token);
            }
        };
        return [languages_1.default.registerTypeDefinitionProvider(options.documentSelector, provider), provider];
    }
}
exports.TypeDefinitionFeature = TypeDefinitionFeature;
//# sourceMappingURL=typeDefinition.js.map

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const UUID = tslib_1.__importStar(__webpack_require__(531));
const logger = __webpack_require__(64)('language-client-workspaceFolder');
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
function arrayDiff(left, right) {
    return left.filter(element => !right.includes(element));
}
class WorkspaceFoldersFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: workspaceFolder.uri, name: workspaceFolder.name };
    }
    fillInitializeParams(params) {
        const folders = workspace_1.default.workspaceFolders;
        this._initialFolders = folders;
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
        params.workspaceFolders = workspace_1.default.workspaceFolders;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            let workspaceFolders = () => {
                let folders = workspace_1.default.workspaceFolders;
                if (folders === void 0) {
                    return null;
                }
                let result = folders.map(folder => this.asProtocol(folder));
                return result;
            };
            let middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        let value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register(this.messages, {
                id,
                registerOptions: undefined
            });
        }
    }
    doSendEvent(addedFolders, removedFolders) {
        let params = {
            event: {
                added: addedFolders.map(folder => this.asProtocol(folder)),
                removed: removedFolders.map(folder => this.asProtocol(folder))
            }
        };
        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    sendInitialEvent(currentWorkspaceFolders) {
        if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
                this.doSendEvent(added, removed);
            }
        }
        else if (this._initialFolders) {
            this.doSendEvent([], this._initialFolders);
        }
        else if (currentWorkspaceFolders) {
            this.doSendEvent(currentWorkspaceFolders, []);
        }
    }
    register(_message, data) {
        let id = data.id;
        let client = this._client;
        let disposable = workspace_1.default.onDidChangeWorkspaceFolders(event => {
            let didChangeWorkspaceFolders = (event) => {
                this.doSendEvent(event.added, event.removed);
            };
            let middleware = client.clientOptions.middleware.workspace;
            middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(workspace_1.default.workspaceFolders);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolders.js.map

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const client_1 = __webpack_require__(527);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class SelectionRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let capability = ensure(ensure(capabilites, 'textDocument'), 'selectionRange');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSelectionRanges: (document, positions, token) => {
                const client = this._client;
                const provideSelectionRanges = (document, positions, token) => {
                    const requestParams = {
                        textDocument: { uri: document.uri },
                        positions
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token).then(ranges => ranges, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideSelectionRanges
                    ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges)
                    : provideSelectionRanges(document, positions, token);
            }
        };
        return [languages_1.default.registerSelectionRangeProvider(options.documentSelector, provider), provider];
    }
}
exports.SelectionRangeFeature = SelectionRangeFeature;
//# sourceMappingURL=selectionRange.js.map

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const extensions_1 = tslib_1.__importDefault(__webpack_require__(333));
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const configuration_1 = tslib_1.__importDefault(__webpack_require__(542));
const mappings_1 = tslib_1.__importDefault(__webpack_require__(543));
const prompt_1 = tslib_1.__importDefault(__webpack_require__(544));
const session_1 = tslib_1.__importDefault(__webpack_require__(578));
const actions_1 = tslib_1.__importDefault(__webpack_require__(585));
const commands_1 = tslib_1.__importDefault(__webpack_require__(587));
const diagnostics_1 = tslib_1.__importDefault(__webpack_require__(588));
const extensions_2 = tslib_1.__importDefault(__webpack_require__(590));
const folders_1 = tslib_1.__importDefault(__webpack_require__(591));
const links_1 = tslib_1.__importDefault(__webpack_require__(592));
const lists_1 = tslib_1.__importDefault(__webpack_require__(593));
const location_1 = tslib_1.__importDefault(__webpack_require__(589));
const outline_1 = tslib_1.__importDefault(__webpack_require__(594));
const services_1 = tslib_1.__importDefault(__webpack_require__(596));
const sources_1 = tslib_1.__importDefault(__webpack_require__(597));
const symbols_1 = tslib_1.__importDefault(__webpack_require__(598));
const logger = __webpack_require__(64)('list-manager');
const mouseKeys = ['<LeftMouse>', '<LeftDrag>', '<LeftRelease>', '<2-LeftMouse>'];
class ListManager {
    constructor() {
        this.plugTs = 0;
        this.sessionsMap = new Map();
        this.disposables = [];
        this.listMap = new Map();
    }
    init(nvim) {
        this.nvim = nvim;
        this.config = new configuration_1.default();
        this.prompt = new prompt_1.default(nvim, this.config);
        this.mappings = new mappings_1.default(this, nvim, this.config);
        let signText = this.config.get('selectedSignText', '*');
        nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);
        events_1.default.on('InputChar', this.onInputChar, this, this.disposables);
        events_1.default.on('FocusGained', debounce_1.default(async () => {
            let session = await this.getCurrentSession();
            if (session)
                this.prompt.drawPrompt();
        }, 100), null, this.disposables);
        let timer;
        events_1.default.on('WinEnter', winid => {
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(() => {
                let session = this.getSessionByWinid(winid);
                if (session) {
                    this.prompt.start(session.listOptions);
                }
                else {
                    this.prompt.cancel();
                }
            }, 100);
        }, null, this.disposables);
        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            if (timer)
                clearTimeout(timer);
        }));
        // filter history on input
        this.prompt.onDidChangeInput(() => {
            let { session } = this;
            if (!session)
                return;
            session.onInputChange();
            session.history.filter();
        });
        this.registerList(new links_1.default(nvim));
        this.registerList(new location_1.default(nvim));
        this.registerList(new symbols_1.default(nvim));
        this.registerList(new outline_1.default(nvim));
        this.registerList(new commands_1.default(nvim));
        this.registerList(new extensions_2.default(nvim));
        this.registerList(new diagnostics_1.default(nvim));
        this.registerList(new sources_1.default(nvim));
        this.registerList(new services_1.default(nvim));
        this.registerList(new lists_1.default(nvim, this.listMap));
        this.registerList(new folders_1.default(nvim));
        this.registerList(new actions_1.default(nvim));
    }
    async start(args) {
        this.getCharMap().logError();
        let res = this.parseArgs(args);
        if (!res)
            return;
        let { name } = res.list;
        let curr = this.sessionsMap.get(name);
        if (curr) {
            this.nvim.command('pclose', true);
            curr.dispose();
        }
        this.prompt.start(res.options);
        let session = new session_1.default(this.nvim, this.prompt, res.list, res.options, res.listArgs, this.config);
        this.sessionsMap.set(name, session);
        this.lastSession = session;
        try {
            await session.start(args);
        }
        catch (e) {
            this.nvim.call('coc#list#stop_prompt', [], true);
            let msg = e instanceof Error ? e.message : e.toString();
            workspace_1.default.showMessage(`Error on "CocList ${name}": ${msg}`, 'error');
            logger.error(e);
        }
    }
    getSessionByWinid(winid) {
        for (let session of this.sessionsMap.values()) {
            if (session && session.winid == winid) {
                this.lastSession = session;
                return session;
            }
        }
        return null;
    }
    async getCurrentSession() {
        let { id } = await this.nvim.window;
        for (let session of this.sessionsMap.values()) {
            if (session && session.winid == id) {
                this.lastSession = session;
                return session;
            }
        }
        return null;
    }
    async resume(name) {
        var _a;
        if (!name) {
            await ((_a = this.session) === null || _a === void 0 ? void 0 : _a.resume());
        }
        else {
            let session = this.sessionsMap.get(name);
            if (!session) {
                workspace_1.default.showMessage(`Can't find exists ${name} list`);
                return;
            }
            await session.resume();
        }
    }
    async doAction(name) {
        let lastSession = this.lastSession;
        if (!lastSession)
            return;
        await lastSession.doAction(name);
    }
    async first(name) {
        let s = this.getSession(name);
        if (s)
            await s.first();
    }
    async last(name) {
        let s = this.getSession(name);
        if (s)
            await s.last();
    }
    async previous(name) {
        let s = this.getSession(name);
        if (s)
            await s.previous();
    }
    async next(name) {
        let s = this.getSession(name);
        if (s)
            await s.next();
    }
    getSession(name) {
        if (!name)
            return this.session;
        return this.sessionsMap.get(name);
    }
    async cancel(close = true) {
        this.prompt.cancel();
        if (!close)
            return;
        if (this.session)
            await this.session.hide();
    }
    /**
     * Clear all list sessions
     */
    async reset() {
        this.prompt.cancel();
        this.lastSession = undefined;
        for (let session of this.sessionsMap.values()) {
            await session.hide();
            session.dispose();
        }
        this.sessionsMap.clear();
    }
    switchMatcher() {
        var _a;
        (_a = this.session) === null || _a === void 0 ? void 0 : _a.switchMatcher();
    }
    async togglePreview() {
        let { nvim } = this;
        let has = await nvim.call('coc#list#has_preview');
        if (has) {
            await nvim.command('pclose');
            await nvim.command('redraw');
        }
        else {
            await this.doAction('preview');
        }
    }
    async chooseAction() {
        let { lastSession } = this;
        if (lastSession)
            await lastSession.chooseAction();
    }
    parseArgs(args) {
        let options = [];
        let interactive = false;
        let autoPreview = false;
        let numberSelect = false;
        let noQuit = false;
        let first = false;
        let name;
        let input = '';
        let matcher = 'fuzzy';
        let position = 'bottom';
        let listArgs = [];
        let listOptions = [];
        for (let arg of args) {
            if (!name && arg.startsWith('-')) {
                listOptions.push(arg);
            }
            else if (!name) {
                if (!/^\w+$/.test(arg)) {
                    workspace_1.default.showMessage(`Invalid list option: "${arg}"`, 'error');
                    return null;
                }
                name = arg;
            }
            else {
                listArgs.push(arg);
            }
        }
        name = name || 'lists';
        let config = workspace_1.default.getConfiguration(`list.source.${name}`);
        if (!listOptions.length && !listArgs.length)
            listOptions = config.get('defaultOptions', []);
        if (!listArgs.length)
            listArgs = config.get('defaultArgs', []);
        for (let opt of listOptions) {
            if (opt.startsWith('--input')) {
                input = opt.slice(8);
            }
            else if (opt == '--number-select' || opt == '-N') {
                numberSelect = true;
            }
            else if (opt == '--auto-preview' || opt == '-A') {
                autoPreview = true;
            }
            else if (opt == '--regex' || opt == '-R') {
                matcher = 'regex';
            }
            else if (opt == '--strict' || opt == '-S') {
                matcher = 'strict';
            }
            else if (opt == '--interactive' || opt == '-I') {
                interactive = true;
            }
            else if (opt == '--top') {
                position = 'top';
            }
            else if (opt == '--tab') {
                position = 'tab';
            }
            else if (opt == '--ignore-case' || opt == '--normal' || opt == '--no-sort') {
                options.push(opt.slice(2));
            }
            else if (opt == '--first') {
                first = true;
            }
            else if (opt == '--no-quit') {
                noQuit = true;
            }
            else {
                workspace_1.default.showMessage(`Invalid option "${opt}" of list`, 'error');
                return null;
            }
        }
        let list = this.listMap.get(name);
        if (!list) {
            workspace_1.default.showMessage(`List ${name} not found`, 'error');
            return null;
        }
        if (interactive && !list.interactive) {
            workspace_1.default.showMessage(`Interactive mode of "${name}" list not supported`, 'error');
            return null;
        }
        return {
            list,
            listArgs,
            options: {
                numberSelect,
                autoPreview,
                noQuit,
                first,
                input,
                interactive,
                matcher,
                position,
                ignorecase: options.includes('ignore-case') ? true : false,
                mode: !options.includes('normal') ? 'insert' : 'normal',
                sort: !options.includes('no-sort') ? true : false
            },
        };
    }
    async onInputChar(ch, charmod) {
        let { mode } = this.prompt;
        let mapped = this.charMap.get(ch);
        let now = Date.now();
        if (mapped == '<plug>' || now - this.plugTs < 2) {
            this.plugTs = now;
            return;
        }
        if (!ch)
            return;
        if (ch == '\x1b') {
            await this.cancel();
            return;
        }
        // console.log(123)
        // console.log(mode)
        // console.log(ch)
        try {
            if (mode == 'insert') {
                await this.onInsertInput(ch, charmod);
            }
            else {
                await this.onNormalInput(ch, charmod);
            }
        }
        catch (e) {
            workspace_1.default.showMessage(`Error on input ${ch}: ${e}`);
            logger.error(e);
        }
    }
    async onInsertInput(ch, charmod) {
        let { session } = this;
        if (!session)
            return;
        let inserted = this.charMap.get(ch) || ch;
        if (mouseKeys.includes(inserted)) {
            await this.onMouseEvent(inserted);
            return;
        }
        let n = await session.doNumberSelect(ch);
        if (n)
            return;
        let done = await this.mappings.doInsertKeymap(inserted);
        if (done || charmod || this.charMap.has(ch))
            return;
        for (let s of ch) {
            let code = s.codePointAt(0);
            if (code == 65533)
                return;
            // exclude control character
            if (code < 32 || code >= 127 && code <= 159)
                return;
            await this.prompt.acceptCharacter(s);
        }
    }
    async onNormalInput(ch, _charmod) {
        let inserted = this.charMap.get(ch) || ch;
        if (mouseKeys.includes(inserted)) {
            await this.onMouseEvent(inserted);
            return;
        }
        let done = await this.mappings.doNormalKeymap(inserted);
        if (!done)
            await this.feedkeys(inserted);
    }
    onMouseEvent(key) {
        if (this.session)
            return this.session.onMouseEvent(key);
    }
    async feedkeys(key, remap = true) {
        let { nvim } = this;
        key = key.startsWith('<') && key.endsWith('>') ? `\\${key}` : key;
        await nvim.call('coc#list#stop_prompt', [1]);
        await nvim.call('eval', [`feedkeys("${key}", "${remap ? 'i' : 'in'}")`]);
        this.prompt.start();
    }
    async command(command) {
        let { nvim } = this;
        await nvim.call('coc#list#stop_prompt', [1]);
        await nvim.command(command);
        this.prompt.start();
    }
    async normal(command, bang = true) {
        let { nvim } = this;
        await nvim.call('coc#list#stop_prompt', [1]);
        await nvim.command(`normal${bang ? '!' : ''} ${command}`);
        this.prompt.start();
    }
    async call(fname) {
        if (this.session)
            return await this.session.call(fname);
    }
    get session() {
        return this.lastSession;
    }
    registerList(list) {
        const { name } = list;
        let exists = this.listMap.get(name);
        if (this.listMap.has(name)) {
            if (exists) {
                if (typeof exists.dispose == 'function') {
                    exists.dispose();
                }
                this.listMap.delete(name);
            }
            workspace_1.default.showMessage(`list "${name}" recreated.`);
        }
        this.listMap.set(name, list);
        extensions_1.default.addSchemeProperty(`list.source.${name}.defaultOptions`, {
            type: 'array',
            default: list.interactive ? ['--interactive'] : [],
            description: `Default list options of "${name}" list, only used when both list option and argument are empty.`,
            uniqueItems: true,
            items: {
                type: 'string',
                enum: ['--top', '--normal', '--no-sort', '--input', '--tab',
                    '--strict', '--regex', '--ignore-case', '--number-select',
                    '--interactive', '--auto-preview', '--first', '--no-quit']
            }
        });
        extensions_1.default.addSchemeProperty(`list.source.${name}.defaultArgs`, {
            type: 'array',
            default: [],
            description: `Default argument list of "${name}" list, only used when list argument is empty.`,
            uniqueItems: true,
            items: { type: 'string' }
        });
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            if (typeof list.dispose == 'function') {
                list.dispose();
            }
            this.listMap.delete(name);
        });
    }
    get names() {
        return Array.from(this.listMap.keys());
    }
    get descriptions() {
        let d = {};
        for (let name of this.listMap.keys()) {
            let list = this.listMap.get(name);
            d[name] = list.description;
        }
        return d;
    }
    /**
     * Get items of {name} list, not work with interactive list and list return task.
     *
     * @param {string} name
     * @returns {Promise<any>}
     */
    async loadItems(name) {
        let args = [name];
        let res = this.parseArgs(args);
        if (!res)
            return;
        let { list, options, listArgs } = res;
        let source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let token = source.token;
        let arr = await this.nvim.eval('[win_getid(),bufnr("%")]');
        let items = await list.loadItems({
            options,
            args: listArgs,
            input: '',
            cwd: workspace_1.default.cwd,
            window: this.nvim.createWindow(arr[0]),
            buffer: this.nvim.createBuffer(arr[1]),
            listWindow: null
        }, token);
        return items;
    }
    toggleMode() {
        let lastSession = this.lastSession;
        if (lastSession)
            lastSession.toggleMode();
    }
    get isActivated() {
        var _a;
        return ((_a = this.session) === null || _a === void 0 ? void 0 : _a.winid) != null;
    }
    stop() {
        let lastSession = this.lastSession;
        if (lastSession)
            lastSession.stop();
    }
    async getCharMap() {
        if (this.charMap)
            return;
        this.charMap = new Map();
        let chars = await this.nvim.call('coc#list#get_chars');
        Object.keys(chars).forEach(key => {
            this.charMap.set(chars[key], key);
        });
        return;
    }
    dispose() {
        for (let session of this.sessionsMap.values()) {
            session.dispose();
        }
        this.sessionsMap.clear();
        if (this.config) {
            this.config.dispose();
        }
        this.lastSession = undefined;
        util_1.disposeAll(this.disposables);
    }
}
exports.ListManager = ListManager;
exports.default = new ListManager();
//# sourceMappingURL=manager.js.map

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const events_1 = __webpack_require__(198);
exports.validKeys = [
    '<esc>',
    '<space>',
    '<tab>',
    '<s-tab>',
    '<bs>',
    '<right>',
    '<left>',
    '<up>',
    '<down>',
    '<home>',
    '<end>',
    '<cr>',
    '<FocusGained>',
    '<ScrollWheelUp>',
    '<ScrollWheelDown>',
    '<LeftMouse>',
    '<LeftDrag>',
    '<LeftRelease>',
    '<2-LeftMouse>',
    '<C-a>',
    '<C-b>',
    '<C-c>',
    '<C-d>',
    '<C-e>',
    '<C-f>',
    '<C-g>',
    '<C-h>',
    '<C-i>',
    '<C-j>',
    '<C-k>',
    '<C-l>',
    '<C-m>',
    '<C-n>',
    '<C-o>',
    '<C-p>',
    '<C-q>',
    '<C-r>',
    '<C-s>',
    '<C-t>',
    '<C-u>',
    '<C-v>',
    '<C-w>',
    '<C-x>',
    '<C-y>',
    '<C-z>',
    '<A-a>',
    '<A-b>',
    '<A-c>',
    '<A-d>',
    '<A-e>',
    '<A-f>',
    '<A-g>',
    '<A-h>',
    '<A-i>',
    '<A-j>',
    '<A-k>',
    '<A-l>',
    '<A-m>',
    '<A-n>',
    '<A-o>',
    '<A-p>',
    '<A-q>',
    '<A-r>',
    '<A-s>',
    '<A-t>',
    '<A-u>',
    '<A-v>',
    '<A-w>',
    '<A-x>',
    '<A-y>',
    '<A-z>',
];
class ListConfiguration extends events_1.EventEmitter {
    constructor() {
        super();
        this.configuration = workspace_1.default.getConfiguration('list');
        this.disposable = workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('list')) {
                this.configuration = workspace_1.default.getConfiguration('list');
                this.emit('change');
            }
        });
    }
    get(key, defaultValue) {
        return this.configuration.get(key, defaultValue);
    }
    get previousKey() {
        return this.fixKey(this.configuration.get('previousKeymap', '<C-j>'));
    }
    get nextKey() {
        return this.fixKey(this.configuration.get('nextKeymap', '<C-k>'));
    }
    dispose() {
        this.disposable.dispose();
        this.removeAllListeners();
    }
    fixKey(key) {
        if (exports.validKeys.includes(key))
            return key;
        let find = exports.validKeys.find(s => s.toLowerCase() == key.toLowerCase());
        if (find)
            return find;
        workspace_1.default.showMessage(`Configured key "${key}" not supported.`, 'error');
        return null;
    }
}
exports.default = ListConfiguration;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
__webpack_require__(491);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const configuration_1 = __webpack_require__(542);
const logger = __webpack_require__(64)('list-mappings');
class Mappings {
    constructor(manager, nvim, config) {
        this.manager = manager;
        this.nvim = nvim;
        this.config = config;
        this.insertMappings = new Map();
        this.normalMappings = new Map();
        this.userInsertMappings = new Map();
        this.userNormalMappings = new Map();
        let { prompt } = manager;
        this.add('insert', '<C-k>', () => {
            prompt.removeTail();
        });
        this.add('insert', '<C-n>', () => {
            var _a;
            (_a = manager.session) === null || _a === void 0 ? void 0 : _a.history.next();
        });
        this.add('insert', '<C-p>', () => {
            var _a;
            (_a = manager.session) === null || _a === void 0 ? void 0 : _a.history.previous();
        });
        this.add('insert', '<C-v>', async () => {
            await prompt.paste();
        });
        this.add('insert', '<C-s>', () => manager.switchMatcher());
        this.add('insert', ['<C-m>', '<cr>'], async () => {
            await manager.doAction();
        });
        this.add('insert', ['<tab>', '<C-i>', '\t'], () => manager.chooseAction());
        this.add('insert', '<C-o>', () => {
            manager.toggleMode();
        });
        this.add('insert', '<C-c>', () => {
            manager.stop();
            return;
        });
        this.add('insert', '<esc>', () => manager.cancel());
        this.add('insert', '<C-l>', async () => {
            var _a;
            await ((_a = manager.session) === null || _a === void 0 ? void 0 : _a.reloadItems());
        });
        this.add('insert', '<left>', () => {
            prompt.moveLeft();
        });
        this.add('insert', '<right>', () => {
            prompt.moveRight();
        });
        this.add('insert', ['<end>', '<C-e>'], () => {
            prompt.moveToEnd();
        });
        this.add('insert', ['<home>', '<C-a>'], () => {
            prompt.moveToStart();
        });
        this.add('insert', ['<C-h>', '<bs>'], () => {
            prompt.onBackspace();
        });
        this.add('insert', '<C-w>', () => {
            prompt.removeWord();
        });
        this.add('insert', '<C-u>', () => {
            prompt.removeAhead();
        });
        this.add('insert', '<C-r>', () => prompt.insertRegister());
        this.add('insert', '<C-d>', () => manager.feedkeys('<C-d>', false));
        this.add('insert', '<PageUp>', () => manager.feedkeys('<PageUp>', false));
        this.add('insert', '<PageDown>', () => manager.feedkeys('<PageDown>', false));
        this.add('insert', '<down>', () => manager.normal('j'));
        this.add('insert', '<up>', () => manager.normal('k'));
        this.add('insert', ['<ScrollWheelUp>'], this.doScroll.bind(this, '<ScrollWheelUp>'));
        this.add('insert', ['<ScrollWheelDown>'], this.doScroll.bind(this, '<ScrollWheelDown>'));
        this.add('insert', ['<C-f>'], this.doScroll.bind(this, '<C-f>'));
        this.add('insert', ['<C-b>'], this.doScroll.bind(this, '<C-b>'));
        this.add('normal', '<C-o>', () => {
            // do nothing, avoid buffer switch by accident
        });
        this.add('normal', 't', () => manager.doAction('tabe'));
        this.add('normal', 's', () => manager.doAction('split'));
        this.add('normal', 'd', () => manager.doAction('drop'));
        this.add('normal', ['<cr>', '<C-m>', '\r'], () => manager.doAction());
        this.add('normal', '<C-a>', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.ui.selectAll(); });
        this.add('normal', ' ', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.ui.toggleSelection(); });
        this.add('normal', 'p', () => manager.togglePreview());
        this.add('normal', ['<tab>', '\t', '<C-i>'], () => manager.chooseAction());
        this.add('normal', '<C-c>', () => {
            manager.stop();
        });
        this.add('normal', '<esc>', () => manager.cancel());
        this.add('normal', '<C-l>', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.reloadItems(); });
        this.add('normal', '<C-o>', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.jumpBack(); });
        this.add('normal', ['i', 'I', 'o', 'O', 'a', 'A'], () => manager.toggleMode());
        this.add('normal', '?', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.showHelp(); });
        this.add('normal', ':', async () => {
            await manager.cancel(false);
            await nvim.eval('feedkeys(":")');
        });
        this.add('normal', ['<ScrollWheelUp>'], this.doScroll.bind(this, '<ScrollWheelUp>'));
        this.add('normal', ['<ScrollWheelDown>'], this.doScroll.bind(this, '<ScrollWheelDown>'));
        this.createMappings();
        config.on('change', () => {
            this.createMappings();
        });
    }
    createMappings() {
        let insertMappings = this.config.get('insertMappings', {});
        this.userInsertMappings = this.fixUserMappings(insertMappings);
        let normalMappings = this.config.get('normalMappings', {});
        this.userNormalMappings = this.fixUserMappings(normalMappings);
    }
    fixUserMappings(mappings) {
        let res = new Map();
        for (let [key, value] of Object.entries(mappings)) {
            if (key.length == 1) {
                res.set(key, value);
            }
            else if (key.startsWith('<') && key.endsWith('>')) {
                if (key.toLowerCase() == '<space>') {
                    res.set(' ', value);
                }
                else if (configuration_1.validKeys.includes(key)) {
                    res.set(key, value);
                }
                else {
                    let find = false;
                    for (let i = 0; i < configuration_1.validKeys.length; i++) {
                        if (configuration_1.validKeys[i].toLowerCase() == key.toLowerCase()) {
                            find = true;
                            res.set(configuration_1.validKeys[i], value);
                            break;
                        }
                    }
                    if (!find)
                        workspace_1.default.showMessage(`Invalid mappings key: ${key}`, 'error');
                }
            }
            else {
                workspace_1.default.showMessage(`Invalid mappings key: ${key}`, 'error');
            }
        }
        return res;
    }
    async doInsertKeymap(key) {
        let nextKey = this.config.nextKey;
        let previousKey = this.config.previousKey;
        let { session } = this.manager;
        if (!session)
            return;
        if (key == nextKey) {
            session.ui.index = session.ui.index + 1;
            return true;
        }
        if (key == previousKey) {
            session.ui.index = session.ui.index - 1;
            return true;
        }
        let expr = this.userInsertMappings.get(key);
        if (expr) {
            await this.evalExpression(expr, 'insert');
            return true;
        }
        if (this.insertMappings.has(key)) {
            let fn = this.insertMappings.get(key);
            await Promise.resolve(fn());
            return true;
        }
        return false;
    }
    async doNormalKeymap(key) {
        let expr = this.userNormalMappings.get(key);
        if (expr) {
            await this.evalExpression(expr, 'normal');
            return true;
        }
        if (this.normalMappings.has(key)) {
            let fn = this.normalMappings.get(key);
            await Promise.resolve(fn());
            return true;
        }
        return false;
    }
    add(mode, key, fn) {
        let mappings = mode == 'insert' ? this.insertMappings : this.normalMappings;
        if (Array.isArray(key)) {
            for (let k of key) {
                mappings.set(k, fn);
            }
        }
        else {
            mappings.set(key, fn);
        }
    }
    async onError(msg) {
        let { nvim } = this;
        await nvim.call('coc#list#stop_prompt', []);
        workspace_1.default.showMessage(msg, 'error');
        this.manager.prompt.start();
    }
    async evalExpression(expr, _mode) {
        var _a, _b, _c, _d, _e, _f;
        if (typeof expr != 'string' || !expr.includes(':')) {
            await this.onError(`Invalid expression ${expr}`);
            return;
        }
        let { manager } = this;
        let { prompt } = manager;
        let [key, action] = expr.split(':', 2);
        if (key == 'do') {
            switch (action) {
                case 'switch':
                    manager.switchMatcher();
                    return;
                case 'selectall':
                    await ((_a = manager.session) === null || _a === void 0 ? void 0 : _a.ui.selectAll());
                    return;
                case 'help':
                    await ((_b = manager.session) === null || _b === void 0 ? void 0 : _b.showHelp());
                    return;
                case 'refresh':
                    await ((_c = manager.session) === null || _c === void 0 ? void 0 : _c.reloadItems());
                    return;
                case 'exit':
                    await manager.cancel();
                    return;
                case 'stop':
                    manager.stop();
                    return;
                case 'cancel':
                    await manager.cancel(false);
                    return;
                case 'toggle':
                    await ((_d = manager.session) === null || _d === void 0 ? void 0 : _d.ui.toggleSelection());
                    return;
                case 'previous':
                    await manager.normal('k');
                    return;
                case 'next':
                    await manager.normal('j');
                    return;
                case 'defaultaction':
                    await manager.doAction();
                    return;
                case 'toggleMode':
                    return manager.toggleMode();
                default:
                    await this.onError(`'${action}' not supported`);
            }
        }
        else if (key == 'prompt') {
            switch (action) {
                case 'previous':
                    (_e = manager.session) === null || _e === void 0 ? void 0 : _e.history.previous();
                    return;
                case 'next':
                    (_f = manager.session) === null || _f === void 0 ? void 0 : _f.history.next();
                    return;
                case 'start':
                    return prompt.moveToStart();
                case 'end':
                    return prompt.moveToEnd();
                case 'left':
                    return prompt.moveLeft();
                case 'right':
                    return prompt.moveRight();
                case 'deleteforward':
                    return prompt.onBackspace();
                case 'deletebackward':
                    return prompt.removeNext();
                case 'removetail':
                    return prompt.removeTail();
                case 'removeahead':
                    return prompt.removeAhead();
                case 'insertregister':
                    prompt.insertRegister();
                    return;
                case 'paste':
                    await prompt.paste();
                    return;
                default:
                    await this.onError(`prompt '${action}' not supported`);
            }
        }
        else if (key == 'eval') {
            await prompt.eval(action);
        }
        else if (key == 'command') {
            await manager.command(action);
        }
        else if (key == 'action') {
            await manager.doAction(action);
        }
        else if (key == 'feedkeys') {
            await manager.feedkeys(action);
        }
        else if (key == 'normal') {
            await manager.normal(action, false);
        }
        else if (key == 'normal!') {
            await manager.normal(action, true);
        }
        else if (key == 'call') {
            await manager.call(action);
        }
        else if (key == 'expr') {
            let name = await manager.call(action);
            if (name)
                await manager.doAction(name);
        }
        else {
            await this.onError(`Invalid expression ${expr}`);
        }
    }
    async doScroll(key) {
        await this.manager.feedkeys(key);
    }
}
exports.default = Mappings;
//# sourceMappingURL=mappings.js.map

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const clipboardy_1 = tslib_1.__importDefault(__webpack_require__(545));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('list-prompt');
class Prompt {
    constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.cusorIndex = 0;
        this._input = '';
        this._mode = 'insert';
        this.interactive = false;
        this.requestInput = false;
        this._onDidChangeInput = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeInput = this._onDidChangeInput.event;
    }
    get input() {
        return this._input;
    }
    set input(str) {
        if (this._input == str)
            return;
        this.cusorIndex = str.length;
        this._input = str;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
    }
    get mode() {
        return this._mode;
    }
    set mode(val) {
        if (val == this._mode)
            return;
        this._mode = val;
        this.drawPrompt();
    }
    set matcher(val) {
        this._matcher = val;
        this.drawPrompt();
    }
    start(opts) {
        if (opts) {
            this.interactive = opts.interactive;
            this.cusorIndex = opts.input.length;
            this._input = opts.input;
            this._mode = opts.mode;
            this._matcher = opts.interactive ? '' : opts.matcher;
        }
        let fn = workspace_1.default.isVim ? 'coc#list#prompt_start' : 'coc#list#start_prompt';
        this.nvim.call(fn, [], true);
        this.drawPrompt();
    }
    cancel() {
        let { nvim } = this;
        nvim.call('coc#list#stop_prompt', [], true);
    }
    reset() {
        this._input = '';
        this.cusorIndex = 0;
    }
    drawPrompt() {
        let indicator = this.config.get('indicator', '>');
        let { cusorIndex, interactive, input, _matcher } = this;
        let cmds = ['echo ""'];
        if (this.mode == 'insert') {
            if (interactive) {
                cmds.push(`echohl MoreMsg | echon 'INTERACTIVE ' | echohl None`);
            }
            else if (_matcher) {
                cmds.push(`echohl MoreMsg | echon '${_matcher.toUpperCase()} ' | echohl None`);
            }
            cmds.push(`echohl Special | echon '${indicator} ' | echohl None`);
            if (cusorIndex == input.length) {
                cmds.push(`echon '${input.replace(/'/g, "''")}'`);
                cmds.push(`echohl Cursor | echon ' ' | echohl None`);
            }
            else {
                let pre = input.slice(0, cusorIndex);
                if (pre)
                    cmds.push(`echon '${pre.replace(/'/g, "''")}'`);
                cmds.push(`echohl Cursor | echon '${input[cusorIndex].replace(/'/, "''")}' | echohl None`);
                let post = input.slice(cusorIndex + 1);
                cmds.push(`echon '${post.replace(/'/g, "''")}'`);
            }
        }
        else {
            cmds.push(`echohl MoreMsg | echo "" | echohl None`);
        }
        cmds.push('redraw');
        let cmd = cmds.join('|');
        this.nvim.command(cmd, true);
    }
    moveLeft() {
        if (this.cusorIndex == 0)
            return;
        this.cusorIndex = this.cusorIndex - 1;
        this.drawPrompt();
    }
    moveRight() {
        if (this.cusorIndex == this._input.length)
            return;
        this.cusorIndex = this.cusorIndex + 1;
        this.drawPrompt();
    }
    moveToEnd() {
        if (this.cusorIndex == this._input.length)
            return;
        this.cusorIndex = this._input.length;
        this.drawPrompt();
    }
    moveToStart() {
        if (this.cusorIndex == 0)
            return;
        this.cusorIndex = 0;
        this.drawPrompt();
    }
    onBackspace() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
            return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this.cusorIndex = cusorIndex - 1;
        this._input = `${pre.slice(0, pre.length - 1)}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
    }
    removeNext() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length - 1)
            return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex + 1);
        this._input = `${pre}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
    }
    removeWord() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
            return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        let remain = pre.replace(/[\w$]+([^\w$]+)?$/, '');
        this.cusorIndex = cusorIndex - (pre.length - remain.length);
        this._input = `${remain}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
    }
    removeTail() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length)
            return;
        let pre = input.slice(0, cusorIndex);
        this._input = pre;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
    }
    removeAhead() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
            return;
        let post = input.slice(cusorIndex);
        this.cusorIndex = 0;
        this._input = post;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
    }
    async acceptCharacter(ch) {
        if (this.requestInput) {
            this.requestInput = false;
            if (/^[0-9a-z"%#*+/:\-.]$/.test(ch)) {
                let text = await this.nvim.call('getreg', ch);
                text = text.replace(/\n/g, ' ');
                this.addText(text);
            }
        }
        else {
            this.addText(ch);
        }
    }
    insertRegister() {
        this.requestInput = true;
    }
    async paste() {
        let text = await clipboardy_1.default.read();
        text = text.replace(/\n/g, '');
        if (!text)
            return;
        this.addText(text);
    }
    async eval(expression) {
        let text = await this.nvim.call('eval', [expression]);
        text = text.replace(/\n/g, '');
        this.addText(text);
    }
    addText(text) {
        let { cusorIndex, input } = this;
        this.cusorIndex = cusorIndex + text.length;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this._input = `${pre}${text}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
    }
}
exports.default = Prompt;
//# sourceMappingURL=prompt.js.map

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const isWSL = __webpack_require__(546);
const termux = __webpack_require__(548);
const linux = __webpack_require__(574);
const macos = __webpack_require__(575);
const windows = __webpack_require__(576);

const platformLib = (() => {
	switch (process.platform) {
		case 'darwin':
			return macos;
		case 'win32':
			return windows;
		case 'android':
			if (process.env.PREFIX !== '/data/data/com.termux/files/usr') {
				throw new Error('You need to install Termux for this module to work on Android: https://termux.com');
			}

			return termux;
		default:
			// `process.platform === 'linux'` for WSL.
			if (isWSL) {
				return windows;
			}

			return linux;
	}
})();

exports.write = async text => {
	if (typeof text !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof text}`);
	}

	await platformLib.copy({input: text});
};

exports.read = async () => platformLib.paste({stripEof: false});

exports.writeSync = text => {
	if (typeof text !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof text}`);
	}

	platformLib.copySync({input: text});
};

exports.readSync = () => platformLib.pasteSync({stripEof: false}).stdout;


/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const os = __webpack_require__(76);
const fs = __webpack_require__(66);
const isDocker = __webpack_require__(547);

const isWsl = () => {
	if (process.platform !== 'linux') {
		return false;
	}

	if (os.release().toLowerCase().includes('microsoft')) {
		if (isDocker()) {
			return false;
		}

		return true;
	}

	try {
		return fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ?
			!isDocker() : false;
	} catch (_) {
		return false;
	}
};

if (process.env.__IS_WSL_TEST__) {
	module.exports = isWsl;
} else {
	module.exports = isWsl();
}


/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const fs = __webpack_require__(66);

let isDocker;

function hasDockerEnv() {
	try {
		fs.statSync('/.dockerenv');
		return true;
	} catch (_) {
		return false;
	}
}

function hasDockerCGroup() {
	try {
		return fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
	} catch (_) {
		return false;
	}
}

module.exports = () => {
	if (isDocker === undefined) {
		isDocker = hasDockerEnv() || hasDockerCGroup();
	}

	return isDocker;
};


/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const execa = __webpack_require__(549);

const handler = error => {
	if (error.code === 'ENOENT') {
		throw new Error('Couldn\'t find the termux-api scripts. You can install them with: apt install termux-api');
	}

	throw error;
};

module.exports = {
	copy: async options => {
		try {
			await execa('termux-clipboard-set', options);
		} catch (error) {
			handler(error);
		}
	},
	paste: async options => {
		try {
			return await execa.stdout('termux-clipboard-get', options);
		} catch (error) {
			handler(error);
		}
	},
	copySync: options => {
		try {
			execa.sync('termux-clipboard-set', options);
		} catch (error) {
			handler(error);
		}
	},
	pasteSync: options => {
		try {
			return execa.sync('termux-clipboard-get', options);
		} catch (error) {
			handler(error);
		}
	}
};


/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(82);
const childProcess = __webpack_require__(239);
const crossSpawn = __webpack_require__(550);
const stripEof = __webpack_require__(562);
const npmRunPath = __webpack_require__(563);
const isStream = __webpack_require__(564);
const _getStream = __webpack_require__(565);
const pFinally = __webpack_require__(569);
const onExit = __webpack_require__(570);
const errname = __webpack_require__(572);
const stdio = __webpack_require__(573);

const TEN_MEGABYTES = 1000 * 1000 * 10;

function handleArgs(cmd, args, opts) {
	let parsed;

	opts = Object.assign({
		extendEnv: true,
		env: {}
	}, opts);

	if (opts.extendEnv) {
		opts.env = Object.assign({}, process.env, opts.env);
	}

	if (opts.__winShell === true) {
		delete opts.__winShell;
		parsed = {
			command: cmd,
			args,
			options: opts,
			file: cmd,
			original: {
				cmd,
				args
			}
		};
	} else {
		parsed = crossSpawn._parse(cmd, args, opts);
	}

	opts = Object.assign({
		maxBuffer: TEN_MEGABYTES,
		buffer: true,
		stripEof: true,
		preferLocal: true,
		localDir: parsed.options.cwd || process.cwd(),
		encoding: 'utf8',
		reject: true,
		cleanup: true
	}, parsed.options);

	opts.stdio = stdio(opts);

	if (opts.preferLocal) {
		opts.env = npmRunPath.env(Object.assign({}, opts, {cwd: opts.localDir}));
	}

	if (opts.detached) {
		// #115
		opts.cleanup = false;
	}

	if (process.platform === 'win32' && path.basename(parsed.command) === 'cmd.exe') {
		// #116
		parsed.args.unshift('/q');
	}

	return {
		cmd: parsed.command,
		args: parsed.args,
		opts,
		parsed
	};
}

function handleInput(spawned, input) {
	if (input === null || input === undefined) {
		return;
	}

	if (isStream(input)) {
		input.pipe(spawned.stdin);
	} else {
		spawned.stdin.end(input);
	}
}

function handleOutput(opts, val) {
	if (val && opts.stripEof) {
		val = stripEof(val);
	}

	return val;
}

function handleShell(fn, cmd, opts) {
	let file = '/bin/sh';
	let args = ['-c', cmd];

	opts = Object.assign({}, opts);

	if (process.platform === 'win32') {
		opts.__winShell = true;
		file = process.env.comspec || 'cmd.exe';
		args = ['/s', '/c', `"${cmd}"`];
		opts.windowsVerbatimArguments = true;
	}

	if (opts.shell) {
		file = opts.shell;
		delete opts.shell;
	}

	return fn(file, args, opts);
}

function getStream(process, stream, {encoding, buffer, maxBuffer}) {
	if (!process[stream]) {
		return null;
	}

	let ret;

	if (!buffer) {
		// TODO: Use `ret = util.promisify(stream.finished)(process[stream]);` when targeting Node.js 10
		ret = new Promise((resolve, reject) => {
			process[stream]
				.once('end', resolve)
				.once('error', reject);
		});
	} else if (encoding) {
		ret = _getStream(process[stream], {
			encoding,
			maxBuffer
		});
	} else {
		ret = _getStream.buffer(process[stream], {maxBuffer});
	}

	return ret.catch(err => {
		err.stream = stream;
		err.message = `${stream} ${err.message}`;
		throw err;
	});
}

function makeError(result, options) {
	const {stdout, stderr} = result;

	let err = result.error;
	const {code, signal} = result;

	const {parsed, joinedCmd} = options;
	const timedOut = options.timedOut || false;

	if (!err) {
		let output = '';

		if (Array.isArray(parsed.opts.stdio)) {
			if (parsed.opts.stdio[2] !== 'inherit') {
				output += output.length > 0 ? stderr : `\n${stderr}`;
			}

			if (parsed.opts.stdio[1] !== 'inherit') {
				output += `\n${stdout}`;
			}
		} else if (parsed.opts.stdio !== 'inherit') {
			output = `\n${stderr}${stdout}`;
		}

		err = new Error(`Command failed: ${joinedCmd}${output}`);
		err.code = code < 0 ? errname(code) : code;
	}

	err.stdout = stdout;
	err.stderr = stderr;
	err.failed = true;
	err.signal = signal || null;
	err.cmd = joinedCmd;
	err.timedOut = timedOut;

	return err;
}

function joinCmd(cmd, args) {
	let joinedCmd = cmd;

	if (Array.isArray(args) && args.length > 0) {
		joinedCmd += ' ' + args.join(' ');
	}

	return joinedCmd;
}

module.exports = (cmd, args, opts) => {
	const parsed = handleArgs(cmd, args, opts);
	const {encoding, buffer, maxBuffer} = parsed.opts;
	const joinedCmd = joinCmd(cmd, args);

	let spawned;
	try {
		spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
	} catch (err) {
		return Promise.reject(err);
	}

	let removeExitHandler;
	if (parsed.opts.cleanup) {
		removeExitHandler = onExit(() => {
			spawned.kill();
		});
	}

	let timeoutId = null;
	let timedOut = false;

	const cleanup = () => {
		if (timeoutId) {
			clearTimeout(timeoutId);
			timeoutId = null;
		}

		if (removeExitHandler) {
			removeExitHandler();
		}
	};

	if (parsed.opts.timeout > 0) {
		timeoutId = setTimeout(() => {
			timeoutId = null;
			timedOut = true;
			spawned.kill(parsed.opts.killSignal);
		}, parsed.opts.timeout);
	}

	const processDone = new Promise(resolve => {
		spawned.on('exit', (code, signal) => {
			cleanup();
			resolve({code, signal});
		});

		spawned.on('error', err => {
			cleanup();
			resolve({error: err});
		});

		if (spawned.stdin) {
			spawned.stdin.on('error', err => {
				cleanup();
				resolve({error: err});
			});
		}
	});

	function destroy() {
		if (spawned.stdout) {
			spawned.stdout.destroy();
		}

		if (spawned.stderr) {
			spawned.stderr.destroy();
		}
	}

	const handlePromise = () => pFinally(Promise.all([
		processDone,
		getStream(spawned, 'stdout', {encoding, buffer, maxBuffer}),
		getStream(spawned, 'stderr', {encoding, buffer, maxBuffer})
	]).then(arr => {
		const result = arr[0];
		result.stdout = arr[1];
		result.stderr = arr[2];

		if (result.error || result.code !== 0 || result.signal !== null) {
			const err = makeError(result, {
				joinedCmd,
				parsed,
				timedOut
			});

			// TODO: missing some timeout logic for killed
			// https://github.com/nodejs/node/blob/master/lib/child_process.js#L203
			// err.killed = spawned.killed || killed;
			err.killed = err.killed || spawned.killed;

			if (!parsed.opts.reject) {
				return err;
			}

			throw err;
		}

		return {
			stdout: handleOutput(parsed.opts, result.stdout),
			stderr: handleOutput(parsed.opts, result.stderr),
			code: 0,
			failed: false,
			killed: false,
			signal: null,
			cmd: joinedCmd,
			timedOut: false
		};
	}), destroy);

	crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);

	handleInput(spawned, parsed.opts.input);

	spawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected);
	spawned.catch = onrejected => handlePromise().catch(onrejected);

	return spawned;
};

// TODO: set `stderr: 'ignore'` when that option is implemented
module.exports.stdout = (...args) => module.exports(...args).then(x => x.stdout);

// TODO: set `stdout: 'ignore'` when that option is implemented
module.exports.stderr = (...args) => module.exports(...args).then(x => x.stderr);

module.exports.shell = (cmd, opts) => handleShell(module.exports, cmd, opts);

module.exports.sync = (cmd, args, opts) => {
	const parsed = handleArgs(cmd, args, opts);
	const joinedCmd = joinCmd(cmd, args);

	if (isStream(parsed.opts.input)) {
		throw new TypeError('The `input` option cannot be a stream in sync mode');
	}

	const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
	result.code = result.status;

	if (result.error || result.status !== 0 || result.signal !== null) {
		const err = makeError(result, {
			joinedCmd,
			parsed
		});

		if (!parsed.opts.reject) {
			return err;
		}

		throw err;
	}

	return {
		stdout: handleOutput(parsed.opts, result.stdout),
		stderr: handleOutput(parsed.opts, result.stderr),
		code: 0,
		failed: false,
		signal: null,
		cmd: joinedCmd,
		timedOut: false
	};
};

module.exports.shellSync = (cmd, opts) => handleShell(module.exports.sync, cmd, opts);


/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const cp = __webpack_require__(239);
const parse = __webpack_require__(551);
const enoent = __webpack_require__(561);

function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);

    return spawned;
}

function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

    return result;
}

module.exports = spawn;
module.exports.spawn = spawn;
module.exports.sync = spawnSync;

module.exports._parse = parse;
module.exports._enoent = enoent;


/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(82);
const niceTry = __webpack_require__(552);
const resolveCommand = __webpack_require__(553);
const escape = __webpack_require__(556);
const readShebang = __webpack_require__(557);
const semver = __webpack_require__(560);

const isWin = process.platform === 'win32';
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

// `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0
const supportsShellOption = niceTry(() => semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true)) || false;

function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);

    const shebang = parsed.file && readShebang(parsed.file);

    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;

        return resolveCommand(parsed);
    }

    return parsed.file;
}

function parseNonShell(parsed) {
    if (!isWin) {
        return parsed;
    }

    // Detect & add support for shebangs
    const commandFile = detectShebang(parsed);

    // We don't need a shell if the command filename is an executable
    const needsShell = !isExecutableRegExp.test(commandFile);

    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = path.normalize(parsed.command);

        // Escape command & arguments
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));

        const shellCommand = [parsed.command].concat(parsed.args).join(' ');

        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
        parsed.command = process.env.comspec || 'cmd.exe';
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }

    return parsed;
}

function parseShell(parsed) {
    // If node supports the shell option, there's no need to mimic its behavior
    if (supportsShellOption) {
        return parsed;
    }

    // Mimic node shell option
    // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335
    const shellCommand = [parsed.command].concat(parsed.args).join(' ');

    if (isWin) {
        parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';
        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    } else {
        if (typeof parsed.options.shell === 'string') {
            parsed.command = parsed.options.shell;
        } else if (process.platform === 'android') {
            parsed.command = '/system/bin/sh';
        } else {
            parsed.command = '/bin/sh';
        }

        parsed.args = ['-c', shellCommand];
    }

    return parsed;
}

function parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }

    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original

    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args,
        },
    };

    // Delegate further parsing to shell or non-shell
    return options.shell ? parseShell(parsed) : parseNonShell(parsed);
}

module.exports = parse;


/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Tries to execute a function and discards any error that occurs.
 * @param {Function} fn - Function that might or might not throw an error.
 * @returns {?*} Return-value of the function when no error occurred.
 */
module.exports = function(fn) {

	try { return fn() } catch (e) {}

}

/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(82);
const which = __webpack_require__(554);
const pathKey = __webpack_require__(555)();

function resolveCommandAttempt(parsed, withoutPathExt) {
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;

    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (hasCustomCwd) {
        try {
            process.chdir(parsed.options.cwd);
        } catch (err) {
            /* Empty */
        }
    }

    let resolved;

    try {
        resolved = which.sync(parsed.command, {
            path: (parsed.options.env || process.env)[pathKey],
            pathExt: withoutPathExt ? path.delimiter : undefined,
        });
    } catch (e) {
        /* Empty */
    } finally {
        process.chdir(cwd);
    }

    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) {
        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
    }

    return resolved;
}

function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}

module.exports = resolveCommand;


/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = which
which.sync = whichSync

var isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

var path = __webpack_require__(82)
var COLON = isWindows ? ';' : ':'
var isexe = __webpack_require__(245)

function getNotFoundError (cmd) {
  var er = new Error('not found: ' + cmd)
  er.code = 'ENOENT'

  return er
}

function getPathInfo (cmd, opt) {
  var colon = opt.colon || COLON
  var pathEnv = opt.path || process.env.PATH || ''
  var pathExt = ['']

  pathEnv = pathEnv.split(colon)

  var pathExtExe = ''
  if (isWindows) {
    pathEnv.unshift(process.cwd())
    pathExtExe = (opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM')
    pathExt = pathExtExe.split(colon)


    // Always test the cmd itself first.  isexe will check to make sure
    // it's found in the pathExt set.
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
    pathEnv = ['']

  return {
    env: pathEnv,
    ext: pathExt,
    extExe: pathExtExe
  }
}

function which (cmd, opt, cb) {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }

  var info = getPathInfo(cmd, opt)
  var pathEnv = info.env
  var pathExt = info.ext
  var pathExtExe = info.extExe
  var found = []

  ;(function F (i, l) {
    if (i === l) {
      if (opt.all && found.length)
        return cb(null, found)
      else
        return cb(getNotFoundError(cmd))
    }

    var pathPart = pathEnv[i]
    if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
      pathPart = pathPart.slice(1, -1)

    var p = path.join(pathPart, cmd)
    if (!pathPart && (/^\.[\\\/]/).test(cmd)) {
      p = cmd.slice(0, 2) + p
    }
    ;(function E (ii, ll) {
      if (ii === ll) return F(i + 1, l)
      var ext = pathExt[ii]
      isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext)
          else
            return cb(null, p + ext)
        }
        return E(ii + 1, ll)
      })
    })(0, pathExt.length)
  })(0, pathEnv.length)
}

function whichSync (cmd, opt) {
  opt = opt || {}

  var info = getPathInfo(cmd, opt)
  var pathEnv = info.env
  var pathExt = info.ext
  var pathExtExe = info.extExe
  var found = []

  for (var i = 0, l = pathEnv.length; i < l; i ++) {
    var pathPart = pathEnv[i]
    if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
      pathPart = pathPart.slice(1, -1)

    var p = path.join(pathPart, cmd)
    if (!pathPart && /^\.[\\\/]/.test(cmd)) {
      p = cmd.slice(0, 2) + p
    }
    for (var j = 0, ll = pathExt.length; j < ll; j ++) {
      var cur = p + pathExt[j]
      var is
      try {
        is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}


/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = opts => {
	opts = opts || {};

	const env = opts.env || process.env;
	const platform = opts.platform || process.platform;

	if (platform !== 'win32') {
		return 'PATH';
	}

	return Object.keys(env).find(x => x.toUpperCase() === 'PATH') || 'Path';
};


/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    return arg;
}

function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;

    // Algorithm below is based on https://qntm.org/cmd

    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');

    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(\\*)$/, '$1$1');

    // All other backslashes occur literally

    // Quote the whole thing:
    arg = `"${arg}"`;

    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, '^$1');
    }

    return arg;
}

module.exports.command = escapeCommand;
module.exports.argument = escapeArgument;


/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(66);
const shebangCommand = __webpack_require__(558);

function readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    let buffer;

    if (Buffer.alloc) {
        // Node.js v4.5+ / v5.10+
        buffer = Buffer.alloc(size);
    } else {
        // Old Node.js API
        buffer = new Buffer(size);
        buffer.fill(0); // zero-fill
    }

    let fd;

    try {
        fd = fs.openSync(command, 'r');
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) { /* Empty */ }

    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}

module.exports = readShebang;


/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var shebangRegex = __webpack_require__(559);

module.exports = function (str) {
	var match = str.match(shebangRegex);

	if (!match) {
		return null;
	}

	var arr = match[0].replace(/#! ?/, '').split(' ');
	var bin = arr[0].split('/').pop();
	var arg = arr[1];

	return (bin === 'env' ?
		arg :
		bin + (arg ? ' ' + arg : '')
	);
};


/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = /^#!.*/;


/***/ }),
/* 560 */
/***/ (function(module, exports) {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const isWin = process.platform === 'win32';

function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: 'ENOENT',
        errno: 'ENOENT',
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args,
    });
}

function hookChildProcess(cp, parsed) {
    if (!isWin) {
        return;
    }

    const originalEmit = cp.emit;

    cp.emit = function (name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === 'exit') {
            const err = verifyENOENT(arg1, parsed, 'spawn');

            if (err) {
                return originalEmit.call(cp, 'error', err);
            }
        }

        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}

function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawn');
    }

    return null;
}

function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawnSync');
    }

    return null;
}

module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError,
};


/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (x) {
	var lf = typeof x === 'string' ? '\n' : '\n'.charCodeAt();
	var cr = typeof x === 'string' ? '\r' : '\r'.charCodeAt();

	if (x[x.length - 1] === lf) {
		x = x.slice(0, x.length - 1);
	}

	if (x[x.length - 1] === cr) {
		x = x.slice(0, x.length - 1);
	}

	return x;
};


/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(82);
const pathKey = __webpack_require__(555);

module.exports = opts => {
	opts = Object.assign({
		cwd: process.cwd(),
		path: process.env[pathKey()]
	}, opts);

	let prev;
	let pth = path.resolve(opts.cwd);
	const ret = [];

	while (prev !== pth) {
		ret.push(path.join(pth, 'node_modules/.bin'));
		prev = pth;
		pth = path.resolve(pth, '..');
	}

	// ensure the running `node` binary is used
	ret.push(path.dirname(process.execPath));

	return ret.concat(opts.path).join(path.delimiter);
};

module.exports.env = opts => {
	opts = Object.assign({
		env: process.env
	}, opts);

	const env = Object.assign({}, opts.env);
	const path = pathKey({env});

	opts.path = env[path];
	env[path] = module.exports(opts);

	return env;
};


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isStream = module.exports = function (stream) {
	return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
};

isStream.writable = function (stream) {
	return isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
};

isStream.readable = function (stream) {
	return isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';
};

isStream.duplex = function (stream) {
	return isStream.writable(stream) && isStream.readable(stream);
};

isStream.transform = function (stream) {
	return isStream.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';
};


/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const pump = __webpack_require__(566);
const bufferStream = __webpack_require__(568);

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

function getStream(inputStream, options) {
	if (!inputStream) {
		return Promise.reject(new Error('Expected a stream'));
	}

	options = Object.assign({maxBuffer: Infinity}, options);

	const {maxBuffer} = options;

	let stream;
	return new Promise((resolve, reject) => {
		const rejectPromise = error => {
			if (error) { // A null check
				error.bufferedData = stream.getBufferedValue();
			}
			reject(error);
		};

		stream = pump(inputStream, bufferStream(options), error => {
			if (error) {
				rejectPromise(error);
				return;
			}

			resolve();
		});

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	}).then(() => stream.getBufferedValue());
}

module.exports = getStream;
module.exports.buffer = (stream, options) => getStream(stream, Object.assign({}, options, {encoding: 'buffer'}));
module.exports.array = (stream, options) => getStream(stream, Object.assign({}, options, {array: true}));
module.exports.MaxBufferError = MaxBufferError;


/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

var once = __webpack_require__(282)
var eos = __webpack_require__(567)
var fs = __webpack_require__(66) // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

var once = __webpack_require__(282);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const {PassThrough} = __webpack_require__(106);

module.exports = options => {
	options = Object.assign({}, options);

	const {array} = options;
	let {encoding} = options;
	const buffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || buffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (buffer) {
		encoding = null;
	}

	let len = 0;
	const ret = [];
	const stream = new PassThrough({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	stream.on('data', chunk => {
		ret.push(chunk);

		if (objectMode) {
			len = ret.length;
		} else {
			len += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return ret;
		}

		return buffer ? Buffer.concat(ret, len) : ret.join('');
	};

	stream.getBufferedLength = () => len;

	return stream;
};


/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = (promise, onFinally) => {
	onFinally = onFinally || (() => {});

	return promise.then(
		val => new Promise(resolve => {
			resolve(onFinally());
		}).then(() => val),
		err => new Promise(resolve => {
			resolve(onFinally());
		}).then(() => {
			throw err;
		})
	);
};


/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
var assert = __webpack_require__(108)
var signals = __webpack_require__(571)
var isWin = /^win/i.test(process.platform)

var EE = __webpack_require__(198)
/* istanbul ignore if */
if (typeof EE !== 'function') {
  EE = EE.EventEmitter
}

var emitter
if (process.__signal_exit_emitter__) {
  emitter = process.__signal_exit_emitter__
} else {
  emitter = process.__signal_exit_emitter__ = new EE()
  emitter.count = 0
  emitter.emitted = {}
}

// Because this emitter is a global, we have to check to see if a
// previous version of this library failed to enable infinite listeners.
// I know what you're about to say.  But literally everything about
// signal-exit is a compromise with evil.  Get used to it.
if (!emitter.infinite) {
  emitter.setMaxListeners(Infinity)
  emitter.infinite = true
}

module.exports = function (cb, opts) {
  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')

  if (loaded === false) {
    load()
  }

  var ev = 'exit'
  if (opts && opts.alwaysLast) {
    ev = 'afterexit'
  }

  var remove = function () {
    emitter.removeListener(ev, cb)
    if (emitter.listeners('exit').length === 0 &&
        emitter.listeners('afterexit').length === 0) {
      unload()
    }
  }
  emitter.on(ev, cb)

  return remove
}

module.exports.unload = unload
function unload () {
  if (!loaded) {
    return
  }
  loaded = false

  signals.forEach(function (sig) {
    try {
      process.removeListener(sig, sigListeners[sig])
    } catch (er) {}
  })
  process.emit = originalProcessEmit
  process.reallyExit = originalProcessReallyExit
  emitter.count -= 1
}

function emit (event, code, signal) {
  if (emitter.emitted[event]) {
    return
  }
  emitter.emitted[event] = true
  emitter.emit(event, code, signal)
}

// { <signal>: <listener fn>, ... }
var sigListeners = {}
signals.forEach(function (sig) {
  sigListeners[sig] = function listener () {
    // If there are no other listeners, an exit is coming!
    // Simplest way: remove us and then re-send the signal.
    // We know that this will kill the process, so we can
    // safely emit now.
    var listeners = process.listeners(sig)
    if (listeners.length === emitter.count) {
      unload()
      emit('exit', null, sig)
      /* istanbul ignore next */
      emit('afterexit', null, sig)
      /* istanbul ignore next */
      if (isWin && sig === 'SIGHUP') {
        // "SIGHUP" throws an `ENOSYS` error on Windows,
        // so use a supported signal instead
        sig = 'SIGINT'
      }
      process.kill(process.pid, sig)
    }
  }
})

module.exports.signals = function () {
  return signals
}

module.exports.load = load

var loaded = false

function load () {
  if (loaded) {
    return
  }
  loaded = true

  // This is the number of onSignalExit's that are in play.
  // It's important so that we can count the correct number of
  // listeners on signals, and don't wait for the other one to
  // handle it instead of us.
  emitter.count += 1

  signals = signals.filter(function (sig) {
    try {
      process.on(sig, sigListeners[sig])
      return true
    } catch (er) {
      return false
    }
  })

  process.emit = processEmit
  process.reallyExit = processReallyExit
}

var originalProcessReallyExit = process.reallyExit
function processReallyExit (code) {
  process.exitCode = code || 0
  emit('exit', process.exitCode, null)
  /* istanbul ignore next */
  emit('afterexit', process.exitCode, null)
  /* istanbul ignore next */
  originalProcessReallyExit.call(process, process.exitCode)
}

var originalProcessEmit = process.emit
function processEmit (ev, arg) {
  if (ev === 'exit') {
    if (arg !== undefined) {
      process.exitCode = arg
    }
    var ret = originalProcessEmit.apply(this, arguments)
    emit('exit', process.exitCode, null)
    /* istanbul ignore next */
    emit('afterexit', process.exitCode, null)
    return ret
  } else {
    return originalProcessEmit.apply(this, arguments)
  }
}


/***/ }),
/* 571 */
/***/ (function(module, exports) {

// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
  'SIGABRT',
  'SIGALRM',
  'SIGHUP',
  'SIGINT',
  'SIGTERM'
]

if (process.platform !== 'win32') {
  module.exports.push(
    'SIGVTALRM',
    'SIGXCPU',
    'SIGXFSZ',
    'SIGUSR2',
    'SIGTRAP',
    'SIGSYS',
    'SIGQUIT',
    'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  )
}

if (process.platform === 'linux') {
  module.exports.push(
    'SIGIO',
    'SIGPOLL',
    'SIGPWR',
    'SIGSTKFLT',
    'SIGUNUSED'
  )
}


/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Older verions of Node.js might not have `util.getSystemErrorName()`.
// In that case, fall back to a deprecated internal.
const util = __webpack_require__(74);

let uv;

if (typeof util.getSystemErrorName === 'function') {
	module.exports = util.getSystemErrorName;
} else {
	try {
		uv = process.binding('uv');

		if (typeof uv.errname !== 'function') {
			throw new TypeError('uv.errname is not a function');
		}
	} catch (err) {
		console.error('execa/lib/errname: unable to establish process.binding(\'uv\')', err);
		uv = null;
	}

	module.exports = code => errname(uv, code);
}

// Used for testing the fallback behavior
module.exports.__test__ = errname;

function errname(uv, code) {
	if (uv) {
		return uv.errname(code);
	}

	if (!(code < 0)) {
		throw new Error('err >= 0');
	}

	return `Unknown system error ${code}`;
}



/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const alias = ['stdin', 'stdout', 'stderr'];

const hasAlias = opts => alias.some(x => Boolean(opts[x]));

module.exports = opts => {
	if (!opts) {
		return null;
	}

	if (opts.stdio && hasAlias(opts)) {
		throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${alias.map(x => `\`${x}\``).join(', ')}`);
	}

	if (typeof opts.stdio === 'string') {
		return opts.stdio;
	}

	const stdio = opts.stdio || [];

	if (!Array.isArray(stdio)) {
		throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
	}

	const result = [];
	const len = Math.max(stdio.length, alias.length);

	for (let i = 0; i < len; i++) {
		let value = null;

		if (stdio[i] !== undefined) {
			value = stdio[i];
		} else if (opts[alias[i]] !== undefined) {
			value = opts[alias[i]];
		}

		result[i] = value;
	}

	return result;
};


/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(82);
const execa = __webpack_require__(549);

const xsel = 'xsel';
const xselFallback = path.join(__dirname, '../fallbacks/linux/xsel');

const copyArguments = ['--clipboard', '--input'];
const pasteArguments = ['--clipboard', '--output'];

const makeError = (xselError, fallbackError) => {
	let error;
	if (xselError.code === 'ENOENT') {
		error = new Error('Couldn\'t find the `xsel` binary and fallback didn\'t work. On Debian/Ubuntu you can install xsel with: sudo apt install xsel');
	} else {
		error = new Error('Both xsel and fallback failed');
		error.xselError = xselError;
	}

	error.fallbackError = fallbackError;
	return error;
};

const xselWithFallback = async (argumentList, options) => {
	try {
		return await execa.stdout(xsel, argumentList, options);
	} catch (xselError) {
		try {
			return await execa.stdout(xselFallback, argumentList, options);
		} catch (fallbackError) {
			throw makeError(xselError, fallbackError);
		}
	}
};

const xselWithFallbackSync = (argumentList, options) => {
	try {
		return execa.sync(xsel, argumentList, options);
	} catch (xselError) {
		try {
			return execa.sync(xselFallback, argumentList, options);
		} catch (fallbackError) {
			throw makeError(xselError, fallbackError);
		}
	}
};

module.exports = {
	copy: async options => {
		await xselWithFallback(copyArguments, options);
	},
	copySync: options => {
		xselWithFallbackSync(copyArguments, options);
	},
	paste: options => xselWithFallback(pasteArguments, options),
	pasteSync: options => xselWithFallbackSync(pasteArguments, options)
};


/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const execa = __webpack_require__(549);

const env = {
	...process.env,
	LC_CTYPE: 'UTF-8'
};

module.exports = {
	copy: async options => execa('pbcopy', {...options, env}),
	paste: async options => execa.stdout('pbpaste', {...options, env}),
	copySync: options => execa.sync('pbcopy', {...options, env}),
	pasteSync: options => execa.sync('pbpaste', {...options, env})
};


/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(82);
const execa = __webpack_require__(549);
const arch = __webpack_require__(577);

// Binaries from: https://github.com/sindresorhus/win-clipboard
const windowBinaryPath = arch() === 'x64' ?
	path.join(__dirname, '../fallbacks/windows/clipboard_x86_64.exe') :
	path.join(__dirname, '../fallbacks/windows/clipboard_i686.exe');

module.exports = {
	copy: async options => execa(windowBinaryPath, ['--copy'], options),
	paste: async options => execa.stdout(windowBinaryPath, ['--paste'], options),
	copySync: options => execa.sync(windowBinaryPath, ['--copy'], options),
	pasteSync: options => execa.sync(windowBinaryPath, ['--paste'], options)
};


/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

var cp = __webpack_require__(239)
var fs = __webpack_require__(66)
var path = __webpack_require__(82)

/**
 * Returns the operating system's CPU architecture. This is different than
 * `process.arch` or `os.arch()` which returns the architecture the Node.js (or
 * Electron) binary was compiled for.
 */
module.exports = function arch () {
  /**
   * The running binary is 64-bit, so the OS is clearly 64-bit.
   */
  if (process.arch === 'x64') {
    return 'x64'
  }

  /**
   * All recent versions of Mac OS are 64-bit.
   */
  if (process.platform === 'darwin') {
    return 'x64'
  }

  /**
   * On Windows, the most reliable way to detect a 64-bit OS from within a 32-bit
   * app is based on the presence of a WOW64 file: %SystemRoot%\SysNative.
   * See: https://twitter.com/feross/status/776949077208510464
   */
  if (process.platform === 'win32') {
    var useEnv = false
    try {
      useEnv = !!(process.env.SYSTEMROOT && fs.statSync(process.env.SYSTEMROOT))
    } catch (err) {}

    var sysRoot = useEnv ? process.env.SYSTEMROOT : 'C:\\Windows'

    // If %SystemRoot%\SysNative exists, we are in a WOW64 FS Redirected application.
    var isWOW64 = false
    try {
      isWOW64 = !!fs.statSync(path.join(sysRoot, 'sysnative'))
    } catch (err) {}

    return isWOW64 ? 'x64' : 'x86'
  }

  /**
   * On Linux, use the `getconf` command to get the architecture.
   */
  if (process.platform === 'linux') {
    var output = cp.execSync('getconf LONG_BIT', {encoding: 'utf8'})
    return output === '64\n' ? 'x64' : 'x86'
  }

  /**
   * If none of the above, assume the architecture is 32-bit.
   */
  return 'x86'
}


/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const extensions_1 = tslib_1.__importDefault(__webpack_require__(333));
const highligher_1 = tslib_1.__importDefault(__webpack_require__(523));
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const history_1 = tslib_1.__importDefault(__webpack_require__(579));
const ui_1 = tslib_1.__importDefault(__webpack_require__(581));
const worker_1 = tslib_1.__importDefault(__webpack_require__(582));
const logger = __webpack_require__(64)('list-session');
/**
 * Activated list session with UI and worker
 */
class ListSession {
    constructor(nvim, prompt, list, listOptions, listArgs = [], config) {
        this.nvim = nvim;
        this.prompt = prompt;
        this.list = list;
        this.listOptions = listOptions;
        this.listArgs = listArgs;
        this.config = config;
        this.hidden = false;
        this.disposables = [];
        /**
         * Original list arguments.
         */
        this.args = [];
        this.ui = new ui_1.default(nvim, list.name, listOptions, config);
        this.history = new history_1.default(prompt, list.name);
        this.worker = new worker_1.default(nvim, list, prompt, listOptions, {
            interactiveDebounceTime: config.get('interactiveDebounceTime', 100),
            extendedSearchMode: config.get('extendedSearchMode', true)
        });
        let debouncedChangeLine = debounce_1.default(async () => {
            let [previewing, mode] = await nvim.eval('[coc#util#has_preview(),mode()]');
            if (!previewing || mode != 'n')
                return;
            if (previewing)
                await this.doAction('preview');
        }, 50);
        this.disposables.push({
            dispose: () => {
                debouncedChangeLine.clear();
            }
        });
        this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);
        this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);
        this.ui.onDidLineChange(this.resolveItem, this, this.disposables);
        let debounced = debounce_1.default(async () => {
            let { autoPreview } = this.listOptions;
            if (!autoPreview) {
                let [previewing, mode] = await nvim.eval('[coc#util#has_preview(),mode()]');
                if (!previewing || mode != 'n')
                    return;
            }
            await this.doAction('preview');
        }, 50);
        this.disposables.push({
            dispose: () => {
                debounced.clear();
            }
        });
        this.ui.onDidLineChange(debounced, null, this.disposables);
        this.ui.onDidOpen(async () => {
            if (typeof this.list.doHighlight == 'function') {
                this.list.doHighlight();
            }
            if (this.listOptions.first) {
                await this.doAction();
            }
        }, null, this.disposables);
        this.ui.onDidClose(async () => {
            await this.hide();
        }, null, this.disposables);
        this.ui.onDidChange(() => {
            if (this.hidden)
                return;
            this.updateStatus();
        }, null, this.disposables);
        this.ui.onDidDoubleClick(async () => {
            await this.doAction();
        }, null, this.disposables);
        this.worker.onDidChangeItems(async ({ items, highlights, reload, append, finished }) => {
            if (this.hidden)
                return;
            if (append) {
                this.ui.addHighlights(highlights, true);
                await this.ui.appendItems(items);
            }
            else {
                this.ui.addHighlights(highlights);
                let height = this.config.get('height', 10);
                if (finished && !listOptions.interactive && listOptions.input.length == 0) {
                    height = Math.min(items.length, height);
                }
                await this.ui.drawItems(items, Math.max(1, height), reload);
            }
        }, null, this.disposables);
    }
    async start(args) {
        this.args = args;
        this.hidden = false;
        let { listOptions, listArgs } = this;
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.listArgs = listArgs;
        this.history.load(listOptions.input || '');
        this.window = this.nvim.createWindow(res[0]);
        this.buffer = this.nvim.createBuffer(res[1]);
        this.savedHeight = res[2];
        await this.worker.loadItems(this.context);
    }
    async reloadItems() {
        if (!this.window)
            return;
        let bufnr = await this.nvim.call('winbufnr', [this.window.id]);
        // can't reload since window not exists
        if (bufnr == -1)
            return;
        this.buffer = this.nvim.createBuffer(bufnr);
        await this.worker.loadItems(this.context, true);
    }
    async call(fname) {
        var _a, _b;
        await this.nvim.call('coc#list#stop_prompt', []);
        let targets = await this.ui.getItems();
        let context = {
            name: this.name,
            args: this.listArgs,
            input: this.prompt.input,
            winid: (_a = this.window) === null || _a === void 0 ? void 0 : _a.id,
            bufnr: (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.id,
            targets
        };
        let res = await this.nvim.call(fname, [context]);
        this.prompt.start();
        return res;
    }
    async chooseAction() {
        let { nvim } = this;
        let { actions, defaultAction } = this.list;
        let names = actions.map(o => o.name);
        let idx = names.indexOf(defaultAction);
        if (idx != -1) {
            names.splice(idx, 1);
            names.unshift(defaultAction);
        }
        let shortcuts = new Set();
        let choices = [];
        let invalids = [];
        for (let name of names) {
            let i = 0;
            for (let ch of name) {
                if (!shortcuts.has(ch)) {
                    shortcuts.add(ch);
                    choices.push(`${name.slice(0, i)}&${name.slice(i)}`);
                    break;
                }
                i++;
            }
            if (i == name.length) {
                invalids.push(name);
            }
        }
        if (invalids.length) {
            logger.error(`Can't create shortcut for actions: ${invalids.join(',')} of "${this.name}" list`);
            names = names.filter(s => !invalids.includes(s));
        }
        await nvim.call('coc#list#stop_prompt');
        let n = await nvim.call('confirm', ['Choose action:', choices.join('\n')]);
        await util_1.wait(10);
        this.prompt.start();
        if (n)
            await this.doAction(names[n - 1]);
    }
    async doAction(name) {
        let { list } = this;
        name = name || list.defaultAction;
        let action = list.actions.find(o => o.name == name);
        if (!action) {
            workspace_1.default.showMessage(`Action ${name} not found`, 'error');
            return;
        }
        let items;
        if (name == 'preview') {
            let item = await this.ui.item;
            items = item ? [item] : [];
        }
        else {
            items = await this.ui.getItems();
        }
        if (items.length)
            await this.doItemAction(items, action);
    }
    async first() {
        let { ui } = this;
        let item = this.ui.firstItem;
        if (!item)
            return;
        ui.index = 0;
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
    }
    async last() {
        let { ui } = this;
        let item = this.ui.lastItem;
        if (!item)
            return;
        ui.index = this.ui.length - 1;
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
    }
    async previous() {
        let { ui } = this;
        let item = ui.getItem(-1);
        if (!item)
            return;
        ui.index = ui.index - 1;
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
    }
    async next() {
        let { ui } = this;
        let item = ui.getItem(1);
        if (!item)
            return;
        ui.index = ui.index + 1;
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
    }
    /**
     * list name
     */
    get name() {
        return this.list.name;
    }
    /**
     * Window id used by list.
     *
     * @returns {number | undefined}
     */
    get winid() {
        return this.ui.winid;
    }
    get length() {
        return this.ui.length;
    }
    get defaultAction() {
        let { defaultAction, actions } = this.list;
        let action = actions.find(o => o.name == defaultAction);
        if (!action)
            throw new Error(`default action "${defaultAction}" not found`);
        return action;
    }
    async hide() {
        if (this.hidden)
            return;
        let { nvim, listOptions, savedHeight, window } = this;
        this.hidden = true;
        this.worker.stop();
        this.history.add();
        nvim.pauseNotification();
        nvim.call('coc#list#stop_prompt', [], true);
        nvim.command('pclose', true);
        this.ui.close();
        if (window && savedHeight && listOptions.position != 'tab') {
            nvim.call('coc#list#restore', [window.id, savedHeight], true);
        }
        nvim.command('redraw', true);
        await nvim.resumeNotification();
    }
    toggleMode() {
        let mode = this.prompt.mode == 'normal' ? 'insert' : 'normal';
        this.prompt.mode = mode;
        this.listOptions.mode = mode;
        this.updateStatus();
    }
    stop() {
        this.worker.stop();
    }
    async resolveItem() {
        let index = this.ui.index;
        let item = this.ui.getItem(0);
        if (!item || item.resolved)
            return;
        let { list } = this;
        if (typeof list.resolveItem == 'function') {
            let resolved = await Promise.resolve(list.resolveItem(item));
            if (resolved && index == this.ui.index) {
                await this.ui.updateItem(resolved, index);
            }
        }
    }
    async showHelp() {
        await this.hide();
        let { list, nvim } = this;
        if (!list)
            return;
        let previewHeight = await nvim.eval('&previewheight');
        nvim.pauseNotification();
        nvim.command(`belowright ${previewHeight}sp +setl\\ previewwindow [LIST HELP]`, true);
        nvim.command('setl nobuflisted noswapfile buftype=nofile bufhidden=wipe', true);
        await nvim.resumeNotification();
        let hasOptions = list.options && list.options.length;
        let buf = await nvim.buffer;
        let highligher = new highligher_1.default();
        highligher.addLine('NAME', 'Label');
        highligher.addLine(`  ${list.name} - ${list.description || ''}\n`);
        highligher.addLine('SYNOPSIS', 'Label');
        highligher.addLine(`  :CocList [LIST OPTIONS] ${list.name}${hasOptions ? ' [ARGUMENTS]' : ''}\n`);
        if (list.detail) {
            highligher.addLine('DESCRIPTION', 'Label');
            let lines = list.detail.split('\n').map(s => '  ' + s);
            highligher.addLine(lines.join('\n') + '\n');
        }
        if (hasOptions) {
            highligher.addLine('ARGUMENTS', 'Label');
            highligher.addLine('');
            for (let opt of list.options) {
                highligher.addLine(opt.name, 'Special');
                highligher.addLine(`  ${opt.description}`);
                highligher.addLine('');
            }
            highligher.addLine('');
        }
        let config = workspace_1.default.getConfiguration(`list.source.${list.name}`);
        if (Object.keys(config).length) {
            highligher.addLine('CONFIGURATIONS', 'Label');
            highligher.addLine('');
            let props = {};
            extensions_1.default.all.forEach(extension => {
                let { packageJSON } = extension;
                let { contributes } = packageJSON;
                if (!contributes)
                    return;
                let { configuration } = contributes;
                if (configuration) {
                    let { properties } = configuration;
                    if (properties) {
                        for (let key of Object.keys(properties)) {
                            props[key] = properties[key];
                        }
                    }
                }
            });
            for (let key of Object.keys(config)) {
                let val = config[key];
                let name = `list.source.${list.name}.${key}`;
                let description = props[name] && props[name].description ? props[name].description : key;
                highligher.addLine(`  "${name}"`, 'MoreMsg');
                highligher.addText(` - ${description}, current value: `);
                highligher.addText(JSON.stringify(val), 'Special');
            }
            highligher.addLine('');
        }
        highligher.addLine('ACTIONS', 'Label');
        highligher.addLine(`  ${list.actions.map(o => o.name).join(', ')}`);
        highligher.addLine('');
        highligher.addLine(`see ':h coc-list-options' for available list options.`, 'Comment');
        nvim.pauseNotification();
        highligher.render(buf, 0, -1);
        nvim.command('setl nomod', true);
        nvim.command('setl nomodifiable', true);
        nvim.command('normal! gg', true);
        nvim.command('nnoremap <buffer> q :bd!<CR>', true);
        await nvim.resumeNotification();
    }
    switchMatcher() {
        let { matcher, interactive } = this.listOptions;
        if (interactive)
            return;
        const list = ['fuzzy', 'strict', 'regex'];
        let idx = list.indexOf(matcher) + 1;
        if (idx >= list.length)
            idx = 0;
        this.listOptions.matcher = list[idx];
        this.prompt.matcher = list[idx];
        this.worker.drawItems();
    }
    updateStatus() {
        let { ui, list, nvim } = this;
        if (!ui.winid)
            return;
        let buf = nvim.createBuffer(ui.bufnr);
        let status = {
            mode: this.prompt.mode.toUpperCase(),
            args: this.args.join(' '),
            name: list.name,
            total: this.worker.length,
            cwd: workspace_1.default.cwd
        };
        nvim.pauseNotification();
        buf.setVar('list_status', status, true);
        nvim.command('redraws', true);
        nvim.resumeNotification(false, true).logError();
    }
    get context() {
        let { winid } = this.ui;
        return {
            options: this.listOptions,
            args: this.listArgs,
            input: this.prompt.input,
            cwd: workspace_1.default.cwd,
            window: this.window,
            buffer: this.buffer,
            listWindow: winid ? this.nvim.createWindow(winid) : undefined
        };
    }
    redrawItems() {
        this.worker.drawItems();
    }
    onMouseEvent(key) {
        switch (key) {
            case '<LeftMouse>':
                return this.ui.onMouse('mouseDown');
            case '<LeftDrag>':
                return this.ui.onMouse('mouseDrag');
            case '<LeftRelease>':
                return this.ui.onMouse('mouseUp');
            case '<2-LeftMouse>':
                return this.ui.onMouse('doubleClick');
        }
    }
    async doNumberSelect(ch) {
        if (!this.listOptions.numberSelect)
            return false;
        let code = ch.charCodeAt(0);
        if (code >= 48 && code <= 57) {
            let n = Number(ch);
            if (n == 0)
                n = 10;
            if (this.ui.length >= n) {
                this.nvim.pauseNotification();
                this.ui.setCursor(Number(ch), 0);
                await this.nvim.resumeNotification();
                await this.doAction();
            }
            return true;
        }
        return false;
    }
    jumpBack() {
        let { window } = this;
        if (window)
            this.nvim.call('win_gotoid', [window.id], true);
    }
    async resume() {
        if (this.winid)
            await this.hide();
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.hidden = false;
        this.window = this.nvim.createWindow(res[0]);
        this.buffer = this.nvim.createBuffer(res[1]);
        this.savedHeight = res[2];
        this.prompt.start();
        await this.ui.resume();
        if (this.listOptions.autoPreview) {
            await this.doAction('preview');
        }
    }
    async doItemAction(items, action) {
        let { noQuit } = this.listOptions;
        let { nvim } = this;
        let persist = this.winid && (action.persist === true || action.name == 'preview');
        noQuit = noQuit && this.winid != null;
        try {
            if (!persist) {
                if (noQuit) {
                    nvim.pauseNotification();
                    nvim.call('coc#list#stop_prompt', [], true);
                    nvim.call('win_gotoid', [this.context.window.id], true);
                    await nvim.resumeNotification();
                }
                else {
                    await this.hide();
                }
            }
            if (action.multiple) {
                await Promise.resolve(action.execute(items, this.context));
            }
            else if (action.parallel) {
                await Promise.all(items.map(item => Promise.resolve(action.execute(item, this.context))));
            }
            else {
                for (let item of items) {
                    await Promise.resolve(action.execute(item, this.context));
                }
            }
            if (persist) {
                this.prompt.start();
                this.ui.restoreWindow();
                if (action.reload)
                    await this.worker.loadItems(this.context, true);
            }
            else if (noQuit) {
                if (action.reload)
                    await this.worker.loadItems(this.context, true);
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    onInputChange() {
        if (this.timer)
            clearTimeout(this.timer);
        let len = this.worker.length;
        this.listOptions.input = this.prompt.input;
        // reload or filter items
        if (this.listOptions.interactive) {
            this.worker.stop();
            let ms = this.config.get('interactiveDebounceTime', 100);
            this.timer = setTimeout(async () => {
                await this.worker.loadItems(this.context);
            }, ms);
        }
        else if (len) {
            let wait = Math.max(Math.min(Math.floor(len / 200), 300), 50);
            this.timer = setTimeout(() => {
                this.worker.drawItems();
            }, wait);
        }
    }
    dispose() {
        if (this.timer) {
            clearTimeout(this.timer);
        }
        util_1.disposeAll(this.disposables);
        this.worker.dispose();
        this.ui.dispose();
    }
}
exports.default = ListSession;
//# sourceMappingURL=session.js.map

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fuzzy_1 = __webpack_require__(580);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('list-history');
class InputHistory {
    constructor(prompt, name) {
        this.prompt = prompt;
        this.name = name;
        this.index = -1;
        this.loaded = [];
        this.current = [];
        this.db = workspace_1.default.createDatabase(`list-${name}-history`);
        this.key = Buffer.from(workspace_1.default.cwd).toString('base64');
    }
    filter() {
        let { input } = this.prompt;
        if (input == this.curr)
            return;
        this.historyInput = '';
        let codes = fuzzy_1.getCharCodes(input);
        this.current = this.loaded.filter(s => fuzzy_1.fuzzyMatch(codes, s));
        this.index = -1;
    }
    get curr() {
        return this.index == -1 ? null : this.current[this.index];
    }
    load(input) {
        let { db } = this;
        input = input || '';
        let arr = db.fetch(this.key);
        if (!arr || !Array.isArray(arr)) {
            this.loaded = [];
        }
        else {
            this.loaded = arr;
        }
        this.index = -1;
        this.current = this.loaded.filter(s => s.startsWith(input));
    }
    add() {
        let { loaded, db, prompt } = this;
        let { input } = prompt;
        if (!input || input.length < 2 || input == this.historyInput)
            return;
        let idx = loaded.indexOf(input);
        if (idx != -1)
            loaded.splice(idx, 1);
        loaded.push(input);
        if (loaded.length > 200) {
            loaded = loaded.slice(-200);
        }
        db.push(this.key, loaded);
    }
    previous() {
        let { current, index } = this;
        if (!current || !current.length)
            return;
        if (index <= 0) {
            this.index = current.length - 1;
        }
        else {
            this.index = index - 1;
        }
        this.historyInput = this.prompt.input = current[this.index] || '';
    }
    next() {
        let { current, index } = this;
        if (!current || !current.length)
            return;
        if (index == current.length - 1) {
            this.index = 0;
        }
        else {
            this.index = index + 1;
        }
        this.historyInput = this.prompt.input = current[this.index] || '';
    }
}
exports.default = InputHistory;
//# sourceMappingURL=history.js.map

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getCharCodes(str) {
    let res = [];
    for (let i = 0, l = str.length; i < l; i++) {
        res.push(str.charCodeAt(i));
    }
    return res;
}
exports.getCharCodes = getCharCodes;
function wordChar(ch) {
    return (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90);
}
exports.wordChar = wordChar;
function caseMatch(input, code) {
    if (input == code)
        return true;
    if (input >= 97 && input <= 122 && code + 32 === input)
        return true;
    return false;
}
exports.caseMatch = caseMatch;
function fuzzyChar(a, b) {
    let ca = a.charCodeAt(0);
    let cb = b.charCodeAt(0);
    if (ca === cb)
        return true;
    if (ca >= 97 && ca <= 122 && cb + 32 === ca)
        return true;
    return false;
}
exports.fuzzyChar = fuzzyChar;
// upper case must match, lower case ignore case
function fuzzyMatch(needle, text) {
    let totalCount = needle.length;
    if (needle.length > text.length)
        return false;
    let i = 0;
    for (let j = 0; j < text.length; j++) {
        if (i === totalCount)
            break;
        let code = text.charCodeAt(j);
        let m = needle[i];
        if (code === m) {
            i = i + 1;
            continue;
        }
        // upper case match lower case
        if ((m >= 97 && m <= 122) && code + 32 === m) {
            i = i + 1;
            continue;
        }
    }
    return i === totalCount;
}
exports.fuzzyMatch = fuzzyMatch;
//# sourceMappingURL=fuzzy.js.map

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const util_1 = __webpack_require__(238);
const mutex_1 = __webpack_require__(255);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('list-ui');
const StatusLineOption = [
    '%#CocListMode#-- %{get(b:list_status, "mode", "")} --%*',
    '%{get(g:, "coc_list_loading_status", "")}',
    '%{get(b:list_status, "args", "")}',
    '(%L/%{get(b:list_status, "total", "")})',
    '%=',
    '%#CocListPath# %{get(b:list_status, "cwd", "")} %l/%L%*'
].join(' ');
class ListUI {
    constructor(nvim, name, listOptions, config) {
        this.nvim = nvim;
        this.name = name;
        this.listOptions = listOptions;
        this.config = config;
        this.newTab = false;
        this.currIndex = 0;
        this.drawCount = 0;
        this.highlights = [];
        this.items = [];
        this.disposables = [];
        this.selected = new Set();
        this.mutex = new mutex_1.Mutex();
        this._onDidChangeLine = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidLineChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDoubleClick = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeLine = this._onDidChangeLine.event;
        this.onDidLineChange = this._onDidLineChange.event;
        this.onDidOpen = this._onDidOpen.event;
        this.onDidClose = this._onDidClose.event;
        this.onDidChange = this._onDidChange.event;
        this.onDidDoubleClick = this._onDoubleClick.event;
        this.signOffset = config.get('signOffset');
        this.newTab = listOptions.position == 'tab';
        events_1.default.on('BufUnload', async (bufnr) => {
            if (bufnr != this.bufnr || this.window == null)
                return;
            this.window = null;
            this._onDidClose.fire(bufnr);
        }, null, this.disposables);
        events_1.default.on('CursorMoved', async (bufnr, cursor) => {
            if (bufnr != this.bufnr)
                return;
            this.onLineChange(cursor[0] - 1);
        }, null, this.disposables);
        let debounced = debounce_1.default(async (bufnr) => {
            if (bufnr != this.bufnr)
                return;
            let [winid, start, end] = await nvim.eval('[win_getid(),line("w0"),line("w$")]');
            if (end < 300)
                return;
            if (!this.window || winid != this.window.id)
                return;
            // increment highlights
            nvim.pauseNotification();
            this.doHighlight(start - 1, end);
            nvim.command('redraw', true);
            await nvim.resumeNotification(false, true);
        }, 100);
        this.disposables.push({
            dispose: () => {
                debounced.clear();
            }
        });
        events_1.default.on('CursorMoved', debounced, null, this.disposables);
    }
    onLineChange(index) {
        if (this.currIndex == index)
            return;
        this.currIndex = index;
        this._onDidChangeLine.fire(index);
    }
    set index(n) {
        if (n < 0 || n >= this.items.length)
            return;
        let { nvim } = this;
        nvim.pauseNotification();
        this.setCursor(n + 1, 0);
        nvim.command('redraw', true);
        nvim.resumeNotification(false, true).logError();
    }
    get index() {
        return this.currIndex;
    }
    get firstItem() {
        return this.items[0];
    }
    get lastItem() {
        return this.items[this.items.length - 1];
    }
    getItem(delta) {
        let { currIndex } = this;
        return this.items[currIndex + delta];
    }
    get item() {
        let { window } = this;
        if (!window)
            return Promise.resolve(null);
        return window.cursor.then(cursor => {
            this.currIndex = cursor[0] - 1;
            return this.items[this.currIndex];
        }, _e => null);
    }
    async echoMessage(item) {
        if (this.bufnr)
            return;
        let { items } = this;
        let idx = items.indexOf(item);
        let msg = `[${idx + 1}/${items.length}] ${item.label || ''}`;
        this.nvim.callTimer('coc#util#echo_lines', [[msg]], true);
    }
    async updateItem(item, index) {
        if (!this.bufnr || workspace_1.default.bufnr != this.bufnr)
            return;
        let obj = Object.assign({ resolved: true }, item);
        if (index < this.length) {
            this.items[index] = obj;
            let { nvim } = this;
            nvim.pauseNotification();
            nvim.command('setl modifiable', true);
            nvim.call('setline', [index + 1, obj.label], true);
            nvim.command('setl nomodifiable', true);
            await nvim.resumeNotification();
        }
    }
    async getItems() {
        if (this.length == 0 || !this.window)
            return [];
        let mode = await this.nvim.call('mode');
        if (mode == 'v' || mode == 'V') {
            let [start, end] = await this.getSelectedRange();
            let res = [];
            for (let i = start; i <= end; i++) {
                let item = this.items[i - 1];
                if (item)
                    res.push(item);
            }
            return res;
        }
        let { selectedItems } = this;
        if (selectedItems.length)
            return selectedItems;
        let item = await this.item;
        return item == null ? [] : [item];
    }
    async onMouse(event) {
        let { nvim, window } = this;
        let winid = await nvim.getVvar('mouse_winid');
        if (!window)
            return;
        let lnum = await nvim.getVvar('mouse_lnum');
        let col = await nvim.getVvar('mouse_col');
        if (event == 'mouseDown') {
            this.mouseDown = { winid, lnum, col, current: winid == window.id };
            return;
        }
        let current = winid == window.id;
        if (current && event == 'doubleClick') {
            this.setCursor(lnum, 0);
            this._onDoubleClick.fire();
        }
        if (!this.mouseDown || this.mouseDown.winid != this.mouseDown.winid)
            return;
        if (current && event == 'mouseDrag') {
            await this.selectLines(this.mouseDown.lnum, lnum);
        }
        else if (current && event == 'mouseUp') {
            if (this.mouseDown.lnum == lnum) {
                nvim.pauseNotification();
                this.clearSelection();
                this.setCursor(lnum, 0);
                nvim.command('redraw', true);
                await nvim.resumeNotification();
            }
            else {
                await this.selectLines(this.mouseDown.lnum, lnum);
            }
        }
        else if (!current && event == 'mouseUp') {
            nvim.pauseNotification();
            nvim.call('win_gotoid', winid, true);
            nvim.call('cursor', [lnum, col], true);
            await nvim.resumeNotification();
        }
    }
    async resume() {
        let { items, selected, nvim, signOffset } = this;
        await this.drawItems(items, this.height, true);
        if (selected.size > 0 && this.bufnr) {
            nvim.pauseNotification();
            for (let lnum of selected) {
                nvim.command(`sign place ${signOffset + lnum} line=${lnum} name=CocSelected buffer=${this.bufnr}`, true);
            }
            await nvim.resumeNotification();
        }
    }
    async toggleSelection() {
        let { nvim, selected, signOffset, bufnr } = this;
        if (workspace_1.default.bufnr != bufnr)
            return;
        let lnum = await nvim.call('line', '.');
        let mode = await nvim.call('mode');
        if (mode == 'v' || mode == 'V') {
            let [start, end] = await this.getSelectedRange();
            let exists = selected.has(start);
            let reverse = start > end;
            if (reverse)
                [start, end] = [end, start];
            for (let i = start; i <= end; i++) {
                if (!exists) {
                    selected.add(i);
                    nvim.command(`sign place ${signOffset + i} line=${i} name=CocSelected buffer=${bufnr}`, true);
                }
                else {
                    selected.delete(i);
                    nvim.command(`sign unplace ${signOffset + i} buffer=${bufnr}`, true);
                }
            }
            this.setCursor(end, 0);
            nvim.command('redraw', true);
            await nvim.resumeNotification();
            return;
        }
        let exists = selected.has(lnum);
        nvim.pauseNotification();
        if (exists) {
            selected.delete(lnum);
            nvim.command(`sign unplace ${signOffset + lnum} buffer=${bufnr}`, true);
        }
        else {
            selected.add(lnum);
            nvim.command(`sign place ${signOffset + lnum} line=${lnum} name=CocSelected buffer=${bufnr}`, true);
        }
        this.setCursor(lnum + 1, 0);
        nvim.command('redraw', true);
        await nvim.resumeNotification();
    }
    async selectLines(start, end) {
        let { nvim, signOffset, bufnr, length } = this;
        this.clearSelection();
        let { selected } = this;
        nvim.pauseNotification();
        let reverse = start > end;
        if (reverse)
            [start, end] = [end, start];
        for (let i = start; i <= end; i++) {
            if (i > length)
                break;
            selected.add(i);
            nvim.command(`sign place ${signOffset + i} line=${i} name=CocSelected buffer=${bufnr}`, true);
        }
        this.setCursor(end, 0);
        nvim.command('redraw', true);
        await nvim.resumeNotification();
    }
    async selectAll() {
        let { length } = this;
        if (length == 0)
            return;
        await this.selectLines(1, length);
    }
    clearSelection() {
        let { selected, nvim, signOffset, bufnr } = this;
        if (!bufnr)
            return;
        if (selected.size > 0) {
            let signIds = [];
            for (let lnum of selected) {
                signIds.push(signOffset + lnum);
            }
            nvim.call('coc#util#unplace_signs', [bufnr, signIds], true);
            this.selected = new Set();
        }
    }
    get shown() {
        return this.window != null;
    }
    get bufnr() {
        var _a;
        return (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.id;
    }
    get winid() {
        var _a;
        return (_a = this.window) === null || _a === void 0 ? void 0 : _a.id;
    }
    get ready() {
        if (this.window)
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            let timeout = setTimeout(() => {
                reject(new Error('window create timeout'));
            }, 3000);
            let disposable = this.onDidLineChange(() => {
                disposable.dispose();
                clearTimeout(timeout);
                resolve();
            });
        });
    }
    async drawItems(items, height, reload = false) {
        let count = this.drawCount = this.drawCount + 1;
        const { config, nvim, name, listOptions } = this;
        const release = await this.mutex.acquire();
        let limitLines = config.get('limitLines', 30000);
        this.items = items.slice(0, limitLines);
        const create = this.window == null;
        if (create) {
            try {
                let { position, numberSelect } = listOptions;
                let [bufnr, winid] = await nvim.call('coc#list#create', [position, height, name, numberSelect]);
                this.height = height;
                this.buffer = nvim.createBuffer(bufnr);
                this.window = nvim.createWindow(winid);
                this._onDidOpen.fire(this.bufnr);
            }
            catch (e) {
                release();
                workspace_1.default.showMessage(`Error on list create: ${e.message}`, 'error');
                return;
            }
        }
        release();
        if (count !== this.drawCount)
            return;
        let lines = this.items.map(item => item.label);
        this.clearSelection();
        let newIndex = reload ? this.currIndex : 0;
        await this.setLines(lines, false, newIndex);
        this._onDidLineChange.fire(this.currIndex + 1);
    }
    async appendItems(items) {
        if (!this.window)
            return;
        let { config } = this;
        let limitLines = config.get('limitLines', 1000);
        let curr = this.items.length;
        if (curr >= limitLines) {
            this._onDidChange.fire();
            return;
        }
        let max = limitLines - curr;
        let append = items.slice(0, max);
        this.items = this.items.concat(append);
        await this.setLines(append.map(item => item.label), curr > 0, this.currIndex);
    }
    async setLines(lines, append = false, index) {
        let { nvim, bufnr, window } = this;
        if (!bufnr || !window)
            return;
        let buf = nvim.createBuffer(bufnr);
        nvim.pauseNotification();
        if (!append) {
            window.notify('nvim_win_set_option', ['statusline', StatusLineOption]);
        }
        nvim.call('win_gotoid', window.id, true);
        if (!append) {
            nvim.call('clearmatches', [], true);
            if (!lines.length) {
                lines = ['No results, press ? on normal mode to get help.'];
                nvim.call('matchaddpos', ['Comment', [[1]], 99], true);
            }
        }
        nvim.command('setl modifiable', true);
        if (workspace_1.default.isVim) {
            nvim.call('coc#list#setlines', [lines, append], true);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            buf.setLines(lines, { start: append ? -1 : 0, end: -1, strictIndexing: false }, true);
        }
        nvim.command('setl nomodifiable', true);
        if (!append && index == 0) {
            this.doHighlight(0, 300);
        }
        else {
            let height = this.newTab ? workspace_1.default.env.lines : this.height;
            this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));
        }
        if (!append) {
            this.currIndex = index;
            window.notify('nvim_win_set_cursor', [[index + 1, 0]]);
        }
        this._onDidChange.fire();
        if (workspace_1.default.isVim)
            nvim.command('redraw', true);
        let res = await nvim.resumeNotification();
        if (res && res[1])
            logger.error(res[1]);
    }
    restoreWindow() {
        if (this.newTab)
            return;
        let { window, height } = this;
        if (window && height) {
            this.nvim.call('coc#list#restore', [window.id, height], true);
        }
    }
    close() {
        if (this.window) {
            this.window.close(true, true);
            this.window = null;
        }
    }
    dispose() {
        this.close();
        util_1.disposeAll(this.disposables);
        this._onDidChangeLine.dispose();
        this._onDidOpen.dispose();
        this._onDidClose.dispose();
        this._onDidChange.dispose();
        this._onDidLineChange.dispose();
        this._onDoubleClick.dispose();
    }
    get length() {
        return this.items.length;
    }
    get selectedItems() {
        let { selected, items } = this;
        let res = [];
        for (let i of selected) {
            if (items[i - 1])
                res.push(items[i - 1]);
        }
        return res;
    }
    doHighlight(start, end) {
        let { nvim } = workspace_1.default;
        let { highlights, items } = this;
        for (let i = start; i <= Math.min(end, items.length - 1); i++) {
            let { ansiHighlights } = items[i];
            let highlight = highlights[i];
            if (ansiHighlights) {
                for (let hi of ansiHighlights) {
                    let { span, hlGroup } = hi;
                    nvim.call('matchaddpos', [hlGroup, [[i + 1, span[0] + 1, span[1] - span[0]]], 9], true);
                }
            }
            if (highlight) {
                let { spans, hlGroup } = highlight;
                for (let span of spans) {
                    nvim.call('matchaddpos', [hlGroup || 'Search', [[i + 1, span[0] + 1, span[1] - span[0]]], 11], true);
                }
            }
        }
    }
    setCursor(lnum, col) {
        let { window, items } = this;
        let max = items.length == 0 ? 1 : items.length;
        if (lnum > max)
            return;
        // change index since CursorMoved event not fired (seems bug of neovim)!
        this.onLineChange(lnum - 1);
        if (window)
            window.notify('nvim_win_set_cursor', [[lnum, col]]);
    }
    addHighlights(highlights, append = false) {
        let limitLines = this.config.get('limitLines', 1000);
        if (!append) {
            this.highlights = highlights.slice(0, limitLines);
        }
        else {
            if (this.highlights.length < limitLines) {
                this.highlights = this.highlights.concat(highlights.slice(0, limitLines - this.highlights.length));
            }
        }
    }
    async getSelectedRange() {
        let { nvim } = this;
        await nvim.call('coc#list#stop_prompt');
        await nvim.eval('feedkeys("\\<esc>", "in")');
        let [, start] = await nvim.call('getpos', "'<");
        let [, end] = await nvim.call('getpos', "'>");
        if (start > end) {
            [start, end] = [end, start];
        }
        let method = workspace_1.default.isVim ? 'coc#list#prompt_start' : 'coc#list#start_prompt';
        this.nvim.call(method, [], true);
        return [start, end];
    }
}
exports.default = ListUI;
//# sourceMappingURL=ui.js.map

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const ansiparse_1 = __webpack_require__(524);
const diff_1 = __webpack_require__(309);
const fzy_1 = __webpack_require__(583);
const score_1 = __webpack_require__(584);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
const logger = __webpack_require__(64)('list-worker');
const controlCode = '\x1b';
// perform loading task
class Worker {
    constructor(nvim, list, prompt, listOptions, config) {
        this.nvim = nvim;
        this.list = list;
        this.prompt = prompt;
        this.listOptions = listOptions;
        this.config = config;
        this.recentFiles = [];
        this._loading = false;
        this.totalItems = [];
        this._onDidChangeItems = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeItems = this._onDidChangeItems.event;
        let mru = workspace_1.default.createMru('mru');
        mru.load().then(files => {
            this.recentFiles = files;
        }).logError();
    }
    set loading(loading) {
        if (this._loading == loading)
            return;
        this._loading = loading;
        let { nvim } = this;
        if (loading) {
            this.interval = setInterval(() => {
                let idx = Math.floor((new Date()).getMilliseconds() / 100);
                nvim.pauseNotification();
                nvim.setVar('coc_list_loading_status', frames[idx], true);
                nvim.command('redraws', true);
                nvim.resumeNotification(false, true).logError();
            }, 100);
        }
        else {
            if (this.interval) {
                clearInterval(this.interval);
                nvim.pauseNotification();
                nvim.setVar('coc_list_loading_status', '', true);
                nvim.command('redraws', true);
                nvim.resumeNotification(false, true).logError();
            }
        }
    }
    get isLoading() {
        return this._loading;
    }
    async loadItems(context, reload = false) {
        let { list, listOptions } = this;
        this.loading = true;
        let { interactive } = listOptions;
        let source = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let token = source.token;
        let items = await list.loadItems(context, token);
        if (token.isCancellationRequested)
            return;
        if (!items || Array.isArray(items)) {
            items = (items || []);
            this.totalItems = items.map(item => {
                item.label = this.fixLabel(item.label);
                this.parseListItemAnsi(item);
                return item;
            });
            this.loading = false;
            let highlights = [];
            if (!interactive) {
                let res = this.filterItems(items);
                items = res.items;
                highlights = res.highlights;
            }
            else {
                highlights = this.getItemsHighlight(items);
            }
            this._onDidChangeItems.fire({
                items,
                highlights,
                reload,
                finished: true
            });
        }
        else {
            let task = items;
            let totalItems = this.totalItems = [];
            let count = 0;
            let currInput = context.input;
            let timer;
            let lastTs;
            let _onData = (finished) => {
                lastTs = Date.now();
                if (token.isCancellationRequested)
                    return;
                if (count >= totalItems.length)
                    return;
                let inputChanged = this.input != currInput;
                if (interactive && inputChanged)
                    return;
                if (count == 0 || inputChanged) {
                    currInput = this.input;
                    count = totalItems.length;
                    let items;
                    let highlights = [];
                    if (interactive) {
                        items = totalItems.slice();
                        highlights = this.getItemsHighlight(items);
                    }
                    else {
                        let res = this.filterItems(totalItems);
                        items = res.items;
                        highlights = res.highlights;
                    }
                    this._onDidChangeItems.fire({ items, highlights, reload, append: false, finished });
                }
                else {
                    let remain = totalItems.slice(count);
                    count = totalItems.length;
                    let items;
                    let highlights = [];
                    if (!interactive) {
                        let res = this.filterItems(remain);
                        items = res.items;
                        highlights = res.highlights;
                    }
                    else {
                        items = remain;
                        highlights = this.getItemsHighlight(remain);
                    }
                    this._onDidChangeItems.fire({ items, highlights, append: true, finished });
                }
            };
            task.on('data', item => {
                if (timer)
                    clearTimeout(timer);
                if (token.isCancellationRequested)
                    return;
                if (interactive && this.input != currInput)
                    return;
                item.label = this.fixLabel(item.label);
                this.parseListItemAnsi(item);
                totalItems.push(item);
                if ((!lastTs && totalItems.length == 500)
                    || Date.now() - lastTs > 200) {
                    _onData();
                }
                else {
                    timer = setTimeout(() => _onData(), 50);
                }
            });
            let onEnd = () => {
                if (task == null)
                    return;
                task = null;
                this.loading = false;
                disposable.dispose();
                if (timer)
                    clearTimeout(timer);
                if (totalItems.length == 0) {
                    this._onDidChangeItems.fire({ items: [], highlights: [], finished: true });
                }
                else {
                    _onData(true);
                }
            };
            let disposable = token.onCancellationRequested(onEnd);
            task.on('error', async (error) => {
                if (task == null)
                    return;
                task = null;
                this.loading = false;
                disposable.dispose();
                if (timer)
                    clearTimeout(timer);
                this.nvim.call('coc#list#stop_prompt', [], true);
                workspace_1.default.showMessage(`Task error: ${error.toString()}`, 'error');
                logger.error(error);
            });
            task.on('end', onEnd);
        }
    }
    /*
     * Draw all items with filter if necessary
     */
    drawItems() {
        let { totalItems, listOptions } = this;
        let items = totalItems;
        let highlights = [];
        if (!listOptions.interactive) {
            let res = this.filterItems(totalItems);
            items = res.items;
            highlights = res.highlights;
        }
        else {
            highlights = this.getItemsHighlight(items);
        }
        this._onDidChangeItems.fire({ items, highlights, finished: true });
    }
    stop() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
        this.loading = false;
    }
    get length() {
        return this.totalItems.length;
    }
    get input() {
        return this.prompt.input;
    }
    getItemsHighlight(items) {
        let { input } = this;
        if (!input)
            return [];
        return items.map(item => {
            let filterLabel = getFilterLabel(item);
            if (filterLabel == '')
                return null;
            let res = score_1.getMatchResult(filterLabel, input);
            if (!res || !res.score)
                return null;
            return this.getHighlights(filterLabel, res.matches);
        });
    }
    filterItems(items) {
        let { input } = this;
        let highlights = [];
        let { sort, matcher, ignorecase } = this.listOptions;
        if (input.length == 0) {
            let filtered = items.slice();
            let sort = filtered.length && typeof filtered[0].recentScore == 'number';
            return {
                items: sort ? filtered.sort((a, b) => b.recentScore - a.recentScore) : filtered,
                highlights
            };
        }
        let filtered;
        if (input.length > 0) {
            let inputs = this.config.extendedSearchMode ? input.split(/\s+/) : [input];
            if (matcher == 'strict') {
                filtered = items.filter(item => {
                    let spans = [];
                    let filterLabel = getFilterLabel(item);
                    for (let input of inputs) {
                        let idx = ignorecase ? filterLabel.toLowerCase().indexOf(input.toLowerCase()) : filterLabel.indexOf(input);
                        if (idx == -1)
                            return false;
                        spans.push([string_1.byteIndex(filterLabel, idx), string_1.byteIndex(filterLabel, idx + string_1.byteLength(input))]);
                    }
                    highlights.push({ spans });
                    return true;
                });
            }
            else if (matcher == 'regex') {
                let flags = ignorecase ? 'iu' : 'u';
                let regexes = inputs.reduce((p, c) => {
                    try {
                        let regex = new RegExp(c, flags);
                        p.push(regex);
                    }
                    catch (e) { }
                    return p;
                }, []);
                filtered = items.filter(item => {
                    let spans = [];
                    let filterLabel = getFilterLabel(item);
                    for (let regex of regexes) {
                        let ms = filterLabel.match(regex);
                        if (ms == null)
                            return false;
                        spans.push([string_1.byteIndex(filterLabel, ms.index), string_1.byteIndex(filterLabel, ms.index + string_1.byteLength(ms[0]))]);
                    }
                    highlights.push({ spans });
                    return true;
                });
            }
            else {
                filtered = items.filter(item => {
                    let filterText = item.filterText || item.label;
                    return inputs.every(s => fzy_1.hasMatch(s, filterText));
                });
                filtered = filtered.map(item => {
                    let filterLabel = getFilterLabel(item);
                    let matchScore = 0;
                    let matches = [];
                    for (let input of inputs) {
                        matches.push(...fzy_1.positions(input, filterLabel));
                        matchScore += fzy_1.score(input, filterLabel);
                    }
                    let { recentScore } = item;
                    if (!recentScore && item.location) {
                        let uri = getItemUri(item);
                        if (uri.startsWith('file')) {
                            let fsPath = vscode_uri_1.URI.parse(uri).fsPath;
                            recentScore = -this.recentFiles.indexOf(fsPath);
                        }
                    }
                    return Object.assign({}, item, {
                        filterLabel,
                        score: matchScore,
                        recentScore,
                        matches
                    });
                });
                if (sort && items.length) {
                    filtered.sort((a, b) => {
                        if (a.score != b.score)
                            return b.score - a.score;
                        if (input.length && a.recentScore != b.recentScore) {
                            return (a.recentScore || -Infinity) - (b.recentScore || -Infinity);
                        }
                        if (a.location && b.location) {
                            let au = getItemUri(a);
                            let bu = getItemUri(b);
                            return au > bu ? 1 : -1;
                        }
                        return a.label > b.label ? 1 : -1;
                    });
                }
                for (let item of filtered) {
                    if (!item.matches)
                        continue;
                    let hi = this.getHighlights(item.filterLabel, item.matches);
                    highlights.push(hi);
                }
            }
        }
        return {
            items: filtered,
            highlights
        };
    }
    getHighlights(text, matches) {
        let spans = [];
        if (matches.length) {
            let start = matches.shift();
            let next = matches.shift();
            let curr = start;
            while (next) {
                if (next == curr + 1) {
                    curr = next;
                    next = matches.shift();
                    continue;
                }
                spans.push([string_1.byteIndex(text, start), string_1.byteIndex(text, curr) + 1]);
                start = next;
                curr = start;
                next = matches.shift();
            }
            spans.push([string_1.byteIndex(text, start), string_1.byteIndex(text, curr) + 1]);
        }
        return { spans };
    }
    // set correct label, add ansi highlights
    parseListItemAnsi(item) {
        let { label } = item;
        if (item.ansiHighlights || !label.includes(controlCode))
            return;
        let { line, highlights } = ansiparse_1.parseAnsiHighlights(label);
        item.label = line;
        item.ansiHighlights = highlights;
    }
    fixLabel(label) {
        let { columns } = workspace_1.default.env;
        label = label.split('\n').join(' ');
        return label.slice(0, columns * 2);
    }
    dispose() {
        this._onDidChangeItems.dispose();
        this.stop();
    }
}
exports.default = Worker;
function getFilterLabel(item) {
    return item.filterText != null ? diff_1.patchLine(item.filterText, item.label) : item.label;
}
function getItemUri(item) {
    let { location } = item;
    if (typeof location == 'string')
        return location;
    return location.uri;
}
//# sourceMappingURL=worker.js.map

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
let SCORE_MIN = -Infinity;
let SCORE_MAX = Infinity;
let SCORE_GAP_LEADING = -0.005;
let SCORE_GAP_TRAILING = -0.005;
let SCORE_GAP_INNER = -0.01;
let SCORE_MATCH_CONSECUTIVE = 1;
let SCORE_MATCH_SLASH = 0.9;
let SCORE_MATCH_WORD = 0.8;
let SCORE_MATCH_CAPITAL = 0.7;
let SCORE_MATCH_DOT = 0.6;
function islower(s) {
    return s.toLowerCase() === s;
}
function isupper(s) {
    return s.toUpperCase() === s;
}
function precompute_bonus(haystack) {
    /* Which positions are beginning of words */
    let m = haystack.length;
    let match_bonus = new Array(m);
    let last_ch = '/';
    for (let i = 0; i < m; i++) {
        let ch = haystack[i];
        if (last_ch === '/') {
            match_bonus[i] = SCORE_MATCH_SLASH;
        }
        else if (last_ch === '-' || last_ch === '_' || last_ch === ' ') {
            match_bonus[i] = SCORE_MATCH_WORD;
        }
        else if (last_ch === '.') {
            match_bonus[i] = SCORE_MATCH_DOT;
        }
        else if (islower(last_ch) && isupper(ch)) {
            match_bonus[i] = SCORE_MATCH_CAPITAL;
        }
        else {
            match_bonus[i] = 0;
        }
        last_ch = ch;
    }
    return match_bonus;
}
function compute(needle, haystack, D, M) {
    let n = needle.length;
    let m = haystack.length;
    let lower_needle = needle.toLowerCase();
    let lower_haystack = haystack.toLowerCase();
    let match_bonus = precompute_bonus(haystack);
    /*
     * D[][] Stores the best score for this position ending with a match.
     * M[][] Stores the best possible score at this position.
     */
    for (let i = 0; i < n; i++) {
        D[i] = new Array(m);
        M[i] = new Array(m);
        let prev_score = SCORE_MIN;
        let gap_score = i === n - 1 ? SCORE_GAP_TRAILING : SCORE_GAP_INNER;
        for (let j = 0; j < m; j++) {
            if (lower_needle[i] === lower_haystack[j]) {
                let score = SCORE_MIN;
                if (!i) {
                    score = (j * SCORE_GAP_LEADING) + match_bonus[j];
                }
                else if (j) { /* i > 0 && j > 0*/
                    score = Math.max(M[i - 1][j - 1] + match_bonus[j], 
                    /* consecutive match, doesn't stack with match_bonus */
                    D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE);
                }
                D[i][j] = score;
                M[i][j] = prev_score = Math.max(score, prev_score + gap_score);
            }
            else {
                D[i][j] = SCORE_MIN;
                M[i][j] = prev_score = prev_score + gap_score;
            }
        }
    }
}
function score(needle, haystack) {
    let n = needle.length;
    let m = haystack.length;
    if (!n || !m)
        return SCORE_MIN;
    if (n === m) {
        /* Since this method can only be called with a haystack which
         * matches needle. If the lengths of the strings are equal the
         * strings themselves must also be equal (ignoring case).
         */
        return SCORE_MAX;
    }
    if (m > 1024) {
        /*
         * Unreasonably large candidate: return no score
         * If it is a valid match it will still be returned, it will
         * just be ranked below any reasonably sized candidates
         */
        return SCORE_MIN;
    }
    let D = new Array(n);
    let M = new Array(n);
    compute(needle, haystack, D, M);
    return M[n - 1][m - 1];
}
exports.score = score;
function positions(needle, haystack) {
    let n = needle.length;
    let m = haystack.length;
    let positions = new Array(n);
    if (!n || !m)
        return positions;
    if (n === m) {
        for (let i = 0; i < n; i++)
            positions[i] = i;
        return positions;
    }
    if (m > 1024) {
        return positions;
    }
    let D = new Array(n);
    let M = new Array(n);
    compute(needle, haystack, D, M);
    /* backtrack to find the positions of optimal matching */
    let match_required = false;
    for (let i = n - 1, j = m - 1; i >= 0; i--) {
        for (; j >= 0; j--) {
            /*
             * There may be multiple paths which result in
             * the optimal weight.
             *
             * For simplicity, we will pick the first one
             * we encounter, the latest in the candidate
             * string.
             */
            if (D[i][j] !== SCORE_MIN &&
                (match_required || D[i][j] === M[i][j])) {
                /* If this score was determined using
                 * SCORE_MATCH_CONSECUTIVE, the
                 * previous character MUST be a match
                 */
                match_required =
                    i && j &&
                        M[i][j] === D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE;
                positions[i] = j--;
                break;
            }
        }
    }
    return positions;
}
exports.positions = positions;
function hasMatch(needle, haystack) {
    needle = needle.toLowerCase();
    haystack = haystack.toLowerCase();
    let l = needle.length;
    for (let i = 0, j = 0; i < l; i += 1) {
        j = haystack.indexOf(needle[i], j) + 1;
        if (j === 0)
            return false;
    }
    return true;
}
exports.hasMatch = hasMatch;
//# sourceMappingURL=fzy.js.map

/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(82);
const fuzzy_1 = __webpack_require__(580);
// first is start or path start +1, fuzzy +0.5
// next is followed of path start +1, fuzzy +0.5
// filename startsWith +1, fuzzy +0.5
function getMatchResult(text, query, filename = '') {
    if (!query)
        return { score: 1 };
    let matches = [];
    let codes = fuzzy_1.getCharCodes(query);
    let filenameIdx = filename ? text.indexOf(filename) : -1;
    let matchBase = filenameIdx != -1 && fuzzy_1.fuzzyMatch(codes, filename);
    let score = 0;
    let c = query[0];
    let idx = 0;
    // base => start => pathSeparator => fuzzy
    if (matchBase) {
        if (filename.startsWith(c)) {
            score = score + 2;
            idx = filenameIdx + 1;
            matches.push(filenameIdx);
        }
        else if (filename[0].toLowerCase() == c) {
            score = score + 1.5;
            idx = filenameIdx + 1;
            matches.push(filenameIdx);
        }
        else {
            for (let i = 1; i < filename.length; i++) {
                if (fuzzy_1.fuzzyChar(c, filename[i])) {
                    score = score + 1;
                    idx = filenameIdx + i + 1;
                    matches.push(filenameIdx + i);
                    break;
                }
            }
        }
    }
    else if (text.startsWith(c)) {
        score = score + 1;
        matches.push(0);
        idx = 1;
    }
    else {
        for (let i = 1; i < text.length; i++) {
            let pre = text[i - 1];
            if (pre == path_1.sep && text[i] == c) {
                score = score + 1;
                matches.push(i);
                idx = i + 1;
                break;
            }
        }
        if (idx == 0) {
            for (let i = 0; i < text.length; i++) {
                if (fuzzy_1.fuzzyChar(c, text[i])) {
                    score = score + 0.5;
                    matches.push(i);
                    idx = i + 1;
                    break;
                }
            }
        }
    }
    if (idx == 0)
        return { score: 0 };
    if (codes.length == 1)
        return { score, matches };
    return nextResult(codes.slice(1), text, idx, { score, matches });
}
exports.getMatchResult = getMatchResult;
/**
 *
 * @public
 * @param {number[]} codes - remain codes
 * @param {string} text - total text
 * @param {number} idx - start index of text
 * @param {MatchResult} curr - current result
 * @returns {MatchResult | null}
 */
function nextResult(codes, text, idx, curr) {
    let { score, matches } = curr;
    let results = [];
    let c = codes[0];
    let remain = codes.slice(1);
    let result;
    function getRemianResult(index) {
        if (!result)
            return;
        if (remain.length == 0) {
            results.push(result);
        }
        else if (result) {
            let res = nextResult(remain, text, index, result);
            if (res)
                results.push(res);
        }
    }
    let followed = idx < text.length ? text[idx].charCodeAt(0) : null;
    if (!followed)
        return null;
    if (followed == c) {
        result = { score: score + 1, matches: matches.concat([idx]) };
        getRemianResult(idx + 1);
    }
    else if (fuzzy_1.caseMatch(c, followed)) {
        result = { score: score + 0.5, matches: matches.concat([idx]) };
        getRemianResult(idx + 1);
    }
    if (idx + 1 < text.length) {
        // follow path
        for (let i = idx + 1; i < text.length; i++) {
            let ch = text[i].charCodeAt(0);
            if (text[i - 1] == path_1.sep && fuzzy_1.caseMatch(c, ch)) {
                let add = c == ch ? 1 : 0.5;
                result = { score: score + add, matches: matches.concat([i]) };
                getRemianResult(i + 1);
                break;
            }
        }
        // next fuzzy
        for (let i = idx + 1; i < text.length; i++) {
            let ch = text[i].charCodeAt(0);
            if (fuzzy_1.caseMatch(c, ch)) {
                let add = c == ch ? 0.5 : 0.2;
                result = { score: score + add, matches: matches.concat([i]) };
                getRemianResult(i + 1);
                break;
            }
        }
    }
    return results.length ? bestResult(results) : null;
}
function bestResult(results) {
    let res = results[0];
    for (let i = 1; i < results.length; i++) {
        if (results[i].score > res.score) {
            res = results[i];
        }
    }
    return res;
}
//# sourceMappingURL=score.js.map

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const manager_1 = tslib_1.__importDefault(__webpack_require__(253));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const services_1 = tslib_1.__importDefault(__webpack_require__(525));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
const logger = __webpack_require__(64)('list-actions');
class ActionsList extends basic_1.default {
    constructor(nvim) {
        super(nvim);
        this.defaultAction = 'do';
        this.description = 'code actions of selected range.';
        this.name = 'actions';
        this.options = [{
                name: '-start',
                description: 'start of line',
                hasValue: true
            }, {
                name: '-end',
                description: 'end of line',
                hasValue: true
            }, {
                name: '-quickfix',
                description: 'quickfix only',
            }, {
                name: '-source',
                description: 'source action only'
            }];
        this.addAction('do', async (item) => {
            let action = item.data.action;
            let { command, edit } = action;
            if (edit)
                await workspace_1.default.applyEdit(edit);
            if (command) {
                if (commands_1.default.has(command.command)) {
                    commands_1.default.execute(command);
                }
                else {
                    let clientId = action.clientId;
                    let service = services_1.default.getService(clientId);
                    let params = {
                        command: command.command,
                        arguments: command.arguments
                    };
                    if (service.client) {
                        let { client } = service;
                        client
                            .sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params)
                            .then(undefined, error => {
                            workspace_1.default.showMessage(`Execute '${command.command} error: ${error}'`, 'error');
                        });
                    }
                }
            }
        });
    }
    async loadItems(context) {
        let buf = await context.window.buffer;
        let doc = workspace_1.default.getDocument(buf.id);
        if (!doc)
            return null;
        let args = this.parseArguments(context.args);
        let range;
        if (args.start && args.end) {
            range = vscode_languageserver_protocol_1.Range.create(parseInt(args.start, 10) - 1, 0, parseInt(args.end, 10), 0);
        }
        else {
            range = vscode_languageserver_protocol_1.Range.create(0, 0, doc.lineCount, 0);
        }
        let diagnostics = manager_1.default.getDiagnosticsInRange(doc.textDocument, range);
        let actionContext = { diagnostics };
        if (args.quickfix) {
            actionContext.only = [vscode_languageserver_protocol_1.CodeActionKind.QuickFix];
        }
        else if (args.source) {
            actionContext.only = [vscode_languageserver_protocol_1.CodeActionKind.Source];
        }
        let codeActionsMap = await languages_1.default.getCodeActions(doc.textDocument, range, actionContext);
        if (!codeActionsMap)
            return [];
        let codeActions = [];
        for (let clientId of codeActionsMap.keys()) {
            let actions = codeActionsMap.get(clientId);
            for (let action of actions) {
                codeActions.push(Object.assign({ clientId }, action));
            }
        }
        codeActions.sort((a, b) => {
            if (a.isPreferred && !b.isPreferred) {
                return -1;
            }
            if (b.isPreferred && !a.isPreferred) {
                return 1;
            }
            return 0;
        });
        let items = codeActions.map(action => ({
            label: `${action.title} ${action.clientId ? `[${action.clientId}]` : ''} ${action.kind ? `(${action.kind})` : ''}`,
            data: { action }
        }));
        return items;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocActionsTitle /\\v^[^[]+/ contained containedin=CocActionsLine', true);
        nvim.command('syntax match CocActionsClient /\\[\\w\\+\\]/ contained containedin=CocActionsLine', true);
        nvim.command('syntax match CocActionsKind /\\v\\(.*\\)$/ contained containedin=CocActionsLine', true);
        nvim.command('highlight default link CocActionsTitle Normal', true);
        nvim.command('highlight default link CocActionsClient Typedef', true);
        nvim.command('highlight default link CocActionsKind Comment', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = ActionsList;
//# sourceMappingURL=actions.js.map

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const readline_1 = tslib_1.__importDefault(__webpack_require__(206));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const util_1 = __webpack_require__(238);
const position_1 = __webpack_require__(311);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const configuration_1 = tslib_1.__importDefault(__webpack_require__(542));
const logger = __webpack_require__(64)('list-basic');
class BasicList {
    constructor(nvim) {
        this.nvim = nvim;
        this.defaultAction = 'open';
        this.actions = [];
        this.options = [];
        this.disposables = [];
        this.config = new configuration_1.default();
    }
    get hlGroup() {
        return this.config.get('previewHighlightGroup', 'Search');
    }
    get previewHeight() {
        return this.config.get('maxPreviewHeight', 12);
    }
    get splitRight() {
        return this.config.get('previewSplitRight', false);
    }
    parseArguments(args) {
        if (!this.optionMap) {
            this.optionMap = new Map();
            for (let opt of this.options) {
                let parts = opt.name.split(/,\s*/g).map(s => s.replace(/\s+.*/g, ''));
                let name = opt.key ? opt.key : parts[parts.length - 1].replace(/^-/, '');
                for (let p of parts) {
                    this.optionMap.set(p, { name, hasValue: opt.hasValue });
                }
            }
        }
        let res = {};
        for (let i = 0; i < args.length; i++) {
            let arg = args[i];
            let def = this.optionMap.get(arg);
            if (!def) {
                logger.error(`Option "${arg}" of "${this.name}" not found`);
                continue;
            }
            let value = true;
            if (def.hasValue) {
                value = args[i + 1] || '';
                i = i + 1;
            }
            res[def.name] = value;
        }
        return res;
    }
    /**
     * Get configuration of current list
     */
    getConfig() {
        return workspace_1.default.getConfiguration(`list.source.${this.name}`);
    }
    addAction(name, fn, options) {
        this.createAction(Object.assign({
            name,
            execute: fn
        }, options || {}));
    }
    addMultipleAction(name, fn, options) {
        this.createAction(Object.assign({
            name,
            multiple: true,
            execute: fn
        }, options || {}));
    }
    addLocationActions() {
        this.createAction({
            name: 'preview',
            execute: async (item, context) => {
                let loc = await this.convertLocation(item.location);
                await this.previewLocation(loc, context);
            }
        });
        let { nvim } = this;
        this.createAction({
            name: 'quickfix',
            multiple: true,
            execute: async (items) => {
                let quickfixItems = await Promise.all(items.map(item => this.convertLocation(item.location).then(loc => workspace_1.default.getQuickfixItem(loc))));
                await nvim.call('setqflist', [quickfixItems]);
                let openCommand = await nvim.getVar('coc_quickfix_open_command');
                nvim.command(typeof openCommand === 'string' ? openCommand : 'copen', true);
            }
        });
        for (let name of ['open', 'tabe', 'drop', 'vsplit', 'split']) {
            this.createAction({
                name,
                execute: async (item) => {
                    await this.jumpTo(item.location, name == 'open' ? null : name);
                }
            });
        }
    }
    async convertLocation(location) {
        if (typeof location == 'string')
            return vscode_languageserver_protocol_1.Location.create(location, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
        if (vscode_languageserver_protocol_1.Location.is(location))
            return location;
        let u = vscode_uri_1.URI.parse(location.uri);
        if (u.scheme != 'file')
            return vscode_languageserver_protocol_1.Location.create(location.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
        const rl = readline_1.default.createInterface({
            input: fs_1.default.createReadStream(u.fsPath, { encoding: 'utf8' }),
        });
        let match = location.line;
        let n = 0;
        let resolved = false;
        let line = await new Promise(resolve => {
            rl.on('line', line => {
                if (resolved)
                    return;
                if (line.includes(match)) {
                    rl.removeAllListeners();
                    rl.close();
                    resolved = true;
                    resolve(line);
                    return;
                }
                n = n + 1;
            });
            rl.on('error', e => {
                this.nvim.errWriteLine(`Read ${u.fsPath} error: ${e.message}`);
                resolve(null);
            });
        });
        if (line != null) {
            let character = location.text ? line.indexOf(location.text) : 0;
            if (character == 0)
                character = line.match(/^\s*/)[0].length;
            let end = vscode_languageserver_protocol_1.Position.create(n, character + (location.text ? location.text.length : 0));
            return vscode_languageserver_protocol_1.Location.create(location.uri, vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(n, character), end));
        }
        return vscode_languageserver_protocol_1.Location.create(location.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
    }
    async jumpTo(location, command) {
        if (typeof location == 'string') {
            await workspace_1.default.jumpTo(location, null, command);
            return;
        }
        let { range, uri } = await this.convertLocation(location);
        let position = range.start;
        if (position.line == 0 && position.character == 0 && position_1.comparePosition(position, range.end) == 0) {
            // allow plugin that remember position.
            position = null;
        }
        await workspace_1.default.jumpTo(uri, position, command);
    }
    createAction(action) {
        let { name } = action;
        let idx = this.actions.findIndex(o => o.name == name);
        // allow override
        if (idx !== -1)
            this.actions.splice(idx, 1);
        this.actions.push(action);
    }
    async previewLocation(location, context) {
        if (!context.listWindow)
            return;
        let { nvim } = this;
        let { uri, range } = location;
        let lineCount = Infinity;
        let doc = workspace_1.default.getDocument(location.uri);
        if (doc)
            lineCount = doc.lineCount;
        let height = Math.min(this.previewHeight, lineCount);
        let u = vscode_uri_1.URI.parse(uri);
        // handle different scheme
        if (u.scheme == 'untitled' || u.scheme == 'unknown') {
            let bufnr = parseInt(u.path, 10);
            let valid = await nvim.call('bufloaded', [bufnr]);
            let lnum = location.range.start.line + 1;
            if (valid) {
                let name = await nvim.call('bufname', [bufnr]);
                name = name || '[No Name]';
                let filetype = await nvim.call('getbufvar', [bufnr, '&filetype']);
                let lines = await nvim.call('getbufline', [bufnr, 1, '$']);
                await this.preview({ bufname: name, sketch: true, filetype: filetype || 'txt', lnum, lines }, context);
            }
            else {
                await this.preview({ sketch: true, filetype: 'txt', lines: [] }, context);
            }
            return;
        }
        // check
        let filepath = u.scheme == 'file' ? u.fsPath : u.toString();
        nvim.pauseNotification();
        nvim.call('fnameescape', filepath, true);
        nvim.call('buflisted', filepath, true);
        nvim.call('eval', `!empty(getwininfo(${context.window.id}))`, true);
        let [res, error] = await nvim.resumeNotification();
        if (error) {
            logger.error(error);
            return;
        }
        // open previewwindow
        let { position } = context.options;
        let [escaped, exists, valid] = res;
        let lnum = range.start.line + 1;
        let winid = context.listWindow.id;
        let positions = await workspace_1.default.getHighlightPositions(uri, range);
        nvim.pauseNotification();
        nvim.command('pclose', true);
        if (this.splitRight || position == 'tab') {
            if (valid && this.splitRight)
                nvim.call('win_gotoid', [context.window.id], true);
            nvim.command(`silent belowright vs +setl\\ previewwindow ${escaped}`, true);
        }
        else {
            let mod = context.options.position == 'top' ? 'below' : 'above';
            nvim.command(`silent ${mod} ${height}sp +setl\\ previewwindow ${escaped}`, true);
            nvim.command(`exe "normal! z${height}\\<cr>"`, true);
        }
        nvim.command(`exe ${lnum}`, true);
        nvim.command('setl winfixheight nofoldenable', true);
        for (let pos of positions) {
            nvim.call('matchaddpos', [this.hlGroup, [pos]], true);
        }
        if (!exists)
            nvim.command('setl nobuflisted bufhidden=wipe', true);
        nvim.command('normal! zt', true);
        nvim.call('win_gotoid', [winid], true);
        if (workspace_1.default.isVim)
            nvim.command('redraw', true);
        let [, err] = await nvim.resumeNotification();
        if (err)
            console.error(`Error on ${err[0]}: ${err[1]} - ${err[2]}`);
    }
    async preview(options, context) {
        let { nvim } = this;
        let { bufname, filetype, sketch, lines, lnum } = options;
        if (!bufname)
            sketch = true;
        let mod = context.options.position == 'top' ? 'below' : 'above';
        let height = Math.min(this.previewHeight, lines ? Math.max(lines.length, 1) : Infinity);
        let winid = context.listWindow.id;
        let valid = await context.window.valid;
        nvim.pauseNotification();
        nvim.command('pclose', true);
        if (this.splitRight || context.options.position == 'tab') {
            if (valid && this.splitRight)
                nvim.call('win_gotoid', [context.window.id], true);
            if (bufname) {
                nvim.command(`silent belowright vs +setl\\ previewwindow ${bufname}`, true);
            }
            else {
                nvim.command(`silent belowright vnew +setl\\ previewwindow`, true);
            }
        }
        else {
            if (bufname) {
                nvim.command(`silent ${mod} ${height}sp +setl\\ previewwindow ${bufname}`, true);
            }
            else {
                nvim.command(`silent ${mod} ${height}new +setl\\ previewwindow`, true);
            }
            nvim.command(`exe "normal! z${height}\\<cr>"`, true);
        }
        if (lines && lines.length) {
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
        }
        nvim.command(`exe ${lnum || 1}`, true);
        nvim.command('setl winfixheight nomodifiable', true);
        if (sketch)
            nvim.command('setl buftype=nofile bufhidden=wipe nobuflisted', true);
        if (filetype == 'detect') {
            nvim.command('filetype detect', true);
        }
        else if (filetype) {
            nvim.command(`setf ${filetype}`, true);
        }
        if (lnum && lnum != 1)
            nvim.command('normal! zt', true);
        nvim.call('win_gotoid', [winid], true);
        if (workspace_1.default.isVim)
            nvim.command('redraw', true);
        let [, err] = await nvim.resumeNotification();
        if (err)
            console.error(`Error on ${err[0]}: ${err[1]} - ${err[2]}`);
    }
    getPreviewCommand(context) {
        let { position } = context.options;
        if (position == 'tab')
            return `belowright vs`;
        let mod = position == 'top' ? 'below' : 'above';
        return `${mod} ${this.previewHeight}sp`;
    }
    doHighlight() {
        // noop
    }
    dispose() {
        util_1.disposeAll(this.disposables);
    }
}
exports.default = BasicList;
//# sourceMappingURL=basic.js.map

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
class CommandsList extends basic_1.default {
    constructor(nvim) {
        super(nvim);
        this.defaultAction = 'run';
        this.description = 'registered commands of coc.nvim';
        this.name = 'commands';
        this.mru = workspace_1.default.createMru('commands');
        this.addAction('run', async (item) => {
            let { cmd } = item.data;
            await events_1.default.fire('Command', [cmd]);
            await commands_1.default.executeCommand(cmd);
            await commands_1.default.addRecent(cmd);
        });
        this.addAction('append', async (item) => {
            let { cmd } = item.data;
            await nvim.feedKeys(`:CocCommand ${cmd} `, 'n', false);
        });
    }
    async loadItems(_context) {
        let items = [];
        let list = commands_1.default.commandList;
        let { titles } = commands_1.default;
        let mruList = await this.mru.load();
        for (const o of list) {
            const { id } = o;
            items.push({
                label: `${id}\t${titles.get(id) || ''}`,
                filterText: id,
                data: { cmd: id, score: score(mruList, id) }
            });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return items;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocCommandsTitle /\\t.*$/ contained containedin=CocCommandsLine', true);
        nvim.command('highlight default link CocCommandsTitle Comment', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = CommandsList;
function score(list, key) {
    let idx = list.indexOf(key);
    return idx == -1 ? -1 : list.length - idx;
}
//# sourceMappingURL=commands.js.map

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const manager_1 = tslib_1.__importDefault(__webpack_require__(253));
const location_1 = tslib_1.__importDefault(__webpack_require__(589));
const fs_1 = __webpack_require__(304);
const logger = __webpack_require__(64)('list-symbols');
class DiagnosticsList extends location_1.default {
    constructor() {
        super(...arguments);
        this.defaultAction = 'open';
        this.description = 'diagnostics of current workspace';
        this.name = 'diagnostics';
    }
    async loadItems(context) {
        let list = manager_1.default.getDiagnosticList();
        let { cwd } = context;
        return list.map(item => {
            let file = fs_1.isParentFolder(cwd, item.file) ? path_1.default.relative(cwd, item.file) : item.file;
            return {
                label: `${file}:${item.lnum}:${item.col}\t${item.severity}\t${item.message.replace(/\n/g, '')}`,
                location: item.location
            };
        });
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocDiagnosticsFile /\\v^\\s*\\S+/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('syntax match CocDiagnosticsError /\\tError\\t/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('syntax match CocDiagnosticsWarning /\\tWarning\\t/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('syntax match CocDiagnosticsInfo /\\tInformation\\t/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('syntax match CocDiagnosticsHint /\\tHint\\t/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('highlight default link CocDiagnosticsFile Comment', true);
        nvim.command('highlight default link CocDiagnosticsError CocErrorSign', true);
        nvim.command('highlight default link CocDiagnosticsWarning CocWarningSign', true);
        nvim.command('highlight default link CocDiagnosticsInfo CocInfoSign', true);
        nvim.command('highlight default link CocDiagnosticsHint CocHintSign', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = DiagnosticsList;
//# sourceMappingURL=diagnostics.js.map

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_types_1 = __webpack_require__(223);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const vscode_uri_1 = __webpack_require__(243);
const fs_1 = __webpack_require__(304);
const logger = __webpack_require__(64)('list-location');
class LocationList extends basic_1.default {
    constructor(nvim) {
        super(nvim);
        this.defaultAction = 'open';
        this.description = 'show locations saved by g:coc_jump_locations variable';
        this.name = 'location';
        this.addLocationActions();
    }
    async loadItems(context) {
        // filename, lnum, col, text, type
        let locs = await this.nvim.getVar('coc_jump_locations');
        locs = locs || [];
        locs.forEach(loc => {
            if (!loc.uri) {
                let fullpath = path_1.default.isAbsolute(loc.filename) ? loc.filename : path_1.default.join(context.cwd, loc.filename);
                loc.uri = vscode_uri_1.URI.file(fullpath).toString();
            }
            if (!loc.bufnr && workspace_1.default.getDocument(loc.uri) != null) {
                loc.bufnr = workspace_1.default.getDocument(loc.uri).bufnr;
            }
            if (!loc.range) {
                let { lnum, col } = loc;
                loc.range = vscode_languageserver_types_1.Range.create(lnum - 1, col - 1, lnum - 1, col - 1);
            }
            else {
                loc.lnum = loc.lnum || loc.range.start.line + 1;
                loc.col = loc.col || loc.range.start.character + 1;
            }
        });
        let bufnr = await this.nvim.call('bufnr', '%');
        let ignoreFilepath = locs.every(o => o.bufnr && bufnr && o.bufnr == bufnr);
        let items = locs.map(loc => {
            let filename = ignoreFilepath ? '' : loc.filename;
            let filterText = `${filename}${loc.text.trim()}`;
            if (path_1.default.isAbsolute(filename)) {
                filename = fs_1.isParentFolder(context.cwd, filename) ? path_1.default.relative(context.cwd, filename) : filename;
            }
            return {
                label: `${filename} |${loc.type ? loc.type + ' ' : ''}${loc.lnum} col ${loc.col}| ${loc.text}`,
                location: vscode_languageserver_types_1.Location.create(loc.uri, loc.range),
                filterText
            };
        });
        return items;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocLocationName /\\v^[^|]+/ contained containedin=CocLocationLine', true);
        nvim.command('syntax match CocLocationPosition /\\v\\|\\w*\\s?\\d+\\scol\\s\\d+\\|/ contained containedin=CocLocationLine', true);
        nvim.command('syntax match CocLocationError /Error/ contained containedin=CocLocationPosition', true);
        nvim.command('syntax match CocLocationWarning /Warning/ contained containedin=CocLocationPosition', true);
        nvim.command('highlight default link CocLocationName Directory', true);
        nvim.command('highlight default link CocLocationPosition LineNr', true);
        nvim.command('highlight default link CocLocationError Error', true);
        nvim.command('highlight default link CocLocationWarning WarningMsg', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = LocationList;
//# sourceMappingURL=location.js.map

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const rimraf_1 = tslib_1.__importDefault(__webpack_require__(267));
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const os_1 = tslib_1.__importDefault(__webpack_require__(76));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_uri_1 = __webpack_require__(243);
const extensions_1 = tslib_1.__importDefault(__webpack_require__(333));
const util_1 = __webpack_require__(238);
const fs_2 = __webpack_require__(304);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
const logger = __webpack_require__(64)('list-extensions');
class ExtensionList extends basic_1.default {
    constructor(nvim) {
        super(nvim);
        this.defaultAction = 'toggle';
        this.description = 'manage coc extensions';
        this.name = 'extensions';
        this.addAction('toggle', async (item) => {
            let { id, state } = item.data;
            if (state == 'disabled')
                return;
            if (state == 'activated') {
                await extensions_1.default.deactivate(id);
            }
            else {
                await extensions_1.default.activate(id);
            }
            await util_1.wait(100);
        }, { persist: true, reload: true, parallel: true });
        this.addAction('configuration', async (item) => {
            let { root } = item.data;
            let jsonFile = path_1.default.join(root, 'package.json');
            if (fs_1.default.existsSync(jsonFile)) {
                let lines = fs_1.default.readFileSync(jsonFile, 'utf8').split(/\r?\n/);
                let idx = lines.findIndex(s => s.includes('"contributes"'));
                await workspace_1.default.jumpTo(vscode_uri_1.URI.file(jsonFile).toString(), { line: idx == -1 ? 0 : idx, character: 0 });
            }
        });
        this.addAction('open', async (item) => {
            let { root } = item.data;
            if (workspace_1.default.env.isiTerm) {
                nvim.call('coc#util#iterm_open', [root], true);
            }
            else {
                nvim.call('coc#util#open_url', [root], true);
            }
        });
        this.addAction('disable', async (item) => {
            let { id, state } = item.data;
            if (state !== 'disabled')
                await extensions_1.default.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction('enable', async (item) => {
            let { id, state } = item.data;
            if (state == 'disabled')
                await extensions_1.default.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction('lock', async (item) => {
            let { id } = item.data;
            await extensions_1.default.toggleLock(id);
        }, { persist: true, reload: true });
        this.addAction('help', async (item) => {
            let { root } = item.data;
            let files = await fs_2.readdirAsync(root);
            let file = files.find(f => /^readme/i.test(f));
            if (file) {
                let escaped = await nvim.call('fnameescape', [path_1.default.join(root, file)]);
                await workspace_1.default.callAsync('coc#util#execute', [`edit ${escaped}`]);
            }
        });
        this.addAction('reload', async (item) => {
            let { id } = item.data;
            await extensions_1.default.reloadExtension(id);
        }, { persist: true, reload: true });
        this.addAction('fix', async (item) => {
            let { root, isLocal } = item.data;
            let { npm } = extensions_1.default;
            if (isLocal) {
                workspace_1.default.showMessage(`Can't fix for local extension.`, 'warning');
                return;
            }
            if (!npm)
                return;
            let folder = path_1.default.join(root, 'node_modules');
            if (fs_1.default.existsSync(folder)) {
                rimraf_1.default.sync(folder);
            }
            let terminal = await workspace_1.default.createTerminal({
                cwd: root
            });
            let shown = await terminal.show(false);
            if (!shown)
                return;
            workspace_1.default.nvim.command(`startinsert`, true);
            terminal.sendText(`${npm} install --production --ignore-scripts --no-lockfile`, true);
        });
        this.addMultipleAction('uninstall', async (items) => {
            let ids = [];
            for (let item of items) {
                if (item.data.isLocal)
                    continue;
                ids.push(item.data.id);
            }
            extensions_1.default.uninstallExtension(ids).catch(e => {
                logger.error(e);
            });
        });
    }
    async loadItems(_context) {
        let items = [];
        let list = await extensions_1.default.getExtensionStates();
        let lockedList = await extensions_1.default.getLockedList();
        for (let stat of list) {
            let prefix = '+';
            if (stat.state == 'disabled') {
                prefix = '-';
            }
            else if (stat.state == 'activated') {
                prefix = '*';
            }
            else if (stat.state == 'unknown') {
                prefix = '?';
            }
            let root = await this.nvim.call('resolve', stat.root);
            let locked = lockedList.includes(stat.id);
            items.push({
                label: `${prefix} ${stat.id}${locked ? ' ' : ''}\t${stat.isLocal ? '[RTP]\t' : ''}${stat.version}\t${root.replace(os_1.default.homedir(), '~')}`,
                filterText: stat.id,
                data: {
                    id: stat.id,
                    root,
                    state: stat.state,
                    isLocal: stat.isLocal,
                    priority: getPriority(stat.state)
                }
            });
        }
        items.sort((a, b) => {
            if (a.data.priority != b.data.priority) {
                return b.data.priority - a.data.priority;
            }
            return b.data.id - a.data.id ? 1 : -1;
        });
        return items;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocExtensionsActivited /\\v^\\*/ contained containedin=CocExtensionsLine', true);
        nvim.command('syntax match CocExtensionsLoaded /\\v^\\+/ contained containedin=CocExtensionsLine', true);
        nvim.command('syntax match CocExtensionsDisabled /\\v^-/ contained containedin=CocExtensionsLine', true);
        nvim.command('syntax match CocExtensionsName /\\v%3c\\S+/ contained containedin=CocExtensionsLine', true);
        nvim.command('syntax match CocExtensionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocExtensionsLine', true);
        nvim.command('syntax match CocExtensionsLocal /\\v\\[RTP\\]/ contained containedin=CocExtensionsLine', true);
        nvim.command('highlight default link CocExtensionsActivited Special', true);
        nvim.command('highlight default link CocExtensionsLoaded Normal', true);
        nvim.command('highlight default link CocExtensionsDisabled Comment', true);
        nvim.command('highlight default link CocExtensionsName String', true);
        nvim.command('highlight default link CocExtensionsLocal MoreMsg', true);
        nvim.command('highlight default link CocExtensionsRoot Comment', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = ExtensionList;
function getPriority(stat) {
    switch (stat) {
        case 'unknown':
            return 2;
        case 'activated':
            return 1;
        case 'disabled':
            return -1;
        default:
            return 0;
    }
}
//# sourceMappingURL=extensions.js.map

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_uri_1 = __webpack_require__(243);
const mkdirp_1 = tslib_1.__importDefault(__webpack_require__(260));
const fs_1 = __webpack_require__(304);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
class FoldList extends basic_1.default {
    constructor(nvim) {
        super(nvim);
        this.defaultAction = 'edit';
        this.description = 'list of current workspace folders';
        this.name = 'folders';
        this.addAction('edit', async (item) => {
            let newPath = await nvim.call('input', ['Folder: ', item.label, 'dir']);
            let stat = await fs_1.statAsync(newPath);
            if (!stat || !stat.isDirectory()) {
                workspace_1.default.showMessage(`invalid path: ${newPath}`, 'error');
                return;
            }
            workspace_1.default.renameWorkspaceFolder(item.label, newPath);
        });
        this.addAction('delete', async (item) => {
            workspace_1.default.removeWorkspaceFolder(item.label);
        }, { reload: true, persist: true });
        this.addAction('newfile', async (item) => {
            let file = await workspace_1.default.requestInput('File name', item.label + '/');
            let dir = path_1.default.dirname(file);
            let stat = await fs_1.statAsync(dir);
            if (!stat || !stat.isDirectory()) {
                let success = await mkdirp_1.default(dir);
                if (!success) {
                    workspace_1.default.showMessage(`Error creating new directory ${dir}`, 'error');
                    return;
                }
            }
            await workspace_1.default.createFile(file, { overwrite: false, ignoreIfExists: true });
            await this.jumpTo(vscode_uri_1.URI.file(file).toString());
        });
    }
    async loadItems(_context) {
        return workspace_1.default.folderPaths.map(p => ({ label: p }));
    }
}
exports.default = FoldList;
//# sourceMappingURL=folders.js.map

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
const vscode_languageserver_types_1 = __webpack_require__(223);
const vscode_uri_1 = __webpack_require__(243);
const fs_1 = __webpack_require__(304);
class LinksList extends basic_1.default {
    constructor(nvim) {
        super(nvim);
        this.defaultAction = 'open';
        this.description = 'links of current buffer';
        this.name = 'links';
        this.addAction('open', async (item) => {
            let { target } = item.data;
            let uri = vscode_uri_1.URI.parse(target);
            if (uri.scheme.startsWith('http')) {
                await nvim.call('coc#util#open_url', target);
            }
            else {
                await workspace_1.default.jumpTo(target);
            }
        });
        this.addAction('jump', async (item) => {
            let { location } = item.data;
            await workspace_1.default.jumpTo(location.uri, location.range.start);
        });
    }
    async loadItems(context) {
        let buf = await context.window.buffer;
        let doc = workspace_1.default.getDocument(buf.id);
        if (!doc)
            return null;
        let items = [];
        let links = await languages_1.default.getDocumentLinks(doc.textDocument);
        if (links == null) {
            throw new Error('Links provider not found.');
        }
        let res = [];
        for (let link of links) {
            if (link.target) {
                items.push({
                    label: formatUri(link.target),
                    data: {
                        target: link.target,
                        location: vscode_languageserver_types_1.Location.create(doc.uri, link.range)
                    }
                });
            }
            else {
                link = await languages_1.default.resolveDocumentLink(link);
                if (link.target) {
                    items.push({
                        label: formatUri(link.target),
                        data: {
                            target: link.target,
                            location: vscode_languageserver_types_1.Location.create(doc.uri, link.range)
                        }
                    });
                }
                res.push(link);
            }
        }
        return items;
    }
}
exports.default = LinksList;
function formatUri(uri) {
    if (!uri.startsWith('file:'))
        return uri;
    let filepath = vscode_uri_1.URI.parse(uri).fsPath;
    return fs_1.isParentFolder(workspace_1.default.cwd, filepath) ? path_1.default.relative(workspace_1.default.cwd, filepath) : filepath;
}
//# sourceMappingURL=links.js.map

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
const mru_1 = tslib_1.__importDefault(__webpack_require__(314));
class LinksList extends basic_1.default {
    constructor(nvim, listMap) {
        super(nvim);
        this.listMap = listMap;
        this.name = 'lists';
        this.defaultAction = 'open';
        this.description = 'registered lists of coc.nvim';
        this.mru = new mru_1.default('lists');
        this.addAction('open', async (item) => {
            let { name } = item.data;
            await this.mru.add(name);
            await nvim.command(`CocList ${name}`);
        });
    }
    async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        for (let list of this.listMap.values()) {
            if (list.name == 'lists')
                continue;
            items.push({
                label: `${list.name}\t${list.description || ''}`,
                data: {
                    name: list.name,
                    interactive: list.interactive,
                    score: score(mruList, list.name)
                }
            });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return items;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocListsDesc /\\t.*$/ contained containedin=CocListsLine', true);
        nvim.command('highlight default link CocListsDesc Comment', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = LinksList;
function score(list, key) {
    let idx = list.indexOf(key);
    return idx == -1 ? -1 : list.length - idx;
}
//# sourceMappingURL=lists.js.map

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_languageserver_types_1 = __webpack_require__(223);
const vscode_uri_1 = __webpack_require__(243);
const which_1 = tslib_1.__importDefault(__webpack_require__(244));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const util_1 = __webpack_require__(238);
const fs_1 = __webpack_require__(304);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const location_1 = tslib_1.__importDefault(__webpack_require__(589));
const convert_1 = __webpack_require__(595);
const logger = __webpack_require__(64)('list-symbols');
function getFilterText(s, kind) {
    return `${s.name}${kind ? ` ${kind}` : ''}`;
}
class Outline extends location_1.default {
    constructor() {
        super(...arguments);
        this.description = 'symbols of current document';
        this.name = 'outline';
        this.options = [{
                name: '-k, -kind KIND',
                hasValue: true,
                description: 'filters also by kind',
            }];
    }
    async loadItems(context) {
        let buf = await context.window.buffer;
        let document = workspace_1.default.getDocument(buf.id);
        if (!document)
            return null;
        let config = this.getConfig();
        let ctagsFilestypes = config.get('ctagsFilestypes', []);
        let symbols;
        let args = this.parseArguments(context.args);
        if (!ctagsFilestypes.includes(document.filetype)) {
            symbols = await languages_1.default.getDocumentSymbol(document.textDocument);
        }
        if (!symbols)
            return await this.loadCtagsSymbols(document);
        if (symbols.length == 0)
            return [];
        let filterKind = args.kind ? args.kind.toLowerCase() : null;
        let items = [];
        let isSymbols = !symbols[0].hasOwnProperty('location');
        if (isSymbols) {
            // eslint-disable-next-line no-inner-declarations
            function addSymbols(symbols, level = 0) {
                symbols.sort(sortSymbols);
                for (let s of symbols) {
                    let kind = convert_1.getSymbolKind(s.kind);
                    let location = vscode_languageserver_types_1.Location.create(document.uri, s.selectionRange);
                    items.push({
                        label: `${' '.repeat(level * 2)}${s.name}\t[${kind}]\t${s.range.start.line + 1}`,
                        filterText: getFilterText(s, args.kind == '' ? kind : null),
                        location,
                        data: { kind }
                    });
                    if (s.children && s.children.length) {
                        addSymbols(s.children, level + 1);
                    }
                }
            }
            addSymbols(symbols);
            if (filterKind) {
                items = items.filter(o => o.data.kind.toLowerCase().indexOf(filterKind) == 0);
            }
        }
        else {
            symbols.sort((a, b) => {
                let sa = a.location.range.start;
                let sb = b.location.range.start;
                let d = sa.line - sb.line;
                return d == 0 ? sa.character - sb.character : d;
            });
            for (let s of symbols) {
                let kind = convert_1.getSymbolKind(s.kind);
                if (s.name.endsWith(') callback'))
                    continue;
                if (filterKind && !kind.toLowerCase().startsWith(filterKind)) {
                    continue;
                }
                if (s.location.uri === undefined) {
                    s.location.uri = document.uri;
                }
                items.push({
                    label: `${s.name} [${kind}] ${s.location.range.start.line + 1}`,
                    filterText: getFilterText(s, args.kind == '' ? kind : null),
                    location: s.location
                });
            }
        }
        return items;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocOutlineName /\\v^\\s*[^\t]+/ contained containedin=CocOutlineLine', true);
        nvim.command('syntax match CocOutlineKind /\\[\\w\\+\\]/ contained containedin=CocOutlineLine', true);
        nvim.command('syntax match CocOutlineLine /\\d\\+$/ contained containedin=CocOutlineLine', true);
        nvim.command('highlight default link CocOutlineName Normal', true);
        nvim.command('highlight default link CocOutlineKind Typedef', true);
        nvim.command('highlight default link CocOutlineLine Comment', true);
        nvim.resumeNotification(false, true).logError();
    }
    async loadCtagsSymbols(document) {
        if (!which_1.default.sync('ctags', { nothrow: true })) {
            return [];
        }
        let uri = vscode_uri_1.URI.parse(document.uri);
        let extname = path_1.default.extname(uri.fsPath);
        let content = '';
        let tempname = await this.nvim.call('tempname');
        let filepath = `${tempname}.${extname}`;
        let escaped = await this.nvim.call('fnameescape', filepath);
        await fs_1.writeFile(escaped, document.getDocumentContent());
        try {
            content = await util_1.runCommand(`ctags -f - --excmd=number --language-force=${document.filetype} ${escaped}`);
        }
        catch (e) {
            // noop
        }
        if (!content.trim().length) {
            content = await util_1.runCommand(`ctags -f - --excmd=number ${escaped}`);
        }
        content = content.trim();
        if (!content)
            return [];
        let lines = content.split('\n');
        let items = [];
        for (let line of lines) {
            let parts = line.split('\t');
            if (parts.length < 4)
                continue;
            let lnum = Number(parts[2].replace(/;"$/, ''));
            let text = document.getline(lnum - 1);
            if (!text)
                continue;
            let idx = text.indexOf(parts[0]);
            let start = idx == -1 ? 0 : idx;
            let range = vscode_languageserver_types_1.Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);
            items.push({
                label: `${parts[0]} [${parts[3]}] ${lnum}`,
                filterText: parts[0],
                location: vscode_languageserver_types_1.Location.create(document.uri, range),
                data: { line: lnum }
            });
        }
        items.sort((a, b) => a.data.line - b.data.line);
        return items;
    }
}
exports.default = Outline;
function sortSymbols(a, b) {
    let ra = a.selectionRange;
    let rb = b.selectionRange;
    if (ra.start.line != rb.start.line) {
        return ra.start.line - rb.start.line;
    }
    return ra.start.character - rb.start.character;
}
//# sourceMappingURL=outline.js.map

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(211);
function getSymbolKind(kind) {
    switch (kind) {
        case vscode_languageserver_protocol_1.SymbolKind.File:
            return 'File';
        case vscode_languageserver_protocol_1.SymbolKind.Module:
            return 'Module';
        case vscode_languageserver_protocol_1.SymbolKind.Namespace:
            return 'Namespace';
        case vscode_languageserver_protocol_1.SymbolKind.Package:
            return 'Package';
        case vscode_languageserver_protocol_1.SymbolKind.Class:
            return 'Class';
        case vscode_languageserver_protocol_1.SymbolKind.Method:
            return 'Method';
        case vscode_languageserver_protocol_1.SymbolKind.Property:
            return 'Property';
        case vscode_languageserver_protocol_1.SymbolKind.Field:
            return 'Field';
        case vscode_languageserver_protocol_1.SymbolKind.Constructor:
            return 'Constructor';
        case vscode_languageserver_protocol_1.SymbolKind.Enum:
            return 'Enum';
        case vscode_languageserver_protocol_1.SymbolKind.Interface:
            return 'Interface';
        case vscode_languageserver_protocol_1.SymbolKind.Function:
            return 'Function';
        case vscode_languageserver_protocol_1.SymbolKind.Variable:
            return 'Variable';
        case vscode_languageserver_protocol_1.SymbolKind.Constant:
            return 'Constant';
        case vscode_languageserver_protocol_1.SymbolKind.String:
            return 'String';
        case vscode_languageserver_protocol_1.SymbolKind.Number:
            return 'Number';
        case vscode_languageserver_protocol_1.SymbolKind.Boolean:
            return 'Boolean';
        case vscode_languageserver_protocol_1.SymbolKind.Array:
            return 'Array';
        case vscode_languageserver_protocol_1.SymbolKind.Object:
            return 'Object';
        case vscode_languageserver_protocol_1.SymbolKind.Key:
            return 'Key';
        case vscode_languageserver_protocol_1.SymbolKind.Null:
            return 'Null';
        case vscode_languageserver_protocol_1.SymbolKind.EnumMember:
            return 'EnumMember';
        case vscode_languageserver_protocol_1.SymbolKind.Struct:
            return 'Struct';
        case vscode_languageserver_protocol_1.SymbolKind.Event:
            return 'Event';
        case vscode_languageserver_protocol_1.SymbolKind.Operator:
            return 'Operator';
        case vscode_languageserver_protocol_1.SymbolKind.TypeParameter:
            return 'TypeParameter';
        default:
            return 'Unknown';
    }
}
exports.getSymbolKind = getSymbolKind;
//# sourceMappingURL=convert.js.map

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const services_1 = tslib_1.__importDefault(__webpack_require__(525));
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
const util_1 = __webpack_require__(238);
class ServicesList extends basic_1.default {
    constructor(nvim) {
        super(nvim);
        this.defaultAction = 'toggle';
        this.description = 'registered services of coc.nvim';
        this.name = 'services';
        this.addAction('toggle', async (item) => {
            let { id } = item.data;
            await services_1.default.toggle(id);
            await util_1.wait(100);
        }, { persist: true, reload: true });
    }
    async loadItems(_context) {
        let stats = services_1.default.getServiceStats();
        stats.sort((a, b) => a.id > b.id ? -1 : 1);
        return stats.map(stat => {
            let prefix = stat.state == 'running' ? '*' : ' ';
            return {
                label: `${prefix}\t${stat.id}\t[${stat.state}]\t${stat.languageIds.join(', ')}`,
                data: { id: stat.id }
            };
        });
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocServicesPrefix /\\v^./ contained containedin=CocServicesLine', true);
        nvim.command('syntax match CocServicesName /\\v%3c\\S+/ contained containedin=CocServicesLine', true);
        nvim.command('syntax match CocServicesStat /\\v\\t\\[\\w+\\]/ contained containedin=CocServicesLine', true);
        nvim.command('syntax match CocServicesLanguages /\\v(\\])@<=.*$/ contained containedin=CocServicesLine', true);
        nvim.command('highlight default link CocServicesPrefix Special', true);
        nvim.command('highlight default link CocServicesName Type', true);
        nvim.command('highlight default link CocServicesStat Statement', true);
        nvim.command('highlight default link CocServicesLanguages Comment', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = ServicesList;
//# sourceMappingURL=services.js.map

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_types_1 = __webpack_require__(223);
const vscode_uri_1 = __webpack_require__(243);
const sources_1 = tslib_1.__importDefault(__webpack_require__(332));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const basic_1 = tslib_1.__importDefault(__webpack_require__(586));
const logger = __webpack_require__(64)('list-sources');
class SourcesList extends basic_1.default {
    constructor(nvim) {
        super(nvim);
        this.defaultAction = 'toggle';
        this.description = 'registered completion sources';
        this.name = 'sources';
        this.addAction('toggle', async (item) => {
            let { name } = item.data;
            sources_1.default.toggleSource(name);
        }, { persist: true, reload: true });
        this.addAction('refresh', async (item) => {
            let { name } = item.data;
            await sources_1.default.refresh(name);
        }, { persist: true, reload: true });
        this.addAction('open', async (item) => {
            let { location } = item;
            if (location)
                await this.jumpTo(location);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async loadItems(context) {
        let stats = sources_1.default.sourceStats();
        let filetype = await context.buffer.getOption('filetype');
        let map = workspace_1.default.env.disabledSources;
        let disables = map ? map[filetype] || [] : [];
        stats.sort((a, b) => {
            if (a.type != b.type)
                return a.type < b.type ? 1 : -1;
            return a.name > b.name ? -1 : 1;
        });
        return stats.map(stat => {
            let prefix = stat.disabled ? ' ' : '*';
            if (disables && disables.includes(stat.name)) {
                prefix = '-';
            }
            let location;
            if (stat.filepath) {
                location = vscode_languageserver_types_1.Location.create(vscode_uri_1.URI.file(stat.filepath).toString(), vscode_languageserver_types_1.Range.create(0, 0, 0, 0));
            }
            return {
                label: `${prefix} ${fixWidth(stat.name, 22)} ${fixWidth('[' + stat.shortcut + ']', 10)} ${fixWidth(stat.triggerCharacters.join(''), 10)} ${fixWidth(stat.priority.toString(), 3)} ${stat.filetypes.join(',')}`,
                location,
                data: { name: stat.name }
            };
        });
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocSourcesPrefix /\\v^./ contained containedin=CocSourcesLine', true);
        nvim.command('syntax match CocSourcesName /\\v%3c\\S+/ contained containedin=CocSourcesLine', true);
        nvim.command('syntax match CocSourcesType /\\v%25v.*%36v/ contained containedin=CocSourcesLine', true);
        nvim.command('syntax match CocSourcesPriority /\\v%46v.*%50v/ contained containedin=CocSourcesLine', true);
        nvim.command('syntax match CocSourcesFileTypes /\\v\\S+$/ contained containedin=CocSourcesLine', true);
        nvim.command('highlight default link CocSourcesPrefix Special', true);
        nvim.command('highlight default link CocSourcesName Type', true);
        nvim.command('highlight default link CocSourcesPriority Number', true);
        nvim.command('highlight default link CocSourcesFileTypes Comment', true);
        nvim.command('highlight default link CocSourcesType Statement', true);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        nvim.resumeNotification(false, true);
    }
}
exports.default = SourcesList;
function fixWidth(str, width) {
    if (str.length > width) {
        return str.slice(0, width - 1) + '.';
    }
    return str + ' '.repeat(width - str.length);
}
//# sourceMappingURL=sources.js.map

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const minimatch_1 = tslib_1.__importDefault(__webpack_require__(271));
const vscode_uri_1 = __webpack_require__(243);
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const location_1 = tslib_1.__importDefault(__webpack_require__(589));
const convert_1 = __webpack_require__(595);
const fs_1 = __webpack_require__(304);
const fzy_1 = __webpack_require__(583);
const logger = __webpack_require__(64)('list-symbols');
class Symbols extends location_1.default {
    constructor() {
        super(...arguments);
        this.interactive = true;
        this.description = 'search workspace symbols';
        this.detail = 'Symbols list is provided by server, it works on interactive mode only.';
        this.name = 'symbols';
        this.options = [{
                name: '-k, -kind KIND',
                description: 'Filter symbols by kind.',
                hasValue: true
            }];
    }
    async loadItems(context) {
        let buf = await context.window.buffer;
        let document = workspace_1.default.getDocument(buf.id);
        if (!document)
            return null;
        let { input } = context;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toLowerCase() : '';
        if (!context.options.interactive) {
            throw new Error('Symbols only works on interactive mode');
        }
        let symbols = await languages_1.default.getWorkspaceSymbols(document.textDocument, input);
        if (!symbols) {
            throw new Error('Workspace symbols provider not found for current document');
        }
        let config = this.getConfig();
        let excludes = config.get('excludes', []);
        let items = [];
        for (let s of symbols) {
            let kind = convert_1.getSymbolKind(s.kind);
            if (filterKind && kind.toLowerCase() != filterKind) {
                continue;
            }
            let file = vscode_uri_1.URI.parse(s.location.uri).fsPath;
            if (fs_1.isParentFolder(workspace_1.default.cwd, file)) {
                file = path_1.default.relative(workspace_1.default.cwd, file);
            }
            if (excludes.some(p => minimatch_1.default(file, p))) {
                continue;
            }
            items.push({
                label: `${s.name} [${kind}]\t${file}`,
                filterText: `${s.name}`,
                location: s.location,
                data: { original: s, kind: s.kind, file, score: fzy_1.score(input, s.name) }
            });
        }
        items.sort((a, b) => {
            if (a.data.score != b.data.score) {
                return b.data.score - a.data.score;
            }
            if (a.data.kind != b.data.kind) {
                return a.data.kind - b.data.kind;
            }
            return a.data.file.length - b.data.file.length;
        });
        return items;
    }
    async resolveItem(item) {
        let s = item.data.original;
        if (!s)
            return null;
        let resolved = await languages_1.default.resolveWorkspaceSymbol(s);
        if (!resolved)
            return null;
        let kind = convert_1.getSymbolKind(resolved.kind);
        let file = vscode_uri_1.URI.parse(resolved.location.uri).fsPath;
        if (fs_1.isParentFolder(workspace_1.default.cwd, file)) {
            file = path_1.default.relative(workspace_1.default.cwd, file);
        }
        return {
            label: `${s.name} [${kind}]\t${file}`,
            filterText: `${s.name}`,
            location: s.location
        };
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocSymbolsName /\\v^\\s*\\S+/ contained containedin=CocSymbolsLine', true);
        nvim.command('syntax match CocSymbolsKind /\\[\\w\\+\\]\\t/ contained containedin=CocSymbolsLine', true);
        nvim.command('syntax match CocSymbolsFile /\\S\\+$/ contained containedin=CocSymbolsLine', true);
        nvim.command('highlight default link CocSymbolsName Normal', true);
        nvim.command('highlight default link CocSymbolsKind Typedef', true);
        nvim.command('highlight default link CocSymbolsFile Comment', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = Symbols;
//# sourceMappingURL=symbols.js.map

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const types_1 = __webpack_require__(295);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('model-source');
class Source {
    constructor(option) {
        this._disabled = false;
        this.nvim = workspace_1.default.nvim;
        // readonly properties
        this.name = option.name;
        this.filepath = option.filepath || '';
        this.sourceType = option.sourceType || types_1.SourceType.Native;
        this.isSnippet = !!option.isSnippet;
        this.defaults = option;
    }
    /**
     * Priority of source, higher priority makes items lower index.
     */
    get priority() {
        return this.getConfig('priority', 1);
    }
    /**
     * When triggerOnly is true, not trigger completion on keyword character insert.
     */
    get triggerOnly() {
        let triggerOnly = this.defaults['triggerOnly'];
        if (typeof triggerOnly == 'boolean')
            return triggerOnly;
        if (!this.triggerCharacters && !this.triggerPatterns)
            return false;
        return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length != 0;
    }
    get triggerCharacters() {
        return this.getConfig('triggerCharacters', null);
    }
    // exists opitonnal function names for remote source
    get optionalFns() {
        return this.defaults['optionalFns'] || [];
    }
    get triggerPatterns() {
        let patterns = this.getConfig('triggerPatterns', null);
        if (!patterns || patterns.length == 0)
            return null;
        return patterns.map(s => (typeof s === 'string') ? new RegExp(s + '$') : s);
    }
    get shortcut() {
        let shortcut = this.getConfig('shortcut', '');
        return shortcut ? shortcut : this.name.slice(0, 3);
    }
    get enable() {
        if (this._disabled)
            return false;
        return this.getConfig('enable', true);
    }
    get filetypes() {
        return this.getConfig('filetypes', null);
    }
    get disableSyntaxes() {
        return this.getConfig('disableSyntaxes', []);
    }
    getConfig(key, defaultValue) {
        let config = workspace_1.default.getConfiguration(`coc.source.${this.name}`);
        defaultValue = this.defaults.hasOwnProperty(key) ? this.defaults[key] : defaultValue;
        return config.get(key, defaultValue);
    }
    toggle() {
        this._disabled = !this._disabled;
    }
    get firstMatch() {
        return this.getConfig('firstMatch', true);
    }
    get menu() {
        let { shortcut } = this;
        return shortcut ? `[${shortcut}]` : '';
    }
    /**
     * Filter words that too short or doesn't match input
     */
    filterWords(words, opt) {
        let { firstMatch } = this;
        let res = [];
        let { input } = opt;
        let cword = opt.word;
        if (!input.length)
            return [];
        let cFirst = input[0];
        for (let word of words) {
            if (!word || word.length < 3)
                continue;
            if (firstMatch && cFirst != word[0])
                continue;
            if (!firstMatch && cFirst.toLowerCase() != word[0].toLowerCase())
                continue;
            if (word == cword || word == input)
                continue;
            res.push(word);
        }
        return res;
    }
    /**
     * fix start column for new valid characters
     *
     * @protected
     * @param {CompleteOption} opt
     * @param {string[]} valids - valid charscters
     * @returns {number}
     */
    fixStartcol(opt, valids) {
        let { col, input, line, bufnr } = opt;
        let start = string_1.byteSlice(line, 0, col);
        let document = workspace_1.default.getDocument(bufnr);
        if (!document)
            return col;
        let { chars } = document;
        for (let i = start.length - 1; i >= 0; i--) {
            let c = start[i];
            if (!chars.isKeywordChar(c) && !valids.includes(c)) {
                break;
            }
            input = `${c}${input}`;
            col = col - 1;
        }
        opt.col = col;
        opt.input = input;
        return col;
    }
    async shouldComplete(opt) {
        let { disableSyntaxes } = this;
        if (opt.synname && disableSyntaxes && disableSyntaxes.length) {
            let synname = (opt.synname || '').toLowerCase();
            if (disableSyntaxes.findIndex(s => synname.includes(s.toLowerCase())) !== -1) {
                return false;
            }
        }
        let fn = this.defaults['shouldComplete'];
        if (fn)
            return await Promise.resolve(fn.call(this, opt));
        return true;
    }
    async refresh() {
        let fn = this.defaults['refresh'];
        if (fn)
            await Promise.resolve(fn.call(this));
    }
    async onCompleteDone(item, opt) {
        let fn = this.defaults['onCompleteDone'];
        if (fn)
            await Promise.resolve(fn.call(this, item, opt));
    }
    async doComplete(opt, token) {
        let fn = this.defaults['doComplete'];
        if (fn)
            return await Promise.resolve(fn.call(this, opt, token));
        return null;
    }
}
exports.default = Source;
//# sourceMappingURL=source.js.map

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fuzzy_1 = __webpack_require__(580);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const source_1 = tslib_1.__importDefault(__webpack_require__(599));
const logger = __webpack_require__(64)('model-source-vim');
class VimSource extends source_1.default {
    async callOptinalFunc(fname, args) {
        let exists = this.optionalFns.includes(fname);
        if (!exists)
            return null;
        let name = `coc#source#${this.name}#${fname}`;
        let res;
        try {
            res = await this.nvim.call(name, args);
        }
        catch (e) {
            workspace_1.default.showMessage(`Vim error from source ${this.name}: ${e.message}`, 'error');
            return null;
        }
        return res;
    }
    async shouldComplete(opt) {
        let shouldRun = await super.shouldComplete(opt);
        if (!shouldRun)
            return false;
        if (!this.optionalFns.includes('should_complete'))
            return true;
        let res = await this.callOptinalFunc('should_complete', [opt]);
        return !!res;
    }
    async refresh() {
        await this.callOptinalFunc('refresh', []);
    }
    async onCompleteDone(item, opt) {
        await super.onCompleteDone(item, opt);
        if (!this.optionalFns.includes('on_complete'))
            return;
        await this.callOptinalFunc('on_complete', [item]);
    }
    onEnter(bufnr) {
        if (!this.optionalFns.includes('on_enter'))
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return;
        let { filetypes } = this;
        if (filetypes && !filetypes.includes(doc.filetype))
            return;
        this.callOptinalFunc('on_enter', [{
                bufnr,
                uri: doc.uri,
                languageId: doc.filetype
            }]).logError();
    }
    async doComplete(opt, token) {
        let { col, input, line, colnr } = opt;
        let startcol = await this.callOptinalFunc('get_startcol', [opt]);
        if (token.isCancellationRequested)
            return;
        if (startcol) {
            if (startcol < 0)
                return null;
            startcol = Number(startcol);
            // invalid startcol
            if (isNaN(startcol) || startcol < 0)
                startcol = col;
            if (startcol !== col) {
                input = string_1.byteSlice(line, startcol, colnr - 1);
                opt = Object.assign({}, opt, {
                    col: startcol,
                    changed: col - startcol,
                    input
                });
            }
        }
        let items = await this.nvim.callAsync('coc#util#do_complete', [this.name, opt]);
        if (!items || items.length == 0 || token.isCancellationRequested)
            return null;
        if (this.firstMatch && input.length) {
            let ch = input[0];
            items = items.filter(item => {
                let cfirst = item.filterText ? item.filterText[0] : item.word[0];
                return fuzzy_1.fuzzyChar(ch, cfirst);
            });
        }
        items = items.map(item => {
            if (typeof item == 'string') {
                return { word: item, menu: this.menu, isSnippet: this.isSnippet };
            }
            let menu = item.menu ? item.menu + ' ' : '';
            item.menu = `${menu}${this.menu}`;
            item.isSnippet = this.isSnippet;
            delete item.user_data;
            return item;
        });
        let res = { items };
        if (startcol)
            res.startcol = startcol;
        return res;
    }
}
exports.default = VimSource;
//# sourceMappingURL=source-vim.js.map

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const source_1 = tslib_1.__importDefault(__webpack_require__(599));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('source-around');
class Around extends source_1.default {
    constructor() {
        super({
            name: 'around',
            filepath: __filename
        });
    }
    doComplete(opt) {
        let { bufnr, input } = opt;
        if (input.length === 0)
            return null;
        let document = workspace_1.default.getDocument(bufnr);
        if (!document)
            return null;
        let words = document.words;
        let moreWords = document.getMoreWords();
        words.push(...moreWords);
        words = this.filterWords(words, opt);
        return Promise.resolve({
            items: words.map(word => ({
                word,
                menu: this.menu
            }))
        });
    }
}
exports.default = Around;
function regist(sourceMap) {
    sourceMap.set('around', new Around());
    return vscode_languageserver_protocol_1.Disposable.create(() => {
        sourceMap.delete('around');
    });
}
exports.regist = regist;
//# sourceMappingURL=around.js.map

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const source_1 = tslib_1.__importDefault(__webpack_require__(599));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('source-buffer');
class Buffer extends source_1.default {
    constructor() {
        super({
            name: 'buffer',
            filepath: __filename
        });
    }
    get ignoreGitignore() {
        return this.getConfig('ignoreGitignore', true);
    }
    getWords(bufnr) {
        let { ignoreGitignore } = this;
        let words = [];
        workspace_1.default.documents.forEach(document => {
            if (document.bufnr == bufnr)
                return;
            if (ignoreGitignore && document.isIgnored)
                return;
            for (let word of document.words) {
                if (!words.includes(word)) {
                    words.push(word);
                }
            }
        });
        return words;
    }
    doComplete(opt) {
        let { bufnr, input } = opt;
        if (input.length == 0)
            return null;
        let words = this.getWords(bufnr);
        words = this.filterWords(words, opt);
        return Promise.resolve({
            items: words.map(word => ({
                word,
                menu: this.menu
            }))
        });
    }
}
exports.default = Buffer;
function regist(sourceMap) {
    sourceMap.set('buffer', new Buffer());
    return vscode_languageserver_protocol_1.Disposable.create(() => {
        sourceMap.delete('buffer');
    });
}
exports.regist = regist;
//# sourceMappingURL=buffer.js.map

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fs_1 = tslib_1.__importDefault(__webpack_require__(66));
const minimatch_1 = tslib_1.__importDefault(__webpack_require__(271));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const util_1 = tslib_1.__importDefault(__webpack_require__(74));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const source_1 = tslib_1.__importDefault(__webpack_require__(599));
const fs_2 = __webpack_require__(304);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('source-file');
const pathRe = /(?:\.{0,2}|~|\$HOME|([\w]+)|)\/(?:[\w.@()-]+\/)*(?:[\w.@()-])*$/;
class File extends source_1.default {
    constructor() {
        super({
            name: 'file',
            filepath: __filename
        });
    }
    resolveEnvVariables(str) {
        let replaced = str;
        // windows
        replaced = replaced.replace(/%([^%]+)%/g, (_, n) => process.env[n]);
        // linux and mac
        replaced = replaced.replace(/\$([A-Z_]+[A-Z0-9_]*)|\${([A-Z0-9_]*)}/gi, (_, a, b) => process.env[a || b]);
        return replaced;
    }
    getPathOption(opt) {
        let { line, colnr } = opt;
        let part = string_1.byteSlice(line, 0, colnr - 1);
        part = this.resolveEnvVariables(part);
        if (!part || part.endsWith('//'))
            return null;
        let ms = part.match(pathRe);
        if (ms && ms.length) {
            const pathstr = workspace_1.default.expand(ms[0]);
            let input = ms[0].match(/[^/]*$/)[0];
            return { pathstr, part: ms[1], startcol: colnr - input.length - 1, input };
        }
        return null;
    }
    async getFileItem(root, filename) {
        let f = path_1.default.join(root, filename);
        let stat = await fs_2.statAsync(f);
        if (stat) {
            let abbr = stat.isDirectory() ? filename + '/' : filename;
            let word = filename;
            return { word, abbr };
        }
        return null;
    }
    filterFiles(files) {
        let ignoreHidden = this.getConfig('ignoreHidden', true);
        let ignorePatterns = this.getConfig('ignorePatterns', []);
        return files.filter(f => {
            if (f == null)
                return false;
            if (ignoreHidden && f.startsWith("."))
                return false;
            for (let p of ignorePatterns) {
                if (minimatch_1.default(f, p, { dot: true }))
                    return false;
            }
            return true;
        });
    }
    async getItemsFromRoot(pathstr, root) {
        let res = [];
        let part = pathstr.endsWith("/") ? pathstr : path_1.default.dirname(pathstr);
        let dir = path_1.default.isAbsolute(pathstr) ? part : path_1.default.join(root, part);
        let stat = await fs_2.statAsync(dir);
        if (stat && stat.isDirectory()) {
            let files = await util_1.default.promisify(fs_1.default.readdir)(dir);
            files = this.filterFiles(files);
            let items = await Promise.all(files.map(filename => this.getFileItem(dir, filename)));
            res = res.concat(items);
        }
        res = res.filter(item => item != null);
        return res;
    }
    get trimSameExts() {
        return this.getConfig('trimSameExts', []);
    }
    async doComplete(opt) {
        let { col, filepath } = opt;
        let option = this.getPathOption(opt);
        if (!option)
            return null;
        let { pathstr, part, startcol, input } = option;
        if (startcol < opt.col)
            return null;
        let startPart = opt.col == startcol ? '' : string_1.byteSlice(opt.line, opt.col, startcol);
        let dirname = path_1.default.dirname(filepath);
        let ext = path_1.default.extname(path_1.default.basename(filepath));
        let cwd = await this.nvim.call('getcwd', []);
        let root;
        if (pathstr.startsWith(".")) {
            root = filepath ? path_1.default.dirname(filepath) : cwd;
        }
        else if (pathstr.startsWith("/")) {
            root = pathstr.endsWith("/") ? pathstr : path_1.default.dirname(pathstr);
        }
        else if (part) {
            if (fs_1.default.existsSync(path_1.default.join(dirname, part))) {
                root = dirname;
            }
            else if (fs_1.default.existsSync(path_1.default.join(cwd, part))) {
                root = cwd;
            }
        }
        else {
            root = cwd;
        }
        if (!root)
            return null;
        let items = await this.getItemsFromRoot(pathstr, root);
        let trimExt = this.trimSameExts.includes(ext);
        let first = input[0];
        if (first && col == startcol)
            items = items.filter(o => o.word[0] === first);
        return {
            items: items.map(item => {
                let ex = path_1.default.extname(item.word);
                item.word = trimExt && ex === ext ? item.word.replace(ext, '') : item.word;
                return {
                    word: `${startPart}${item.word}`,
                    abbr: `${startPart}${item.abbr}`,
                    menu: this.menu
                };
            })
        };
    }
}
exports.default = File;
function regist(sourceMap) {
    sourceMap.set('file', new File());
    return vscode_languageserver_protocol_1.Disposable.create(() => {
        sourceMap.delete('file');
    });
}
exports.regist = regist;
//# sourceMappingURL=file.js.map

/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const fuzzy_1 = __webpack_require__(580);
const string_1 = __webpack_require__(310);
const match_1 = __webpack_require__(605);
const logger = __webpack_require__(64)('completion-complete');
// first time completion
const FIRST_TIMEOUT = 500;
class Complete {
    constructor(option, document, recentScores, config, sources, nvim) {
        this.option = option;
        this.document = document;
        this.config = config;
        this.sources = sources;
        this.nvim = nvim;
        // identify this complete
        this.results = [];
        this.completing = new Set();
        this._canceled = false;
        this.tokenSources = new Map();
        this._onDidComplete = new vscode_languageserver_protocol_1.Emitter();
        this.onDidComplete = this._onDidComplete.event;
        Object.defineProperty(this, 'recentScores', {
            get: () => recentScores || {}
        });
    }
    get isCompleting() {
        return this.completing.size > 0;
    }
    get isCanceled() {
        return this._canceled;
    }
    get isEmpty() {
        return this.results.length == 0;
    }
    get startcol() {
        return this.option.col || 0;
    }
    get input() {
        return this.option.input;
    }
    get isIncomplete() {
        return this.results.findIndex(o => o.isIncomplete) !== -1;
    }
    async completeSource(source) {
        let { col } = this.option;
        // new option for each source
        let opt = Object.assign({}, this.option);
        let timeout = this.config.timeout;
        timeout = Math.max(Math.min(timeout, 15000), 500);
        try {
            if (typeof source.shouldComplete === 'function') {
                let shouldRun = await Promise.resolve(source.shouldComplete(opt));
                if (!shouldRun)
                    return null;
            }
            let start = Date.now();
            let oldSource = this.tokenSources.get(source.name);
            if (oldSource)
                oldSource.cancel();
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            this.tokenSources.set(source.name, tokenSource);
            await new Promise((resolve, reject) => {
                let { name } = source;
                let timer = setTimeout(() => {
                    this.nvim.command(`echohl WarningMsg| echom 'source ${source.name} timeout after ${timeout}ms'|echohl None`, true);
                    tokenSource.cancel();
                }, timeout);
                let cancelled = false;
                let called = false;
                let empty = false;
                let ft = setTimeout(() => {
                    if (called)
                        return;
                    empty = true;
                    resolve();
                }, FIRST_TIMEOUT);
                let onFinished = () => {
                    if (called)
                        return;
                    called = true;
                    disposable.dispose();
                    clearTimeout(ft);
                    clearTimeout(timer);
                    this.tokenSources.delete(name);
                };
                let disposable = tokenSource.token.onCancellationRequested(() => {
                    disposable.dispose();
                    this.completing.delete(name);
                    cancelled = true;
                    onFinished();
                    logger.debug(`Source "${name}" cancelled`);
                    resolve();
                });
                this.completing.add(name);
                Promise.resolve(source.doComplete(opt, tokenSource.token)).then(result => {
                    this.completing.delete(name);
                    if (cancelled)
                        return;
                    onFinished();
                    let dt = Date.now() - start;
                    logger.debug(`Source "${name}" takes ${dt}ms`);
                    if (result && result.items && result.items.length) {
                        result.priority = source.priority;
                        result.source = name;
                        // lazy completed items
                        if (empty && result.startcol && result.startcol != col) {
                            this.results = [result];
                        }
                        else {
                            let { results } = this;
                            let idx = results.findIndex(o => o.source == name);
                            if (idx != -1) {
                                results.splice(idx, 1, result);
                            }
                            else {
                                results.push(result);
                            }
                        }
                        if (empty)
                            this._onDidComplete.fire();
                        resolve();
                    }
                    else {
                        resolve();
                    }
                }, err => {
                    this.completing.delete(name);
                    onFinished();
                    reject(err);
                });
            });
        }
        catch (err) {
            this.nvim.command(`echoerr 'Complete ${source.name} error: ${err.message.replace(/'/g, "''")}'`, true);
            logger.error('Complete error:', source.name, err);
        }
    }
    async completeInComplete(resumeInput) {
        let { results, document } = this;
        let remains = results.filter(res => !res.isIncomplete);
        remains.forEach(res => {
            res.items.forEach(item => delete item.user_data);
        });
        let arr = results.filter(res => res.isIncomplete);
        let names = arr.map(o => o.source);
        let { input, colnr, linenr } = this.option;
        Object.assign(this.option, {
            input: resumeInput,
            line: document.getline(linenr - 1),
            colnr: colnr + (resumeInput.length - input.length),
            triggerCharacter: null,
            triggerForInComplete: true
        });
        let sources = this.sources.filter(s => names.includes(s.name));
        await Promise.all(sources.map(s => this.completeSource(s)));
        return this.filterResults(resumeInput, Math.floor(Date.now() / 1000));
    }
    filterResults(input, cid = 0) {
        let { results } = this;
        results.sort((a, b) => {
            if (a.source == 'tabnine')
                return 1;
            if (b.source == 'tabnine')
                return -1;
            return b.priority - a.priority;
        });
        let now = Date.now();
        let { bufnr } = this.option;
        let { snippetIndicator, removeDuplicateItems, fixInsertedWord, asciiCharactersOnly } = this.config;
        let followPart = (!fixInsertedWord || cid == 0) ? '' : this.getFollowPart();
        if (results.length == 0)
            return [];
        let arr = [];
        let codes = fuzzy_1.getCharCodes(input);
        let words = new Set();
        for (let i = 0, l = results.length; i < l; i++) {
            let res = results[i];
            let { items, source, priority } = res;
            for (let idx = 0; idx < items.length; idx++) {
                let item = items[idx];
                if (!item || typeof item.word !== 'string') {
                    continue;
                }
                let { word } = item;
                // eslint-disable-next-line no-control-regex
                if (asciiCharactersOnly && !/^[\x00-\x7F]*$/.test(word)) {
                    continue;
                }
                if ((!item.dup || source == 'tabnine') && words.has(word))
                    continue;
                if (removeDuplicateItems && !item.isSnippet && words.has(word) && item.line == undefined)
                    continue;
                let filterText = item.filterText || item.word;
                item.filterText = filterText;
                if (filterText.length < input.length)
                    continue;
                let score = item.kind && filterText == input ? 64 : match_1.matchScore(filterText, codes);
                if (input.length && score == 0)
                    continue;
                if (followPart.length && !item.isSnippet) {
                    if (item.word.endsWith(followPart)) {
                        let { word } = item;
                        item.word = item.word.slice(0, -followPart.length);
                        item.abbr = item.abbr || word;
                    }
                }
                if (!item.user_data) {
                    let user_data = { cid, source };
                    user_data.index = item.index || idx;
                    if (item.isSnippet) {
                        let abbr = item.abbr || item.word;
                        if (!abbr.endsWith(snippetIndicator)) {
                            item.abbr = `${item.abbr || item.word}${snippetIndicator}`;
                        }
                    }
                    if (item.signature)
                        user_data.signature = item.signature;
                    item.user_data = JSON.stringify(user_data);
                    item.source = source;
                    let recentScore = this.recentScores[`${bufnr}|${word}`];
                    if (recentScore && now - recentScore < 60 * 1000) {
                        item.recentScore = recentScore;
                    }
                    else {
                        item.recentScore = 0;
                    }
                }
                item.priority = priority;
                item.abbr = item.abbr || item.word;
                item.score = input.length ? score * (item.sourceScore || 1) : 0;
                item.localBonus = this.localBonus ? this.localBonus.get(filterText) || 0 : 0;
                words.add(word);
                if (item.isSnippet && item.word == input) {
                    item.preselect = true;
                }
                arr.push(item);
            }
        }
        arr.sort((a, b) => {
            let sa = a.sortText;
            let sb = b.sortText;
            let wa = a.filterText;
            let wb = b.filterText;
            if (a.score != b.score)
                return b.score - a.score;
            if (a.priority != b.priority)
                return b.priority - a.priority;
            if (sa && sb && sa != sb)
                return sa < sb ? -1 : 1;
            if (a.recentScore != b.recentScore)
                return b.recentScore - a.recentScore;
            if (a.localBonus != b.localBonus) {
                if (a.localBonus && b.localBonus && wa != wb) {
                    if (wa.startsWith(wb))
                        return 1;
                    if (wb.startsWith(wa))
                        return -1;
                }
                return b.localBonus - a.localBonus;
            }
            // Default sort method
            switch (this.config.defaultSortMethod) {
                case 'alphabetical':
                    return a.filterText.localeCompare(b.filterText);
                case 'length':
                default: // Fallback on length
                    return a.filterText.length - b.filterText.length;
            }
        });
        return this.limitCompleteItems(arr.slice(0, this.config.maxItemCount));
    }
    limitCompleteItems(items) {
        let { highPrioritySourceLimit, lowPrioritySourceLimit } = this.config;
        if (!highPrioritySourceLimit && !lowPrioritySourceLimit)
            return items;
        let counts = new Map();
        return items.filter(item => {
            let { priority, source } = item;
            let isLow = priority < 90;
            let curr = counts.get(source) || 0;
            if ((lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit)
                || (highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit)) {
                return false;
            }
            counts.set(source, curr + 1);
            return true;
        });
    }
    hasMatch(input) {
        let { results } = this;
        if (!results)
            return false;
        let codes = fuzzy_1.getCharCodes(input);
        for (let i = 0, l = results.length; i < l; i++) {
            let items = results[i].items;
            let idx = items.findIndex(item => fuzzy_1.fuzzyMatch(codes, item.filterText || item.word));
            if (idx !== -1)
                return true;
        }
        return false;
    }
    async doComplete() {
        let opts = this.option;
        let { line, colnr, linenr, col } = this.option;
        if (this.config.localityBonus) {
            let line = linenr - 1;
            this.localBonus = this.document.getLocalifyBonus(vscode_languageserver_protocol_1.Position.create(line, opts.col - 1), vscode_languageserver_protocol_1.Position.create(line, colnr));
        }
        else {
            this.localBonus = new Map();
        }
        await Promise.all(this.sources.map(s => this.completeSource(s)));
        let { results } = this;
        if (results.length == 0)
            return [];
        let engrossResult = results.find(r => r.startcol != null && r.startcol != col);
        if (engrossResult) {
            let { startcol } = engrossResult;
            opts.col = startcol;
            opts.input = string_1.byteSlice(line, startcol, colnr - 1);
            this.results = [engrossResult];
        }
        logger.info(`Results from: ${this.results.map(s => s.source).join(',')}`);
        return this.filterResults(opts.input, Math.floor(Date.now() / 1000));
    }
    resolveCompletionItem(item) {
        let { results } = this;
        if (!results)
            return null;
        try {
            if (item.user_data) {
                let { source } = JSON.parse(item.user_data);
                let result = results.find(res => res.source == source);
                return result.items.find(o => o.user_data == item.user_data);
            }
            for (let result of results) {
                let res = result.items.find(o => o.abbr == item.abbr && o.info == item.info);
                if (res)
                    return res;
            }
            return null;
        }
        catch (e) {
            return null;
        }
    }
    getFollowPart() {
        let { colnr, line } = this.option;
        let idx = string_1.characterIndex(line, colnr - 1);
        if (idx == line.length)
            return '';
        let part = line.slice(idx - line.length);
        return part.match(/^\S?[\w-]*/)[0];
    }
    dispose() {
        if (this._canceled)
            return;
        this._onDidComplete.dispose();
        this._canceled = true;
        for (let tokenSource of this.tokenSources.values()) {
            tokenSource.cancel();
        }
        this.tokenSources.clear();
        this.sources = [];
        this.results = [];
    }
}
exports.default = Complete;
//# sourceMappingURL=complete.js.map

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const fuzzy_1 = __webpack_require__(580);
function nextWordIndex(start = 0, codes) {
    for (let i = start; i < codes.length; i++) {
        if (isWordIndex(i, codes)) {
            return i;
        }
    }
    return -1;
}
function upperCase(code) {
    return code >= 65 && code <= 90;
}
function isWordIndex(index, codes) {
    if (index == 0)
        return true;
    let curr = codes[index];
    if (!fuzzy_1.wordChar(curr))
        return false;
    let pre = codes[index - 1];
    if (!fuzzy_1.wordChar(pre))
        return true;
    if (upperCase(curr) && !upperCase(pre))
        return true;
    return false;
}
/**
 * Rules:
 * - First strict 5, first case match 2.5
 * - First word character strict 2.5, first word character case 2
 * - First fuzzy match strict 1, first fuzzy case 0.5
 * - Follow strict 1, follow case 0.5
 * - Follow word start 1, follow word case 0.75
 * - First fuzzy strict 0.1, first fuzzy case 0.05
 *
 * @public
 * @param {string} word
 * @param {number[]} input
 * @returns {number}
 */
function matchScore(word, input) {
    if (input.length == 0 || word.length < input.length)
        return 0;
    let codes = fuzzy_1.getCharCodes(word);
    let curr = codes[0];
    let score = 0;
    let first = input[0];
    let idx = 1;
    let allowFuzzy = true;
    if (fuzzy_1.caseMatch(first, curr)) {
        score = first == curr ? 5 : 2.5;
        idx = 1;
    }
    else {
        // first word 2.5/2
        let next = nextWordIndex(1, codes);
        if (next != -1) {
            if (fuzzy_1.caseMatch(first, codes[next])) {
                score = first == codes[next] ? 2.5 : 2;
                idx = next + 1;
            }
        }
        if (score == 0) {
            // first fuzzy 1/0.5
            for (let i = 1; i < codes.length; i++) {
                if (fuzzy_1.caseMatch(first, codes[i])) {
                    score = first == codes[i] ? 1 : 0.5;
                    idx = i + 1;
                    allowFuzzy = false;
                }
            }
        }
    }
    if (input.length == 1 || score == 0)
        return score;
    let next = nextScore(codes, idx, input.slice(1), allowFuzzy);
    return next == 0 ? 0 : score + next;
}
exports.matchScore = matchScore;
function nextScore(codes, index, inputCodes, allowFuzzy = true) {
    if (index >= codes.length)
        return 0;
    let scores = [];
    let input = inputCodes[0];
    let len = codes.length;
    let isFinal = inputCodes.length == 1;
    if (!fuzzy_1.wordChar(input)) {
        for (let i = index; i < len; i++) {
            if (codes[i] == input) {
                if (isFinal)
                    return 1;
                let next = nextScore(codes, i + 1, inputCodes.slice(1), allowFuzzy);
                return next == 0 ? 0 : 1 + next;
            }
        }
        return 0;
    }
    let curr = codes[index];
    let match = fuzzy_1.caseMatch(input, curr);
    if (match) {
        let score = input == curr ? 1 : 0.5;
        if (!isFinal) {
            let next = nextScore(codes, index + 1, inputCodes.slice(1), allowFuzzy);
            score = next == 0 ? 0 : score + next;
        }
        scores.push(score);
    }
    // should not find if current is word index
    if (fuzzy_1.wordChar(input) && !isWordIndex(index, codes)) {
        let idx = nextWordIndex(index + 1, codes);
        if (idx !== -1) {
            let next = codes[idx];
            if (fuzzy_1.caseMatch(input, next)) {
                let score = input == next ? 1 : 0.75;
                if (!isFinal) {
                    let next = nextScore(codes, idx + 1, inputCodes.slice(1), allowFuzzy);
                    score = next == 0 ? 0 : score + next;
                }
                scores.push(score);
            }
        }
    }
    // find fuzzy
    if (!match && allowFuzzy) {
        for (let i = index + 1; i < len; i++) {
            let code = codes[i];
            if (fuzzy_1.caseMatch(input, code)) {
                let score = input == code ? 0.1 : 0.05;
                if (!isFinal) {
                    let next = nextScore(codes, i + 1, inputCodes.slice(1), false);
                    score = next == 0 ? 0 : score + next;
                }
                scores.push(score);
            }
        }
    }
    if (!scores.length)
        return 0;
    return Math.max(...scores);
}
//# sourceMappingURL=match.js.map

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const floatBuffer_1 = tslib_1.__importDefault(__webpack_require__(520));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('floating');
class Floating {
    constructor() {
        this.winid = 0;
        this.bufnr = 0;
        this.floatBuffer = new floatBuffer_1.default(workspace_1.default.nvim);
        let configuration = workspace_1.default.getConfiguration('suggest');
        let enableFloat = configuration.get('floatEnable', true);
        let { env } = workspace_1.default;
        if (enableFloat && !env.floating && !env.textprop) {
            enableFloat = false;
        }
        this.config = {
            srcId: workspace_1.default.createNameSpace('coc-pum-float'),
            maxPreviewWidth: configuration.get('maxPreviewWidth', 80),
            enable: enableFloat
        };
    }
    async show(docs, bounding, token) {
        if (!this.config.enable)
            return;
        await this.showDocumentationFloating(docs, bounding, token);
    }
    async showDocumentationFloating(docs, bounding, token) {
        let { nvim } = workspace_1.default;
        let config = this.calculateBounding(docs, bounding);
        if (!config || token.isCancellationRequested)
            return;
        await this.floatBuffer.setDocuments(docs, config.width);
        if (token.isCancellationRequested)
            return;
        let res = await nvim.call('coc#util#create_float_win', [this.winid, this.bufnr, config]);
        if (!res)
            return;
        let winid = this.winid = res[0];
        let bufnr = this.bufnr = res[1];
        if (token.isCancellationRequested) {
            this.close();
            return;
        }
        nvim.pauseNotification();
        if (workspace_1.default.isNvim) {
            nvim.command(`noa call win_gotoid(${winid})`, true);
            this.floatBuffer.setLines(bufnr);
            nvim.command('noa normal! gg0', true);
            nvim.command('noa wincmd p', true);
        }
        else {
            this.floatBuffer.setLines(bufnr, winid);
            nvim.call('win_execute', [winid, `noa normal! gg0`], true);
            nvim.command('redraw', true);
        }
        let [, err] = await nvim.resumeNotification();
        if (err)
            logger.error(`Error on ${err[0]}: ${err[1]} - ${err[2]}`);
    }
    close() {
        if (!this.winid)
            return;
        let { winid } = this;
        this.winid = null;
        workspace_1.default.nvim.call('coc#util#close_win', [winid], true);
        if (workspace_1.default.isVim)
            workspace_1.default.nvim.command('redraw', true);
    }
    calculateBounding(docs, bounding) {
        let { config } = this;
        let { columns, lines } = workspace_1.default.env;
        let { maxPreviewWidth } = config;
        let pumWidth = bounding.width + (bounding.scrollbar ? 1 : 0);
        let showRight = true;
        let paddingRight = columns - bounding.col - pumWidth;
        if (bounding.col > paddingRight)
            showRight = false;
        let maxWidth = showRight ? paddingRight - 1 : bounding.col - 1;
        maxWidth = Math.min(maxPreviewWidth, maxWidth);
        let maxHeight = lines - bounding.row - workspace_1.default.env.cmdheight - 1;
        let { width, height } = floatBuffer_1.default.getDimension(docs, maxWidth, maxHeight);
        if (width == 0 || height == 0)
            return null;
        return {
            col: showRight ? bounding.col + pumWidth : bounding.col - width - 1,
            row: bounding.row,
            height,
            width,
            relative: 'editor'
        };
    }
}
exports.default = Floating;
//# sourceMappingURL=floating.js.map

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.
 *
 * @param {Function} func Function to wrap.
 * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.
 * @return {Function} A new function that wraps the `func` function passed in.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function throttle(func, wait) {
    let args;
    let rtn;
    let timeoutID;
    let last = 0;
    function fn() {
        args = arguments;
        let delta = Date.now() - last;
        if (!timeoutID) {
            if (last != 0 && delta >= wait) {
                call();
            }
            else {
                timeoutID = setTimeout(call, wait - delta);
            }
        }
        return rtn;
    }
    function call() {
        timeoutID = 0;
        last = Date.now();
        rtn = func.apply(null, args);
        args = null;
    }
    fn.clear = () => {
        if (timeoutID) {
            clearTimeout(timeoutID);
        }
    };
    return fn;
}
exports.default = throttle;
//# sourceMappingURL=throttle.js.map

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_languageserver_textdocument_1 = __webpack_require__(293);
const position_1 = __webpack_require__(311);
const Snippets = tslib_1.__importStar(__webpack_require__(329));
const string_1 = __webpack_require__(310);
const logger = __webpack_require__(64)('snippets-snipet');
class CocSnippet {
    constructor(_snippetString, position, _variableResolver) {
        this._snippetString = _snippetString;
        this.position = position;
        this._variableResolver = _variableResolver;
        this._parser = new Snippets.SnippetParser();
        const snippet = this._parser.parse(this._snippetString, true);
        if (_variableResolver) {
            snippet.resolveVariables(_variableResolver);
        }
        this.tmSnippet = snippet;
        this.update();
    }
    adjustPosition(characterCount, lineCount) {
        let { line, character } = this.position;
        this.position = {
            line: line + lineCount,
            character: character + characterCount
        };
        this.update();
    }
    // adjust for edit before snippet
    adjustTextEdit(edit) {
        let { range, newText } = edit;
        if (position_1.comparePosition(this.range.start, range.end) < 0)
            return false;
        // check change of placeholder at beginning
        if (!newText.includes('\n')
            && position_1.comparePosition(range.start, range.end) == 0
            && position_1.comparePosition(this.range.start, range.start) == 0) {
            let idx = this._placeholders.findIndex(o => position_1.comparePosition(o.range.start, range.start) == 0);
            if (idx !== -1)
                return false;
        }
        let changed = position_1.getChangedPosition(this.range.start, edit);
        if (changed.line == 0 && changed.character == 0)
            return true;
        this.adjustPosition(changed.character, changed.line);
        return true;
    }
    get isPlainText() {
        if (this._placeholders.length > 1)
            return false;
        return this._placeholders.every(o => o.value == '');
    }
    get finalCount() {
        return this._placeholders.filter(o => o.isFinalTabstop).length;
    }
    toString() {
        return this.tmSnippet.toString();
    }
    get range() {
        let { position } = this;
        const content = this.tmSnippet.toString();
        const doc = vscode_languageserver_textdocument_1.TextDocument.create('untitled:/1', 'snippet', 0, content);
        const pos = doc.positionAt(content.length);
        const end = pos.line == 0 ? position.character + pos.character : pos.character;
        return vscode_languageserver_protocol_1.Range.create(position, vscode_languageserver_protocol_1.Position.create(position.line + pos.line, end));
    }
    get firstPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
            if (p.index == 0)
                continue;
            if (index == 0 || p.index < index) {
                index = p.index;
            }
        }
        return this.getPlaceholder(index);
    }
    get lastPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
            if (index == 0 || p.index > index) {
                index = p.index;
            }
        }
        return this.getPlaceholder(index);
    }
    getPlaceholderById(id) {
        return this._placeholders.find(o => o.id == id);
    }
    getPlaceholder(index) {
        let placeholders = this._placeholders.filter(o => o.index == index);
        let filtered = placeholders.filter(o => !o.transform);
        return filtered.length ? filtered[0] : placeholders[0];
    }
    getPrevPlaceholder(index) {
        if (index == 0)
            return this.lastPlaceholder;
        let prev = this.getPlaceholder(index - 1);
        if (!prev)
            return this.getPrevPlaceholder(index - 1);
        return prev;
    }
    getNextPlaceholder(index) {
        let indexes = this._placeholders.map(o => o.index);
        let max = Math.max.apply(null, indexes);
        if (index >= max)
            return this.finalPlaceholder;
        let next = this.getPlaceholder(index + 1);
        if (!next)
            return this.getNextPlaceholder(index + 1);
        return next;
    }
    get finalPlaceholder() {
        return this._placeholders.find(o => o.isFinalTabstop);
    }
    getPlaceholderByRange(range) {
        return this._placeholders.find(o => position_1.rangeInRange(range, o.range));
    }
    insertSnippet(placeholder, snippet, range) {
        let { start } = placeholder.range;
        // let offset = position.character - start.character
        let editStart = vscode_languageserver_protocol_1.Position.create(range.start.line - start.line, range.start.line == start.line ? range.start.character - start.character : range.start.character);
        let editEnd = vscode_languageserver_protocol_1.Position.create(range.end.line - start.line, range.end.line == start.line ? range.end.character - start.character : range.end.character);
        let editRange = vscode_languageserver_protocol_1.Range.create(editStart, editEnd);
        let first = this.tmSnippet.insertSnippet(snippet, placeholder.id, editRange);
        this.update();
        return first;
    }
    // update internal positions, no change of buffer
    // return TextEdit list when needed
    updatePlaceholder(placeholder, edit) {
        let { start, end } = edit.range;
        let { range } = this;
        let { value, id, index } = placeholder;
        let newText = position_1.editRange(placeholder.range, value, edit);
        let delta = 0;
        if (!newText.includes('\n')) {
            for (let p of this._placeholders) {
                if (p.index == index &&
                    p.id < id &&
                    p.line == placeholder.range.start.line) {
                    let text = this.tmSnippet.getPlaceholderText(p.id, newText);
                    delta = delta + string_1.byteLength(text) - string_1.byteLength(p.value);
                }
            }
        }
        if (placeholder.isVariable) {
            this.tmSnippet.updateVariable(id, newText);
        }
        else {
            this.tmSnippet.updatePlaceholder(id, newText);
        }
        let endPosition = position_1.adjustPosition(range.end, edit);
        let snippetEdit = {
            range: vscode_languageserver_protocol_1.Range.create(range.start, endPosition),
            newText: this.tmSnippet.toString()
        };
        this.update();
        return { edits: [snippetEdit], delta };
    }
    update() {
        const snippet = this.tmSnippet;
        const { line, character } = this.position;
        const document = vscode_languageserver_textdocument_1.TextDocument.create('untitled:/1', 'snippet', 0, snippet.toString());
        const { placeholders, variables, maxIndexNumber } = snippet;
        const variableIndexMap = new Map();
        let variableIndex = maxIndexNumber + 1;
        this._placeholders = [...placeholders, ...variables].map((p, idx) => {
            const offset = snippet.offset(p);
            const position = document.positionAt(offset);
            const start = {
                line: line + position.line,
                character: position.line == 0 ? character + position.character : position.character
            };
            let index;
            if (p instanceof Snippets.Variable) {
                let key = p.name;
                if (variableIndexMap.has(key)) {
                    index = variableIndexMap.get(key);
                }
                else {
                    variableIndexMap.set(key, variableIndex);
                    index = variableIndex;
                    variableIndex = variableIndex + 1;
                }
                // variableIndex = variableIndex + 1
            }
            else {
                index = p.index;
            }
            const value = p.toString();
            const lines = value.split('\n');
            let res = {
                range: vscode_languageserver_protocol_1.Range.create(start, {
                    line: start.line + lines.length - 1,
                    character: lines.length == 1 ? start.character + value.length : lines[lines.length - 1].length
                }),
                transform: p.transform != null,
                line: start.line,
                id: idx,
                index,
                value,
                isVariable: p instanceof Snippets.Variable,
                isFinalTabstop: p.index === 0
            };
            Object.defineProperty(res, 'snippet', {
                enumerable: false
            });
            if (p instanceof Snippets.Placeholder && p.choice) {
                let { options } = p.choice;
                if (options && options.length) {
                    res.choice = options.map(o => o.value);
                }
            }
            return res;
        });
    }
}
exports.CocSnippet = CocSnippet;
//# sourceMappingURL=snippet.js.map

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const path = tslib_1.__importStar(__webpack_require__(82));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const vscode_uri_1 = __webpack_require__(243);
const clipboardy_1 = tslib_1.__importDefault(__webpack_require__(545));
const logger = __webpack_require__(64)('snippets-variable');
class SnippetVariableResolver {
    constructor() {
        this._variableToValue = {};
        const currentDate = new Date();
        this._variableToValue = {
            CURRENT_YEAR: currentDate.getFullYear().toString(),
            CURRENT_YEAR_SHORT: currentDate
                .getFullYear()
                .toString()
                .slice(-2),
            CURRENT_MONTH: (currentDate.getMonth() + 1).toString(),
            CURRENT_DATE: currentDate.getDate().toString(),
            CURRENT_HOUR: currentDate.getHours().toString(),
            CURRENT_MINUTE: currentDate.getMinutes().toString(),
            CURRENT_SECOND: currentDate.getSeconds().toString(),
            CURRENT_DAY_NAME: currentDate.toLocaleString("en-US", { weekday: "long" }),
            CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString("en-US", { weekday: "short" }),
            CURRENT_MONTH_NAME: currentDate.toLocaleString("en-US", { month: "long" }),
            CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString("en-US", { month: "short" })
        };
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    async init(document) {
        let filepath = vscode_uri_1.URI.parse(document.uri).fsPath;
        let [lnum, line, cword, selected, yank] = await this.nvim.eval(`[line('.'),getline('.'),expand('<cword>'),get(g:,'coc_selected_text', ''),getreg('"')]`);
        let clipboard = '';
        try {
            clipboard = await clipboardy_1.default.read();
        }
        catch (e) {
            logger.error(`Error with clipboardy:`, e.message);
        }
        Object.assign(this._variableToValue, {
            YANK: yank || undefined,
            CLIPBOARD: clipboard || undefined,
            TM_CURRENT_LINE: line,
            TM_SELECTED_TEXT: selected || undefined,
            TM_CURRENT_WORD: cword,
            TM_LINE_INDEX: (lnum - 1).toString(),
            TM_LINE_NUMBER: lnum.toString(),
            TM_FILENAME: path.basename(filepath),
            TM_FILENAME_BASE: path.basename(filepath, path.extname(filepath)),
            TM_DIRECTORY: path.dirname(filepath),
            TM_FILEPATH: filepath,
        });
    }
    resolve(variable) {
        const variableName = variable.name;
        if (this._variableToValue.hasOwnProperty(variableName)) {
            return this._variableToValue[variableName] || '';
        }
        if (variable.children && variable.children.length) {
            return variable.toString();
        }
        return variableName;
    }
}
exports.SnippetVariableResolver = SnippetVariableResolver;
//# sourceMappingURL=variableResolve.js.map

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const util_1 = __webpack_require__(611);
const logger = __webpack_require__(64)('diagnostic-buffer');
const severityNames = ['CocError', 'CocWarning', 'CocInfo', 'CocHint'];
// maintains sign and highlightId
class DiagnosticBuffer {
    constructor(bufnr, uri, config) {
        this.bufnr = bufnr;
        this.uri = uri;
        this.config = config;
        this.signIds = new Set();
        this._onDidRefresh = new vscode_languageserver_protocol_1.Emitter();
        this.matchIds = new Set();
        this.onDidRefresh = this._onDidRefresh.event;
        this.srdId = workspace_1.default.createNameSpace('coc-diagnostic');
        this.refresh = debounce_1.default((diagnostics) => {
            this._refresh(diagnostics).logError();
        }, 300);
    }
    /**
     * Refresh diagnostics without debounce
     */
    forceRefresh(diagnostics) {
        this.refresh.clear();
        this._refresh(diagnostics).logError();
    }
    async _refresh(diagnostics) {
        let { refreshOnInsertMode } = this.config;
        let { nvim } = this;
        let arr = await nvim.eval(`[coc#util#check_refresh(${this.bufnr}),mode(),bufnr("%"),line("."),getloclist(bufwinid(${this.bufnr}),{'title':1})]`);
        if (arr[0] == 0)
            return;
        let mode = arr[1];
        if (!refreshOnInsertMode && mode.startsWith('i') && diagnostics.length)
            return;
        let bufnr = arr[2];
        let lnum = arr[3];
        nvim.pauseNotification();
        this.setDiagnosticInfo(diagnostics);
        this.addSigns(diagnostics);
        this.addHighlight(diagnostics, bufnr);
        this.updateLocationList(arr[4], diagnostics);
        if (this.bufnr == bufnr) {
            this.showVirtualText(diagnostics, lnum);
        }
        if (workspace_1.default.isVim) {
            this.nvim.command('redraw', true);
        }
        let res = await this.nvim.resumeNotification();
        if (Array.isArray(res) && res[1])
            throw new Error(res[1]);
        this._onDidRefresh.fire(void 0);
    }
    clearSigns() {
        let { nvim, signIds, bufnr } = this;
        if (signIds.size > 0) {
            nvim.call('coc#util#unplace_signs', [bufnr, Array.from(signIds)], true);
            signIds.clear();
        }
    }
    async checkSigns() {
        let { nvim, bufnr, signIds } = this;
        try {
            let content = await this.nvim.call('execute', [`sign place buffer=${bufnr}`]);
            let lines = content.split('\n');
            let ids = [];
            for (let line of lines) {
                let ms = line.match(/^\s*line=\d+\s+id=(\d+)\s+name=(\w+)/);
                if (!ms)
                    continue;
                let [, id, name] = ms;
                if (!signIds.has(Number(id)) && severityNames.includes(name)) {
                    ids.push(id);
                }
            }
            await nvim.call('coc#util#unplace_signs', [bufnr, ids]);
        }
        catch (e) {
            // noop
        }
    }
    updateLocationList(curr, diagnostics) {
        if (!this.config.locationlistUpdate)
            return;
        if (!curr || curr.title !== 'Diagnostics of coc')
            return;
        let items = [];
        for (let diagnostic of diagnostics) {
            let item = util_1.getLocationListItem(this.bufnr, diagnostic);
            items.push(item);
        }
        this.nvim.call('setloclist', [0, [], 'r', { title: 'Diagnostics of coc', items }], true);
    }
    addSigns(diagnostics) {
        if (!this.config.enableSign)
            return;
        this.clearSigns();
        let { nvim, bufnr, signIds } = this;
        let signId = this.config.signOffset;
        let lines = new Set();
        for (let diagnostic of diagnostics) {
            let { range, severity } = diagnostic;
            let line = range.start.line;
            if (lines.has(line))
                continue;
            lines.add(line);
            let name = util_1.getNameFromSeverity(severity);
            nvim.command(`sign place ${signId} line=${line + 1} name=${name} buffer=${bufnr}`, true);
            signIds.add(signId);
            signId = signId + 1;
        }
    }
    setDiagnosticInfo(diagnostics) {
        let lnums = [0, 0, 0, 0];
        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };
        for (let diagnostic of diagnostics) {
            switch (diagnostic.severity) {
                case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:
                    info.warning = info.warning + 1;
                    lnums[1] = lnums[1] || diagnostic.range.start.line + 1;
                    break;
                case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:
                    info.information = info.information + 1;
                    lnums[2] = lnums[2] || diagnostic.range.start.line + 1;
                    break;
                case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:
                    info.hint = info.hint + 1;
                    lnums[3] = lnums[3] || diagnostic.range.start.line + 1;
                    break;
                default:
                    lnums[0] = lnums[0] || diagnostic.range.start.line + 1;
                    info.error = info.error + 1;
            }
        }
        this.nvim.call('coc#util#set_buf_var', [this.bufnr, 'coc_diagnostic_info', info], true);
        this.nvim.call('coc#util#do_autocmd', ['CocDiagnosticChange'], true);
    }
    showVirtualText(diagnostics, lnum) {
        let { bufnr, config } = this;
        if (!config.virtualText)
            return;
        let buffer = this.nvim.createBuffer(bufnr);
        let srcId = this.config.virtualTextSrcId;
        let prefix = this.config.virtualTextPrefix;
        if (this.config.virtualTextCurrentLineOnly) {
            diagnostics = diagnostics.filter(d => {
                let { start, end } = d.range;
                return start.line <= lnum - 1 && end.line >= lnum - 1;
            });
        }
        buffer.clearNamespace(srcId);
        for (let diagnostic of diagnostics) {
            let { line } = diagnostic.range.start;
            let highlight = util_1.getNameFromSeverity(diagnostic.severity) + 'VirtualText';
            let msg = diagnostic.message.split(/\n/)
                .map((l) => l.trim())
                .filter((l) => l.length > 0)
                .slice(0, this.config.virtualTextLines)
                .join(this.config.virtualTextLineSeparator);
            buffer.setVirtualText(srcId, line, [[prefix + msg, highlight]], {}).logError();
        }
    }
    clearHighlight() {
        let { matchIds, document } = this;
        if (document) {
            document.clearMatchIds(matchIds);
        }
        this.matchIds.clear();
    }
    addHighlight(diagnostics, bufnr) {
        this.clearHighlight();
        if (diagnostics.length == 0)
            return;
        // can't add highlight for old vim
        if (workspace_1.default.isVim && !workspace_1.default.env.textprop && bufnr != this.bufnr)
            return;
        let { document } = this;
        if (!document)
            return;
        // TODO support DiagnosticTag
        const highlights = new Map();
        for (let diagnostic of diagnostics) {
            let { range, severity } = diagnostic;
            let hlGroup = util_1.getNameFromSeverity(severity) + 'Highlight';
            let ranges = highlights.get(hlGroup) || [];
            ranges.push(range);
            highlights.set(hlGroup, ranges);
        }
        for (let [hlGroup, ranges] of highlights.entries()) {
            let matchIds = document.highlightRanges(ranges, hlGroup, this.srdId);
            for (let id of matchIds)
                this.matchIds.add(id);
        }
    }
    /**
     * Used on buffer unload
     *
     * @public
     * @returns {Promise<void>}
     */
    async clear() {
        this.refresh.clear();
        let { nvim } = this;
        nvim.pauseNotification();
        this.clearHighlight();
        this.clearSigns();
        if (this.config.virtualText) {
            let buffer = nvim.createBuffer(this.bufnr);
            buffer.clearNamespace(this.config.virtualTextSrcId);
        }
        this.setDiagnosticInfo([]);
        await nvim.resumeNotification(false, true);
    }
    hasHighlights() {
        return this.matchIds.size > 0;
    }
    dispose() {
        this.refresh.clear();
        this._onDidRefresh.dispose();
    }
    get document() {
        return workspace_1.default.getDocument(this.uri);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
}
exports.DiagnosticBuffer = DiagnosticBuffer;
//# sourceMappingURL=buffer.js.map

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(211);
function getSeverityName(severity) {
    switch (severity) {
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Error:
            return 'Error';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:
            return 'Warning';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:
            return 'Information';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:
            return 'Hint';
        default:
            return 'Error';
    }
}
exports.getSeverityName = getSeverityName;
function getSeverityType(severity) {
    switch (severity) {
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Error:
            return 'E';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:
            return 'W';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:
            return 'I';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:
            return 'I';
        default:
            return 'Error';
    }
}
exports.getSeverityType = getSeverityType;
function severityLevel(level) {
    switch (level) {
        case 'hint':
            return vscode_languageserver_protocol_1.DiagnosticSeverity.Hint;
        case 'information':
            return vscode_languageserver_protocol_1.DiagnosticSeverity.Information;
        case 'warning':
            return vscode_languageserver_protocol_1.DiagnosticSeverity.Warning;
        case 'error':
            return vscode_languageserver_protocol_1.DiagnosticSeverity.Error;
        default:
            return vscode_languageserver_protocol_1.DiagnosticSeverity.Hint;
    }
}
exports.severityLevel = severityLevel;
function getNameFromSeverity(severity) {
    switch (severity) {
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Error:
            return 'CocError';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:
            return 'CocWarning';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:
            return 'CocInfo';
        case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:
            return 'CocHint';
        default:
            return 'CocError';
    }
}
exports.getNameFromSeverity = getNameFromSeverity;
function getLocationListItem(bufnr, diagnostic) {
    let { start } = diagnostic.range;
    let owner = diagnostic.source || 'coc.nvim';
    let msg = diagnostic.message.split('\n')[0];
    let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();
    return {
        bufnr,
        lnum: start.line + 1,
        col: start.character + 1,
        text: `[${owner}${diagnostic.code ? ' ' + diagnostic.code : ''}] ${msg} [${type}]`,
        type
    };
}
exports.getLocationListItem = getLocationListItem;
//# sourceMappingURL=util.js.map

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const vscode_uri_1 = __webpack_require__(243);
const position_1 = __webpack_require__(311);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('diagnostic-collection');
class Collection {
    constructor(owner) {
        this.diagnosticsMap = new Map();
        this._onDispose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidDiagnosticsChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidDiagnosticsClear = new vscode_languageserver_protocol_1.Emitter();
        this.onDispose = this._onDispose.event;
        this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;
        this.onDidDiagnosticsClear = this._onDidDiagnosticsClear.event;
        this.name = owner;
    }
    set(entries, diagnostics) {
        if (!Array.isArray(entries)) {
            let uri = entries;
            // if called as set(uri, diagnostics)
            // -> convert into single-entry entries list
            entries = [[uri, diagnostics]];
        }
        let diagnosticsPerFile = new Map();
        for (let item of entries) {
            let [file, diagnostics] = item;
            if (diagnostics == null) {
                // clear diagnostics if entry contains null
                diagnostics = [];
            }
            else {
                diagnostics = (diagnosticsPerFile.get(file) || []).concat(diagnostics);
            }
            diagnosticsPerFile.set(file, diagnostics);
        }
        for (let item of diagnosticsPerFile) {
            let [uri, diagnostics] = item;
            uri = vscode_uri_1.URI.parse(uri).toString();
            diagnostics.forEach(o => {
                o.range = o.range || vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0);
                o.message = o.message || 'Empty error message';
                if (position_1.emptyRange(o.range)) {
                    o.range.end = {
                        line: o.range.end.line,
                        character: o.range.end.character + 1
                    };
                }
                let { start, end } = o.range;
                // fix empty diagnostic at the and of line
                if (end.character == 0 && end.line - start.line == 1 && start.character > 0) {
                    // add last character when start character is end
                    let doc = workspace_1.default.getDocument(uri);
                    if (doc) {
                        let line = doc.getline(start.line);
                        if (start.character == line.length) {
                            o.range.start.character = start.character - 1;
                        }
                    }
                }
                o.source = o.source || this.name;
            });
            this.diagnosticsMap.set(uri, diagnostics);
            this._onDidDiagnosticsChange.fire(uri);
        }
        return;
    }
    delete(uri) {
        this.diagnosticsMap.delete(uri);
    }
    clear() {
        let uris = Array.from(this.diagnosticsMap.keys());
        this.diagnosticsMap.clear();
        this._onDidDiagnosticsClear.fire(uris);
    }
    forEach(callback, thisArg) {
        for (let uri of this.diagnosticsMap.keys()) {
            let diagnostics = this.diagnosticsMap.get(uri);
            callback.call(thisArg, uri, diagnostics, this);
        }
    }
    get(uri) {
        let arr = this.diagnosticsMap.get(uri);
        return arr == null ? [] : arr;
    }
    has(uri) {
        return this.diagnosticsMap.has(uri);
    }
    dispose() {
        this.clear();
        this._onDispose.fire(void 0);
        this._onDispose.dispose();
        this._onDidDiagnosticsClear.dispose();
        this._onDidDiagnosticsChange.dispose();
    }
}
exports.default = Collection;
//# sourceMappingURL=collection.js.map

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fast_diff_1 = tslib_1.__importDefault(__webpack_require__(259));
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const vscode_languageserver_types_1 = __webpack_require__(223);
const vscode_languageserver_textdocument_1 = __webpack_require__(293);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const util_1 = __webpack_require__(238);
const array_1 = __webpack_require__(308);
const position_1 = __webpack_require__(311);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const range_1 = tslib_1.__importDefault(__webpack_require__(614));
const logger = __webpack_require__(64)('cursors');
class Cursors {
    constructor(nvim) {
        this.nvim = nvim;
        this._activated = false;
        this._changed = false;
        this.ranges = [];
        this.disposables = [];
        this.changing = false;
        this.loadConfig();
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('cursors')) {
                this.loadConfig();
            }
        });
    }
    loadConfig() {
        let config = workspace_1.default.getConfiguration('cursors');
        this.config = {
            nextKey: config.get('nextKey', '<C-n>'),
            previousKey: config.get('previousKey', '<C-p>'),
            cancelKey: config.get('cancelKey', '<esc>')
        };
    }
    async select(bufnr, kind, mode) {
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return;
        doc.forceSync();
        let { nvim } = this;
        if (this._changed || bufnr != this.bufnr) {
            this.cancel();
        }
        let pos = await workspace_1.default.getCursorPosition();
        let range;
        if (kind == 'operator') {
            await nvim.command(`normal! ${mode == 'line' ? `'[` : '`['}`);
            let start = await workspace_1.default.getCursorPosition();
            await nvim.command(`normal! ${mode == 'line' ? `']` : '`]'}`);
            let end = await workspace_1.default.getCursorPosition();
            await workspace_1.default.moveTo(pos);
            let relative = position_1.comparePosition(start, end);
            // do nothing for empty range
            if (relative == 0)
                return;
            if (relative >= 0)
                [start, end] = [end, start];
            // include end character
            let line = doc.getline(end.line);
            if (end.character < line.length) {
                end.character = end.character + 1;
            }
            let ranges = splitRange(doc, vscode_languageserver_types_1.Range.create(start, end));
            for (let r of ranges) {
                let text = doc.textDocument.getText(r);
                this.addRange(r, text);
            }
        }
        else if (kind == 'word') {
            range = doc.getWordRangeAtPosition(pos);
            if (!range) {
                let line = doc.getline(pos.line);
                if (pos.character == line.length) {
                    range = vscode_languageserver_types_1.Range.create(pos.line, Math.max(0, line.length - 1), pos.line, line.length);
                }
                else {
                    range = vscode_languageserver_types_1.Range.create(pos.line, pos.character, pos.line, pos.character + 1);
                }
            }
            let line = doc.getline(pos.line);
            let text = line.slice(range.start.character, range.end.character);
            this.addRange(range, text);
        }
        else if (kind == 'position') {
            // make sure range contains character for highlight
            let line = doc.getline(pos.line);
            if (pos.character >= line.length) {
                range = vscode_languageserver_types_1.Range.create(pos.line, line.length - 1, pos.line, line.length);
            }
            else {
                range = vscode_languageserver_types_1.Range.create(pos.line, pos.character, pos.line, pos.character + 1);
            }
            this.addRange(range, line.slice(range.start.character, range.end.character));
        }
        else if (kind == 'range') {
            await nvim.call('eval', 'feedkeys("\\<esc>", "in")');
            let range = await workspace_1.default.getSelectedRange(mode, doc);
            if (!range || position_1.comparePosition(range.start, range.end) == 0)
                return;
            let ranges = mode == '\x16' ? getVisualRanges(doc, range) : splitRange(doc, range);
            for (let r of ranges) {
                let text = doc.textDocument.getText(r);
                this.addRange(r, text);
            }
        }
        else {
            workspace_1.default.showMessage(`${kind} not supported`, 'error');
            return;
        }
        if (this._activated && !this.ranges.length) {
            this.cancel();
        }
        else if (this.ranges.length && !this._activated) {
            let winid = await nvim.call('win_getid');
            this.activate(doc, winid);
        }
        if (this._activated) {
            nvim.pauseNotification();
            this.doHighlights();
            let [, err] = await nvim.resumeNotification();
            if (err)
                logger.error(err);
        }
        if (kind == 'word' || kind == 'position') {
            await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        }
    }
    activate(doc, winid) {
        if (this._activated)
            return;
        this._activated = true;
        this.bufnr = doc.bufnr;
        this.winid = winid;
        this.nvim.setVar('coc_cursors_activated', 1, true);
        doc.forceSync();
        this.textDocument = doc.textDocument;
        workspace_1.default.onDidChangeTextDocument(async (e) => {
            if (e.textDocument.uri != doc.uri)
                return;
            if (this.changing || !this.ranges.length)
                return;
            let change = e.contentChanges[0];
            if (!('range' in change))
                return;
            let { original } = e;
            let { text, range } = change;
            // ignore change after last range
            if (position_1.comparePosition(range.start, this.lastPosition) > 0) {
                if (this._changed) {
                    this.cancel();
                }
                else {
                    this.textDocument = doc.textDocument;
                }
                return;
            }
            let changeCount = text.split('\n').length - (range.end.line - range.start.line + 1);
            // adjust line when change before first position
            let d = position_1.comparePosition(range.end, this.firstPosition);
            if (d < 0 || d == 0 && (position_1.comparePosition(range.start, range.end) != 0 || text.endsWith('\n'))) {
                if (this._changed) {
                    this.cancel();
                }
                else {
                    if (changeCount != 0)
                        this.ranges.forEach(r => r.line = r.line + changeCount);
                    this.textDocument = doc.textDocument;
                }
                return;
            }
            // ignore changes when not overlap
            if (changeCount == 0) {
                let lnums = array_1.distinct(this.ranges.map(r => r.line));
                let startLine = range.start.line;
                let endLine = range.end.line;
                let overlap = lnums.some(line => line >= startLine && line <= endLine);
                if (!overlap)
                    return;
            }
            this._changed = true;
            // get range from edit
            let textRange = this.getTextRange(range, text);
            if (textRange) {
                await this.applySingleEdit(textRange, { range, newText: text });
            }
            else {
                await this.applyComposedEdit(original, { range, newText: text });
            }
        }, null, this.disposables);
        let { cancelKey, nextKey, previousKey } = this.config;
        workspace_1.default.registerLocalKeymap('n', cancelKey, () => {
            if (!this._activated)
                return this.unmap(cancelKey);
            this.cancel();
        }, true);
        workspace_1.default.registerLocalKeymap('n', nextKey, async () => {
            if (!this._activated)
                return this.unmap(nextKey);
            let ranges = this.ranges.map(o => o.currRange);
            let curr = await workspace_1.default.getCursorPosition();
            for (let r of ranges) {
                if (position_1.comparePosition(r.start, curr) > 0) {
                    await workspace_1.default.moveTo(r.start);
                    return;
                }
            }
            if (ranges.length)
                await workspace_1.default.moveTo(ranges[0].start);
        }, true);
        workspace_1.default.registerLocalKeymap('n', previousKey, async () => {
            if (!this._activated)
                return this.unmap(previousKey);
            let ranges = this.ranges.map(o => o.currRange);
            ranges.reverse();
            let curr = await workspace_1.default.getCursorPosition();
            for (let r of ranges) {
                if (position_1.comparePosition(r.end, curr) < 0) {
                    await workspace_1.default.moveTo(r.start);
                    return;
                }
            }
            if (ranges.length)
                await workspace_1.default.moveTo(ranges[0].start);
        }, true);
        events_1.default.on('CursorMoved', debounce_1.default(async (bufnr) => {
            if (bufnr != this.bufnr)
                return this.cancel();
            let winid = await this.nvim.call('win_getid');
            if (winid != this.winid) {
                this.cancel();
            }
        }, 100), null, this.disposables);
    }
    doHighlights() {
        let doc = workspace_1.default.getDocument(this.bufnr);
        if (!doc || !this.ranges.length)
            return;
        this.nvim.call('coc#util#clear_pos_matches', ['^CocCursorRange', this.winid], true);
        let searchRanges = this.ranges.map(o => o.currRange);
        doc.matchAddRanges(searchRanges, 'CocCursorRange', 99);
        if (workspace_1.default.isVim)
            this.nvim.command('redraw', true);
    }
    cancel() {
        if (!this._activated)
            return;
        this.nvim.setVar('coc_cursors_activated', 0, true);
        this.nvim.call('coc#util#clear_pos_matches', ['^CocCursorRange', this.winid], true);
        util_1.disposeAll(this.disposables);
        this._changed = false;
        this.ranges = [];
        this.changing = false;
        this._activated = false;
    }
    unmap(key) {
        let { nvim, bufnr } = this;
        let { cancelKey, nextKey, previousKey } = this.config;
        let escaped = key.startsWith('<') && key.endsWith('>') ? `\\${key}` : key;
        nvim.pauseNotification();
        nvim.call('coc#util#unmap', [bufnr, [cancelKey, nextKey, previousKey]], true);
        nvim.call('eval', `feedkeys("${escaped}", 't')`, true);
        nvim.resumeNotification(false, true).logError();
    }
    // Add ranges to current document
    async addRanges(ranges) {
        let { nvim } = this;
        let [bufnr, winid] = await nvim.eval('[bufnr("%"),win_getid()]');
        if (this._activated && (this.bufnr != bufnr || this.winid != winid)) {
            this.cancel();
        }
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return;
        doc.forceSync();
        // filter overlap ranges
        if (!this._changed) {
            this.ranges = this.ranges.filter(r => {
                let { currRange } = r;
                return !ranges.some(range => position_1.rangeOverlap(range, currRange));
            });
        }
        else {
            // use new ranges
            this.ranges = [];
        }
        let { textDocument } = doc;
        for (let range of ranges) {
            let { line } = range.start;
            let textRange = new range_1.default(line, range.start.character, range.end.character, textDocument.getText(range), 0);
            this.ranges.push(textRange);
        }
        this.ranges.sort((a, b) => position_1.comparePosition(a.range.start, b.range.start));
        // fix preCount
        let preCount = 0;
        let currline = -1;
        for (let range of this.ranges) {
            let { line } = range;
            if (line != currline) {
                preCount = 0;
            }
            range.preCount = preCount;
            preCount = preCount + 1;
            currline = line;
        }
        if (!this.ranges.length)
            return;
        this.activate(doc, winid);
        nvim.pauseNotification();
        this.doHighlights();
        let [, err] = await nvim.resumeNotification();
        if (err)
            logger.error(err);
    }
    get activated() {
        return this._activated;
    }
    /**
     * Find single range from edit
     */
    getTextRange(range, text) {
        let { ranges } = this;
        // can't support line count change
        if (text.includes('\n') || range.start.line != range.end.line)
            return null;
        ranges.sort((a, b) => {
            if (a.line != b.line)
                return a.line - b.line;
            return a.currRange.start.character - b.currRange.start.character;
        });
        for (let i = 0; i < ranges.length; i++) {
            let r = ranges[i];
            if (position_1.rangeInRange(range, r.currRange)) {
                return r;
            }
            if (r.line != range.start.line) {
                continue;
            }
            if (text.length && range.start.character == r.currRange.end.character) {
                // end add
                let next = ranges[i + 1];
                if (!next)
                    return r;
                return position_1.positionInRange(next.currRange.start, range) ? null : r;
            }
        }
        return null;
    }
    async applySingleEdit(textRange, edit) {
        // single range change, calculate & apply changes for all ranges
        let { range, newText } = edit;
        let doc = workspace_1.default.getDocument(this.bufnr);
        this.adjustChange(textRange, range, newText);
        if (this.ranges.length == 1) {
            this.doHighlights();
            return;
        }
        let edits = this.ranges.map(o => o.textEdit);
        let content = vscode_languageserver_textdocument_1.TextDocument.applyEdits(this.textDocument, edits);
        let newLines = content.split('\n');
        let changedLnum = new Set();
        let arr = [];
        for (let r of this.ranges) {
            if (!changedLnum.has(r.line)) {
                changedLnum.add(r.line);
                arr.push([r.line, newLines[r.line]]);
            }
        }
        let { nvim } = this;
        this.changing = true;
        // apply changes
        nvim.pauseNotification();
        nvim.command('undojoin', true);
        doc.changeLines(arr);
        let { cursor } = events_1.default;
        if (textRange.preCount > 0 && cursor.bufnr == this.bufnr && textRange.line + 1 == cursor.lnum) {
            let changed = textRange.preCount * (newText.length - (range.end.character - range.start.character));
            nvim.call('cursor', [cursor.lnum, cursor.col + changed], true);
        }
        this.doHighlights();
        if (workspace_1.default.isNvim)
            nvim.command('redraw', true);
        let [, err] = await nvim.resumeNotification();
        this.changing = false;
        if (err)
            logger.error(err);
    }
    async applyComposedEdit(original, edit) {
        // check complex edit
        let { range, newText } = edit;
        let { nvim, ranges } = this;
        let doc = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', '', 0, original);
        let edits = [];
        let diffs = fast_diff_1.default(original, newText);
        let offset = 0;
        for (let i = 0; i < diffs.length; i++) {
            let diff = diffs[i];
            let pos = adjustPosition(range.start, doc.positionAt(offset));
            if (diff[0] == fast_diff_1.default.EQUAL) {
                offset = offset + diff[1].length;
            }
            else if (diff[0] == fast_diff_1.default.DELETE) {
                let end = adjustPosition(range.start, doc.positionAt(offset + diff[1].length));
                if (diffs[i + 1] && diffs[i + 1][0] == fast_diff_1.default.INSERT) {
                    // change
                    edits.push({ range: vscode_languageserver_types_1.Range.create(pos, end), newText: diffs[i + 1][1] });
                    i = i + 1;
                }
                else {
                    // delete
                    edits.push({ range: vscode_languageserver_types_1.Range.create(pos, end), newText: '' });
                }
                offset = offset + diff[1].length;
            }
            else if (diff[0] == fast_diff_1.default.INSERT) {
                edits.push({ range: vscode_languageserver_types_1.Range.create(pos, pos), newText: diff[1] });
            }
        }
        if (edits.some(edit => edit.newText.includes('\n') || edit.range.start.line != edit.range.end.line)) {
            this.cancel();
            return;
        }
        if (edits.length == ranges.length) {
            let last;
            for (let i = 0; i < edits.length; i++) {
                let edit = edits[i];
                let textRange = this.ranges[i];
                if (!position_1.rangeIntersect(textRange.currRange, edit.range)) {
                    this.cancel();
                    return;
                }
                if (last && !equalEdit(edit, last)) {
                    this.cancel();
                    return;
                }
                textRange.applyEdit(edit);
                last = edit;
            }
        }
        else if (edits.length == ranges.length * 2) {
            for (let i = 0; i < edits.length - 1; i = i + 2) {
                let edit = edits[i];
                let next = edits[i + 1];
                if (edit.newText.length == 0 && next.newText.length == 0) {
                    // remove begin & end
                    let textRange = this.ranges[i / 2];
                    if (position_1.comparePosition(textRange.currRange.end, next.range.end) != 0) {
                        this.cancel();
                        return;
                    }
                    let start = edit.range.start.character - textRange.currRange.start.character;
                    textRange.replace(start, edit.range.end.character - edit.range.start.character, '');
                    let offset = next.range.end.character - next.range.start.character;
                    let len = textRange.text.length;
                    textRange.replace(len - offset, len);
                }
                else if (position_1.emptyRange(edit.range) && position_1.emptyRange(next.range)) {
                    // add begin & end
                    let textRange = this.ranges[i / 2];
                    if (position_1.comparePosition(textRange.currRange.end, next.range.start) != 0) {
                        this.cancel();
                        return;
                    }
                    let start = edit.range.start.character - textRange.currRange.start.character;
                    textRange.add(start, edit.newText);
                    let len = textRange.text.length;
                    textRange.add(len, next.newText);
                }
                else {
                    this.cancel();
                }
            }
        }
        else {
            this.cancel();
        }
        nvim.pauseNotification();
        this.doHighlights();
        await nvim.resumeNotification(false, true);
    }
    adjustChange(textRange, range, text) {
        let { ranges } = this;
        if (range.start.character == range.end.character) {
            // add
            let isEnd = textRange.currRange.end.character == range.start.character;
            if (isEnd) {
                ranges.forEach(r => {
                    r.add(r.text.length, text);
                });
            }
            else {
                let d = range.start.character - textRange.currRange.start.character;
                ranges.forEach(r => {
                    r.add(Math.min(r.text.length, d), text);
                });
            }
        }
        else {
            // replace
            let d = range.end.character - range.start.character;
            let isEnd = textRange.currRange.end.character == range.end.character;
            if (isEnd) {
                if (textRange.currRange.start.character == range.start.character) {
                    // changed both start and end
                    if (text.includes(textRange.text)) {
                        let idx = text.indexOf(textRange.text);
                        let pre = idx == 0 ? '' : text.slice(0, idx);
                        let post = text.slice(idx + textRange.text.length);
                        if (pre)
                            ranges.forEach(r => r.add(0, pre));
                        if (post)
                            ranges.forEach(r => r.add(r.text.length, post));
                    }
                    else if (textRange.text.includes(text)) {
                        // delete
                        let idx = textRange.text.indexOf(text);
                        let offset = textRange.text.length - (idx + text.length);
                        if (idx != 0)
                            ranges.forEach(r => r.replace(0, idx));
                        if (offset > 0)
                            ranges.forEach(r => r.replace(r.text.length - offset, r.text.length));
                    }
                    else {
                        this.cancel();
                    }
                }
                else {
                    ranges.forEach(r => {
                        let l = r.text.length;
                        r.replace(Math.max(0, l - d), l, text);
                    });
                }
            }
            else {
                let start = range.start.character - textRange.currRange.start.character;
                ranges.forEach(r => {
                    let l = r.text.length;
                    r.replace(start, Math.min(start + d, l), text);
                });
            }
        }
    }
    addRange(range, text) {
        let { ranges } = this;
        let idx = ranges.findIndex(o => position_1.rangeIntersect(o.range, range));
        // remove range when intersect
        if (idx !== -1) {
            ranges.splice(idx, 1);
            // adjust preCount after
            for (let r of ranges) {
                if (r.line == range.start.line && r.start > range.start.character) {
                    r.preCount = r.preCount - 1;
                }
            }
        }
        else {
            let preCount = 0;
            let idx = 0;
            let { line } = range.start;
            // idx & preCount
            for (let r of ranges) {
                if (r.line > line || (r.line == line && r.start > range.end.character)) {
                    break;
                }
                if (r.line == line)
                    preCount++;
                idx++;
            }
            let created = new range_1.default(line, range.start.character, range.end.character, text, preCount);
            ranges.splice(idx, 0, created);
            // adjust preCount after
            for (let r of ranges) {
                if (r.line == range.start.line && r.start > range.start.character) {
                    r.preCount = r.preCount + 1;
                }
            }
        }
    }
    get lastPosition() {
        let { ranges } = this;
        let r = ranges[ranges.length - 1];
        return r.currRange.end;
    }
    get firstPosition() {
        let { ranges } = this;
        return ranges[0].currRange.start;
    }
}
exports.default = Cursors;
function splitRange(doc, range) {
    let splited = [];
    for (let i = range.start.line; i <= range.end.line; i++) {
        let curr = doc.getline(i) || '';
        let sc = i == range.start.line ? range.start.character : 0;
        let ec = i == range.end.line ? range.end.character : curr.length;
        if (sc == ec)
            continue;
        splited.push(vscode_languageserver_types_1.Range.create(i, sc, i, ec));
    }
    return splited;
}
/**
 * Get ranges of visual block
 */
function getVisualRanges(doc, range) {
    let { start, end } = range;
    if (start.line > end.line) {
        [start, end] = [end, start];
    }
    let sc = start.character < end.character ? start.character : end.character;
    let ec = start.character < end.character ? end.character : start.character;
    let ranges = [];
    for (let i = start.line; i <= end.line; i++) {
        let line = doc.getline(i);
        ranges.push(vscode_languageserver_types_1.Range.create(i, sc, i, Math.min(line.length, ec)));
    }
    return ranges;
}
function adjustPosition(position, delta) {
    let { line, character } = delta;
    return vscode_languageserver_types_1.Position.create(position.line + line, line == 0 ? position.character + character : character);
}
function equalEdit(one, two) {
    if (one.newText.length != two.newText.length)
        return false;
    let { range } = one;
    if (range.end.character - range.start.character != two.range.end.character - two.range.start.character) {
        return false;
    }
    return true;
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = __webpack_require__(223);
const logger = __webpack_require__(64)('cursors-range');
// edit range
class TextRange {
    constructor(line, start, end, text, 
    // range count at this line before, shuld be updated on range add
    preCount) {
        this.line = line;
        this.start = start;
        this.end = end;
        this.text = text;
        this.preCount = preCount;
        this.currStart = start;
        this.currEnd = end;
    }
    add(offset, add) {
        let { text, preCount } = this;
        let pre = offset == 0 ? '' : text.slice(0, offset);
        let post = text.slice(offset);
        this.text = `${pre}${add}${post}`;
        this.currStart = this.currStart + preCount * add.length;
        this.currEnd = this.currEnd + (preCount + 1) * add.length;
    }
    replace(begin, end, add = '') {
        let { text, preCount } = this;
        let pre = begin == 0 ? '' : text.slice(0, begin);
        let post = text.slice(end);
        this.text = pre + add + post;
        let l = end - begin - add.length;
        this.currStart = this.currStart - preCount * l;
        this.currEnd = this.currEnd - (preCount + 1) * l;
    }
    get range() {
        return vscode_languageserver_types_1.Range.create(this.line, this.start, this.line, this.end);
    }
    get currRange() {
        return vscode_languageserver_types_1.Range.create(this.line, this.currStart, this.line, this.currEnd);
    }
    applyEdit(edit) {
        let { range, newText } = edit;
        let start = range.start.character;
        let end = range.end.character;
        let isAdd = start == end;
        if (isAdd) {
            this.add(start - this.currStart, newText);
        }
        else {
            this.replace(start - this.currStart, end - this.currStart, newText);
        }
    }
    get textEdit() {
        return {
            range: this.range,
            newText: this.text
        };
    }
}
exports.default = TextRange;
//# sourceMappingURL=range.js.map

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const manager_1 = tslib_1.__importDefault(__webpack_require__(253));
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const manager_2 = tslib_1.__importDefault(__webpack_require__(541));
const floatFactory_1 = tslib_1.__importDefault(__webpack_require__(254));
const services_1 = tslib_1.__importDefault(__webpack_require__(525));
const manager_3 = tslib_1.__importDefault(__webpack_require__(256));
const util_1 = __webpack_require__(238);
const convert_1 = __webpack_require__(595);
const object_1 = __webpack_require__(249);
const position_1 = __webpack_require__(311);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const codelens_1 = tslib_1.__importDefault(__webpack_require__(616));
const colors_1 = tslib_1.__importDefault(__webpack_require__(617));
const documentHighlight_1 = tslib_1.__importDefault(__webpack_require__(619));
const refactor_1 = tslib_1.__importDefault(__webpack_require__(620));
const search_1 = tslib_1.__importDefault(__webpack_require__(621));
const debounce = __webpack_require__(240);
const vscode_uri_1 = __webpack_require__(243);
const logger = __webpack_require__(64)('Handler');
const pairs = new Map([
    ['<', '>'],
    ['>', '<'],
    ['{', '}'],
    ['[', ']'],
    ['(', ')'],
]);
class Handler {
    constructor(nvim) {
        this.nvim = nvim;
        this.refactorMap = new Map();
        this.documentLines = [];
        this.disposables = [];
        this.labels = {};
        this.selectionRange = null;
        this.getPreferences();
        this.requestStatusItem = workspace_1.default.createStatusBarItem(0, { progress: true });
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('coc.preferences')) {
                this.getPreferences();
            }
        });
        this.hoverFactory = new floatFactory_1.default(nvim, workspace_1.default.env);
        this.disposables.push(this.hoverFactory);
        let { signaturePreferAbove, signatureFloatMaxWidth, signatureMaxHeight } = this.preferences;
        this.signatureFactory = new floatFactory_1.default(nvim, workspace_1.default.env, signaturePreferAbove, signatureMaxHeight, signatureFloatMaxWidth, false);
        this.disposables.push(this.signatureFactory);
        events_1.default.on('BufUnload', async (bufnr) => {
            let refactor = this.refactorMap.get(bufnr);
            if (refactor) {
                refactor.dispose();
                this.refactorMap.delete(bufnr);
            }
        }, null, this.disposables);
        events_1.default.on(['CursorMoved', 'CursorMovedI'], () => {
            if (this.requestTokenSource) {
                this.requestTokenSource.cancel();
            }
        }, null, this.disposables);
        events_1.default.on('CursorMovedI', async (bufnr, cursor) => {
            if (!this.signaturePosition)
                return;
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc)
                return;
            let { line, character } = this.signaturePosition;
            if (cursor[0] - 1 == line) {
                let currline = doc.getline(cursor[0] - 1);
                let col = string_1.byteLength(currline.slice(0, character)) + 1;
                if (cursor[1] >= col)
                    return;
            }
            this.signatureFactory.close();
        }, null, this.disposables);
        events_1.default.on('InsertLeave', () => {
            this.signatureFactory.close();
        }, null, this.disposables);
        events_1.default.on(['TextChangedI', 'TextChangedP'], async () => {
            if (this.preferences.signatureHideOnChange) {
                this.signatureFactory.close();
            }
            this.hoverFactory.close();
        }, null, this.disposables);
        let lastInsert;
        events_1.default.on('InsertCharPre', async (character) => {
            lastInsert = Date.now();
            if (character == ')')
                this.signatureFactory.close();
        }, null, this.disposables);
        events_1.default.on('Enter', async (bufnr) => {
            let { bracketEnterImprove } = this.preferences;
            await this.tryFormatOnType('\n', bufnr);
            if (bracketEnterImprove) {
                let line = await nvim.call('line', '.') - 1;
                let doc = workspace_1.default.getDocument(bufnr);
                if (!doc)
                    return;
                await doc.checkDocument();
                let pre = doc.getline(line - 1);
                let curr = doc.getline(line);
                let prevChar = pre[pre.length - 1];
                if (prevChar && pairs.has(prevChar)) {
                    let nextChar = curr.trim()[0];
                    if (nextChar && pairs.get(prevChar) == nextChar) {
                        let edits = [];
                        let opts = await workspace_1.default.getFormatOptions(doc.uri);
                        let space = opts.insertSpaces ? ' '.repeat(opts.tabSize) : '\t';
                        let preIndent = pre.match(/^\s*/)[0];
                        let currIndent = curr.match(/^\s*/)[0];
                        let newText = '\n' + preIndent + space;
                        let pos = vscode_languageserver_protocol_1.Position.create(line - 1, pre.length);
                        // make sure indent of current line
                        if (preIndent != currIndent) {
                            let newText = doc.filetype == 'vim' ? '  \\ ' + preIndent : preIndent;
                            edits.push({ range: vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(line, 0), vscode_languageserver_protocol_1.Position.create(line, currIndent.length)), newText });
                        }
                        else if (doc.filetype == 'vim') {
                            edits.push({ range: vscode_languageserver_protocol_1.Range.create(line, currIndent.length, line, currIndent.length), newText: '  \\ ' });
                        }
                        if (doc.filetype == 'vim') {
                            newText = newText + '\\ ';
                        }
                        edits.push({ range: vscode_languageserver_protocol_1.Range.create(pos, pos), newText });
                        await doc.applyEdits(edits);
                        await workspace_1.default.moveTo(vscode_languageserver_protocol_1.Position.create(line, newText.length - 1));
                    }
                }
            }
        }, null, this.disposables);
        events_1.default.on('TextChangedI', async (bufnr) => {
            let curr = Date.now();
            if (!lastInsert || curr - lastInsert > 300)
                return;
            lastInsert = null;
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc || doc.isCommandLine || !doc.attached)
                return;
            let { triggerSignatureHelp, formatOnType } = this.preferences;
            if (!triggerSignatureHelp && !formatOnType)
                return;
            let [pos, line] = await nvim.eval('[coc#util#cursor(), getline(".")]');
            let pre = pos[1] == 0 ? '' : line.slice(pos[1] - 1, pos[1]);
            if (!pre || string_1.isWord(pre))
                return;
            await this.tryFormatOnType(pre, bufnr);
            if (triggerSignatureHelp && languages_1.default.shouldTriggerSignatureHelp(doc.textDocument, pre)) {
                try {
                    let [mode, cursor] = await nvim.eval('[mode(),coc#util#cursor()]');
                    if (mode !== 'i')
                        return;
                    await synchronizeDocument(doc);
                    await this.triggerSignatureHelp(doc, { line: cursor[0], character: cursor[1] });
                }
                catch (e) {
                    logger.error(`Error on signature help:`, e);
                }
            }
        }, null, this.disposables);
        events_1.default.on('InsertLeave', async (bufnr) => {
            if (!this.preferences.formatOnInsertLeave)
                return;
            await util_1.wait(30);
            if (workspace_1.default.insertMode)
                return;
            await this.tryFormatOnType('\n', bufnr, true);
        }, null, this.disposables);
        events_1.default.on('CursorMoved', debounce((bufnr, cursor) => {
            if (!this.preferences.previewAutoClose || !this.hoverPosition)
                return;
            if (this.preferences.hoverTarget == 'float')
                return;
            let arr = [bufnr, cursor[0], cursor[1]];
            if (object_1.equals(arr, this.hoverPosition))
                return;
            let doc = workspace_1.default.documents.find(doc => doc.uri.startsWith('coc://'));
            if (doc && doc.bufnr != bufnr) {
                nvim.command('pclose', true);
            }
        }, 100), null, this.disposables);
        if (this.preferences.currentFunctionSymbolAutoUpdate) {
            events_1.default.on('CursorHold', () => {
                this.getCurrentFunctionSymbol().logError();
            }, null, this.disposables);
        }
        let provider = {
            onDidChange: null,
            provideTextDocumentContent: async () => {
                nvim.pauseNotification();
                nvim.command('setlocal conceallevel=2 nospell nofoldenable wrap', true);
                nvim.command('setlocal bufhidden=wipe nobuflisted', true);
                nvim.command('setfiletype markdown', true);
                nvim.command(`if winnr('j') != winnr('k') | exe "normal! z${Math.min(this.documentLines.length, this.preferences.previewMaxHeight)}\\<cr> | endif"`, true);
                await nvim.resumeNotification();
                return this.documentLines.join('\n');
            }
        };
        this.disposables.push(workspace_1.default.registerTextDocumentContentProvider('coc', provider));
        this.codeLensManager = new codelens_1.default(nvim);
        this.colors = new colors_1.default(nvim);
        this.documentHighlighter = new documentHighlight_1.default(nvim, this.colors);
        this.disposables.push(commands_1.default.registerCommand('editor.action.organizeImport', async (bufnr) => {
            if (!bufnr)
                bufnr = await nvim.call('bufnr', '%');
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc)
                return false;
            let range = vscode_languageserver_protocol_1.Range.create(0, 0, doc.lineCount, 0);
            let actions = await this.getCodeActions(bufnr, range, [vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports]);
            if (actions && actions.length) {
                await this.applyCodeAction(actions[0]);
                return true;
            }
            workspace_1.default.showMessage(`Organize import action not found.`, 'warning');
            return false;
        }));
        commands_1.default.titles.set('editor.action.organizeImport', 'run organize import code action.');
    }
    getRequestToken(name) {
        if (this.requestTokenSource) {
            this.requestTokenSource.cancel();
        }
        this.requestTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let { token } = this.requestTokenSource;
        let disposable = token.onCancellationRequested(() => {
            disposable.dispose();
            this.requestStatusItem.text = `${name} request canceled`;
            this.requestStatusItem.isProgress = false;
            this.requestTimer = setTimeout(() => {
                this.requestStatusItem.hide();
            }, 500);
        });
        this.requestStatusItem.isProgress = true;
        this.requestStatusItem.text = `requesting ${name}`;
        this.requestStatusItem.show();
        if (this.requestTimer) {
            clearTimeout(this.requestTimer);
        }
        return token;
    }
    async getCurrentFunctionSymbol() {
        let position = await workspace_1.default.getCursorPosition();
        let buffer = await this.nvim.buffer;
        let document = workspace_1.default.getDocument(buffer.id);
        if (!document)
            return;
        let symbols = await this.getDocumentSymbols(document);
        if (!symbols || symbols.length === 0) {
            buffer.setVar('coc_current_function', '', true);
            this.nvim.call('coc#util#do_autocmd', ['CocStatusChange'], true);
            return '';
        }
        symbols = symbols.filter(s => [
            'Class',
            'Method',
            'Function',
            'Struct',
        ].includes(s.kind));
        let functionName = '';
        for (let sym of symbols.reverse()) {
            if (sym.range
                && position_1.positionInRange(position, sym.range) == 0
                && !sym.text.endsWith(') callback')) {
                functionName = sym.text;
                let label = this.labels[sym.kind.toLowerCase()];
                if (label)
                    functionName = `${label} ${functionName}`;
                break;
            }
        }
        buffer.setVar('coc_current_function', functionName, true);
        this.nvim.call('coc#util#do_autocmd', ['CocStatusChange'], true);
        return functionName;
    }
    async hasProvider(id) {
        let bufnr = await this.nvim.call('bufnr', '%');
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return false;
        return languages_1.default.hasProvider(id, doc.textDocument);
    }
    async onHover() {
        let { document, position } = await workspace_1.default.getCurrentState();
        let winid = await this.nvim.call('win_getid');
        let token = this.getRequestToken('hover');
        let hovers = await languages_1.default.getHover(document, position, token);
        if (token.isCancellationRequested)
            return false;
        if (this.checkEmpty('hover', hovers))
            return false;
        let hover = hovers.find(o => vscode_languageserver_protocol_1.Range.is(o.range));
        if (hover) {
            let doc = workspace_1.default.getDocument(document.uri);
            if (doc) {
                doc.matchAddRanges([hover.range], 'CocHoverRange', 999);
                setTimeout(() => {
                    this.nvim.call('coc#util#clear_pos_matches', ['^CocHoverRange', winid], true);
                }, 1000);
            }
            await this.previewHover(hovers);
            return true;
        }
        let target = this.preferences.hoverTarget;
        if (target == 'float') {
            this.hoverFactory.close();
        }
        else if (target == 'preview') {
            this.nvim.command('pclose', true);
        }
        return false;
    }
    async gotoDefinition(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let token = this.getRequestToken('definition');
        let definition = await languages_1.default.getDefinition(document, position, token);
        if (token.isCancellationRequested)
            return false;
        if (this.checkEmpty('definition', definition))
            return false;
        await this.handleLocations(definition, openCommand);
        return true;
    }
    async gotoDeclaration(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let token = this.getRequestToken('declaration');
        let definition = await languages_1.default.getDeclaration(document, position, token);
        if (token.isCancellationRequested)
            return false;
        if (this.checkEmpty('declaration', definition))
            return false;
        await this.handleLocations(definition, openCommand);
        return true;
    }
    async gotoTypeDefinition(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let token = this.getRequestToken('type definition');
        let definition = await languages_1.default.getTypeDefinition(document, position, token);
        if (token.isCancellationRequested)
            return false;
        if (this.checkEmpty('type definition', definition))
            return false;
        await this.handleLocations(definition, openCommand);
        return true;
    }
    async gotoImplementation(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let token = this.getRequestToken('implementation');
        let definition = await languages_1.default.getImplementation(document, position, token);
        if (token.isCancellationRequested)
            return false;
        if (this.checkEmpty('implementation', definition))
            return false;
        await this.handleLocations(definition, openCommand);
        return true;
    }
    async gotoReferences(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let token = this.getRequestToken('references');
        let locs = await languages_1.default.getReferences(document, { includeDeclaration: false }, position, token);
        if (token.isCancellationRequested)
            return false;
        if (this.checkEmpty('references', locs))
            return false;
        await this.handleLocations(locs, openCommand);
        return true;
    }
    async getDocumentSymbols(document) {
        document = document || workspace_1.default.getDocument(workspace_1.default.bufnr);
        if (!document)
            return [];
        let symbols = await languages_1.default.getDocumentSymbol(document.textDocument);
        if (!symbols)
            return null;
        if (symbols.length == 0)
            return [];
        let level = 0;
        let res = [];
        let pre = null;
        if (isDocumentSymbols(symbols)) {
            symbols.sort(sortDocumentSymbols);
            symbols.forEach(s => addDoucmentSymbol(res, s, level));
        }
        else {
            symbols.sort(sortSymbolInformations);
            for (let sym of symbols) {
                let { name, kind, location, containerName } = sym;
                if (!containerName || !pre) {
                    level = 0;
                }
                else {
                    if (pre.containerName == containerName) {
                        level = pre.level || 0;
                    }
                    else {
                        let container = getPreviousContainer(containerName, res);
                        level = container ? container.level + 1 : 0;
                    }
                }
                let { start } = location.range;
                let o = {
                    col: start.character + 1,
                    lnum: start.line + 1,
                    text: name,
                    level,
                    kind: convert_1.getSymbolKind(kind),
                    range: location.range,
                    containerName
                };
                res.push(o);
                pre = o;
            }
        }
        return res;
    }
    async getWordEdit() {
        let bufnr = await this.nvim.call('bufnr', '%');
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return null;
        let position = await workspace_1.default.getCursorPosition();
        let range = doc.getWordRangeAtPosition(position);
        if (!range || position_1.emptyRange(range))
            return null;
        let curname = doc.textDocument.getText(range);
        if (languages_1.default.hasProvider('rename', doc.textDocument)) {
            await synchronizeDocument(doc);
            let res = await languages_1.default.prepareRename(doc.textDocument, position);
            if (res === false)
                return null;
            let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, curname);
            if (edit)
                return edit;
        }
        workspace_1.default.showMessage('Rename provider not found, extract word ranges from current buffer', 'more');
        let ranges = doc.getSymbolRanges(curname);
        return {
            changes: {
                [doc.uri]: ranges.map(r => ({ range: r, newText: curname }))
            }
        };
    }
    async rename(newName) {
        let bufnr = await this.nvim.call('bufnr', '%');
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return false;
        let { nvim } = this;
        let position = await workspace_1.default.getCursorPosition();
        let range = doc.getWordRangeAtPosition(position);
        if (!range || position_1.emptyRange(range))
            return false;
        if (!languages_1.default.hasProvider('rename', doc.textDocument)) {
            workspace_1.default.showMessage(`Rename provider not found for current document`, 'error');
            return false;
        }
        await synchronizeDocument(doc);
        let res = await languages_1.default.prepareRename(doc.textDocument, position);
        if (res === false) {
            workspace_1.default.showMessage('Invalid position for renmame', 'error');
            return false;
        }
        if (!newName) {
            let curname = await nvim.eval('expand("<cword>")');
            newName = await workspace_1.default.callAsync('input', ['New name: ', curname]);
            nvim.command('normal! :<C-u>', true);
            if (!newName) {
                workspace_1.default.showMessage('Empty name, canceled', 'warning');
                return false;
            }
        }
        let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, newName);
        if (!edit) {
            workspace_1.default.showMessage('Invalid position for rename', 'warning');
            return false;
        }
        await workspace_1.default.applyEdit(edit);
        return true;
    }
    async documentFormatting() {
        let bufnr = await this.nvim.eval('bufnr("%")');
        let document = workspace_1.default.getDocument(bufnr);
        if (!document)
            return false;
        await synchronizeDocument(document);
        let options = await workspace_1.default.getFormatOptions(document.uri);
        let textEdits = await languages_1.default.provideDocumentFormattingEdits(document.textDocument, options);
        if (!textEdits || textEdits.length == 0)
            return false;
        await document.applyEdits(textEdits);
        return true;
    }
    async documentRangeFormatting(mode) {
        let document = await workspace_1.default.document;
        if (!document)
            return -1;
        await synchronizeDocument(document);
        let range;
        if (mode) {
            range = await workspace_1.default.getSelectedRange(mode, document);
            if (!range)
                return -1;
        }
        else {
            let lnum = await this.nvim.getVvar('lnum');
            let count = await this.nvim.getVvar('count');
            let mode = await this.nvim.call('mode');
            // we can't handle
            if (count == 0 || mode == 'i' || mode == 'R')
                return -1;
            range = vscode_languageserver_protocol_1.Range.create(lnum - 1, 0, lnum - 1 + count, 0);
        }
        let options = await workspace_1.default.getFormatOptions(document.uri);
        let textEdits = await languages_1.default.provideDocumentRangeFormattingEdits(document.textDocument, range, options);
        if (!textEdits)
            return -1;
        await document.applyEdits(textEdits);
        return 0;
    }
    async getTagList() {
        let position = await workspace_1.default.getCursorPosition();
        let document = await workspace_1.default.document;
        let word = await this.nvim.call('expand', '<cword>');
        if (!word)
            return null;
        if (!languages_1.default.hasProvider('definition', document.textDocument)) {
            return null;
        }
        let { token } = this.requestTokenSource;
        let definitions = await languages_1.default.getDefinition(document.textDocument, position, token);
        if (!definitions || !definitions.length)
            return null;
        return definitions.map(location => {
            let parsedURI = vscode_uri_1.URI.parse(location.uri);
            const filename = parsedURI.scheme == 'file' ? parsedURI.fsPath : parsedURI.toString();
            return {
                name: word,
                cmd: `keepjumps ${location.range.start.line + 1} | normal ${location.range.start.character + 1}|`,
                filename,
            };
        });
    }
    async runCommand(id, ...args) {
        if (id) {
            await events_1.default.fire('Command', [id]);
            let res = await commands_1.default.executeCommand(id, ...args);
            if (args.length == 0) {
                await commands_1.default.addRecent(id);
            }
            return res;
        }
        else {
            await manager_2.default.start(['commands']);
        }
    }
    async getCodeActions(bufnr, range, only) {
        let document = workspace_1.default.getDocument(bufnr);
        if (!document)
            return [];
        range = range || vscode_languageserver_protocol_1.Range.create(0, 0, document.lineCount, 0);
        let diagnostics = manager_1.default.getDiagnosticsInRange(document.textDocument, range);
        let context = { diagnostics };
        if (only && Array.isArray(only))
            context.only = only;
        let codeActionsMap = await languages_1.default.getCodeActions(document.textDocument, range, context);
        if (!codeActionsMap)
            return [];
        let codeActions = [];
        for (let clientId of codeActionsMap.keys()) {
            let actions = codeActionsMap.get(clientId);
            for (let action of actions) {
                codeActions.push(Object.assign({ clientId }, action));
            }
        }
        codeActions.sort((a, b) => {
            if (a.isPreferred && !b.isPreferred) {
                return -1;
            }
            if (b.isPreferred && !a.isPreferred) {
                return 1;
            }
            return 0;
        });
        return codeActions;
    }
    async doCodeAction(mode, only) {
        let bufnr = await this.nvim.call('bufnr', '%');
        let range;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return;
        await synchronizeDocument(doc);
        if (mode)
            range = await workspace_1.default.getSelectedRange(mode, doc);
        let codeActions = await this.getCodeActions(bufnr, range, Array.isArray(only) ? only : null);
        if (only && typeof only == 'string') {
            codeActions = codeActions.filter(o => o.title == only || (o.command && o.command.title == only));
        }
        if (!codeActions || codeActions.length == 0) {
            workspace_1.default.showMessage(`No${only ? ' ' + only : ''} code action available`, 'warning');
            return;
        }
        if (!only || codeActions.length > 1) {
            let idx = await workspace_1.default.showQuickpick(codeActions.map(o => o.title));
            if (idx == -1)
                return;
            let action = codeActions[idx];
            if (action)
                await this.applyCodeAction(action);
        }
        else {
            await this.applyCodeAction(codeActions[0]);
        }
    }
    /**
     * Get current codeActions
     *
     * @public
     * @returns {Promise<CodeAction[]>}
     */
    async getCurrentCodeActions(mode, only) {
        let bufnr = await this.nvim.call('bufnr', '%');
        let document = workspace_1.default.getDocument(bufnr);
        if (!document)
            return [];
        let range;
        if (mode)
            range = await workspace_1.default.getSelectedRange(mode, workspace_1.default.getDocument(bufnr));
        return await this.getCodeActions(bufnr, range, only);
    }
    /**
     * Invoke preferred quickfix at current position, return false when failed
     *
     * @returns {Promise<boolean>}
     */
    async doQuickfix() {
        let actions = await this.getCurrentCodeActions('n', [vscode_languageserver_protocol_1.CodeActionKind.QuickFix]);
        if (!actions || actions.length == 0) {
            workspace_1.default.showMessage('No quickfix action available', 'warning');
            return false;
        }
        await this.applyCodeAction(actions[0]);
        await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-fix-current)", -1)`);
        return true;
    }
    async applyCodeAction(action) {
        let { command, edit } = action;
        if (edit)
            await workspace_1.default.applyEdit(edit);
        if (command) {
            if (commands_1.default.has(command.command)) {
                commands_1.default.execute(command);
            }
            else {
                let clientId = action.clientId;
                let service = services_1.default.getService(clientId);
                let params = {
                    command: command.command,
                    arguments: command.arguments
                };
                if (service.client) {
                    let { client } = service;
                    client
                        .sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params)
                        .then(undefined, error => {
                        workspace_1.default.showMessage(`Execute '${command.command} error: ${error}'`, 'error');
                    });
                }
            }
        }
    }
    async doCodeLensAction() {
        await this.codeLensManager.doAction();
    }
    async fold(kind) {
        let document = await workspace_1.default.document;
        if (!document || !document.attached) {
            workspace_1.default.showMessage('document not attached', 'warning');
            return false;
        }
        await synchronizeDocument(document);
        let win = await this.nvim.window;
        let foldmethod = await win.getOption('foldmethod');
        if (foldmethod != 'manual') {
            workspace_1.default.showMessage('foldmethod option should be manual!', 'warning');
            return false;
        }
        let ranges = await languages_1.default.provideFoldingRanges(document.textDocument, {});
        if (ranges == null) {
            workspace_1.default.showMessage('no folding range provider found', 'warning');
            return false;
        }
        if (!ranges || ranges.length == 0) {
            workspace_1.default.showMessage('no range found', 'warning');
            return false;
        }
        if (kind) {
            ranges = ranges.filter(o => o.kind == kind);
        }
        if (ranges && ranges.length) {
            await win.setOption('foldenable', true);
            for (let range of ranges.reverse()) {
                let { startLine, endLine } = range;
                let cmd = `${startLine + 1}, ${endLine + 1}fold`;
                this.nvim.command(cmd, true);
            }
            return true;
        }
        return false;
    }
    async pickColor() {
        await this.colors.pickColor();
    }
    async pickPresentation() {
        await this.colors.pickPresentation();
    }
    async highlight() {
        let [bufnr, arr] = await this.nvim.eval('[bufnr("%"),coc#util#cursor()]');
        await this.documentHighlighter.highlight(bufnr, vscode_languageserver_protocol_1.Position.create(arr[0], arr[1]));
    }
    async getSymbolsRanges() {
        let [bufnr, arr] = await this.nvim.eval('[bufnr("%"),coc#util#cursor()]');
        let highlights = await this.documentHighlighter.getHighlights(workspace_1.default.getDocument(bufnr), vscode_languageserver_protocol_1.Position.create(arr[0], arr[1]));
        if (!highlights)
            return null;
        return highlights.map(o => o.range);
    }
    async links() {
        let doc = await workspace_1.default.document;
        let links = await languages_1.default.getDocumentLinks(doc.textDocument);
        links = links || [];
        let res = [];
        for (let link of links) {
            if (link.target) {
                res.push(link);
            }
            else {
                link = await languages_1.default.resolveDocumentLink(link);
                res.push(link);
            }
        }
        return links;
    }
    async openLink() {
        let { document, position } = await workspace_1.default.getCurrentState();
        let links = await languages_1.default.getDocumentLinks(document);
        if (!links || links.length == 0)
            return false;
        for (let link of links) {
            if (position_1.positionInRange(position, link.range)) {
                let { target } = link;
                if (!target) {
                    link = await languages_1.default.resolveDocumentLink(link);
                    target = link.target;
                }
                if (target) {
                    await workspace_1.default.openResource(target);
                    return true;
                }
                return false;
            }
        }
        return false;
    }
    async getCommands() {
        let list = commands_1.default.commandList;
        let res = [];
        let { titles } = commands_1.default;
        for (let item of list) {
            res.push({
                id: item.id,
                title: titles.get(item.id) || ''
            });
        }
        return res;
    }
    /*
     * supportedSymbols must be string values of symbolKind
     */
    async selectSymbolRange(inner, visualmode, supportedSymbols) {
        let doc = await workspace_1.default.document;
        if (!doc || !doc.attached)
            return;
        await synchronizeDocument(doc);
        let range;
        if (visualmode) {
            range = await workspace_1.default.getSelectedRange(visualmode, doc);
        }
        else {
            let pos = await workspace_1.default.getCursorPosition();
            range = vscode_languageserver_protocol_1.Range.create(pos, pos);
        }
        let symbols = await this.getDocumentSymbols(doc);
        if (!symbols || symbols.length === 0) {
            workspace_1.default.showMessage('No symbols found', 'warning');
            return;
        }
        let properties = symbols.filter(s => s.kind == 'Property');
        symbols = symbols.filter(s => supportedSymbols.includes(s.kind));
        let selectRange;
        for (let sym of symbols.reverse()) {
            if (sym.range && !object_1.equals(sym.range, range) && position_1.rangeInRange(range, sym.range)) {
                selectRange = sym.range;
                break;
            }
        }
        if (!selectRange) {
            for (let sym of properties) {
                if (sym.range && !object_1.equals(sym.range, range) && position_1.rangeInRange(range, sym.range)) {
                    selectRange = sym.range;
                    break;
                }
            }
        }
        if (inner && selectRange) {
            let { start, end } = selectRange;
            let line = doc.getline(start.line + 1);
            let endLine = doc.getline(end.line - 1);
            selectRange = vscode_languageserver_protocol_1.Range.create(start.line + 1, line.match(/^\s*/)[0].length, end.line - 1, endLine.length);
        }
        if (selectRange)
            await workspace_1.default.selectRange(selectRange);
    }
    async tryFormatOnType(ch, bufnr, insertLeave = false) {
        if (!ch || string_1.isWord(ch) || !this.preferences.formatOnType)
            return;
        if (manager_3.default.getSession(bufnr) != null)
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || !doc.attached)
            return;
        if (!languages_1.default.hasOnTypeProvider(ch, doc.textDocument))
            return;
        const filetypes = this.preferences.formatOnTypeFiletypes;
        if (filetypes.length && !filetypes.includes(doc.filetype)) {
            // Only check formatOnTypeFiletypes when set, avoid breaking change
            return;
        }
        let position = await workspace_1.default.getCursorPosition();
        let origLine = doc.getline(position.line);
        let pos = insertLeave ? { line: position.line, character: origLine.length } : position;
        let { changedtick } = doc;
        await synchronizeDocument(doc);
        if (doc.changedtick != changedtick)
            return;
        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let disposable = doc.onDocumentChange(() => {
            clearTimeout(timer);
            disposable.dispose();
            tokenSource.cancel();
        });
        let timer = setTimeout(() => {
            disposable.dispose();
            tokenSource.cancel();
        }, 2000);
        let edits;
        try {
            edits = await languages_1.default.provideDocumentOnTypeEdits(ch, doc.textDocument, pos, tokenSource.token);
        }
        catch (e) {
            logger.error(`Error on format: ${e.message}`, e.stack);
        }
        if (!edits || !edits.length)
            return;
        if (tokenSource.token.isCancellationRequested)
            return;
        clearTimeout(timer);
        disposable.dispose();
        let changed = position_1.getChangedFromEdits(position, edits);
        await doc.applyEdits(edits);
        let to = changed ? vscode_languageserver_protocol_1.Position.create(position.line + changed.line, position.character + changed.character) : null;
        if (to)
            await workspace_1.default.moveTo(to);
    }
    async triggerSignatureHelp(document, position) {
        let { signatureHelpTarget } = this.preferences;
        if (this.signatureTokenSource) {
            this.signatureTokenSource.cancel();
            this.signatureTokenSource = null;
        }
        let part = document.getline(position.line).slice(0, position.character);
        if (part.endsWith(')')) {
            this.signatureFactory.close();
            return;
        }
        let tokenSource = this.signatureTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        let timer = setTimeout(() => {
            if (!token.isCancellationRequested) {
                tokenSource.cancel();
            }
        }, 3000);
        let signatureHelp = await languages_1.default.getSignatureHelp(document.textDocument, position, token);
        clearTimeout(timer);
        if (token.isCancellationRequested || !signatureHelp || signatureHelp.signatures.length == 0) {
            this.signatureFactory.close();
            return false;
        }
        let { activeParameter, activeSignature, signatures } = signatureHelp;
        if (activeSignature) {
            // make active first
            let [active] = signatures.splice(activeSignature, 1);
            if (active)
                signatures.unshift(active);
        }
        if (signatureHelpTarget == 'echo') {
            let columns = workspace_1.default.env.columns;
            signatures = signatures.slice(0, workspace_1.default.env.cmdheight);
            let signatureList = [];
            for (let signature of signatures) {
                let parts = [];
                let { label } = signature;
                label = label.replace(/\n/g, ' ');
                if (label.length >= columns - 16) {
                    label = label.slice(0, columns - 16) + '...';
                }
                let nameIndex = label.indexOf('(');
                if (nameIndex == -1) {
                    parts = [{ text: label, type: 'Normal' }];
                }
                else {
                    parts.push({
                        text: label.slice(0, nameIndex),
                        type: 'Label'
                    });
                    let after = label.slice(nameIndex);
                    if (signatureList.length == 0 && activeParameter != null) {
                        let active = signature.parameters[activeParameter];
                        if (active) {
                            let start;
                            let end;
                            if (typeof active.label === 'string') {
                                let str = after.slice(0);
                                let ms = str.match(new RegExp('\\b' + active.label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b'));
                                let idx = ms ? ms.index : str.indexOf(active.label);
                                if (idx == -1) {
                                    parts.push({ text: after, type: 'Normal' });
                                }
                                else {
                                    start = idx;
                                    end = idx + active.label.length;
                                }
                            }
                            else {
                                [start, end] = active.label;
                                start = start - nameIndex;
                                end = end - nameIndex;
                            }
                            if (start != null && end != null) {
                                parts.push({ text: after.slice(0, start), type: 'Normal' });
                                parts.push({ text: after.slice(start, end), type: 'MoreMsg' });
                                parts.push({ text: after.slice(end), type: 'Normal' });
                            }
                        }
                    }
                    else {
                        parts.push({
                            text: after,
                            type: 'Normal'
                        });
                    }
                }
                signatureList.push(parts);
            }
            this.nvim.callTimer('coc#util#echo_signatures', [signatureList], true);
        }
        else {
            let offset = 0;
            let paramDoc = null;
            let docs = signatures.reduce((p, c, idx) => {
                let activeIndexes = null;
                let nameIndex = c.label.indexOf('(');
                if (idx == 0 && activeParameter != null) {
                    let active = c.parameters[activeParameter];
                    if (active) {
                        let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
                        paramDoc = active.documentation;
                        if (typeof active.label === 'string') {
                            let str = after.slice(0);
                            let ms = str.match(new RegExp('\\b' + active.label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b'));
                            let index = ms ? ms.index : str.indexOf(active.label);
                            if (index != -1) {
                                activeIndexes = [
                                    index + nameIndex,
                                    index + active.label.length + nameIndex
                                ];
                            }
                        }
                        else {
                            activeIndexes = active.label;
                        }
                    }
                }
                if (activeIndexes == null) {
                    activeIndexes = [nameIndex + 1, nameIndex + 1];
                }
                if (offset == 0) {
                    offset = activeIndexes[0] + 1;
                }
                p.push({
                    content: c.label,
                    filetype: document.filetype,
                    active: activeIndexes
                });
                if (paramDoc) {
                    let content = typeof paramDoc === 'string' ? paramDoc : paramDoc.value;
                    if (content.trim().length) {
                        p.push({
                            content,
                            filetype: vscode_languageserver_protocol_1.MarkupContent.is(c.documentation) ? 'markdown' : 'txt'
                        });
                    }
                }
                if (idx == 0 && c.documentation) {
                    let { documentation } = c;
                    let content = typeof documentation === 'string' ? documentation : documentation.value;
                    if (content.trim().length) {
                        p.push({
                            content,
                            filetype: vscode_languageserver_protocol_1.MarkupContent.is(c.documentation) ? 'markdown' : 'txt'
                        });
                    }
                }
                return p;
            }, []);
            if (signatureHelpTarget == 'float') {
                let session = manager_3.default.getSession(document.bufnr);
                if (session && session.isActive) {
                    let { value } = session.placeholder;
                    if (!value.includes('\n'))
                        offset += value.length;
                    this.signaturePosition = vscode_languageserver_protocol_1.Position.create(position.line, position.character - value.length);
                }
                else {
                    this.signaturePosition = position;
                }
                await this.signatureFactory.create(docs, true, offset);
                // show float
            }
            else {
                this.documentLines = docs.reduce((p, c) => {
                    p.push('``` ' + c.filetype);
                    p.push(...c.content.split(/\r?\n/));
                    p.push('```');
                    return p;
                }, []);
                await this.nvim.command(`pedit coc://document`);
            }
        }
        return true;
    }
    async showSignatureHelp() {
        let buffer = await this.nvim.buffer;
        let document = workspace_1.default.getDocument(buffer.id);
        if (!document)
            return false;
        let position = await workspace_1.default.getCursorPosition();
        return await this.triggerSignatureHelp(document, position);
    }
    async findLocations(id, method, params, openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        params = params || {};
        Object.assign(params, {
            textDocument: { uri: document.uri },
            position
        });
        let res = await services_1.default.sendRequest(id, method, params);
        res = res || [];
        let locations = [];
        if (Array.isArray(res)) {
            locations = res;
        }
        else if (res.hasOwnProperty('location') && res.hasOwnProperty('children')) {
            let getLocation = (item) => {
                locations.push(item.location);
                if (item.children && item.children.length) {
                    for (let loc of item.children) {
                        getLocation(loc);
                    }
                }
            };
            getLocation(res);
        }
        await this.handleLocations(locations, openCommand);
    }
    async handleLocations(definition, openCommand) {
        if (!definition)
            return;
        let locations = Array.isArray(definition) ? definition : [definition];
        let len = locations.length;
        if (len == 0)
            return;
        if (len == 1 && openCommand !== false) {
            let location = definition[0];
            if (vscode_languageserver_protocol_1.LocationLink.is(definition[0])) {
                let link = definition[0];
                location = vscode_languageserver_protocol_1.Location.create(link.targetUri, link.targetRange);
            }
            let { uri, range } = location;
            await workspace_1.default.jumpTo(uri, range.start, openCommand);
        }
        else {
            await workspace_1.default.showLocations(definition);
        }
    }
    async getSelectionRanges() {
        let { document, position } = await workspace_1.default.getCurrentState();
        let selectionRanges = await languages_1.default.getSelectionRanges(document, [position]);
        if (selectionRanges && selectionRanges.length)
            return selectionRanges;
        return null;
    }
    async selectRange(visualmode, forward) {
        let { nvim } = this;
        let positions = [];
        let bufnr = await nvim.call('bufnr', '%');
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return;
        if (!forward && (!this.selectionRange || !visualmode))
            return;
        if (visualmode) {
            let range = await workspace_1.default.getSelectedRange(visualmode, doc);
            positions.push(range.start, range.end);
        }
        else {
            let position = await workspace_1.default.getCursorPosition();
            positions.push(position);
        }
        if (!forward) {
            let curr = vscode_languageserver_protocol_1.Range.create(positions[0], positions[1]);
            let { selectionRange } = this;
            while (selectionRange && selectionRange.parent) {
                if (object_1.equals(selectionRange.parent.range, curr)) {
                    break;
                }
                selectionRange = selectionRange.parent;
            }
            if (selectionRange && selectionRange.parent) {
                await workspace_1.default.selectRange(selectionRange.range);
            }
            return;
        }
        let selectionRanges = await languages_1.default.getSelectionRanges(doc.textDocument, positions);
        if (selectionRanges == null) {
            workspace_1.default.showMessage('Selection range provider not found for current document', 'warning');
            return;
        }
        if (!selectionRanges || selectionRanges.length == 0) {
            workspace_1.default.showMessage('No selection range found', 'warning');
            return;
        }
        let mode = await nvim.eval('mode()');
        if (mode != 'n')
            await nvim.eval(`feedkeys("\\<Esc>", 'in')`);
        let selectionRange;
        if (selectionRanges.length == 1) {
            selectionRange = selectionRanges[0];
        }
        else if (positions.length > 1) {
            let r = vscode_languageserver_protocol_1.Range.create(positions[0], positions[1]);
            selectionRange = selectionRanges[0];
            while (selectionRange) {
                if (object_1.equals(r, selectionRange.range)) {
                    selectionRange = selectionRange.parent;
                    continue;
                }
                if (position_1.positionInRange(positions[1], selectionRange.range) == 0) {
                    break;
                }
                selectionRange = selectionRange.parent;
            }
        }
        if (!selectionRange)
            return;
        this.selectionRange = selectionRanges[0];
        await workspace_1.default.selectRange(selectionRange.range);
    }
    async codeActionRange(start, end, only) {
        let listArgs = ['--normal', '--number-select', 'actions', `-start`, start + '', `-end`, end + ''];
        if (only == 'quickfix') {
            listArgs.push('-quickfix');
        }
        else if (only == 'source') {
            listArgs.push('-source');
        }
        await manager_2.default.start(listArgs);
    }
    /**
     * Refactor of current symbol
     */
    async doRefactor() {
        let [bufnr, cursor, filetype] = await this.nvim.eval('[bufnr("%"),coc#util#cursor(),&filetype]');
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return;
        let position = { line: cursor[0], character: cursor[1] };
        let res = await languages_1.default.prepareRename(doc.textDocument, position);
        if (res === false) {
            workspace_1.default.showMessage('Invalid position for rename', 'error');
            return;
        }
        let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, 'NewName');
        if (!edit) {
            workspace_1.default.showMessage('Empty workspaceEdit from server', 'warning');
            return;
        }
        let refactor = await refactor_1.default.createFromWorkspaceEdit(edit, filetype);
        if (!refactor.buffer)
            return;
        this.refactorMap.set(refactor.buffer.id, refactor);
    }
    async saveRefactor(bufnr) {
        let refactor = this.refactorMap.get(bufnr);
        if (refactor) {
            await refactor.saveRefactor();
        }
    }
    async search(args) {
        let cwd = await this.nvim.call('getcwd');
        let refactor = new refactor_1.default();
        await refactor.createRefactorBuffer();
        if (!refactor.buffer)
            return;
        this.refactorMap.set(refactor.buffer.id, refactor);
        let search = new search_1.default(this.nvim);
        search.run(args, cwd, refactor).logError();
    }
    async previewHover(hovers) {
        let lines = [];
        let target = this.preferences.hoverTarget;
        let i = 0;
        let docs = [];
        for (let hover of hovers) {
            let { contents } = hover;
            if (i > 0)
                lines.push('---');
            if (Array.isArray(contents)) {
                for (let item of contents) {
                    if (typeof item === 'string') {
                        if (item.trim().length) {
                            lines.push(...item.split('\n'));
                            docs.push({ content: item, filetype: 'markdown' });
                        }
                    }
                    else {
                        let content = item.value.trim();
                        if (target == 'preview') {
                            content = '``` ' + item.language + '\n' + content + '\n```';
                        }
                        lines.push(...content.trim().split('\n'));
                        docs.push({ filetype: item.language, content: item.value });
                    }
                }
            }
            else if (typeof contents == 'string') {
                lines.push(...contents.split('\n'));
                docs.push({ content: contents, filetype: 'markdown' });
            }
            else if (vscode_languageserver_protocol_1.MarkedString.is(contents)) {
                let content = contents.value.trim();
                if (target == 'preview') {
                    content = '``` ' + contents.language + '\n' + content + '\n```';
                }
                lines.push(...content.split('\n'));
                docs.push({ filetype: contents.language, content: contents.value });
            }
            else if (vscode_languageserver_protocol_1.MarkupContent.is(contents)) {
                lines.push(...contents.value.split('\n'));
                docs.push({ filetype: contents.kind == 'markdown' ? 'markdown' : 'txt', content: contents.value });
            }
            i++;
        }
        if (target == 'echo') {
            const msg = lines.join('\n').trim();
            if (msg.length) {
                await this.nvim.call('coc#util#echo_hover', msg);
            }
        }
        else if (target == 'float') {
            manager_1.default.hideFloat();
            await this.hoverFactory.create(docs);
        }
        else {
            this.documentLines = lines;
            let arr = await this.nvim.call('getcurpos');
            this.hoverPosition = [workspace_1.default.bufnr, arr[1], arr[2]];
            await this.nvim.command(`pedit coc://document`);
        }
    }
    getPreferences() {
        let config = workspace_1.default.getConfiguration('coc.preferences');
        let hoverTarget = config.get('hoverTarget', 'float');
        if (hoverTarget == 'float' && !workspace_1.default.env.floating && !workspace_1.default.env.textprop) {
            hoverTarget = 'preview';
        }
        let signatureConfig = workspace_1.default.getConfiguration('signature');
        let signatureHelpTarget = signatureConfig.get('target', 'float');
        if (signatureHelpTarget == 'float' && !workspace_1.default.floatSupported) {
            signatureHelpTarget = 'echo';
        }
        this.labels = workspace_1.default.getConfiguration('suggest').get('completionItemKindLabels', {});
        this.preferences = {
            hoverTarget,
            signatureHelpTarget,
            signatureMaxHeight: signatureConfig.get('maxWindowHeight', 8),
            triggerSignatureHelp: signatureConfig.get('enable', true),
            triggerSignatureWait: Math.max(signatureConfig.get('triggerSignatureWait', 50), 50),
            signaturePreferAbove: signatureConfig.get('preferShownAbove', true),
            signatureFloatMaxWidth: signatureConfig.get('floatMaxWidth', 60),
            signatureHideOnChange: signatureConfig.get('hideOnTextChange', false),
            formatOnType: config.get('formatOnType', false),
            formatOnTypeFiletypes: config.get('formatOnTypeFiletypes', []),
            formatOnInsertLeave: config.get('formatOnInsertLeave', false),
            bracketEnterImprove: config.get('bracketEnterImprove', true),
            previewMaxHeight: config.get('previewMaxHeight', 12),
            previewAutoClose: config.get('previewAutoClose', false),
            currentFunctionSymbolAutoUpdate: config.get('currentFunctionSymbolAutoUpdate', false),
        };
    }
    checkEmpty(name, location) {
        let statusItem = this.requestStatusItem;
        if (this.requestTokenSource) {
            this.requestTokenSource.dispose();
            this.requestTokenSource = undefined;
        }
        if (location == null) {
            statusItem.hide();
            workspace_1.default.showMessage(`${name} provider not found for current document`, 'warning');
            return true;
        }
        if (Array.isArray(location) && location.length == 0) {
            statusItem.hide();
            workspace_1.default.showMessage(`${name} not found`, 'warning');
            return true;
        }
        this.requestStatusItem.hide();
        return false;
    }
    dispose() {
        this.colors.dispose();
        util_1.disposeAll(this.disposables);
    }
}
exports.default = Handler;
function getPreviousContainer(containerName, symbols) {
    if (!symbols.length)
        return null;
    let i = symbols.length - 1;
    let last = symbols[i];
    if (last.text == containerName) {
        return last;
    }
    while (i >= 0) {
        let sym = symbols[i];
        if (sym.text == containerName) {
            return sym;
        }
        i--;
    }
    return null;
}
function sortDocumentSymbols(a, b) {
    let ra = a.selectionRange;
    let rb = b.selectionRange;
    if (ra.start.line < rb.start.line) {
        return -1;
    }
    if (ra.start.line > rb.start.line) {
        return 1;
    }
    return ra.start.character - rb.start.character;
}
function addDoucmentSymbol(res, sym, level) {
    let { name, selectionRange, kind, children, range } = sym;
    let { start } = selectionRange;
    res.push({
        col: start.character + 1,
        lnum: start.line + 1,
        text: name,
        level,
        kind: convert_1.getSymbolKind(kind),
        range,
        selectionRange
    });
    if (children && children.length) {
        children.sort(sortDocumentSymbols);
        for (let sym of children) {
            addDoucmentSymbol(res, sym, level + 1);
        }
    }
}
function sortSymbolInformations(a, b) {
    let sa = a.location.range.start;
    let sb = b.location.range.start;
    let d = sa.line - sb.line;
    return d == 0 ? sa.character - sb.character : d;
}
function isDocumentSymbol(a) {
    return a && !a.hasOwnProperty('location');
}
function isDocumentSymbols(a) {
    return isDocumentSymbol(a[0]);
}
async function synchronizeDocument(doc) {
    let { changedtick } = doc;
    await doc.patchChange();
    if (changedtick != doc.changedtick) {
        await util_1.wait(50);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const services_1 = tslib_1.__importDefault(__webpack_require__(525));
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('codelens');
class CodeLensManager {
    constructor(nvim) {
        this.nvim = nvim;
        this.fetching = new Set();
        this.disposables = [];
        this.codeLensMap = new Map();
        this.setConfiguration();
        this.srcId = workspace_1.default.createNameSpace('coc-codelens') || 1080;
        services_1.default.on('ready', async (id) => {
            let service = services_1.default.getService(id);
            let doc = workspace_1.default.getDocument(workspace_1.default.bufnr);
            if (!doc || !this.enabled)
                return;
            if (workspace_1.default.match(service.selector, doc.textDocument)) {
                this.resolveCodeLens.clear();
                await util_1.wait(2000);
                await this.fetchDocumentCodeLenses();
            }
        });
        let timer;
        workspace_1.default.onDidChangeTextDocument(async (e) => {
            if (!this.enabled)
                return;
            let doc = workspace_1.default.getDocument(e.textDocument.uri);
            if (doc && doc.bufnr == workspace_1.default.bufnr) {
                if (timer)
                    clearTimeout(timer);
                setTimeout(async () => {
                    await this.fetchDocumentCodeLenses();
                }, 100);
            }
        }, null, this.disposables);
        workspace_1.default.onDidChangeConfiguration(e => {
            this.setConfiguration(e);
        }, null, this.disposables);
        events_1.default.on(['TextChanged', 'TextChangedI'], async () => {
            if (!this.enabled)
                return;
            this.resolveCodeLens.clear();
        }, null, this.disposables);
        events_1.default.on('CursorMoved', () => {
            if (!this.enabled)
                return;
            this.resolveCodeLens();
        }, null, this.disposables);
        events_1.default.on('BufUnload', bufnr => {
            if (!this.enabled)
                return;
            this.clear(bufnr);
        }, null, this.disposables);
        events_1.default.on('BufEnter', bufnr => {
            if (!this.enabled)
                return;
            setTimeout(async () => {
                if (workspace_1.default.bufnr == bufnr) {
                    await this.fetchDocumentCodeLenses();
                }
            }, 100);
        }, null, this.disposables);
        events_1.default.on('InsertLeave', async () => {
            if (!this.enabled)
                return;
            let { bufnr } = workspace_1.default;
            let info = this.codeLensMap.get(bufnr);
            if (info && info.version != this.version) {
                this.resolveCodeLens.clear();
                await util_1.wait(50);
                await this.fetchDocumentCodeLenses();
            }
        }, null, this.disposables);
        this.resolveCodeLens = debounce_1.default(() => {
            this._resolveCodeLenses().logError();
        }, 200);
    }
    setConfiguration(e) {
        if (e && !e.affectsConfiguration('codeLens'))
            return;
        let { nvim } = this;
        let config = workspace_1.default.getConfiguration('codeLens');
        if (e) {
            if (!this.enabled && config.get('enable')) {
                this.fetchDocumentCodeLenses().logError();
            }
            else if (this.enabled && config.get('enable') == false) {
                workspace_1.default.documents.forEach(doc => {
                    this.clear(doc.bufnr);
                });
            }
        }
        this.separator = config.get('separator', '‣');
        this.subseparator = config.get('subseparator', ' ');
        this.enabled = nvim.hasFunction('nvim_buf_set_virtual_text') && config.get('enable', true);
    }
    async fetchDocumentCodeLenses(retry = 0) {
        let doc = workspace_1.default.getDocument(workspace_1.default.bufnr);
        if (!doc)
            return;
        let { uri, version, bufnr } = doc;
        let document = workspace_1.default.getDocument(uri);
        if (!this.validDocument(document))
            return;
        if (this.fetching.has(bufnr))
            return;
        this.fetching.add(bufnr);
        try {
            let codeLenses = await languages_1.default.getCodeLens(document.textDocument);
            if (codeLenses && codeLenses.length > 0) {
                this.codeLensMap.set(document.bufnr, { codeLenses, version });
                if (workspace_1.default.bufnr == document.bufnr) {
                    this.resolveCodeLens.clear();
                    await this._resolveCodeLenses(true);
                }
            }
            this.fetching.delete(bufnr);
        }
        catch (e) {
            this.fetching.delete(bufnr);
            logger.error(e);
            if (e.message.includes("timeout") && retry < 5) {
                this.fetchDocumentCodeLenses(retry + 1).logError();
            }
        }
    }
    async setVirtualText(buffer, codeLenses) {
        let list = new Map();
        for (let codeLens of codeLenses) {
            let { range, command } = codeLens;
            if (!command)
                continue;
            let { line } = range.start;
            if (list.has(line)) {
                list.get(line).push(codeLens);
            }
            else {
                list.set(line, [codeLens]);
            }
        }
        for (let lnum of list.keys()) {
            let codeLenses = list.get(lnum);
            let commands = codeLenses.map(codeLens => codeLens.command);
            commands = commands.filter(c => c && c.title);
            let chunks = [];
            let n_commands = commands.length;
            for (let i = 0; i < n_commands; i++) {
                let c = commands[i];
                chunks.push([c.title, 'CocCodeLens']);
                if (i != n_commands - 1) {
                    chunks.push([this.subseparator, 'CocCodeLens']);
                }
            }
            chunks.unshift([`${this.separator} `, 'CocCodeLens']);
            await buffer.setVirtualText(this.srcId, lnum, chunks);
        }
    }
    async _resolveCodeLenses(clear = false) {
        let { nvim } = this;
        let { bufnr } = workspace_1.default;
        let { codeLenses, version } = this.codeLensMap.get(bufnr) || {};
        if (codeLenses && codeLenses.length) {
            // resolve codeLens of current window
            let start = await nvim.call('line', 'w0');
            let end = await nvim.call('line', 'w$');
            if (version && this.version != version)
                return;
            if (end >= start) {
                codeLenses = codeLenses.filter(o => {
                    let lnum = o.range.start.line + 1;
                    return lnum >= start && lnum <= end;
                });
                if (codeLenses.length) {
                    await Promise.all(codeLenses.map(codeLens => languages_1.default.resolveCodeLens(codeLens)));
                }
            }
            else {
                codeLenses = null;
            }
        }
        nvim.pauseNotification();
        let doc = workspace_1.default.getDocument(bufnr);
        if (doc && clear) {
            doc.clearMatchIds([this.srcId]);
        }
        if (codeLenses && codeLenses.length)
            await this.setVirtualText(doc.buffer, codeLenses);
        await nvim.resumeNotification(false, true);
    }
    async doAction() {
        let { nvim } = this;
        let bufnr = await nvim.call('bufnr', '%');
        let line = await nvim.call('line', '.') - 1;
        let { codeLenses } = this.codeLensMap.get(bufnr) || {};
        if (!codeLenses || codeLenses.length == 0) {
            workspace_1.default.showMessage('No codeLenses available', 'warning');
            return;
        }
        let list = new Map();
        for (let codeLens of codeLenses) {
            let { range, command } = codeLens;
            if (!command)
                continue;
            let { line } = range.start;
            if (list.has(line)) {
                list.get(line).push(codeLens);
            }
            else {
                list.set(line, [codeLens]);
            }
        }
        let current = null;
        for (let i = line; i >= 0; i--) {
            if (list.has(i)) {
                current = list.get(i);
                break;
            }
        }
        if (!current) {
            workspace_1.default.showMessage('No codeLenses available', 'warning');
            return;
        }
        let commands = current.map(o => o.command);
        commands = commands.filter(c => c.command != null && c.command != '');
        if (commands.length == 0) {
            workspace_1.default.showMessage('CodeLenses command not found', 'warning');
        }
        else if (commands.length == 1) {
            commands_1.default.execute(commands[0]);
        }
        else {
            let res = await workspace_1.default.showQuickpick(commands.map(c => c.title));
            if (res == -1)
                return;
            commands_1.default.execute(commands[res]);
        }
    }
    clear(bufnr) {
        if (!this.enabled)
            return;
        let buf = this.nvim.createBuffer(bufnr);
        if (this.nvim.hasFunction('nvim_create_namespace')) {
            buf.clearNamespace(this.srcId);
        }
        else {
            buf.clearHighlight({ srcId: this.srcId });
        }
    }
    validDocument(doc) {
        if (!doc)
            return false;
        if (doc.schema != 'file' || doc.buftype != '')
            return false;
        return true;
    }
    get version() {
        let doc = workspace_1.default.getDocument(workspace_1.default.bufnr);
        return doc ? doc.version : 0;
    }
    dispose() {
        if (this.resolveCodeLens) {
            this.resolveCodeLens.clear();
        }
        util_1.disposeAll(this.disposables);
    }
}
exports.default = CodeLensManager;
//# sourceMappingURL=codelens.js.map

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const extensions_1 = tslib_1.__importDefault(__webpack_require__(333));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const util_1 = __webpack_require__(238);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const highlighter_1 = tslib_1.__importStar(__webpack_require__(618));
const logger = __webpack_require__(64)('colors');
class Colors {
    constructor(nvim) {
        this.nvim = nvim;
        this._enabled = true;
        this.srcId = 1090;
        this.disposables = [];
        this.highlighters = new Map();
        if (workspace_1.default.isVim && !workspace_1.default.env.textprop) {
            return;
        }
        workspace_1.default.documents.forEach(doc => {
            this.createHighlighter(doc.bufnr);
        });
        workspace_1.default.onDidOpenTextDocument(e => {
            let doc = workspace_1.default.getDocument(e.uri);
            let highlighter = this.createHighlighter(doc.bufnr);
            if (highlighter && this.enabled)
                highlighter.highlight();
        });
        workspace_1.default.onDidChangeTextDocument(({ bufnr }) => {
            let highlighter = this.highlighters.get(bufnr);
            if (highlighter && this.enabled)
                highlighter.highlight();
        }, null, this.disposables);
        events_1.default.on('BufUnload', async (bufnr) => {
            let highlighter = this.highlighters.get(bufnr);
            if (!highlighter)
                return;
            highlighter.dispose();
            this.highlighters.delete(bufnr);
        }, null, this.disposables);
        let config = workspace_1.default.getConfiguration('coc.preferences');
        this._enabled = config.get('colorSupport', true);
        this.srcId = workspace_1.default.createNameSpace('coc-colors');
        extensions_1.default.onDidLoadExtension(() => {
            this.highlightAll();
        }, null, this.disposables);
        events_1.default.on('InsertLeave', async () => {
            if (false)
                {}
            this.highlightAll();
        }, null, this.disposables);
        workspace_1.default.onDidChangeConfiguration(async (e) => {
            if (e.affectsConfiguration('coc.preferences.colorSupport')) {
                let config = workspace_1.default.getConfiguration('coc.preferences');
                this._enabled = config.get('colorSupport', true);
                if (!this._enabled) {
                    for (let highlighter of this.highlighters.values()) {
                        highlighter.cancel();
                        highlighter.clearHighlight();
                    }
                }
                else {
                    this.highlightAll();
                }
            }
        }, null, this.disposables);
    }
    async pickPresentation() {
        let info = await this.currentColorInfomation();
        if (!info)
            return workspace_1.default.showMessage('Color not found at current position', 'warning');
        let document = await workspace_1.default.document;
        let presentations = await languages_1.default.provideColorPresentations(info, document.textDocument);
        if (!presentations || presentations.length == 0)
            return;
        let res = await workspace_1.default.showQuickpick(presentations.map(o => o.label), 'choose a color presentation:');
        if (res == -1)
            return;
        let presentation = presentations[res];
        let { textEdit, additionalTextEdits, label } = presentation;
        if (!textEdit)
            textEdit = { range: info.range, newText: label };
        await document.applyEdits([textEdit]);
        if (additionalTextEdits) {
            await document.applyEdits(additionalTextEdits);
        }
    }
    async pickColor() {
        let info = await this.currentColorInfomation();
        if (!info)
            return workspace_1.default.showMessage('Color not found at current position', 'warning');
        let { color } = info;
        let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];
        let res = await this.nvim.call('coc#util#pick_color', [colorArr]);
        if (res === false) {
            // cancel
            return;
        }
        if (!res || res.length != 3) {
            workspace_1.default.showMessage('Failed to get color', 'warning');
            return;
        }
        let hex = highlighter_1.toHexString({
            red: (res[0] / 65535),
            green: (res[1] / 65535),
            blue: (res[2] / 65535),
            alpha: 1
        });
        let document = await workspace_1.default.document;
        await document.applyEdits([{
                range: info.range,
                newText: `#${hex}`
            }]);
    }
    get enabled() {
        return this._enabled;
    }
    clearHighlight(bufnr) {
        let highlighter = this.highlighters.get(bufnr);
        if (!highlighter)
            return;
        highlighter.clearHighlight();
    }
    hasColor(bufnr) {
        let highlighter = this.highlighters.get(bufnr);
        if (!highlighter)
            return false;
        return highlighter.hasColor();
    }
    hasColorAtPostion(bufnr, position) {
        let highlighter = this.highlighters.get(bufnr);
        if (!highlighter)
            return false;
        return highlighter.hasColorAtPostion(position);
    }
    dispose() {
        for (let highlighter of this.highlighters.values()) {
            highlighter.dispose();
        }
        util_1.disposeAll(this.disposables);
    }
    highlightAll() {
        if (!this.enabled)
            return;
        workspace_1.default.documents.forEach(doc => {
            let highlighter = this.highlighters.get(doc.bufnr);
            if (highlighter)
                highlighter.highlight();
        });
    }
    async doHighlight(bufnr) {
        let highlighter = this.highlighters.get(bufnr);
        if (!highlighter)
            return;
        await highlighter.doHighlight();
    }
    createHighlighter(bufnr) {
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || !isValid(doc))
            return null;
        let obj = new highlighter_1.default(this.nvim, bufnr, this.srcId);
        this.highlighters.set(bufnr, obj);
        return obj;
    }
    async currentColorInfomation() {
        let bufnr = await this.nvim.call('bufnr', '%');
        let highlighter = this.highlighters.get(bufnr);
        if (!highlighter)
            return null;
        let position = await workspace_1.default.getCursorPosition();
        for (let info of highlighter.colors) {
            let { range } = info;
            let { start, end } = range;
            if (position.line == start.line
                && position.character >= start.character
                && position.character <= end.character) {
                return info;
            }
        }
        return null;
    }
}
exports.default = Colors;
function isValid(document) {
    if (['help', 'terminal', 'quickfix'].includes(document.buftype))
        return false;
    return true;
}
//# sourceMappingURL=colors.js.map

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const debounce_1 = tslib_1.__importDefault(__webpack_require__(240));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const util_1 = __webpack_require__(238);
const array_1 = __webpack_require__(308);
const object_1 = __webpack_require__(249);
const position_1 = __webpack_require__(311);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const logger = __webpack_require__(64)('highlighter');
const usedColors = new Set();
class Highlighter {
    // last highlight version
    constructor(nvim, bufnr, srcId) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this.srcId = srcId;
        this._colors = [];
        this.highlight = debounce_1.default(() => {
            this.doHighlight().catch(e => {
                logger.error('Error on color highlight:', e.stack);
            });
        }, 500);
    }
    get buffer() {
        return this.nvim.createBuffer(this.bufnr);
    }
    get colors() {
        return this._colors;
    }
    hasColor() {
        return this._colors.length > 0;
    }
    async doHighlight() {
        this.cancel();
        let doc = workspace_1.default.getDocument(this.bufnr);
        if (!doc)
            return;
        this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let { token } = this.tokenSource;
        await synchronizeDocument(doc);
        if (workspace_1.default.insertMode)
            return;
        if (token.isCancellationRequested)
            return;
        if (this.version && doc.version == this.version)
            return;
        let colors;
        try {
            colors = await languages_1.default.provideDocumentColors(doc.textDocument, token);
            colors = colors || [];
            if (token.isCancellationRequested)
                return;
            this.version = doc.version;
        }
        catch (e) {
            logger.error('Error on request colors:', e);
        }
        await this.addHighlight(doc, colors, token);
    }
    async addHighlight(doc, colors, token) {
        colors = colors || [];
        if (object_1.equals(this._colors, colors) || !doc)
            return;
        this._colors = colors;
        // improve performance
        let groups = array_1.group(colors, 100);
        let cleared = false;
        for (let colors of groups) {
            if (token.isCancellationRequested) {
                this._colors = [];
                return;
            }
            this.nvim.pauseNotification();
            if (!cleared) {
                this.buffer.clearHighlight({ srcId: this.srcId });
                cleared = true;
            }
            let colorRanges = this.getColorRanges(colors);
            this.addColors(colors.map(o => o.color));
            for (let o of colorRanges) {
                this.highlightColor(doc, o.ranges, o.color);
            }
            this.nvim.command('redraw', true);
            await this.nvim.resumeNotification();
        }
    }
    highlightColor(doc, ranges, color) {
        let { red, green, blue } = toHexColor(color);
        let hlGroup = `BG${toHexString(color)}`;
        doc.highlightRanges(ranges, hlGroup, this.srcId);
    }
    addColors(colors) {
        let commands = [];
        for (let color of colors) {
            let hex = toHexString(color);
            if (!usedColors.has(hex)) {
                commands.push(`hi BG${hex} guibg=#${hex} guifg=#${isDark(color) ? 'ffffff' : '000000'}`);
                usedColors.add(hex);
            }
        }
        this.nvim.command(commands.join('|'), true);
    }
    getColorRanges(infos) {
        let res = [];
        for (let info of infos) {
            let { color, range } = info;
            let idx = res.findIndex(o => object_1.equals(toHexColor(o.color), toHexColor(color)));
            if (idx == -1) {
                res.push({
                    color,
                    ranges: [range]
                });
            }
            else {
                let r = res[idx];
                r.ranges.push(range);
            }
        }
        return res;
    }
    clearHighlight() {
        this._colors = [];
        this.version = null;
        this.buffer.clearHighlight({ srcId: this.srcId });
    }
    hasColorAtPostion(position) {
        let { colors } = this;
        return colors.some(o => position_1.positionInRange(position, o.range) == 0);
    }
    cancel() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
    }
    dispose() {
        this.highlight.clear();
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource.dispose();
        }
    }
}
exports.default = Highlighter;
function toHexString(color) {
    let c = toHexColor(color);
    return `${pad(c.red.toString(16))}${pad(c.green.toString(16))}${pad(c.blue.toString(16))}`;
}
exports.toHexString = toHexString;
function pad(str) {
    return str.length == 1 ? `0${str}` : str;
}
function toHexColor(color) {
    let { red, green, blue } = color;
    return {
        red: Math.round(red * 255),
        green: Math.round(green * 255),
        blue: Math.round(blue * 255)
    };
}
function isDark(color) {
    // http://www.w3.org/TR/WCAG20/#relativeluminancedef
    let rgb = [color.red, color.green, color.blue];
    let lum = [];
    for (let i = 0; i < rgb.length; i++) {
        let chan = rgb[i];
        lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
    }
    let luma = 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    return luma <= 0.5;
}
async function synchronizeDocument(doc) {
    let { changedtick } = doc;
    await doc.patchChange();
    if (changedtick != doc.changedtick) {
        await util_1.wait(50);
    }
}
//# sourceMappingURL=highlighter.js.map

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const events_1 = tslib_1.__importDefault(__webpack_require__(210));
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const languages_1 = tslib_1.__importDefault(__webpack_require__(497));
const vscode_languageserver_protocol_1 = __webpack_require__(211);
const util_1 = __webpack_require__(238);
const logger = __webpack_require__(64)('documentHighlight');
class DocumentHighlighter {
    constructor(nvim, colors) {
        this.nvim = nvim;
        this.colors = colors;
        this.disposables = [];
        events_1.default.on('WinLeave', winid => {
            if (this.tokenSource)
                this.tokenSource.cancel();
            this.clearHighlight(winid);
        }, null, this.disposables);
        events_1.default.on('BufWinEnter', () => {
            if (this.tokenSource)
                this.tokenSource.cancel();
        }, null, this.disposables);
        events_1.default.on(['CursorMoved', 'CursorMovedI'], () => {
            this.cursorMoveTs = Date.now();
        }, null, this.disposables);
        events_1.default.on('InsertEnter', () => {
            this.clearHighlight();
        }, null, this.disposables);
    }
    clearHighlight(winid) {
        let { nvim } = workspace_1.default;
        nvim.pauseNotification();
        nvim.call('coc#util#clear_highlights', winid ? [winid] : [], true);
        if (workspace_1.default.isVim) {
            nvim.command('redraw', true);
        }
        nvim.resumeNotification(false, true).catch(_e => {
            // noop
        });
    }
    async highlight(bufnr, position) {
        let { nvim } = this;
        let doc = workspace_1.default.getDocument(bufnr);
        if (this.tokenSource)
            this.tokenSource.cancel();
        let highlights = await this.getHighlights(doc, position);
        if (!highlights || highlights.length == 0) {
            this.clearHighlight();
            return;
        }
        if (workspace_1.default.bufnr != bufnr)
            return;
        nvim.pauseNotification();
        this.clearHighlight();
        let groups = {};
        for (let hl of highlights) {
            if (!hl.range)
                continue;
            let hlGroup = hl.kind == vscode_languageserver_protocol_1.DocumentHighlightKind.Text
                ? 'CocHighlightText'
                : hl.kind == vscode_languageserver_protocol_1.DocumentHighlightKind.Read ? 'CocHighlightRead' : 'CocHighlightWrite';
            groups[hlGroup] = groups[hlGroup] || [];
            groups[hlGroup].push(hl.range);
        }
        for (let hlGroup of Object.keys(groups)) {
            doc.matchAddRanges(groups[hlGroup], hlGroup, -1);
        }
        this.nvim.command('redraw', true);
        await this.nvim.resumeNotification(false, true);
    }
    async getHighlights(document, position) {
        if (!document)
            return null;
        let ts = Date.now();
        let { bufnr } = document;
        let line = document.getline(position.line);
        let ch = line[position.character];
        if (!ch || !document.isWord(ch) || this.colors.hasColorAtPostion(bufnr, position))
            return null;
        try {
            this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let highlights = await languages_1.default.getDocumentHighLight(document.textDocument, position, this.tokenSource.token);
            if (workspace_1.default.bufnr != document.bufnr || (this.cursorMoveTs && this.cursorMoveTs > ts)) {
                return null;
            }
            return highlights;
        }
        catch (_e) {
            return null;
        }
    }
    dispose() {
        if (this.tokenSource)
            this.tokenSource.dispose();
        util_1.disposeAll(this.disposables);
    }
}
exports.default = DocumentHighlighter;
//# sourceMappingURL=documentHighlight.js.map

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const fast_diff_1 = tslib_1.__importDefault(__webpack_require__(259));
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const vscode_languageserver_types_1 = __webpack_require__(223);
const vscode_languageserver_textdocument_1 = __webpack_require__(293);
const vscode_uri_1 = __webpack_require__(243);
const commands_1 = tslib_1.__importDefault(__webpack_require__(252));
const highligher_1 = tslib_1.__importDefault(__webpack_require__(523));
const util_1 = __webpack_require__(238);
const fs_1 = __webpack_require__(304);
const object_1 = __webpack_require__(249);
const string_1 = __webpack_require__(310);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('refactor');
// cases: buffer change event
const name = '__coc_refactor__';
const separator = '\u3000';
let refactorId = 0;
class Refactor {
    constructor() {
        this.changing = false;
        this.matchIds = new Set();
        this.disposables = [];
        this.fileItems = [];
        this.nvim = workspace_1.default.nvim;
        if (workspace_1.default.isNvim && this.nvim.hasFunction('nvim_buf_set_virtual_text')) {
            this.srcId = workspace_1.default.createNameSpace('coc-refactor');
        }
        let config = workspace_1.default.getConfiguration('refactor');
        this.config = {
            afterContext: config.get('afterContext', 3),
            beforeContext: config.get('beforeContext', 3),
            openCommand: config.get('openCommand', 'edit')
        };
    }
    get buffer() {
        if (!this.bufnr)
            return null;
        return this.nvim.createBuffer(this.bufnr);
    }
    get document() {
        if (!this.bufnr)
            return null;
        return workspace_1.default.getDocument(this.bufnr);
    }
    async valid() {
        let { buffer } = this;
        if (!buffer)
            return false;
        return await buffer.valid;
    }
    /**
     * Start refactor from workspaceEdit
     */
    async fromWorkspaceEdit(edit, filetype) {
        let items = await this.getItemsFromWorkspaceEdit(edit);
        await this.createRefactorBuffer(filetype);
        await this.addFileItems(items);
    }
    async fromLines(lines) {
        let buf = await this.createRefactorBuffer();
        await buf.setLines(lines, { start: 0, end: -1, strictIndexing: false });
    }
    /**
     * Create initialized refactor buffer
     */
    async createRefactorBuffer(filetype) {
        let { nvim } = this;
        let [fromWinid, cwd] = await nvim.eval('[win_getid(),getcwd()]');
        let { openCommand } = this.config;
        nvim.pauseNotification();
        nvim.command(`${openCommand} ${name}${refactorId++}`, true);
        nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);
        nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);
        nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);
        nvim.call('setline', [1, ['Save current buffer to make changes', separator]], true);
        nvim.call('matchadd', ['Comment', '\\%1l'], true);
        nvim.call('matchadd', ['Conceal', '^\\%u3000'], true);
        nvim.call('matchadd', ['Label', '^\\%u3000\\zs\\S\\+'], true);
        nvim.command('setl nomod', true);
        if (filetype)
            nvim.command(`runtime! syntax/${filetype}.vim`, true);
        nvim.call('coc#util#do_autocmd', ['CocRefactorOpen'], true);
        workspace_1.default.registerLocalKeymap('n', '<CR>', this.splitOpen.bind(this), true);
        let [, err] = await nvim.resumeNotification();
        if (err) {
            logger.error(err);
            workspace_1.default.showMessage(`Error on open refactor window: ${err}`, 'error');
            return;
        }
        let [bufnr, win] = await nvim.eval('[bufnr("%"),win_getid()]');
        this.fromWinid = fromWinid;
        this.winid = win;
        this.bufnr = bufnr;
        this.cwd = cwd;
        await this.ensureDocument();
        workspace_1.default.onDidChangeTextDocument(this.onBufferChange, this, this.disposables);
        return nvim.createBuffer(bufnr);
    }
    /**
     * Add FileItem to refactor buffer.
     */
    async addFileItems(items) {
        let { document } = this;
        if (!document)
            return;
        if (document.dirty)
            document.forceSync();
        for (let item of items) {
            let fileItem = this.fileItems.find(o => o.filepath == item.filepath);
            if (fileItem) {
                fileItem.ranges.push(...item.ranges);
            }
            else {
                this.fileItems.push(item);
            }
        }
        let count = document.lineCount;
        let highligher = new highligher_1.default();
        let hlRanges = [];
        for (let item of items) {
            for (let range of item.ranges) {
                highligher.addLine(separator);
                highligher.addLine(separator);
                range.lnum = count + highligher.length;
                highligher.addText(`${this.cwd && fs_1.isParentFolder(this.cwd, item.filepath) ? path_1.default.relative(this.cwd, item.filepath) : item.filepath}`);
                // white spaces for conceal texts
                let n = String(range.start + 1).length + String(range.end).length + 4;
                if (!this.srcId)
                    highligher.addText(' '.repeat(n));
                let base = 0 - highligher.length - count;
                if (range.highlights) {
                    hlRanges.push(...range.highlights.map(r => adjustRange(r, base)));
                }
                let { lines } = range;
                if (!lines) {
                    lines = await this.getLines(item.filepath, range.start, range.end);
                    range.lines = lines;
                }
                highligher.addLines(lines);
            }
        }
        let { nvim, buffer } = this;
        this.version = document.version;
        nvim.pauseNotification();
        highligher.render(buffer, count);
        this.highlightLineNr();
        buffer.setOption('modified', false, true);
        buffer.setOption('undolevels', 1000, true);
        if (count == 2 && hlRanges.length) {
            let pos = hlRanges[0].start;
            nvim.call('coc#util#jumpTo', [pos.line, pos.character], true);
        }
        if (workspace_1.default.isVim) {
            nvim.command('redraw', true);
        }
        let [, err] = await nvim.resumeNotification();
        if (err) {
            logger.error(err);
            return;
        }
        await document.patchChange();
        await commands_1.default.executeCommand('editor.action.addRanges', hlRanges);
    }
    async ensureDocument() {
        let { bufnr } = this;
        let doc = workspace_1.default.getDocument(bufnr);
        if (doc)
            return;
        return new Promise((resolve, reject) => {
            let timer = setTimeout(() => {
                reject(new Error('Document create timeout after 2s.'));
            }, 2000);
            let disposable = workspace_1.default.onDidOpenTextDocument(({ uri }) => {
                let doc = workspace_1.default.getDocument(uri);
                if (doc.bufnr == bufnr) {
                    clearTimeout(timer);
                    disposable.dispose();
                    resolve();
                }
            });
        });
    }
    /**
     * Use conceal to add lineNr
     */
    highlightLineNr() {
        let { fileItems, nvim, winid, srcId, bufnr } = this;
        let info = {};
        if (srcId) {
            nvim.call('nvim_buf_clear_namespace', [bufnr, srcId, 0, -1], true);
            for (let item of fileItems) {
                for (let range of item.ranges) {
                    let text = `${range.start + 1}:${range.end}`;
                    info[range.lnum] = [range.start + 1, range.end];
                    nvim.call('nvim_buf_set_virtual_text', [bufnr, srcId, range.lnum - 1, [[text, 'LineNr']], {}], true);
                }
            }
        }
        else {
            if (this.matchIds.size) {
                nvim.call('coc#util#clearmatches', [Array.from(this.matchIds), this.winid], true);
                this.matchIds.clear();
            }
            let id = 2000;
            for (let item of fileItems) {
                let filename = `${this.cwd ? path_1.default.relative(this.cwd, item.filepath) : item.filepath}`;
                let col = string_1.byteLength(filename) + 1;
                for (let range of item.ranges) {
                    let text = `:${range.start + 1}:${range.end}`;
                    for (let i = 0; i < text.length; i++) {
                        let ch = text[i];
                        this.matchIds.add(id);
                        info[range.lnum] = [range.start + 1, range.end];
                        nvim.call('matchaddpos', ['Conceal', [[range.lnum, col + i]], 99, id, { conceal: ch, window: winid }], true);
                        id++;
                    }
                }
            }
        }
        this.buffer.setVar('line_infos', info, true);
    }
    /**
     * Current changed file ranges
     */
    async getFileChanges() {
        let changes = [];
        let { document } = this;
        if (!document)
            return;
        let lines = await document.buffer.lines;
        lines.push(separator);
        // current lines
        let arr = [];
        let fsPath;
        let lnum;
        for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            if (line.startsWith(separator)) {
                if (fsPath) {
                    changes.push({
                        filepath: fsPath,
                        lines: arr,
                        lnum
                    });
                    fsPath = undefined;
                    arr = [];
                }
                if (line.length > 1) {
                    let ms = line.match(/^\u3000(.*)/);
                    if (ms) {
                        let filepath = ms[1].replace(/\s+$/, '');
                        fsPath = !path_1.default.isAbsolute(filepath) && this.cwd ? path_1.default.join(this.cwd, filepath) : filepath;
                        lnum = i + 1;
                        arr = [];
                    }
                }
            }
            else {
                arr.push(line);
            }
        }
        return changes;
    }
    /**
     * Save changes to files, return false when no change made.
     */
    async saveRefactor() {
        let { nvim } = this;
        let doc = this.document;
        if (!doc)
            return;
        let { buffer } = doc;
        await doc.patchChange();
        let changes = await this.getFileChanges();
        if (!changes)
            return;
        changes.sort((a, b) => a.lnum - b.lnum);
        // filter changes that not change
        let removeList = [];
        let deltaMap = new Map();
        for (let i = 0; i < changes.length; i++) {
            let change = changes[i];
            let { filepath, lnum } = change;
            let curr = deltaMap.get(filepath) || 0;
            let item = this.fileItems.find(o => o.filepath == filepath);
            let range = item ? item.ranges.find(o => o.lnum == lnum) : null;
            if (!range || object_1.equals(range.lines, change.lines)) {
                removeList.push(i);
                if (curr) {
                    range.start = range.start + curr;
                    range.end = range.end + curr;
                }
                continue;
            }
            change.start = range.start;
            change.end = range.end;
            if (curr != 0)
                range.start = range.start + curr;
            if (change.lines.length != range.lines.length) {
                let delta = change.lines.length - range.lines.length;
                let total = delta + curr;
                deltaMap.set(filepath, total);
                range.end = range.end + total;
            }
            else {
                range.end = range.end + curr;
            }
            range.lines = change.lines;
        }
        if (removeList.length)
            changes = changes.filter((_, i) => !removeList.includes(i));
        if (changes.length == 0) {
            workspace_1.default.showMessage('No change.', 'more');
            await buffer.setOption('modified', false);
            return false;
        }
        let changeMap = {};
        for (let change of changes) {
            let uri = vscode_uri_1.URI.file(change.filepath).toString();
            let edits = changeMap[uri] || [];
            edits.push({
                range: vscode_languageserver_types_1.Range.create(change.start, 0, change.end, 0),
                newText: change.lines.join('\n') + '\n'
            });
            changeMap[uri] = edits;
        }
        this.changing = true;
        await workspace_1.default.applyEdit({ changes: changeMap });
        this.changing = false;
        nvim.pauseNotification();
        buffer.setOption('modified', false, true);
        nvim.command('silent noa wa', true);
        this.highlightLineNr();
        await nvim.resumeNotification();
        return true;
    }
    getFileRange(lnum) {
        for (let item of this.fileItems) {
            for (let r of item.ranges) {
                if (r.lnum == lnum) {
                    return r;
                }
            }
        }
        return null;
    }
    async onBufferChange(e) {
        if (e.bufnr == this.bufnr) {
            return await this.onRefactorChange(e);
        }
        if (this.changing)
            return;
        let { uri } = e.textDocument;
        if (!('range' in e.contentChanges[0]))
            return;
        let { range, text } = e.contentChanges[0];
        let filepath = vscode_uri_1.URI.parse(uri).fsPath;
        let fileItem = this.fileItems.find(o => o.filepath == filepath);
        if (!fileItem)
            return;
        let lineChange = text.split('\n').length - (range.end.line - range.start.line) - 1;
        let edits = [];
        // 4 cases: ignore, change lineNr, reload, remove
        for (let i = 0; i < fileItem.ranges.length; i++) {
            let r = fileItem.ranges[i];
            if (range.start.line >= r.end) {
                continue;
            }
            if (range.end.line < r.start) {
                if (lineChange == 0) {
                    continue;
                }
                else {
                    r.start = r.start + lineChange;
                    r.end = r.end + lineChange;
                }
            }
            else {
                let doc = workspace_1.default.getDocument(uri);
                let newLines = doc.getLines(r.start, r.end);
                if (!newLines.length) {
                    // remove this range
                    fileItem.ranges.splice(i, 1);
                    edits.push({
                        range: this.getFileRangeRange(r, false),
                        newText: ''
                    });
                }
                else {
                    r.end = r.start + newLines.length;
                    // reload lines, reset end
                    edits.push({
                        range: this.getFileRangeRange(r, true),
                        newText: newLines.join('\n') + '\n'
                    });
                }
            }
            let buf = this.document.buffer;
            let mod = await buf.getOption('modified');
            if (edits.length) {
                this.version = this.document.version;
                await this.document.applyEdits(edits);
            }
            this.nvim.pauseNotification();
            this.highlightLineNr();
            if (!mod)
                buf.setOption('modified', false, true);
            await this.nvim.resumeNotification();
        }
    }
    /**
     * Edit range of FileRange
     */
    getFileRangeRange(range, lineOnly = true) {
        let { document } = this;
        if (!document)
            return null;
        let { lnum } = range;
        let first = document.getline(lnum - 1);
        if (!first.startsWith('\u3000'))
            return null;
        let start = lineOnly ? lnum : lnum - 1;
        let end = document.lineCount;
        for (let i = lnum; i < document.lineCount; i++) {
            let line = document.getline(i);
            if (line.startsWith('\u3000')) {
                end = lineOnly ? i : i + 1;
                break;
            }
        }
        return vscode_languageserver_types_1.Range.create(start, 0, end, 0);
    }
    /**
     * Open line under cursor in split window
     */
    async splitOpen() {
        let { nvim } = this;
        let win = nvim.createWindow(this.fromWinid);
        let valid = await win.valid;
        let lines = await nvim.eval('getline(1,line("."))');
        let len = lines.length;
        for (let i = 0; i < len; i++) {
            let line = lines[len - i - 1];
            let ms = line.match(/^\u3000(.+)/);
            if (ms) {
                let filepath = ms[1].trim();
                let r = this.getLinesRange(len - i);
                if (!r)
                    return;
                let lnum = r[0] + i;
                let bufname = filepath.startsWith(workspace_1.default.cwd) ? path_1.default.relative(workspace_1.default.cwd, filepath) : filepath;
                nvim.pauseNotification();
                if (valid) {
                    nvim.call('win_gotoid', [this.fromWinid], true);
                    this.nvim.call('coc#util#jump', ['edit', bufname, [lnum, 1]], true);
                }
                else {
                    this.nvim.call('coc#util#jump', ['belowright vs', bufname, [lnum, 1]], true);
                }
                nvim.command('normal! zz', true);
                let [, err] = await nvim.resumeNotification();
                if (err)
                    workspace_1.default.showMessage(`Error on open ${filepath}: ${err}`, 'error');
                if (!valid) {
                    this.fromWinid = await nvim.call('win_getid');
                }
                break;
            }
        }
    }
    async onRefactorChange(e) {
        let { nvim } = this;
        let doc = this.document;
        if (doc.version - this.version == 1)
            return;
        let { fileItems } = this;
        if (!fileItems.length)
            return;
        let change = e.contentChanges[0];
        if (!('range' in change))
            return;
        let { original } = e;
        if (change.range.end.line < 2)
            return;
        doc.buffer.setOption('modified', true, true);
        let { range, text } = change;
        let lines = text.split('\n');
        let lineChange = lines.length - (range.end.line - range.start.line) - 1;
        if (lineChange == 0)
            return;
        let lineChanges = [];
        if (text.includes('\u3000')) {
            let startLine = range.start.line;
            let diffs = fast_diff_1.default(original, text);
            let offset = 0;
            let orig = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', '', 0, original);
            for (let i = 0; i < diffs.length; i++) {
                let diff = diffs[i];
                let pos = orig.positionAt(offset);
                if (diff[0] == fast_diff_1.default.EQUAL) {
                    offset = offset + diff[1].length;
                }
                else if (diff[0] == fast_diff_1.default.DELETE) {
                    let end = orig.positionAt(offset + diff[1].length);
                    if (diffs[i + 1] && diffs[i + 1][0] == fast_diff_1.default.INSERT) {
                        let delta = diffs[i + 1][1].split('\n').length - (end.line - pos.line) - 1;
                        if (delta != 0)
                            lineChanges.push({ delta, lnum: pos.line + startLine });
                        i = i + 1;
                    }
                    else {
                        let delta = -(end.line - pos.line);
                        if (delta != 0)
                            lineChanges.push({ delta, lnum: pos.line + startLine });
                    }
                    offset = offset + diff[1].length;
                }
                else if (diff[0] == fast_diff_1.default.INSERT) {
                    let delta = diff[1].split('\n').length - 1;
                    if (delta != 0)
                        lineChanges.push({ delta, lnum: pos.line + startLine });
                }
            }
        }
        else {
            lineChanges = [{ delta: lineChange, lnum: range.start.line }];
        }
        let changed = false;
        // adjust LineNr highlights
        for (let item of fileItems) {
            for (let range of item.ranges) {
                let arr = lineChanges.filter(o => o.lnum < range.lnum - 1);
                if (arr.length) {
                    let total = arr.reduce((p, c) => p + c.delta, 0);
                    range.lnum = range.lnum + total;
                    changed = true;
                }
            }
        }
        if (!changed || this.srcId)
            return;
        let winid = await nvim.call('win_getid');
        if (winid != this.winid) {
            await nvim.call('win_gotoid', [winid]);
        }
        nvim.pauseNotification();
        this.highlightLineNr();
        await nvim.resumeNotification();
    }
    async getItemsFromWorkspaceEdit(edit) {
        let res = [];
        let { beforeContext, afterContext } = this.config;
        let { changes, documentChanges } = edit;
        if (!changes) {
            changes = {};
            for (let change of documentChanges || []) {
                if (vscode_languageserver_types_1.TextDocumentEdit.is(change)) {
                    let { textDocument, edits } = change;
                    changes[textDocument.uri] = edits;
                }
            }
        }
        for (let key of Object.keys(changes)) {
            let max = await this.getLineCount(key);
            let edits = changes[key];
            let ranges = [];
            // start end highlights
            let start = null;
            let end = null;
            let highlights = [];
            edits.sort((a, b) => a.range.start.line - b.range.start.line);
            for (let edit of edits) {
                let { line } = edit.range.start;
                let s = Math.max(0, line - beforeContext);
                if (start != null && s < end) {
                    end = Math.min(max, line + afterContext + 1);
                    highlights.push(adjustRange(edit.range, start));
                }
                else {
                    if (start != null)
                        ranges.push({ start, end, highlights });
                    start = s;
                    end = Math.min(max, line + afterContext + 1);
                    highlights = [adjustRange(edit.range, start)];
                }
            }
            if (start != null)
                ranges.push({ start, end, highlights });
            res.push({
                ranges,
                filepath: vscode_uri_1.URI.parse(key).fsPath
            });
        }
        return res;
    }
    async getLineCount(uri) {
        let doc = workspace_1.default.getDocument(uri);
        if (doc)
            return doc.lineCount;
        return await fs_1.getFileLineCount(vscode_uri_1.URI.parse(uri).fsPath);
    }
    async getLines(fsPath, start, end) {
        let uri = vscode_uri_1.URI.file(fsPath).toString();
        let doc = workspace_1.default.getDocument(uri);
        if (doc)
            return doc.getLines(start, end);
        return await fs_1.readFileLines(fsPath, start, end - 1);
    }
    getLinesRange(lnum) {
        for (let item of this.fileItems) {
            for (let range of item.ranges) {
                if (range.lnum == lnum) {
                    return [range.start, range.end];
                }
            }
        }
        return null;
    }
    dispose() {
        this.fileItems = [];
        util_1.disposeAll(this.disposables);
    }
    /**
     * Refactor from workspaceEdit.
     */
    static async createFromWorkspaceEdit(edit, filetype) {
        if (!edit || emptyWorkspaceEdit(edit))
            return null;
        let refactor = new Refactor();
        await refactor.fromWorkspaceEdit(edit, filetype);
        return refactor;
    }
    /**
     * Refactor from locations.
     */
    static async createFromLocations(locations, filetype) {
        if (!locations || locations.length == 0)
            return null;
        let changes = {};
        let edit = { changes };
        for (let location of locations) {
            let edits = changes[location.uri] || [];
            edits.push({ range: location.range, newText: '' });
            changes[location.uri] = edits;
        }
        let refactor = new Refactor();
        await refactor.fromWorkspaceEdit(edit, filetype);
        return refactor;
    }
    static async createFromLines(lines) {
        let refactor = new Refactor();
        await refactor.fromLines(lines);
        return refactor;
    }
}
exports.default = Refactor;
function adjustRange(range, offset) {
    let { start, end } = range;
    return vscode_languageserver_types_1.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
function emptyWorkspaceEdit(edit) {
    let { changes, documentChanges } = edit;
    if (documentChanges && documentChanges.length)
        return false;
    if (changes && Object.keys(changes).length)
        return false;
    return true;
}
//# sourceMappingURL=refactor.js.map

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(65);
const mutex_1 = __webpack_require__(255);
const child_process_1 = __webpack_require__(239);
const events_1 = __webpack_require__(198);
const path_1 = tslib_1.__importDefault(__webpack_require__(82));
const readline_1 = tslib_1.__importDefault(__webpack_require__(206));
const vscode_languageserver_types_1 = __webpack_require__(223);
const which_1 = tslib_1.__importDefault(__webpack_require__(244));
const highligher_1 = tslib_1.__importDefault(__webpack_require__(523));
const ansiparse_1 = __webpack_require__(524);
const workspace_1 = tslib_1.__importDefault(__webpack_require__(257));
const logger = __webpack_require__(64)('handler-search');
const defaultArgs = ['--color', 'ansi', '--colors', 'path:fg:black', '--colors', 'line:fg:green', '--colors', 'match:fg:red', '--no-messages', '--heading', '-n'];
const controlCode = '\x1b';
// emit FileItem
class Task extends events_1.EventEmitter {
    start(cmd, args, cwd) {
        this.process = child_process_1.spawn(cmd, args, { cwd });
        this.process.on('error', e => {
            this.emit('error', e.message);
        });
        const rl = readline_1.default.createInterface(this.process.stdout);
        let start;
        let fileItem;
        let lines = [];
        let highlights = [];
        let create = true;
        rl.on('line', content => {
            if (content.includes(controlCode)) {
                let items = ansiparse_1.ansiparse(content);
                if (items[0].foreground == 'black') {
                    fileItem = { filepath: path_1.default.join(cwd, items[0].text), ranges: [] };
                    return;
                }
                let normalLine = items[0].foreground == 'green';
                if (normalLine) {
                    let lnum = parseInt(items[0].text, 10) - 1;
                    let padlen = items[0].text.length + 1;
                    if (create) {
                        start = lnum;
                        create = false;
                    }
                    let line = '';
                    for (let item of items) {
                        if (item.foreground == 'red') {
                            let l = lnum - start;
                            let c = line.length - padlen;
                            highlights.push(vscode_languageserver_types_1.Range.create(l, c, l, c + item.text.length));
                        }
                        line += item.text;
                    }
                    let currline = line.slice(padlen);
                    lines.push(currline);
                }
            }
            else {
                let fileEnd = content.trim().length == 0;
                if (fileItem && (fileEnd || content.trim() == '--')) {
                    let fileRange = {
                        lines,
                        highlights,
                        start,
                        end: start + lines.length
                    };
                    fileItem.ranges.push(fileRange);
                }
                if (fileEnd) {
                    this.emit('item', fileItem);
                    fileItem = null;
                }
                lines = [];
                highlights = [];
                create = true;
            }
        });
        rl.on('close', () => {
            if (fileItem) {
                if (lines.length) {
                    let fileRange = {
                        lines,
                        highlights,
                        start,
                        end: start + lines.length
                    };
                    fileItem.ranges.push(fileRange);
                }
                this.emit('item', fileItem);
            }
            lines = highlights = fileItem = null;
            this.emit('end');
        });
    }
    dispose() {
        if (this.process) {
            this.process.kill();
        }
    }
}
class Search {
    constructor(nvim, cmd = 'rg') {
        this.nvim = nvim;
        this.cmd = cmd;
    }
    run(args, cwd, refactor) {
        let { nvim, cmd } = this;
        let { afterContext, beforeContext } = refactor.config;
        let argList = ['-A', afterContext.toString(), '-B', beforeContext.toString()].concat(defaultArgs, args);
        argList.push('--', './');
        try {
            cmd = which_1.default.sync(cmd);
        }
        catch (e) {
            workspace_1.default.showMessage('Please install ripgrep and make sure rg is in your $PATH', 'error');
            return Promise.reject(e);
        }
        this.task = new Task();
        this.task.start(cmd, argList, cwd);
        let mutex = new mutex_1.Mutex();
        let files = 0;
        let matches = 0;
        let start = Date.now();
        // remaining items
        let fileItems = [];
        const addFileItems = async () => {
            if (fileItems.length == 0)
                return;
            let items = fileItems.slice();
            fileItems = [];
            const release = await mutex.acquire();
            try {
                await refactor.addFileItems(items);
            }
            catch (e) {
                logger.error(e);
            }
            release();
        };
        return new Promise((resolve, reject) => {
            let interval = setInterval(addFileItems, 100);
            this.task.on('item', async (fileItem) => {
                files++;
                matches = matches + fileItem.ranges.reduce((p, r) => p + r.highlights.length, 0);
                fileItems.push(fileItem);
            });
            this.task.on('error', message => {
                clearInterval(interval);
                workspace_1.default.showMessage(`Error on command "${cmd}": ${message}`, 'error');
                this.task = null;
                reject(new Error(message));
            });
            this.task.on('end', async () => {
                clearInterval(interval);
                try {
                    await addFileItems();
                    const release = await mutex.acquire();
                    release();
                    this.task.removeAllListeners();
                    this.task = null;
                    let { document } = refactor;
                    if (document) {
                        let buf = document.buffer;
                        nvim.pauseNotification();
                        if (files == 0) {
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            buf.setLines(['No match found'], { start: 1, end: 2, strictIndexing: false }, true);
                            buf.addHighlight({ line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: 'Error' }).logError();
                            buf.setOption('modified', false, true);
                        }
                        else {
                            let highligher = new highligher_1.default();
                            highligher.addText('Files', 'MoreMsg');
                            highligher.addText(': ');
                            highligher.addText(`${files} `, 'Number');
                            highligher.addText('Matches', 'MoreMsg');
                            highligher.addText(': ');
                            highligher.addText(`${matches} `, 'Number');
                            highligher.addText('Duration', 'MoreMsg');
                            highligher.addText(': ');
                            highligher.addText(`${Date.now() - start}ms`, 'Number');
                            highligher.render(buf, 1, 2);
                        }
                        buf.setOption('modified', false, true);
                        await nvim.resumeNotification(false, true);
                    }
                }
                catch (e) {
                    reject(e);
                    return;
                }
                resolve();
            });
        });
    }
}
exports.default = Search;
//# sourceMappingURL=search.js.map

/***/ })
/******/ ]);